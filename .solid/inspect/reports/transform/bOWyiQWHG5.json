{
  "resolvedId": "C:/Users/quan.doan/Documents/GitHub/chat-web-client/node_modules/.vite/deps/livekit-client.js?v=f9cc9616",
  "transforms": [
    {
      "name": "vite:optimized-deps",
      "result": "// node_modules/livekit-client/dist/livekit-client.esm.mjs\nfunction _mergeNamespaces(n, m) {\n  m.forEach(function(e) {\n    e && typeof e !== \"string\" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n      if (k !== \"default\" && !(k in n)) {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function() {\n            return e[k];\n          }\n        });\n      }\n    });\n  });\n  return Object.freeze(n);\n}\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nfunction getDefaultExportFromCjs(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar loglevel = { exports: {} };\n(function(module) {\n  (function(root, definition) {\n    if (module.exports) {\n      module.exports = definition();\n    } else {\n      root.log = definition();\n    }\n  })(commonjsGlobal, function() {\n    var noop2 = function() {\n    };\n    var undefinedType = \"undefined\";\n    var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\\/|MSIE /.test(window.navigator.userAgent);\n    var logMethods = [\"trace\", \"debug\", \"info\", \"warn\", \"error\"];\n    function bindMethod(obj, methodName) {\n      var method = obj[methodName];\n      if (typeof method.bind === \"function\") {\n        return method.bind(obj);\n      } else {\n        try {\n          return Function.prototype.bind.call(method, obj);\n        } catch (e) {\n          return function() {\n            return Function.prototype.apply.apply(method, [obj, arguments]);\n          };\n        }\n      }\n    }\n    function traceForIE() {\n      if (console.log) {\n        if (console.log.apply) {\n          console.log.apply(console, arguments);\n        } else {\n          Function.prototype.apply.apply(console.log, [console, arguments]);\n        }\n      }\n      if (console.trace)\n        console.trace();\n    }\n    function realMethod(methodName) {\n      if (methodName === \"debug\") {\n        methodName = \"log\";\n      }\n      if (typeof console === undefinedType) {\n        return false;\n      } else if (methodName === \"trace\" && isIE) {\n        return traceForIE;\n      } else if (console[methodName] !== void 0) {\n        return bindMethod(console, methodName);\n      } else if (console.log !== void 0) {\n        return bindMethod(console, \"log\");\n      } else {\n        return noop2;\n      }\n    }\n    function replaceLoggingMethods(level, loggerName) {\n      for (var i = 0; i < logMethods.length; i++) {\n        var methodName = logMethods[i];\n        this[methodName] = i < level ? noop2 : this.methodFactory(methodName, level, loggerName);\n      }\n      this.log = this.debug;\n    }\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n      return function() {\n        if (typeof console !== undefinedType) {\n          replaceLoggingMethods.call(this, level, loggerName);\n          this[methodName].apply(this, arguments);\n        }\n      };\n    }\n    function defaultMethodFactory(methodName, level, loggerName) {\n      return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n    function Logger(name, defaultLevel, factory) {\n      var self2 = this;\n      var currentLevel;\n      defaultLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n      var storageKey = \"loglevel\";\n      if (typeof name === \"string\") {\n        storageKey += \":\" + name;\n      } else if (typeof name === \"symbol\") {\n        storageKey = void 0;\n      }\n      function persistLevelIfPossible(levelNum) {\n        var levelName = (logMethods[levelNum] || \"silent\").toUpperCase();\n        if (typeof window === undefinedType || !storageKey)\n          return;\n        try {\n          window.localStorage[storageKey] = levelName;\n          return;\n        } catch (ignore) {\n        }\n        try {\n          window.document.cookie = encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n        } catch (ignore) {\n        }\n      }\n      function getPersistedLevel() {\n        var storedLevel;\n        if (typeof window === undefinedType || !storageKey)\n          return;\n        try {\n          storedLevel = window.localStorage[storageKey];\n        } catch (ignore) {\n        }\n        if (typeof storedLevel === undefinedType) {\n          try {\n            var cookie = window.document.cookie;\n            var location = cookie.indexOf(encodeURIComponent(storageKey) + \"=\");\n            if (location !== -1) {\n              storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n            }\n          } catch (ignore) {\n          }\n        }\n        if (self2.levels[storedLevel] === void 0) {\n          storedLevel = void 0;\n        }\n        return storedLevel;\n      }\n      function clearPersistedLevel() {\n        if (typeof window === undefinedType || !storageKey)\n          return;\n        try {\n          window.localStorage.removeItem(storageKey);\n          return;\n        } catch (ignore) {\n        }\n        try {\n          window.document.cookie = encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n        } catch (ignore) {\n        }\n      }\n      self2.name = name;\n      self2.levels = {\n        \"TRACE\": 0,\n        \"DEBUG\": 1,\n        \"INFO\": 2,\n        \"WARN\": 3,\n        \"ERROR\": 4,\n        \"SILENT\": 5\n      };\n      self2.methodFactory = factory || defaultMethodFactory;\n      self2.getLevel = function() {\n        return currentLevel;\n      };\n      self2.setLevel = function(level, persist) {\n        if (typeof level === \"string\" && self2.levels[level.toUpperCase()] !== void 0) {\n          level = self2.levels[level.toUpperCase()];\n        }\n        if (typeof level === \"number\" && level >= 0 && level <= self2.levels.SILENT) {\n          currentLevel = level;\n          if (persist !== false) {\n            persistLevelIfPossible(level);\n          }\n          replaceLoggingMethods.call(self2, level, name);\n          if (typeof console === undefinedType && level < self2.levels.SILENT) {\n            return \"No console available for logging\";\n          }\n        } else {\n          throw \"log.setLevel() called with invalid level: \" + level;\n        }\n      };\n      self2.setDefaultLevel = function(level) {\n        defaultLevel = level;\n        if (!getPersistedLevel()) {\n          self2.setLevel(level, false);\n        }\n      };\n      self2.resetLevel = function() {\n        self2.setLevel(defaultLevel, false);\n        clearPersistedLevel();\n      };\n      self2.enableAll = function(persist) {\n        self2.setLevel(self2.levels.TRACE, persist);\n      };\n      self2.disableAll = function(persist) {\n        self2.setLevel(self2.levels.SILENT, persist);\n      };\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n        initialLevel = defaultLevel;\n      }\n      self2.setLevel(initialLevel, false);\n    }\n    var defaultLogger = new Logger();\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n      if (typeof name !== \"symbol\" && typeof name !== \"string\" || name === \"\") {\n        throw new TypeError(\"You must supply a name when creating a logger.\");\n      }\n      var logger = _loggersByName[name];\n      if (!logger) {\n        logger = _loggersByName[name] = new Logger(name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n      }\n      return logger;\n    };\n    var _log = typeof window !== undefinedType ? window.log : void 0;\n    defaultLogger.noConflict = function() {\n      if (typeof window !== undefinedType && window.log === defaultLogger) {\n        window.log = _log;\n      }\n      return defaultLogger;\n    };\n    defaultLogger.getLoggers = function getLoggers() {\n      return _loggersByName;\n    };\n    defaultLogger[\"default\"] = defaultLogger;\n    return defaultLogger;\n  });\n})(loglevel);\nvar loglevelExports = loglevel.exports;\nvar LogLevel;\n(function(LogLevel2) {\n  LogLevel2[LogLevel2[\"trace\"] = 0] = \"trace\";\n  LogLevel2[LogLevel2[\"debug\"] = 1] = \"debug\";\n  LogLevel2[LogLevel2[\"info\"] = 2] = \"info\";\n  LogLevel2[LogLevel2[\"warn\"] = 3] = \"warn\";\n  LogLevel2[LogLevel2[\"error\"] = 4] = \"error\";\n  LogLevel2[LogLevel2[\"silent\"] = 5] = \"silent\";\n})(LogLevel || (LogLevel = {}));\nvar livekitLogger = loglevelExports.getLogger(\"livekit\");\nlivekitLogger.setLevel(LogLevel.info);\nfunction setLogLevel(level) {\n  livekitLogger.setLevel(level);\n}\nfunction setLogExtension(extension) {\n  const originalFactory = livekitLogger.methodFactory;\n  livekitLogger.methodFactory = (methodName, logLevel, loggerName) => {\n    const rawMethod = originalFactory(methodName, logLevel, loggerName);\n    const configLevel = livekitLogger.getLevel();\n    const needLog = logLevel >= configLevel && logLevel < LogLevel.silent;\n    return (msg, context) => {\n      if (context)\n        rawMethod(msg, context);\n      else\n        rawMethod(msg);\n      if (needLog) {\n        extension(logLevel, msg, context);\n      }\n    };\n  };\n  livekitLogger.setLevel(livekitLogger.getLevel());\n}\nvar long = Long;\nvar wasm = null;\ntry {\n  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;\n} catch (e) {\n}\nfunction Long(low, high, unsigned) {\n  this.low = low | 0;\n  this.high = high | 0;\n  this.unsigned = !!unsigned;\n}\nLong.prototype.__isLong__;\nObject.defineProperty(Long.prototype, \"__isLong__\", {\n  value: true\n});\nfunction isLong(obj) {\n  return (obj && obj[\"__isLong__\"]) === true;\n}\nLong.isLong = isLong;\nvar INT_CACHE = {};\nvar UINT_CACHE = {};\nfunction fromInt(value, unsigned) {\n  var obj, cachedObj, cache;\n  if (unsigned) {\n    value >>>= 0;\n    if (cache = 0 <= value && value < 256) {\n      cachedObj = UINT_CACHE[value];\n      if (cachedObj)\n        return cachedObj;\n    }\n    obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\n    if (cache)\n      UINT_CACHE[value] = obj;\n    return obj;\n  } else {\n    value |= 0;\n    if (cache = -128 <= value && value < 128) {\n      cachedObj = INT_CACHE[value];\n      if (cachedObj)\n        return cachedObj;\n    }\n    obj = fromBits(value, value < 0 ? -1 : 0, false);\n    if (cache)\n      INT_CACHE[value] = obj;\n    return obj;\n  }\n}\nLong.fromInt = fromInt;\nfunction fromNumber(value, unsigned) {\n  if (isNaN(value))\n    return unsigned ? UZERO : ZERO;\n  if (unsigned) {\n    if (value < 0)\n      return UZERO;\n    if (value >= TWO_PWR_64_DBL)\n      return MAX_UNSIGNED_VALUE;\n  } else {\n    if (value <= -TWO_PWR_63_DBL)\n      return MIN_VALUE;\n    if (value + 1 >= TWO_PWR_63_DBL)\n      return MAX_VALUE;\n  }\n  if (value < 0)\n    return fromNumber(-value, unsigned).neg();\n  return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);\n}\nLong.fromNumber = fromNumber;\nfunction fromBits(lowBits, highBits, unsigned) {\n  return new Long(lowBits, highBits, unsigned);\n}\nLong.fromBits = fromBits;\nvar pow_dbl = Math.pow;\nfunction fromString(str, unsigned, radix) {\n  if (str.length === 0)\n    throw Error(\"empty string\");\n  if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\n    return ZERO;\n  if (typeof unsigned === \"number\") {\n    radix = unsigned, unsigned = false;\n  } else {\n    unsigned = !!unsigned;\n  }\n  radix = radix || 10;\n  if (radix < 2 || 36 < radix)\n    throw RangeError(\"radix\");\n  var p;\n  if ((p = str.indexOf(\"-\")) > 0)\n    throw Error(\"interior hyphen\");\n  else if (p === 0) {\n    return fromString(str.substring(1), unsigned, radix).neg();\n  }\n  var radixToPower = fromNumber(pow_dbl(radix, 8));\n  var result = ZERO;\n  for (var i = 0; i < str.length; i += 8) {\n    var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);\n    if (size < 8) {\n      var power = fromNumber(pow_dbl(radix, size));\n      result = result.mul(power).add(fromNumber(value));\n    } else {\n      result = result.mul(radixToPower);\n      result = result.add(fromNumber(value));\n    }\n  }\n  result.unsigned = unsigned;\n  return result;\n}\nLong.fromString = fromString;\nfunction fromValue(val, unsigned) {\n  if (typeof val === \"number\")\n    return fromNumber(val, unsigned);\n  if (typeof val === \"string\")\n    return fromString(val, unsigned);\n  return fromBits(val.low, val.high, typeof unsigned === \"boolean\" ? unsigned : val.unsigned);\n}\nLong.fromValue = fromValue;\nvar TWO_PWR_16_DBL = 1 << 16;\nvar TWO_PWR_24_DBL = 1 << 24;\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\nvar ZERO = fromInt(0);\nLong.ZERO = ZERO;\nvar UZERO = fromInt(0, true);\nLong.UZERO = UZERO;\nvar ONE = fromInt(1);\nLong.ONE = ONE;\nvar UONE = fromInt(1, true);\nLong.UONE = UONE;\nvar NEG_ONE = fromInt(-1);\nLong.NEG_ONE = NEG_ONE;\nvar MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);\nLong.MAX_VALUE = MAX_VALUE;\nvar MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);\nLong.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\nvar MIN_VALUE = fromBits(0, 2147483648 | 0, false);\nLong.MIN_VALUE = MIN_VALUE;\nvar LongPrototype = Long.prototype;\nLongPrototype.toInt = function toInt() {\n  return this.unsigned ? this.low >>> 0 : this.low;\n};\nLongPrototype.toNumber = function toNumber() {\n  if (this.unsigned)\n    return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n  return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n};\nLongPrototype.toString = function toString(radix) {\n  radix = radix || 10;\n  if (radix < 2 || 36 < radix)\n    throw RangeError(\"radix\");\n  if (this.isZero())\n    return \"0\";\n  if (this.isNegative()) {\n    if (this.eq(MIN_VALUE)) {\n      var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);\n      return div.toString(radix) + rem1.toInt().toString(radix);\n    } else\n      return \"-\" + this.neg().toString(radix);\n  }\n  var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;\n  var result = \"\";\n  while (true) {\n    var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);\n    rem = remDiv;\n    if (rem.isZero())\n      return digits + result;\n    else {\n      while (digits.length < 6)\n        digits = \"0\" + digits;\n      result = \"\" + digits + result;\n    }\n  }\n};\nLongPrototype.getHighBits = function getHighBits() {\n  return this.high;\n};\nLongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\n  return this.high >>> 0;\n};\nLongPrototype.getLowBits = function getLowBits() {\n  return this.low;\n};\nLongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\n  return this.low >>> 0;\n};\nLongPrototype.getNumBitsAbs = function getNumBitsAbs() {\n  if (this.isNegative())\n    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n  var val = this.high != 0 ? this.high : this.low;\n  for (var bit = 31; bit > 0; bit--)\n    if ((val & 1 << bit) != 0)\n      break;\n  return this.high != 0 ? bit + 33 : bit + 1;\n};\nLongPrototype.isZero = function isZero() {\n  return this.high === 0 && this.low === 0;\n};\nLongPrototype.eqz = LongPrototype.isZero;\nLongPrototype.isNegative = function isNegative() {\n  return !this.unsigned && this.high < 0;\n};\nLongPrototype.isPositive = function isPositive() {\n  return this.unsigned || this.high >= 0;\n};\nLongPrototype.isOdd = function isOdd() {\n  return (this.low & 1) === 1;\n};\nLongPrototype.isEven = function isEven() {\n  return (this.low & 1) === 0;\n};\nLongPrototype.equals = function equals(other) {\n  if (!isLong(other))\n    other = fromValue(other);\n  if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)\n    return false;\n  return this.high === other.high && this.low === other.low;\n};\nLongPrototype.eq = LongPrototype.equals;\nLongPrototype.notEquals = function notEquals(other) {\n  return !this.eq(\n    /* validates */\n    other\n  );\n};\nLongPrototype.neq = LongPrototype.notEquals;\nLongPrototype.ne = LongPrototype.notEquals;\nLongPrototype.lessThan = function lessThan(other) {\n  return this.comp(\n    /* validates */\n    other\n  ) < 0;\n};\nLongPrototype.lt = LongPrototype.lessThan;\nLongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\n  return this.comp(\n    /* validates */\n    other\n  ) <= 0;\n};\nLongPrototype.lte = LongPrototype.lessThanOrEqual;\nLongPrototype.le = LongPrototype.lessThanOrEqual;\nLongPrototype.greaterThan = function greaterThan(other) {\n  return this.comp(\n    /* validates */\n    other\n  ) > 0;\n};\nLongPrototype.gt = LongPrototype.greaterThan;\nLongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\n  return this.comp(\n    /* validates */\n    other\n  ) >= 0;\n};\nLongPrototype.gte = LongPrototype.greaterThanOrEqual;\nLongPrototype.ge = LongPrototype.greaterThanOrEqual;\nLongPrototype.compare = function compare(other) {\n  if (!isLong(other))\n    other = fromValue(other);\n  if (this.eq(other))\n    return 0;\n  var thisNeg = this.isNegative(), otherNeg = other.isNegative();\n  if (thisNeg && !otherNeg)\n    return -1;\n  if (!thisNeg && otherNeg)\n    return 1;\n  if (!this.unsigned)\n    return this.sub(other).isNegative() ? -1 : 1;\n  return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;\n};\nLongPrototype.comp = LongPrototype.compare;\nLongPrototype.negate = function negate() {\n  if (!this.unsigned && this.eq(MIN_VALUE))\n    return MIN_VALUE;\n  return this.not().add(ONE);\n};\nLongPrototype.neg = LongPrototype.negate;\nLongPrototype.add = function add(addend) {\n  if (!isLong(addend))\n    addend = fromValue(addend);\n  var a48 = this.high >>> 16;\n  var a32 = this.high & 65535;\n  var a16 = this.low >>> 16;\n  var a00 = this.low & 65535;\n  var b48 = addend.high >>> 16;\n  var b32 = addend.high & 65535;\n  var b16 = addend.low >>> 16;\n  var b00 = addend.low & 65535;\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 + b00;\n  c16 += c00 >>> 16;\n  c00 &= 65535;\n  c16 += a16 + b16;\n  c32 += c16 >>> 16;\n  c16 &= 65535;\n  c32 += a32 + b32;\n  c48 += c32 >>> 16;\n  c32 &= 65535;\n  c48 += a48 + b48;\n  c48 &= 65535;\n  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n};\nLongPrototype.subtract = function subtract(subtrahend) {\n  if (!isLong(subtrahend))\n    subtrahend = fromValue(subtrahend);\n  return this.add(subtrahend.neg());\n};\nLongPrototype.sub = LongPrototype.subtract;\nLongPrototype.multiply = function multiply(multiplier) {\n  if (this.isZero())\n    return ZERO;\n  if (!isLong(multiplier))\n    multiplier = fromValue(multiplier);\n  if (wasm) {\n    var low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);\n    return fromBits(low, wasm.get_high(), this.unsigned);\n  }\n  if (multiplier.isZero())\n    return ZERO;\n  if (this.eq(MIN_VALUE))\n    return multiplier.isOdd() ? MIN_VALUE : ZERO;\n  if (multiplier.eq(MIN_VALUE))\n    return this.isOdd() ? MIN_VALUE : ZERO;\n  if (this.isNegative()) {\n    if (multiplier.isNegative())\n      return this.neg().mul(multiplier.neg());\n    else\n      return this.neg().mul(multiplier).neg();\n  } else if (multiplier.isNegative())\n    return this.mul(multiplier.neg()).neg();\n  if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\n    return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\n  var a48 = this.high >>> 16;\n  var a32 = this.high & 65535;\n  var a16 = this.low >>> 16;\n  var a00 = this.low & 65535;\n  var b48 = multiplier.high >>> 16;\n  var b32 = multiplier.high & 65535;\n  var b16 = multiplier.low >>> 16;\n  var b00 = multiplier.low & 65535;\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 * b00;\n  c16 += c00 >>> 16;\n  c00 &= 65535;\n  c16 += a16 * b00;\n  c32 += c16 >>> 16;\n  c16 &= 65535;\n  c16 += a00 * b16;\n  c32 += c16 >>> 16;\n  c16 &= 65535;\n  c32 += a32 * b00;\n  c48 += c32 >>> 16;\n  c32 &= 65535;\n  c32 += a16 * b16;\n  c48 += c32 >>> 16;\n  c32 &= 65535;\n  c32 += a00 * b32;\n  c48 += c32 >>> 16;\n  c32 &= 65535;\n  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n  c48 &= 65535;\n  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n};\nLongPrototype.mul = LongPrototype.multiply;\nLongPrototype.divide = function divide(divisor) {\n  if (!isLong(divisor))\n    divisor = fromValue(divisor);\n  if (divisor.isZero())\n    throw Error(\"division by zero\");\n  if (wasm) {\n    if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {\n      return this;\n    }\n    var low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);\n    return fromBits(low, wasm.get_high(), this.unsigned);\n  }\n  if (this.isZero())\n    return this.unsigned ? UZERO : ZERO;\n  var approx, rem, res;\n  if (!this.unsigned) {\n    if (this.eq(MIN_VALUE)) {\n      if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\n        return MIN_VALUE;\n      else if (divisor.eq(MIN_VALUE))\n        return ONE;\n      else {\n        var halfThis = this.shr(1);\n        approx = halfThis.div(divisor).shl(1);\n        if (approx.eq(ZERO)) {\n          return divisor.isNegative() ? ONE : NEG_ONE;\n        } else {\n          rem = this.sub(divisor.mul(approx));\n          res = approx.add(rem.div(divisor));\n          return res;\n        }\n      }\n    } else if (divisor.eq(MIN_VALUE))\n      return this.unsigned ? UZERO : ZERO;\n    if (this.isNegative()) {\n      if (divisor.isNegative())\n        return this.neg().div(divisor.neg());\n      return this.neg().div(divisor).neg();\n    } else if (divisor.isNegative())\n      return this.div(divisor.neg()).neg();\n    res = ZERO;\n  } else {\n    if (!divisor.unsigned)\n      divisor = divisor.toUnsigned();\n    if (divisor.gt(this))\n      return UZERO;\n    if (divisor.gt(this.shru(1)))\n      return UONE;\n    res = UZERO;\n  }\n  rem = this;\n  while (rem.gte(divisor)) {\n    approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n    var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);\n    while (approxRem.isNegative() || approxRem.gt(rem)) {\n      approx -= delta;\n      approxRes = fromNumber(approx, this.unsigned);\n      approxRem = approxRes.mul(divisor);\n    }\n    if (approxRes.isZero())\n      approxRes = ONE;\n    res = res.add(approxRes);\n    rem = rem.sub(approxRem);\n  }\n  return res;\n};\nLongPrototype.div = LongPrototype.divide;\nLongPrototype.modulo = function modulo(divisor) {\n  if (!isLong(divisor))\n    divisor = fromValue(divisor);\n  if (wasm) {\n    var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);\n    return fromBits(low, wasm.get_high(), this.unsigned);\n  }\n  return this.sub(this.div(divisor).mul(divisor));\n};\nLongPrototype.mod = LongPrototype.modulo;\nLongPrototype.rem = LongPrototype.modulo;\nLongPrototype.not = function not() {\n  return fromBits(~this.low, ~this.high, this.unsigned);\n};\nLongPrototype.and = function and(other) {\n  if (!isLong(other))\n    other = fromValue(other);\n  return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n};\nLongPrototype.or = function or(other) {\n  if (!isLong(other))\n    other = fromValue(other);\n  return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n};\nLongPrototype.xor = function xor(other) {\n  if (!isLong(other))\n    other = fromValue(other);\n  return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n};\nLongPrototype.shiftLeft = function shiftLeft(numBits) {\n  if (isLong(numBits))\n    numBits = numBits.toInt();\n  if ((numBits &= 63) === 0)\n    return this;\n  else if (numBits < 32)\n    return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);\n  else\n    return fromBits(0, this.low << numBits - 32, this.unsigned);\n};\nLongPrototype.shl = LongPrototype.shiftLeft;\nLongPrototype.shiftRight = function shiftRight(numBits) {\n  if (isLong(numBits))\n    numBits = numBits.toInt();\n  if ((numBits &= 63) === 0)\n    return this;\n  else if (numBits < 32)\n    return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);\n  else\n    return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n};\nLongPrototype.shr = LongPrototype.shiftRight;\nLongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\n  if (isLong(numBits))\n    numBits = numBits.toInt();\n  numBits &= 63;\n  if (numBits === 0)\n    return this;\n  else {\n    var high = this.high;\n    if (numBits < 32) {\n      var low = this.low;\n      return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);\n    } else if (numBits === 32)\n      return fromBits(high, 0, this.unsigned);\n    else\n      return fromBits(high >>> numBits - 32, 0, this.unsigned);\n  }\n};\nLongPrototype.shru = LongPrototype.shiftRightUnsigned;\nLongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\nLongPrototype.toSigned = function toSigned() {\n  if (!this.unsigned)\n    return this;\n  return fromBits(this.low, this.high, false);\n};\nLongPrototype.toUnsigned = function toUnsigned() {\n  if (this.unsigned)\n    return this;\n  return fromBits(this.low, this.high, true);\n};\nLongPrototype.toBytes = function toBytes(le) {\n  return le ? this.toBytesLE() : this.toBytesBE();\n};\nLongPrototype.toBytesLE = function toBytesLE() {\n  var hi = this.high, lo = this.low;\n  return [lo & 255, lo >>> 8 & 255, lo >>> 16 & 255, lo >>> 24, hi & 255, hi >>> 8 & 255, hi >>> 16 & 255, hi >>> 24];\n};\nLongPrototype.toBytesBE = function toBytesBE() {\n  var hi = this.high, lo = this.low;\n  return [hi >>> 24, hi >>> 16 & 255, hi >>> 8 & 255, hi & 255, lo >>> 24, lo >>> 16 & 255, lo >>> 8 & 255, lo & 255];\n};\nLong.fromBytes = function fromBytes(bytes, unsigned, le) {\n  return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\n};\nLong.fromBytesLE = function fromBytesLE(bytes, unsigned) {\n  return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);\n};\nLong.fromBytesBE = function fromBytesBE(bytes, unsigned) {\n  return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);\n};\nvar Long$1 = getDefaultExportFromCjs(long);\nvar indexMinimal = {};\nvar minimal$1 = {};\nvar aspromise;\nvar hasRequiredAspromise;\nfunction requireAspromise() {\n  if (hasRequiredAspromise)\n    return aspromise;\n  hasRequiredAspromise = 1;\n  aspromise = asPromise;\n  function asPromise(fn, ctx) {\n    var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;\n    while (index < arguments.length)\n      params[offset++] = arguments[index++];\n    return new Promise(function executor(resolve, reject) {\n      params[offset] = function callback(err) {\n        if (pending) {\n          pending = false;\n          if (err)\n            reject(err);\n          else {\n            var params2 = new Array(arguments.length - 1), offset2 = 0;\n            while (offset2 < params2.length)\n              params2[offset2++] = arguments[offset2];\n            resolve.apply(null, params2);\n          }\n        }\n      };\n      try {\n        fn.apply(ctx || null, params);\n      } catch (err) {\n        if (pending) {\n          pending = false;\n          reject(err);\n        }\n      }\n    });\n  }\n  return aspromise;\n}\nvar base64$1 = {};\nvar hasRequiredBase64;\nfunction requireBase64() {\n  if (hasRequiredBase64)\n    return base64$1;\n  hasRequiredBase64 = 1;\n  (function(exports) {\n    var base642 = exports;\n    base642.length = function length(string) {\n      var p = string.length;\n      if (!p)\n        return 0;\n      var n = 0;\n      while (--p % 4 > 1 && string.charAt(p) === \"=\")\n        ++n;\n      return Math.ceil(string.length * 3) / 4 - n;\n    };\n    var b64 = new Array(64);\n    var s64 = new Array(123);\n    for (var i = 0; i < 64; )\n      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\n    base642.encode = function encode(buffer, start, end2) {\n      var parts = null, chunk = [];\n      var i2 = 0, j = 0, t;\n      while (start < end2) {\n        var b = buffer[start++];\n        switch (j) {\n          case 0:\n            chunk[i2++] = b64[b >> 2];\n            t = (b & 3) << 4;\n            j = 1;\n            break;\n          case 1:\n            chunk[i2++] = b64[t | b >> 4];\n            t = (b & 15) << 2;\n            j = 2;\n            break;\n          case 2:\n            chunk[i2++] = b64[t | b >> 6];\n            chunk[i2++] = b64[b & 63];\n            j = 0;\n            break;\n        }\n        if (i2 > 8191) {\n          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n          i2 = 0;\n        }\n      }\n      if (j) {\n        chunk[i2++] = b64[t];\n        chunk[i2++] = 61;\n        if (j === 1)\n          chunk[i2++] = 61;\n      }\n      if (parts) {\n        if (i2)\n          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));\n        return parts.join(\"\");\n      }\n      return String.fromCharCode.apply(String, chunk.slice(0, i2));\n    };\n    var invalidEncoding = \"invalid encoding\";\n    base642.decode = function decode(string, buffer, offset) {\n      var start = offset;\n      var j = 0, t;\n      for (var i2 = 0; i2 < string.length; ) {\n        var c = string.charCodeAt(i2++);\n        if (c === 61 && j > 1)\n          break;\n        if ((c = s64[c]) === void 0)\n          throw Error(invalidEncoding);\n        switch (j) {\n          case 0:\n            t = c;\n            j = 1;\n            break;\n          case 1:\n            buffer[offset++] = t << 2 | (c & 48) >> 4;\n            t = c;\n            j = 2;\n            break;\n          case 2:\n            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\n            t = c;\n            j = 3;\n            break;\n          case 3:\n            buffer[offset++] = (t & 3) << 6 | c;\n            j = 0;\n            break;\n        }\n      }\n      if (j === 1)\n        throw Error(invalidEncoding);\n      return offset - start;\n    };\n    base642.test = function test(string) {\n      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\n    };\n  })(base64$1);\n  return base64$1;\n}\nvar eventemitter;\nvar hasRequiredEventemitter;\nfunction requireEventemitter() {\n  if (hasRequiredEventemitter)\n    return eventemitter;\n  hasRequiredEventemitter = 1;\n  eventemitter = EventEmitter2;\n  function EventEmitter2() {\n    this._listeners = {};\n  }\n  EventEmitter2.prototype.on = function on(evt, fn, ctx) {\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\n      fn,\n      ctx: ctx || this\n    });\n    return this;\n  };\n  EventEmitter2.prototype.off = function off(evt, fn) {\n    if (evt === void 0)\n      this._listeners = {};\n    else {\n      if (fn === void 0)\n        this._listeners[evt] = [];\n      else {\n        var listeners2 = this._listeners[evt];\n        for (var i = 0; i < listeners2.length; )\n          if (listeners2[i].fn === fn)\n            listeners2.splice(i, 1);\n          else\n            ++i;\n      }\n    }\n    return this;\n  };\n  EventEmitter2.prototype.emit = function emit2(evt) {\n    var listeners2 = this._listeners[evt];\n    if (listeners2) {\n      var args = [], i = 1;\n      for (; i < arguments.length; )\n        args.push(arguments[i++]);\n      for (i = 0; i < listeners2.length; )\n        listeners2[i].fn.apply(listeners2[i++].ctx, args);\n    }\n    return this;\n  };\n  return eventemitter;\n}\nvar float;\nvar hasRequiredFloat;\nfunction requireFloat() {\n  if (hasRequiredFloat)\n    return float;\n  hasRequiredFloat = 1;\n  float = factory(factory);\n  function factory(exports) {\n    if (typeof Float32Array !== \"undefined\")\n      (function() {\n        var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;\n        function writeFloat_f32_cpy(val, buf, pos) {\n          f32[0] = val;\n          buf[pos] = f8b[0];\n          buf[pos + 1] = f8b[1];\n          buf[pos + 2] = f8b[2];\n          buf[pos + 3] = f8b[3];\n        }\n        function writeFloat_f32_rev(val, buf, pos) {\n          f32[0] = val;\n          buf[pos] = f8b[3];\n          buf[pos + 1] = f8b[2];\n          buf[pos + 2] = f8b[1];\n          buf[pos + 3] = f8b[0];\n        }\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\n        function readFloat_f32_cpy(buf, pos) {\n          f8b[0] = buf[pos];\n          f8b[1] = buf[pos + 1];\n          f8b[2] = buf[pos + 2];\n          f8b[3] = buf[pos + 3];\n          return f32[0];\n        }\n        function readFloat_f32_rev(buf, pos) {\n          f8b[3] = buf[pos];\n          f8b[2] = buf[pos + 1];\n          f8b[1] = buf[pos + 2];\n          f8b[0] = buf[pos + 3];\n          return f32[0];\n        }\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\n      })();\n    else\n      (function() {\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\n          var sign = val < 0 ? 1 : 0;\n          if (sign)\n            val = -val;\n          if (val === 0)\n            writeUint(1 / val > 0 ? (\n              /* positive */\n              0\n            ) : (\n              /* negative 0 */\n              2147483648\n            ), buf, pos);\n          else if (isNaN(val))\n            writeUint(2143289344, buf, pos);\n          else if (val > 34028234663852886e22)\n            writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\n          else if (val < 11754943508222875e-54)\n            writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);\n          else {\n            var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\n            writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\n          }\n        }\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\n        function readFloat_ieee754(readUint, buf, pos) {\n          var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;\n          return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\n        }\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\n      })();\n    if (typeof Float64Array !== \"undefined\")\n      (function() {\n        var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;\n        function writeDouble_f64_cpy(val, buf, pos) {\n          f64[0] = val;\n          buf[pos] = f8b[0];\n          buf[pos + 1] = f8b[1];\n          buf[pos + 2] = f8b[2];\n          buf[pos + 3] = f8b[3];\n          buf[pos + 4] = f8b[4];\n          buf[pos + 5] = f8b[5];\n          buf[pos + 6] = f8b[6];\n          buf[pos + 7] = f8b[7];\n        }\n        function writeDouble_f64_rev(val, buf, pos) {\n          f64[0] = val;\n          buf[pos] = f8b[7];\n          buf[pos + 1] = f8b[6];\n          buf[pos + 2] = f8b[5];\n          buf[pos + 3] = f8b[4];\n          buf[pos + 4] = f8b[3];\n          buf[pos + 5] = f8b[2];\n          buf[pos + 6] = f8b[1];\n          buf[pos + 7] = f8b[0];\n        }\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\n        function readDouble_f64_cpy(buf, pos) {\n          f8b[0] = buf[pos];\n          f8b[1] = buf[pos + 1];\n          f8b[2] = buf[pos + 2];\n          f8b[3] = buf[pos + 3];\n          f8b[4] = buf[pos + 4];\n          f8b[5] = buf[pos + 5];\n          f8b[6] = buf[pos + 6];\n          f8b[7] = buf[pos + 7];\n          return f64[0];\n        }\n        function readDouble_f64_rev(buf, pos) {\n          f8b[7] = buf[pos];\n          f8b[6] = buf[pos + 1];\n          f8b[5] = buf[pos + 2];\n          f8b[4] = buf[pos + 3];\n          f8b[3] = buf[pos + 4];\n          f8b[2] = buf[pos + 5];\n          f8b[1] = buf[pos + 6];\n          f8b[0] = buf[pos + 7];\n          return f64[0];\n        }\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\n      })();\n    else\n      (function() {\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\n          var sign = val < 0 ? 1 : 0;\n          if (sign)\n            val = -val;\n          if (val === 0) {\n            writeUint(0, buf, pos + off0);\n            writeUint(1 / val > 0 ? (\n              /* positive */\n              0\n            ) : (\n              /* negative 0 */\n              2147483648\n            ), buf, pos + off1);\n          } else if (isNaN(val)) {\n            writeUint(0, buf, pos + off0);\n            writeUint(2146959360, buf, pos + off1);\n          } else if (val > 17976931348623157e292) {\n            writeUint(0, buf, pos + off0);\n            writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\n          } else {\n            var mantissa;\n            if (val < 22250738585072014e-324) {\n              mantissa = val / 5e-324;\n              writeUint(mantissa >>> 0, buf, pos + off0);\n              writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\n            } else {\n              var exponent = Math.floor(Math.log(val) / Math.LN2);\n              if (exponent === 1024)\n                exponent = 1023;\n              mantissa = val * Math.pow(2, -exponent);\n              writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\n              writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\n            }\n          }\n        }\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\n          var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);\n          var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;\n          return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\n        }\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\n      })();\n    return exports;\n  }\n  function writeUintLE(val, buf, pos) {\n    buf[pos] = val & 255;\n    buf[pos + 1] = val >>> 8 & 255;\n    buf[pos + 2] = val >>> 16 & 255;\n    buf[pos + 3] = val >>> 24;\n  }\n  function writeUintBE(val, buf, pos) {\n    buf[pos] = val >>> 24;\n    buf[pos + 1] = val >>> 16 & 255;\n    buf[pos + 2] = val >>> 8 & 255;\n    buf[pos + 3] = val & 255;\n  }\n  function readUintLE(buf, pos) {\n    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;\n  }\n  function readUintBE(buf, pos) {\n    return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;\n  }\n  return float;\n}\nvar inquire_1;\nvar hasRequiredInquire;\nfunction requireInquire() {\n  if (hasRequiredInquire)\n    return inquire_1;\n  hasRequiredInquire = 1;\n  inquire_1 = inquire;\n  function inquire(moduleName) {\n    try {\n      var mod = void 0;\n      if (mod && (mod.length || Object.keys(mod).length))\n        return mod;\n    } catch (e) {\n    }\n    return null;\n  }\n  return inquire_1;\n}\nvar utf8$2 = {};\nvar hasRequiredUtf8;\nfunction requireUtf8() {\n  if (hasRequiredUtf8)\n    return utf8$2;\n  hasRequiredUtf8 = 1;\n  (function(exports) {\n    var utf82 = exports;\n    utf82.length = function utf8_length(string) {\n      var len = 0, c = 0;\n      for (var i = 0; i < string.length; ++i) {\n        c = string.charCodeAt(i);\n        if (c < 128)\n          len += 1;\n        else if (c < 2048)\n          len += 2;\n        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {\n          ++i;\n          len += 4;\n        } else\n          len += 3;\n      }\n      return len;\n    };\n    utf82.read = function utf8_read(buffer, start, end2) {\n      var len = end2 - start;\n      if (len < 1)\n        return \"\";\n      var parts = null, chunk = [], i = 0, t;\n      while (start < end2) {\n        t = buffer[start++];\n        if (t < 128)\n          chunk[i++] = t;\n        else if (t > 191 && t < 224)\n          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\n        else if (t > 239 && t < 365) {\n          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;\n          chunk[i++] = 55296 + (t >> 10);\n          chunk[i++] = 56320 + (t & 1023);\n        } else\n          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\n        if (i > 8191) {\n          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n          i = 0;\n        }\n      }\n      if (parts) {\n        if (i)\n          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n        return parts.join(\"\");\n      }\n      return String.fromCharCode.apply(String, chunk.slice(0, i));\n    };\n    utf82.write = function utf8_write(string, buffer, offset) {\n      var start = offset, c1, c2;\n      for (var i = 0; i < string.length; ++i) {\n        c1 = string.charCodeAt(i);\n        if (c1 < 128) {\n          buffer[offset++] = c1;\n        } else if (c1 < 2048) {\n          buffer[offset++] = c1 >> 6 | 192;\n          buffer[offset++] = c1 & 63 | 128;\n        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {\n          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);\n          ++i;\n          buffer[offset++] = c1 >> 18 | 240;\n          buffer[offset++] = c1 >> 12 & 63 | 128;\n          buffer[offset++] = c1 >> 6 & 63 | 128;\n          buffer[offset++] = c1 & 63 | 128;\n        } else {\n          buffer[offset++] = c1 >> 12 | 224;\n          buffer[offset++] = c1 >> 6 & 63 | 128;\n          buffer[offset++] = c1 & 63 | 128;\n        }\n      }\n      return offset - start;\n    };\n  })(utf8$2);\n  return utf8$2;\n}\nvar pool_1;\nvar hasRequiredPool;\nfunction requirePool() {\n  if (hasRequiredPool)\n    return pool_1;\n  hasRequiredPool = 1;\n  pool_1 = pool;\n  function pool(alloc2, slice, size) {\n    var SIZE = size || 8192;\n    var MAX = SIZE >>> 1;\n    var slab = null;\n    var offset = SIZE;\n    return function pool_alloc(size2) {\n      if (size2 < 1 || size2 > MAX)\n        return alloc2(size2);\n      if (offset + size2 > SIZE) {\n        slab = alloc2(SIZE);\n        offset = 0;\n      }\n      var buf = slice.call(slab, offset, offset += size2);\n      if (offset & 7)\n        offset = (offset | 7) + 1;\n      return buf;\n    };\n  }\n  return pool_1;\n}\nvar longbits;\nvar hasRequiredLongbits;\nfunction requireLongbits() {\n  if (hasRequiredLongbits)\n    return longbits;\n  hasRequiredLongbits = 1;\n  longbits = LongBits2;\n  var util2 = requireMinimal();\n  function LongBits2(lo, hi) {\n    this.lo = lo >>> 0;\n    this.hi = hi >>> 0;\n  }\n  var zero = LongBits2.zero = new LongBits2(0, 0);\n  zero.toNumber = function() {\n    return 0;\n  };\n  zero.zzEncode = zero.zzDecode = function() {\n    return this;\n  };\n  zero.length = function() {\n    return 1;\n  };\n  var zeroHash = LongBits2.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n  LongBits2.fromNumber = function fromNumber2(value) {\n    if (value === 0)\n      return zero;\n    var sign = value < 0;\n    if (sign)\n      value = -value;\n    var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n      hi = ~hi >>> 0;\n      lo = ~lo >>> 0;\n      if (++lo > 4294967295) {\n        lo = 0;\n        if (++hi > 4294967295)\n          hi = 0;\n      }\n    }\n    return new LongBits2(lo, hi);\n  };\n  LongBits2.from = function from(value) {\n    if (typeof value === \"number\")\n      return LongBits2.fromNumber(value);\n    if (util2.isString(value)) {\n      if (util2.Long)\n        value = util2.Long.fromString(value);\n      else\n        return LongBits2.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits2(value.low >>> 0, value.high >>> 0) : zero;\n  };\n  LongBits2.prototype.toNumber = function toNumber2(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n      var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;\n      if (!lo)\n        hi = hi + 1 >>> 0;\n      return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n  };\n  LongBits2.prototype.toLong = function toLong(unsigned) {\n    return util2.Long ? new util2.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : {\n      low: this.lo | 0,\n      high: this.hi | 0,\n      unsigned: Boolean(unsigned)\n    };\n  };\n  var charCodeAt = String.prototype.charCodeAt;\n  LongBits2.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n      return zero;\n    return new LongBits2((charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0, (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0);\n  };\n  LongBits2.prototype.toHash = function toHash() {\n    return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);\n  };\n  LongBits2.prototype.zzEncode = function zzEncode() {\n    var mask = this.hi >> 31;\n    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo = (this.lo << 1 ^ mask) >>> 0;\n    return this;\n  };\n  LongBits2.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi = (this.hi >>> 1 ^ mask) >>> 0;\n    return this;\n  };\n  LongBits2.prototype.length = function length() {\n    var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;\n    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;\n  };\n  return longbits;\n}\nvar hasRequiredMinimal;\nfunction requireMinimal() {\n  if (hasRequiredMinimal)\n    return minimal$1;\n  hasRequiredMinimal = 1;\n  (function(exports) {\n    var util2 = exports;\n    util2.asPromise = requireAspromise();\n    util2.base64 = requireBase64();\n    util2.EventEmitter = requireEventemitter();\n    util2.float = requireFloat();\n    util2.inquire = requireInquire();\n    util2.utf8 = requireUtf8();\n    util2.pool = requirePool();\n    util2.LongBits = requireLongbits();\n    util2.isNode = Boolean(typeof commonjsGlobal !== \"undefined\" && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node);\n    util2.global = util2.isNode && commonjsGlobal || typeof window !== \"undefined\" && window || typeof self !== \"undefined\" && self || commonjsGlobal;\n    util2.emptyArray = Object.freeze ? Object.freeze([]) : (\n      /* istanbul ignore next */\n      []\n    );\n    util2.emptyObject = Object.freeze ? Object.freeze({}) : (\n      /* istanbul ignore next */\n      {}\n    );\n    util2.isInteger = Number.isInteger || /* istanbul ignore next */\n    function isInteger(value) {\n      return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n    };\n    util2.isString = function isString(value) {\n      return typeof value === \"string\" || value instanceof String;\n    };\n    util2.isObject = function isObject2(value) {\n      return value && typeof value === \"object\";\n    };\n    util2.isset = /**\n     * Checks if a property on a message is considered to be present.\n     * @param {Object} obj Plain object or message instance\n     * @param {string} prop Property name\n     * @returns {boolean} `true` if considered to be present, otherwise `false`\n     */\n    util2.isSet = function isSet2(obj, prop) {\n      var value = obj[prop];\n      if (value != null && obj.hasOwnProperty(prop))\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n      return false;\n    };\n    util2.Buffer = function() {\n      try {\n        var Buffer = util2.inquire(\"buffer\").Buffer;\n        return Buffer.prototype.utf8Write ? Buffer : (\n          /* istanbul ignore next */\n          null\n        );\n      } catch (e) {\n        return null;\n      }\n    }();\n    util2._Buffer_from = null;\n    util2._Buffer_allocUnsafe = null;\n    util2.newBuffer = function newBuffer(sizeOrArray) {\n      return typeof sizeOrArray === \"number\" ? util2.Buffer ? util2._Buffer_allocUnsafe(sizeOrArray) : new util2.Array(sizeOrArray) : util2.Buffer ? util2._Buffer_from(sizeOrArray) : typeof Uint8Array === \"undefined\" ? sizeOrArray : new Uint8Array(sizeOrArray);\n    };\n    util2.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n    util2.Long = /* istanbul ignore next */\n    util2.global.dcodeIO && /* istanbul ignore next */\n    util2.global.dcodeIO.Long || /* istanbul ignore next */\n    util2.global.Long || util2.inquire(\"long\");\n    util2.key2Re = /^true|false|0|1$/;\n    util2.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n    util2.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n    util2.longToHash = function longToHash(value) {\n      return value ? util2.LongBits.from(value).toHash() : util2.LongBits.zeroHash;\n    };\n    util2.longFromHash = function longFromHash(hash, unsigned) {\n      var bits = util2.LongBits.fromHash(hash);\n      if (util2.Long)\n        return util2.Long.fromBits(bits.lo, bits.hi, unsigned);\n      return bits.toNumber(Boolean(unsigned));\n    };\n    function merge(dst, src, ifNotSet) {\n      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === void 0 || !ifNotSet)\n          dst[keys[i]] = src[keys[i]];\n      return dst;\n    }\n    util2.merge = merge;\n    util2.lcFirst = function lcFirst(str) {\n      return str.charAt(0).toLowerCase() + str.substring(1);\n    };\n    function newError(name) {\n      function CustomError(message, properties) {\n        if (!(this instanceof CustomError))\n          return new CustomError(message, properties);\n        Object.defineProperty(this, \"message\", {\n          get: function() {\n            return message;\n          }\n        });\n        if (Error.captureStackTrace)\n          Error.captureStackTrace(this, CustomError);\n        else\n          Object.defineProperty(this, \"stack\", {\n            value: new Error().stack || \"\"\n          });\n        if (properties)\n          merge(this, properties);\n      }\n      CustomError.prototype = Object.create(Error.prototype, {\n        constructor: {\n          value: CustomError,\n          writable: true,\n          enumerable: false,\n          configurable: true\n        },\n        name: {\n          get: function get() {\n            return name;\n          },\n          set: void 0,\n          enumerable: false,\n          // configurable: false would accurately preserve the behavior of\n          // the original, but I'm guessing that was not intentional.\n          // For an actual error subclass, this property would\n          // be configurable.\n          configurable: true\n        },\n        toString: {\n          value: function value() {\n            return this.name + \": \" + this.message;\n          },\n          writable: true,\n          enumerable: false,\n          configurable: true\n        }\n      });\n      return CustomError;\n    }\n    util2.newError = newError;\n    util2.ProtocolError = newError(\"ProtocolError\");\n    util2.oneOfGetter = function getOneOf(fieldNames) {\n      var fieldMap = {};\n      for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n      return function() {\n        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)\n          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)\n            return keys[i2];\n      };\n    };\n    util2.oneOfSetter = function setOneOf(fieldNames) {\n      return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n          if (fieldNames[i] !== name)\n            delete this[fieldNames[i]];\n      };\n    };\n    util2.toJSONOptions = {\n      longs: String,\n      enums: String,\n      bytes: String,\n      json: true\n    };\n    util2._configure = function() {\n      var Buffer = util2.Buffer;\n      if (!Buffer) {\n        util2._Buffer_from = util2._Buffer_allocUnsafe = null;\n        return;\n      }\n      util2._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from || /* istanbul ignore next */\n      function Buffer_from(value, encoding) {\n        return new Buffer(value, encoding);\n      };\n      util2._Buffer_allocUnsafe = Buffer.allocUnsafe || /* istanbul ignore next */\n      function Buffer_allocUnsafe(size) {\n        return new Buffer(size);\n      };\n    };\n  })(minimal$1);\n  return minimal$1;\n}\nvar writer$2 = Writer$1;\nvar util$4 = requireMinimal();\nvar BufferWriter$1;\nvar LongBits$1 = util$4.LongBits;\nvar base64 = util$4.base64;\nvar utf8$1 = util$4.utf8;\nfunction Op(fn, len, val) {\n  this.fn = fn;\n  this.len = len;\n  this.next = void 0;\n  this.val = val;\n}\nfunction noop() {\n}\nfunction State(writer2) {\n  this.head = writer2.head;\n  this.tail = writer2.tail;\n  this.len = writer2.len;\n  this.next = writer2.states;\n}\nfunction Writer$1() {\n  this.len = 0;\n  this.head = new Op(noop, 0, 0);\n  this.tail = this.head;\n  this.states = null;\n}\nvar create$1 = function create() {\n  return util$4.Buffer ? function create_buffer_setup() {\n    return (Writer$1.create = function create_buffer() {\n      return new BufferWriter$1();\n    })();\n  } : function create_array3() {\n    return new Writer$1();\n  };\n};\nWriter$1.create = create$1();\nWriter$1.alloc = function alloc(size) {\n  return new util$4.Array(size);\n};\nif (util$4.Array !== Array)\n  Writer$1.alloc = util$4.pool(Writer$1.alloc, util$4.Array.prototype.subarray);\nWriter$1.prototype._push = function push(fn, len, val) {\n  this.tail = this.tail.next = new Op(fn, len, val);\n  this.len += len;\n  return this;\n};\nfunction writeByte(val, buf, pos) {\n  buf[pos] = val & 255;\n}\nfunction writeVarint32(val, buf, pos) {\n  while (val > 127) {\n    buf[pos++] = val & 127 | 128;\n    val >>>= 7;\n  }\n  buf[pos] = val;\n}\nfunction VarintOp(len, val) {\n  this.len = len;\n  this.next = void 0;\n  this.val = val;\n}\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\nWriter$1.prototype.uint32 = function write_uint32(value) {\n  this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;\n  return this;\n};\nWriter$1.prototype.int32 = function write_int32(value) {\n  return value < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(value)) : this.uint32(value);\n};\nWriter$1.prototype.sint32 = function write_sint32(value) {\n  return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\nfunction writeVarint64(val, buf, pos) {\n  while (val.hi) {\n    buf[pos++] = val.lo & 127 | 128;\n    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n    val.hi >>>= 7;\n  }\n  while (val.lo > 127) {\n    buf[pos++] = val.lo & 127 | 128;\n    val.lo = val.lo >>> 7;\n  }\n  buf[pos++] = val.lo;\n}\nWriter$1.prototype.uint64 = function write_uint64(value) {\n  var bits = LongBits$1.from(value);\n  return this._push(writeVarint64, bits.length(), bits);\n};\nWriter$1.prototype.int64 = Writer$1.prototype.uint64;\nWriter$1.prototype.sint64 = function write_sint64(value) {\n  var bits = LongBits$1.from(value).zzEncode();\n  return this._push(writeVarint64, bits.length(), bits);\n};\nWriter$1.prototype.bool = function write_bool(value) {\n  return this._push(writeByte, 1, value ? 1 : 0);\n};\nfunction writeFixed32(val, buf, pos) {\n  buf[pos] = val & 255;\n  buf[pos + 1] = val >>> 8 & 255;\n  buf[pos + 2] = val >>> 16 & 255;\n  buf[pos + 3] = val >>> 24;\n}\nWriter$1.prototype.fixed32 = function write_fixed32(value) {\n  return this._push(writeFixed32, 4, value >>> 0);\n};\nWriter$1.prototype.sfixed32 = Writer$1.prototype.fixed32;\nWriter$1.prototype.fixed64 = function write_fixed64(value) {\n  var bits = LongBits$1.from(value);\n  return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\nWriter$1.prototype.sfixed64 = Writer$1.prototype.fixed64;\nWriter$1.prototype.float = function write_float(value) {\n  return this._push(util$4.float.writeFloatLE, 4, value);\n};\nWriter$1.prototype.double = function write_double(value) {\n  return this._push(util$4.float.writeDoubleLE, 8, value);\n};\nvar writeBytes = util$4.Array.prototype.set ? function writeBytes_set(val, buf, pos) {\n  buf.set(val, pos);\n} : function writeBytes_for(val, buf, pos) {\n  for (var i = 0; i < val.length; ++i)\n    buf[pos + i] = val[i];\n};\nWriter$1.prototype.bytes = function write_bytes(value) {\n  var len = value.length >>> 0;\n  if (!len)\n    return this._push(writeByte, 1, 0);\n  if (util$4.isString(value)) {\n    var buf = Writer$1.alloc(len = base64.length(value));\n    base64.decode(value, buf, 0);\n    value = buf;\n  }\n  return this.uint32(len)._push(writeBytes, len, value);\n};\nWriter$1.prototype.string = function write_string(value) {\n  var len = utf8$1.length(value);\n  return len ? this.uint32(len)._push(utf8$1.write, len, value) : this._push(writeByte, 1, 0);\n};\nWriter$1.prototype.fork = function fork() {\n  this.states = new State(this);\n  this.head = this.tail = new Op(noop, 0, 0);\n  this.len = 0;\n  return this;\n};\nWriter$1.prototype.reset = function reset() {\n  if (this.states) {\n    this.head = this.states.head;\n    this.tail = this.states.tail;\n    this.len = this.states.len;\n    this.states = this.states.next;\n  } else {\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n  }\n  return this;\n};\nWriter$1.prototype.ldelim = function ldelim() {\n  var head = this.head, tail = this.tail, len = this.len;\n  this.reset().uint32(len);\n  if (len) {\n    this.tail.next = head.next;\n    this.tail = tail;\n    this.len += len;\n  }\n  return this;\n};\nWriter$1.prototype.finish = function finish() {\n  var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;\n  while (head) {\n    head.fn(head.val, buf, pos);\n    pos += head.len;\n    head = head.next;\n  }\n  return buf;\n};\nWriter$1._configure = function(BufferWriter_) {\n  BufferWriter$1 = BufferWriter_;\n  Writer$1.create = create$1();\n  BufferWriter$1._configure();\n};\nvar writer_buffer = BufferWriter;\nvar Writer = writer$2;\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\nvar util$3 = requireMinimal();\nfunction BufferWriter() {\n  Writer.call(this);\n}\nBufferWriter._configure = function() {\n  BufferWriter.alloc = util$3._Buffer_allocUnsafe;\n  BufferWriter.writeBytesBuffer = util$3.Buffer && util$3.Buffer.prototype instanceof Uint8Array && util$3.Buffer.prototype.set.name === \"set\" ? function writeBytesBuffer_set(val, buf, pos) {\n    buf.set(val, pos);\n  } : function writeBytesBuffer_copy(val, buf, pos) {\n    if (val.copy)\n      val.copy(buf, pos, 0, val.length);\n    else\n      for (var i = 0; i < val.length; )\n        buf[pos++] = val[i++];\n  };\n};\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n  if (util$3.isString(value))\n    value = util$3._Buffer_from(value, \"base64\");\n  var len = value.length >>> 0;\n  this.uint32(len);\n  if (len)\n    this._push(BufferWriter.writeBytesBuffer, len, value);\n  return this;\n};\nfunction writeStringBuffer(val, buf, pos) {\n  if (val.length < 40)\n    util$3.utf8.write(val, buf, pos);\n  else if (buf.utf8Write)\n    buf.utf8Write(val, pos);\n  else\n    buf.write(val, pos);\n}\nBufferWriter.prototype.string = function write_string_buffer(value) {\n  var len = util$3.Buffer.byteLength(value);\n  this.uint32(len);\n  if (len)\n    this._push(writeStringBuffer, len, value);\n  return this;\n};\nBufferWriter._configure();\nvar reader = Reader$1;\nvar util$2 = requireMinimal();\nvar BufferReader$1;\nvar LongBits = util$2.LongBits;\nvar utf8 = util$2.utf8;\nfunction indexOutOfRange(reader2, writeLength) {\n  return RangeError(\"index out of range: \" + reader2.pos + \" + \" + (writeLength || 1) + \" > \" + reader2.len);\n}\nfunction Reader$1(buffer) {\n  this.buf = buffer;\n  this.pos = 0;\n  this.len = buffer.length;\n}\nvar create_array = typeof Uint8Array !== \"undefined\" ? function create_typed_array(buffer) {\n  if (buffer instanceof Uint8Array || Array.isArray(buffer))\n    return new Reader$1(buffer);\n  throw Error(\"illegal buffer\");\n} : function create_array2(buffer) {\n  if (Array.isArray(buffer))\n    return new Reader$1(buffer);\n  throw Error(\"illegal buffer\");\n};\nvar create2 = function create3() {\n  return util$2.Buffer ? function create_buffer_setup(buffer) {\n    return (Reader$1.create = function create_buffer(buffer2) {\n      return util$2.Buffer.isBuffer(buffer2) ? new BufferReader$1(buffer2) : create_array(buffer2);\n    })(buffer);\n  } : create_array;\n};\nReader$1.create = create2();\nReader$1.prototype._slice = util$2.Array.prototype.subarray || /* istanbul ignore next */\nutil$2.Array.prototype.slice;\nReader$1.prototype.uint32 = function read_uint32_setup() {\n  var value = 4294967295;\n  return function read_uint32() {\n    value = (this.buf[this.pos] & 127) >>> 0;\n    if (this.buf[this.pos++] < 128)\n      return value;\n    value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;\n    if (this.buf[this.pos++] < 128)\n      return value;\n    value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;\n    if (this.buf[this.pos++] < 128)\n      return value;\n    value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;\n    if (this.buf[this.pos++] < 128)\n      return value;\n    value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;\n    if (this.buf[this.pos++] < 128)\n      return value;\n    if ((this.pos += 5) > this.len) {\n      this.pos = this.len;\n      throw indexOutOfRange(this, 10);\n    }\n    return value;\n  };\n}();\nReader$1.prototype.int32 = function read_int32() {\n  return this.uint32() | 0;\n};\nReader$1.prototype.sint32 = function read_sint32() {\n  var value = this.uint32();\n  return value >>> 1 ^ -(value & 1) | 0;\n};\nfunction readLongVarint() {\n  var bits = new LongBits(0, 0);\n  var i = 0;\n  if (this.len - this.pos > 4) {\n    for (; i < 4; ++i) {\n      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n      if (this.buf[this.pos++] < 128)\n        return bits;\n    }\n    bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n    bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;\n    if (this.buf[this.pos++] < 128)\n      return bits;\n    i = 0;\n  } else {\n    for (; i < 3; ++i) {\n      if (this.pos >= this.len)\n        throw indexOutOfRange(this);\n      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n      if (this.buf[this.pos++] < 128)\n        return bits;\n    }\n    bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n    return bits;\n  }\n  if (this.len - this.pos > 4) {\n    for (; i < 5; ++i) {\n      bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n      if (this.buf[this.pos++] < 128)\n        return bits;\n    }\n  } else {\n    for (; i < 5; ++i) {\n      if (this.pos >= this.len)\n        throw indexOutOfRange(this);\n      bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n      if (this.buf[this.pos++] < 128)\n        return bits;\n    }\n  }\n  throw Error(\"invalid varint encoding\");\n}\nReader$1.prototype.bool = function read_bool() {\n  return this.uint32() !== 0;\n};\nfunction readFixed32_end(buf, end2) {\n  return (buf[end2 - 4] | buf[end2 - 3] << 8 | buf[end2 - 2] << 16 | buf[end2 - 1] << 24) >>> 0;\n}\nReader$1.prototype.fixed32 = function read_fixed32() {\n  if (this.pos + 4 > this.len)\n    throw indexOutOfRange(this, 4);\n  return readFixed32_end(this.buf, this.pos += 4);\n};\nReader$1.prototype.sfixed32 = function read_sfixed32() {\n  if (this.pos + 4 > this.len)\n    throw indexOutOfRange(this, 4);\n  return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\nfunction readFixed64() {\n  if (this.pos + 8 > this.len)\n    throw indexOutOfRange(this, 8);\n  return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\nReader$1.prototype.float = function read_float() {\n  if (this.pos + 4 > this.len)\n    throw indexOutOfRange(this, 4);\n  var value = util$2.float.readFloatLE(this.buf, this.pos);\n  this.pos += 4;\n  return value;\n};\nReader$1.prototype.double = function read_double() {\n  if (this.pos + 8 > this.len)\n    throw indexOutOfRange(this, 4);\n  var value = util$2.float.readDoubleLE(this.buf, this.pos);\n  this.pos += 8;\n  return value;\n};\nReader$1.prototype.bytes = function read_bytes() {\n  var length = this.uint32(), start = this.pos, end2 = this.pos + length;\n  if (end2 > this.len)\n    throw indexOutOfRange(this, length);\n  this.pos += length;\n  if (Array.isArray(this.buf))\n    return this.buf.slice(start, end2);\n  return start === end2 ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end2);\n};\nReader$1.prototype.string = function read_string() {\n  var bytes = this.bytes();\n  return utf8.read(bytes, 0, bytes.length);\n};\nReader$1.prototype.skip = function skip(length) {\n  if (typeof length === \"number\") {\n    if (this.pos + length > this.len)\n      throw indexOutOfRange(this, length);\n    this.pos += length;\n  } else {\n    do {\n      if (this.pos >= this.len)\n        throw indexOutOfRange(this);\n    } while (this.buf[this.pos++] & 128);\n  }\n  return this;\n};\nReader$1.prototype.skipType = function(wireType) {\n  switch (wireType) {\n    case 0:\n      this.skip();\n      break;\n    case 1:\n      this.skip(8);\n      break;\n    case 2:\n      this.skip(this.uint32());\n      break;\n    case 3:\n      while ((wireType = this.uint32() & 7) !== 4) {\n        this.skipType(wireType);\n      }\n      break;\n    case 5:\n      this.skip(4);\n      break;\n    default:\n      throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n  }\n  return this;\n};\nReader$1._configure = function(BufferReader_) {\n  BufferReader$1 = BufferReader_;\n  Reader$1.create = create2();\n  BufferReader$1._configure();\n  var fn = util$2.Long ? \"toLong\" : (\n    /* istanbul ignore next */\n    \"toNumber\"\n  );\n  util$2.merge(Reader$1.prototype, {\n    int64: function read_int64() {\n      return readLongVarint.call(this)[fn](false);\n    },\n    uint64: function read_uint64() {\n      return readLongVarint.call(this)[fn](true);\n    },\n    sint64: function read_sint64() {\n      return readLongVarint.call(this).zzDecode()[fn](false);\n    },\n    fixed64: function read_fixed64() {\n      return readFixed64.call(this)[fn](true);\n    },\n    sfixed64: function read_sfixed64() {\n      return readFixed64.call(this)[fn](false);\n    }\n  });\n};\nvar reader_buffer = BufferReader;\nvar Reader = reader;\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\nvar util$1 = requireMinimal();\nfunction BufferReader(buffer) {\n  Reader.call(this, buffer);\n}\nBufferReader._configure = function() {\n  if (util$1.Buffer)\n    BufferReader.prototype._slice = util$1.Buffer.prototype.slice;\n};\nBufferReader.prototype.string = function read_string_buffer() {\n  var len = this.uint32();\n  return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\nBufferReader._configure();\nvar rpc = {};\nvar service = Service;\nvar util = requireMinimal();\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n  if (typeof rpcImpl !== \"function\")\n    throw TypeError(\"rpcImpl must be a function\");\n  util.EventEmitter.call(this);\n  this.rpcImpl = rpcImpl;\n  this.requestDelimited = Boolean(requestDelimited);\n  this.responseDelimited = Boolean(responseDelimited);\n}\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n  if (!request)\n    throw TypeError(\"request must be specified\");\n  var self2 = this;\n  if (!callback)\n    return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);\n  if (!self2.rpcImpl) {\n    setTimeout(function() {\n      callback(Error(\"already ended\"));\n    }, 0);\n    return void 0;\n  }\n  try {\n    return self2.rpcImpl(method, requestCtor[self2.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(), function rpcCallback(err, response) {\n      if (err) {\n        self2.emit(\"error\", err, method);\n        return callback(err);\n      }\n      if (response === null) {\n        self2.end(\n          /* endedByRPC */\n          true\n        );\n        return void 0;\n      }\n      if (!(response instanceof responseCtor)) {\n        try {\n          response = responseCtor[self2.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n        } catch (err2) {\n          self2.emit(\"error\", err2, method);\n          return callback(err2);\n        }\n      }\n      self2.emit(\"data\", response, method);\n      return callback(null, response);\n    });\n  } catch (err) {\n    self2.emit(\"error\", err, method);\n    setTimeout(function() {\n      callback(err);\n    }, 0);\n    return void 0;\n  }\n};\nService.prototype.end = function end(endedByRPC) {\n  if (this.rpcImpl) {\n    if (!endedByRPC)\n      this.rpcImpl(null, null, null);\n    this.rpcImpl = null;\n    this.emit(\"end\").off();\n  }\n  return this;\n};\n(function(exports) {\n  var rpc2 = exports;\n  rpc2.Service = service;\n})(rpc);\nvar roots = {};\n(function(exports) {\n  var protobuf = exports;\n  protobuf.build = \"minimal\";\n  protobuf.Writer = writer$2;\n  protobuf.BufferWriter = writer_buffer;\n  protobuf.Reader = reader;\n  protobuf.BufferReader = reader_buffer;\n  protobuf.util = requireMinimal();\n  protobuf.rpc = rpc;\n  protobuf.roots = roots;\n  protobuf.configure = configure;\n  function configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n  }\n  configure();\n})(indexMinimal);\nvar minimal = indexMinimal;\nvar _m0 = getDefaultExportFromCjs(minimal);\n(() => {\n  if (typeof globalThis !== \"undefined\") {\n    return globalThis;\n  }\n  if (typeof self !== \"undefined\") {\n    return self;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n  throw \"Unable to locate global object\";\n})();\nif (_m0.util.Long !== Long$1) {\n  _m0.util.Long = Long$1;\n  _m0.configure();\n}\nvar AudioCodec;\n(function(AudioCodec2) {\n  AudioCodec2[AudioCodec2[\"DEFAULT_AC\"] = 0] = \"DEFAULT_AC\";\n  AudioCodec2[AudioCodec2[\"OPUS\"] = 1] = \"OPUS\";\n  AudioCodec2[AudioCodec2[\"AAC\"] = 2] = \"AAC\";\n  AudioCodec2[AudioCodec2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(AudioCodec || (AudioCodec = {}));\nvar VideoCodec;\n(function(VideoCodec2) {\n  VideoCodec2[VideoCodec2[\"DEFAULT_VC\"] = 0] = \"DEFAULT_VC\";\n  VideoCodec2[VideoCodec2[\"H264_BASELINE\"] = 1] = \"H264_BASELINE\";\n  VideoCodec2[VideoCodec2[\"H264_MAIN\"] = 2] = \"H264_MAIN\";\n  VideoCodec2[VideoCodec2[\"H264_HIGH\"] = 3] = \"H264_HIGH\";\n  VideoCodec2[VideoCodec2[\"VP8\"] = 4] = \"VP8\";\n  VideoCodec2[VideoCodec2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(VideoCodec || (VideoCodec = {}));\nvar TrackType;\n(function(TrackType2) {\n  TrackType2[TrackType2[\"AUDIO\"] = 0] = \"AUDIO\";\n  TrackType2[TrackType2[\"VIDEO\"] = 1] = \"VIDEO\";\n  TrackType2[TrackType2[\"DATA\"] = 2] = \"DATA\";\n  TrackType2[TrackType2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(TrackType || (TrackType = {}));\nfunction trackTypeFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"AUDIO\":\n      return TrackType.AUDIO;\n    case 1:\n    case \"VIDEO\":\n      return TrackType.VIDEO;\n    case 2:\n    case \"DATA\":\n      return TrackType.DATA;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return TrackType.UNRECOGNIZED;\n  }\n}\nfunction trackTypeToJSON(object) {\n  switch (object) {\n    case TrackType.AUDIO:\n      return \"AUDIO\";\n    case TrackType.VIDEO:\n      return \"VIDEO\";\n    case TrackType.DATA:\n      return \"DATA\";\n    case TrackType.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar TrackSource;\n(function(TrackSource2) {\n  TrackSource2[TrackSource2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  TrackSource2[TrackSource2[\"CAMERA\"] = 1] = \"CAMERA\";\n  TrackSource2[TrackSource2[\"MICROPHONE\"] = 2] = \"MICROPHONE\";\n  TrackSource2[TrackSource2[\"SCREEN_SHARE\"] = 3] = \"SCREEN_SHARE\";\n  TrackSource2[TrackSource2[\"SCREEN_SHARE_AUDIO\"] = 4] = \"SCREEN_SHARE_AUDIO\";\n  TrackSource2[TrackSource2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(TrackSource || (TrackSource = {}));\nfunction trackSourceFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"UNKNOWN\":\n      return TrackSource.UNKNOWN;\n    case 1:\n    case \"CAMERA\":\n      return TrackSource.CAMERA;\n    case 2:\n    case \"MICROPHONE\":\n      return TrackSource.MICROPHONE;\n    case 3:\n    case \"SCREEN_SHARE\":\n      return TrackSource.SCREEN_SHARE;\n    case 4:\n    case \"SCREEN_SHARE_AUDIO\":\n      return TrackSource.SCREEN_SHARE_AUDIO;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return TrackSource.UNRECOGNIZED;\n  }\n}\nfunction trackSourceToJSON(object) {\n  switch (object) {\n    case TrackSource.UNKNOWN:\n      return \"UNKNOWN\";\n    case TrackSource.CAMERA:\n      return \"CAMERA\";\n    case TrackSource.MICROPHONE:\n      return \"MICROPHONE\";\n    case TrackSource.SCREEN_SHARE:\n      return \"SCREEN_SHARE\";\n    case TrackSource.SCREEN_SHARE_AUDIO:\n      return \"SCREEN_SHARE_AUDIO\";\n    case TrackSource.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar VideoQuality;\n(function(VideoQuality2) {\n  VideoQuality2[VideoQuality2[\"LOW\"] = 0] = \"LOW\";\n  VideoQuality2[VideoQuality2[\"MEDIUM\"] = 1] = \"MEDIUM\";\n  VideoQuality2[VideoQuality2[\"HIGH\"] = 2] = \"HIGH\";\n  VideoQuality2[VideoQuality2[\"OFF\"] = 3] = \"OFF\";\n  VideoQuality2[VideoQuality2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(VideoQuality || (VideoQuality = {}));\nfunction videoQualityFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"LOW\":\n      return VideoQuality.LOW;\n    case 1:\n    case \"MEDIUM\":\n      return VideoQuality.MEDIUM;\n    case 2:\n    case \"HIGH\":\n      return VideoQuality.HIGH;\n    case 3:\n    case \"OFF\":\n      return VideoQuality.OFF;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return VideoQuality.UNRECOGNIZED;\n  }\n}\nfunction videoQualityToJSON(object) {\n  switch (object) {\n    case VideoQuality.LOW:\n      return \"LOW\";\n    case VideoQuality.MEDIUM:\n      return \"MEDIUM\";\n    case VideoQuality.HIGH:\n      return \"HIGH\";\n    case VideoQuality.OFF:\n      return \"OFF\";\n    case VideoQuality.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar ConnectionQuality$1;\n(function(ConnectionQuality2) {\n  ConnectionQuality2[ConnectionQuality2[\"POOR\"] = 0] = \"POOR\";\n  ConnectionQuality2[ConnectionQuality2[\"GOOD\"] = 1] = \"GOOD\";\n  ConnectionQuality2[ConnectionQuality2[\"EXCELLENT\"] = 2] = \"EXCELLENT\";\n  ConnectionQuality2[ConnectionQuality2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(ConnectionQuality$1 || (ConnectionQuality$1 = {}));\nfunction connectionQualityFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"POOR\":\n      return ConnectionQuality$1.POOR;\n    case 1:\n    case \"GOOD\":\n      return ConnectionQuality$1.GOOD;\n    case 2:\n    case \"EXCELLENT\":\n      return ConnectionQuality$1.EXCELLENT;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return ConnectionQuality$1.UNRECOGNIZED;\n  }\n}\nfunction connectionQualityToJSON(object) {\n  switch (object) {\n    case ConnectionQuality$1.POOR:\n      return \"POOR\";\n    case ConnectionQuality$1.GOOD:\n      return \"GOOD\";\n    case ConnectionQuality$1.EXCELLENT:\n      return \"EXCELLENT\";\n    case ConnectionQuality$1.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar ClientConfigSetting;\n(function(ClientConfigSetting2) {\n  ClientConfigSetting2[ClientConfigSetting2[\"UNSET\"] = 0] = \"UNSET\";\n  ClientConfigSetting2[ClientConfigSetting2[\"DISABLED\"] = 1] = \"DISABLED\";\n  ClientConfigSetting2[ClientConfigSetting2[\"ENABLED\"] = 2] = \"ENABLED\";\n  ClientConfigSetting2[ClientConfigSetting2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(ClientConfigSetting || (ClientConfigSetting = {}));\nfunction clientConfigSettingFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"UNSET\":\n      return ClientConfigSetting.UNSET;\n    case 1:\n    case \"DISABLED\":\n      return ClientConfigSetting.DISABLED;\n    case 2:\n    case \"ENABLED\":\n      return ClientConfigSetting.ENABLED;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return ClientConfigSetting.UNRECOGNIZED;\n  }\n}\nfunction clientConfigSettingToJSON(object) {\n  switch (object) {\n    case ClientConfigSetting.UNSET:\n      return \"UNSET\";\n    case ClientConfigSetting.DISABLED:\n      return \"DISABLED\";\n    case ClientConfigSetting.ENABLED:\n      return \"ENABLED\";\n    case ClientConfigSetting.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar DisconnectReason;\n(function(DisconnectReason2) {\n  DisconnectReason2[DisconnectReason2[\"UNKNOWN_REASON\"] = 0] = \"UNKNOWN_REASON\";\n  DisconnectReason2[DisconnectReason2[\"CLIENT_INITIATED\"] = 1] = \"CLIENT_INITIATED\";\n  DisconnectReason2[DisconnectReason2[\"DUPLICATE_IDENTITY\"] = 2] = \"DUPLICATE_IDENTITY\";\n  DisconnectReason2[DisconnectReason2[\"SERVER_SHUTDOWN\"] = 3] = \"SERVER_SHUTDOWN\";\n  DisconnectReason2[DisconnectReason2[\"PARTICIPANT_REMOVED\"] = 4] = \"PARTICIPANT_REMOVED\";\n  DisconnectReason2[DisconnectReason2[\"ROOM_DELETED\"] = 5] = \"ROOM_DELETED\";\n  DisconnectReason2[DisconnectReason2[\"STATE_MISMATCH\"] = 6] = \"STATE_MISMATCH\";\n  DisconnectReason2[DisconnectReason2[\"JOIN_FAILURE\"] = 7] = \"JOIN_FAILURE\";\n  DisconnectReason2[DisconnectReason2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(DisconnectReason || (DisconnectReason = {}));\nfunction disconnectReasonFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"UNKNOWN_REASON\":\n      return DisconnectReason.UNKNOWN_REASON;\n    case 1:\n    case \"CLIENT_INITIATED\":\n      return DisconnectReason.CLIENT_INITIATED;\n    case 2:\n    case \"DUPLICATE_IDENTITY\":\n      return DisconnectReason.DUPLICATE_IDENTITY;\n    case 3:\n    case \"SERVER_SHUTDOWN\":\n      return DisconnectReason.SERVER_SHUTDOWN;\n    case 4:\n    case \"PARTICIPANT_REMOVED\":\n      return DisconnectReason.PARTICIPANT_REMOVED;\n    case 5:\n    case \"ROOM_DELETED\":\n      return DisconnectReason.ROOM_DELETED;\n    case 6:\n    case \"STATE_MISMATCH\":\n      return DisconnectReason.STATE_MISMATCH;\n    case 7:\n    case \"JOIN_FAILURE\":\n      return DisconnectReason.JOIN_FAILURE;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return DisconnectReason.UNRECOGNIZED;\n  }\n}\nfunction disconnectReasonToJSON(object) {\n  switch (object) {\n    case DisconnectReason.UNKNOWN_REASON:\n      return \"UNKNOWN_REASON\";\n    case DisconnectReason.CLIENT_INITIATED:\n      return \"CLIENT_INITIATED\";\n    case DisconnectReason.DUPLICATE_IDENTITY:\n      return \"DUPLICATE_IDENTITY\";\n    case DisconnectReason.SERVER_SHUTDOWN:\n      return \"SERVER_SHUTDOWN\";\n    case DisconnectReason.PARTICIPANT_REMOVED:\n      return \"PARTICIPANT_REMOVED\";\n    case DisconnectReason.ROOM_DELETED:\n      return \"ROOM_DELETED\";\n    case DisconnectReason.STATE_MISMATCH:\n      return \"STATE_MISMATCH\";\n    case DisconnectReason.JOIN_FAILURE:\n      return \"JOIN_FAILURE\";\n    case DisconnectReason.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar ReconnectReason;\n(function(ReconnectReason2) {\n  ReconnectReason2[ReconnectReason2[\"RR_UNKOWN\"] = 0] = \"RR_UNKOWN\";\n  ReconnectReason2[ReconnectReason2[\"RR_SIGNAL_DISCONNECTED\"] = 1] = \"RR_SIGNAL_DISCONNECTED\";\n  ReconnectReason2[ReconnectReason2[\"RR_PUBLISHER_FAILED\"] = 2] = \"RR_PUBLISHER_FAILED\";\n  ReconnectReason2[ReconnectReason2[\"RR_SUBSCRIBER_FAILED\"] = 3] = \"RR_SUBSCRIBER_FAILED\";\n  ReconnectReason2[ReconnectReason2[\"RR_SWITCH_CANDIDATE\"] = 4] = \"RR_SWITCH_CANDIDATE\";\n  ReconnectReason2[ReconnectReason2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(ReconnectReason || (ReconnectReason = {}));\nvar ParticipantInfo_State;\n(function(ParticipantInfo_State2) {\n  ParticipantInfo_State2[ParticipantInfo_State2[\"JOINING\"] = 0] = \"JOINING\";\n  ParticipantInfo_State2[ParticipantInfo_State2[\"JOINED\"] = 1] = \"JOINED\";\n  ParticipantInfo_State2[ParticipantInfo_State2[\"ACTIVE\"] = 2] = \"ACTIVE\";\n  ParticipantInfo_State2[ParticipantInfo_State2[\"DISCONNECTED\"] = 3] = \"DISCONNECTED\";\n  ParticipantInfo_State2[ParticipantInfo_State2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(ParticipantInfo_State || (ParticipantInfo_State = {}));\nfunction participantInfo_StateFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"JOINING\":\n      return ParticipantInfo_State.JOINING;\n    case 1:\n    case \"JOINED\":\n      return ParticipantInfo_State.JOINED;\n    case 2:\n    case \"ACTIVE\":\n      return ParticipantInfo_State.ACTIVE;\n    case 3:\n    case \"DISCONNECTED\":\n      return ParticipantInfo_State.DISCONNECTED;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return ParticipantInfo_State.UNRECOGNIZED;\n  }\n}\nfunction participantInfo_StateToJSON(object) {\n  switch (object) {\n    case ParticipantInfo_State.JOINING:\n      return \"JOINING\";\n    case ParticipantInfo_State.JOINED:\n      return \"JOINED\";\n    case ParticipantInfo_State.ACTIVE:\n      return \"ACTIVE\";\n    case ParticipantInfo_State.DISCONNECTED:\n      return \"DISCONNECTED\";\n    case ParticipantInfo_State.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar Encryption_Type;\n(function(Encryption_Type2) {\n  Encryption_Type2[Encryption_Type2[\"NONE\"] = 0] = \"NONE\";\n  Encryption_Type2[Encryption_Type2[\"GCM\"] = 1] = \"GCM\";\n  Encryption_Type2[Encryption_Type2[\"CUSTOM\"] = 2] = \"CUSTOM\";\n  Encryption_Type2[Encryption_Type2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(Encryption_Type || (Encryption_Type = {}));\nfunction encryption_TypeFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"NONE\":\n      return Encryption_Type.NONE;\n    case 1:\n    case \"GCM\":\n      return Encryption_Type.GCM;\n    case 2:\n    case \"CUSTOM\":\n      return Encryption_Type.CUSTOM;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return Encryption_Type.UNRECOGNIZED;\n  }\n}\nfunction encryption_TypeToJSON(object) {\n  switch (object) {\n    case Encryption_Type.NONE:\n      return \"NONE\";\n    case Encryption_Type.GCM:\n      return \"GCM\";\n    case Encryption_Type.CUSTOM:\n      return \"CUSTOM\";\n    case Encryption_Type.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar DataPacket_Kind;\n(function(DataPacket_Kind2) {\n  DataPacket_Kind2[DataPacket_Kind2[\"RELIABLE\"] = 0] = \"RELIABLE\";\n  DataPacket_Kind2[DataPacket_Kind2[\"LOSSY\"] = 1] = \"LOSSY\";\n  DataPacket_Kind2[DataPacket_Kind2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(DataPacket_Kind || (DataPacket_Kind = {}));\nfunction dataPacket_KindFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"RELIABLE\":\n      return DataPacket_Kind.RELIABLE;\n    case 1:\n    case \"LOSSY\":\n      return DataPacket_Kind.LOSSY;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return DataPacket_Kind.UNRECOGNIZED;\n  }\n}\nfunction dataPacket_KindToJSON(object) {\n  switch (object) {\n    case DataPacket_Kind.RELIABLE:\n      return \"RELIABLE\";\n    case DataPacket_Kind.LOSSY:\n      return \"LOSSY\";\n    case DataPacket_Kind.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar ServerInfo_Edition;\n(function(ServerInfo_Edition2) {\n  ServerInfo_Edition2[ServerInfo_Edition2[\"Standard\"] = 0] = \"Standard\";\n  ServerInfo_Edition2[ServerInfo_Edition2[\"Cloud\"] = 1] = \"Cloud\";\n  ServerInfo_Edition2[ServerInfo_Edition2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(ServerInfo_Edition || (ServerInfo_Edition = {}));\nfunction serverInfo_EditionFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"Standard\":\n      return ServerInfo_Edition.Standard;\n    case 1:\n    case \"Cloud\":\n      return ServerInfo_Edition.Cloud;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return ServerInfo_Edition.UNRECOGNIZED;\n  }\n}\nfunction serverInfo_EditionToJSON(object) {\n  switch (object) {\n    case ServerInfo_Edition.Standard:\n      return \"Standard\";\n    case ServerInfo_Edition.Cloud:\n      return \"Cloud\";\n    case ServerInfo_Edition.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar ClientInfo_SDK;\n(function(ClientInfo_SDK2) {\n  ClientInfo_SDK2[ClientInfo_SDK2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  ClientInfo_SDK2[ClientInfo_SDK2[\"JS\"] = 1] = \"JS\";\n  ClientInfo_SDK2[ClientInfo_SDK2[\"SWIFT\"] = 2] = \"SWIFT\";\n  ClientInfo_SDK2[ClientInfo_SDK2[\"ANDROID\"] = 3] = \"ANDROID\";\n  ClientInfo_SDK2[ClientInfo_SDK2[\"FLUTTER\"] = 4] = \"FLUTTER\";\n  ClientInfo_SDK2[ClientInfo_SDK2[\"GO\"] = 5] = \"GO\";\n  ClientInfo_SDK2[ClientInfo_SDK2[\"UNITY\"] = 6] = \"UNITY\";\n  ClientInfo_SDK2[ClientInfo_SDK2[\"REACT_NATIVE\"] = 7] = \"REACT_NATIVE\";\n  ClientInfo_SDK2[ClientInfo_SDK2[\"RUST\"] = 8] = \"RUST\";\n  ClientInfo_SDK2[ClientInfo_SDK2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(ClientInfo_SDK || (ClientInfo_SDK = {}));\nfunction clientInfo_SDKFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"UNKNOWN\":\n      return ClientInfo_SDK.UNKNOWN;\n    case 1:\n    case \"JS\":\n      return ClientInfo_SDK.JS;\n    case 2:\n    case \"SWIFT\":\n      return ClientInfo_SDK.SWIFT;\n    case 3:\n    case \"ANDROID\":\n      return ClientInfo_SDK.ANDROID;\n    case 4:\n    case \"FLUTTER\":\n      return ClientInfo_SDK.FLUTTER;\n    case 5:\n    case \"GO\":\n      return ClientInfo_SDK.GO;\n    case 6:\n    case \"UNITY\":\n      return ClientInfo_SDK.UNITY;\n    case 7:\n    case \"REACT_NATIVE\":\n      return ClientInfo_SDK.REACT_NATIVE;\n    case 8:\n    case \"RUST\":\n      return ClientInfo_SDK.RUST;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return ClientInfo_SDK.UNRECOGNIZED;\n  }\n}\nfunction clientInfo_SDKToJSON(object) {\n  switch (object) {\n    case ClientInfo_SDK.UNKNOWN:\n      return \"UNKNOWN\";\n    case ClientInfo_SDK.JS:\n      return \"JS\";\n    case ClientInfo_SDK.SWIFT:\n      return \"SWIFT\";\n    case ClientInfo_SDK.ANDROID:\n      return \"ANDROID\";\n    case ClientInfo_SDK.FLUTTER:\n      return \"FLUTTER\";\n    case ClientInfo_SDK.GO:\n      return \"GO\";\n    case ClientInfo_SDK.UNITY:\n      return \"UNITY\";\n    case ClientInfo_SDK.REACT_NATIVE:\n      return \"REACT_NATIVE\";\n    case ClientInfo_SDK.RUST:\n      return \"RUST\";\n    case ClientInfo_SDK.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nfunction createBaseRoom() {\n  return {\n    sid: \"\",\n    name: \"\",\n    emptyTimeout: 0,\n    maxParticipants: 0,\n    creationTime: 0,\n    turnPassword: \"\",\n    enabledCodecs: [],\n    metadata: \"\",\n    numParticipants: 0,\n    numPublishers: 0,\n    activeRecording: false\n  };\n}\nvar Room$1 = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.sid !== \"\") {\n      writer2.uint32(10).string(message.sid);\n    }\n    if (message.name !== \"\") {\n      writer2.uint32(18).string(message.name);\n    }\n    if (message.emptyTimeout !== 0) {\n      writer2.uint32(24).uint32(message.emptyTimeout);\n    }\n    if (message.maxParticipants !== 0) {\n      writer2.uint32(32).uint32(message.maxParticipants);\n    }\n    if (message.creationTime !== 0) {\n      writer2.uint32(40).int64(message.creationTime);\n    }\n    if (message.turnPassword !== \"\") {\n      writer2.uint32(50).string(message.turnPassword);\n    }\n    for (const v of message.enabledCodecs) {\n      Codec.encode(v, writer2.uint32(58).fork()).ldelim();\n    }\n    if (message.metadata !== \"\") {\n      writer2.uint32(66).string(message.metadata);\n    }\n    if (message.numParticipants !== 0) {\n      writer2.uint32(72).uint32(message.numParticipants);\n    }\n    if (message.numPublishers !== 0) {\n      writer2.uint32(88).uint32(message.numPublishers);\n    }\n    if (message.activeRecording === true) {\n      writer2.uint32(80).bool(message.activeRecording);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseRoom();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.sid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.name = reader2.string();\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.emptyTimeout = reader2.uint32();\n          continue;\n        case 4:\n          if (tag != 32) {\n            break;\n          }\n          message.maxParticipants = reader2.uint32();\n          continue;\n        case 5:\n          if (tag != 40) {\n            break;\n          }\n          message.creationTime = longToNumber$1(reader2.int64());\n          continue;\n        case 6:\n          if (tag != 50) {\n            break;\n          }\n          message.turnPassword = reader2.string();\n          continue;\n        case 7:\n          if (tag != 58) {\n            break;\n          }\n          message.enabledCodecs.push(Codec.decode(reader2, reader2.uint32()));\n          continue;\n        case 8:\n          if (tag != 66) {\n            break;\n          }\n          message.metadata = reader2.string();\n          continue;\n        case 9:\n          if (tag != 72) {\n            break;\n          }\n          message.numParticipants = reader2.uint32();\n          continue;\n        case 11:\n          if (tag != 88) {\n            break;\n          }\n          message.numPublishers = reader2.uint32();\n          continue;\n        case 10:\n          if (tag != 80) {\n            break;\n          }\n          message.activeRecording = reader2.bool();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      sid: isSet$1(object.sid) ? String(object.sid) : \"\",\n      name: isSet$1(object.name) ? String(object.name) : \"\",\n      emptyTimeout: isSet$1(object.emptyTimeout) ? Number(object.emptyTimeout) : 0,\n      maxParticipants: isSet$1(object.maxParticipants) ? Number(object.maxParticipants) : 0,\n      creationTime: isSet$1(object.creationTime) ? Number(object.creationTime) : 0,\n      turnPassword: isSet$1(object.turnPassword) ? String(object.turnPassword) : \"\",\n      enabledCodecs: Array.isArray(object === null || object === void 0 ? void 0 : object.enabledCodecs) ? object.enabledCodecs.map((e) => Codec.fromJSON(e)) : [],\n      metadata: isSet$1(object.metadata) ? String(object.metadata) : \"\",\n      numParticipants: isSet$1(object.numParticipants) ? Number(object.numParticipants) : 0,\n      numPublishers: isSet$1(object.numPublishers) ? Number(object.numPublishers) : 0,\n      activeRecording: isSet$1(object.activeRecording) ? Boolean(object.activeRecording) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.sid !== void 0 && (obj.sid = message.sid);\n    message.name !== void 0 && (obj.name = message.name);\n    message.emptyTimeout !== void 0 && (obj.emptyTimeout = Math.round(message.emptyTimeout));\n    message.maxParticipants !== void 0 && (obj.maxParticipants = Math.round(message.maxParticipants));\n    message.creationTime !== void 0 && (obj.creationTime = Math.round(message.creationTime));\n    message.turnPassword !== void 0 && (obj.turnPassword = message.turnPassword);\n    if (message.enabledCodecs) {\n      obj.enabledCodecs = message.enabledCodecs.map((e) => e ? Codec.toJSON(e) : void 0);\n    } else {\n      obj.enabledCodecs = [];\n    }\n    message.metadata !== void 0 && (obj.metadata = message.metadata);\n    message.numParticipants !== void 0 && (obj.numParticipants = Math.round(message.numParticipants));\n    message.numPublishers !== void 0 && (obj.numPublishers = Math.round(message.numPublishers));\n    message.activeRecording !== void 0 && (obj.activeRecording = message.activeRecording);\n    return obj;\n  },\n  create(base) {\n    return Room$1.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n    const message = createBaseRoom();\n    message.sid = (_a = object.sid) !== null && _a !== void 0 ? _a : \"\";\n    message.name = (_b = object.name) !== null && _b !== void 0 ? _b : \"\";\n    message.emptyTimeout = (_c = object.emptyTimeout) !== null && _c !== void 0 ? _c : 0;\n    message.maxParticipants = (_d = object.maxParticipants) !== null && _d !== void 0 ? _d : 0;\n    message.creationTime = (_e = object.creationTime) !== null && _e !== void 0 ? _e : 0;\n    message.turnPassword = (_f = object.turnPassword) !== null && _f !== void 0 ? _f : \"\";\n    message.enabledCodecs = ((_g = object.enabledCodecs) === null || _g === void 0 ? void 0 : _g.map((e) => Codec.fromPartial(e))) || [];\n    message.metadata = (_h = object.metadata) !== null && _h !== void 0 ? _h : \"\";\n    message.numParticipants = (_j = object.numParticipants) !== null && _j !== void 0 ? _j : 0;\n    message.numPublishers = (_k = object.numPublishers) !== null && _k !== void 0 ? _k : 0;\n    message.activeRecording = (_l = object.activeRecording) !== null && _l !== void 0 ? _l : false;\n    return message;\n  }\n};\nfunction createBaseCodec() {\n  return {\n    mime: \"\",\n    fmtpLine: \"\"\n  };\n}\nvar Codec = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.mime !== \"\") {\n      writer2.uint32(10).string(message.mime);\n    }\n    if (message.fmtpLine !== \"\") {\n      writer2.uint32(18).string(message.fmtpLine);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseCodec();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.mime = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.fmtpLine = reader2.string();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      mime: isSet$1(object.mime) ? String(object.mime) : \"\",\n      fmtpLine: isSet$1(object.fmtpLine) ? String(object.fmtpLine) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.mime !== void 0 && (obj.mime = message.mime);\n    message.fmtpLine !== void 0 && (obj.fmtpLine = message.fmtpLine);\n    return obj;\n  },\n  create(base) {\n    return Codec.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseCodec();\n    message.mime = (_a = object.mime) !== null && _a !== void 0 ? _a : \"\";\n    message.fmtpLine = (_b = object.fmtpLine) !== null && _b !== void 0 ? _b : \"\";\n    return message;\n  }\n};\nfunction createBaseParticipantPermission() {\n  return {\n    canSubscribe: false,\n    canPublish: false,\n    canPublishData: false,\n    canPublishSources: [],\n    hidden: false,\n    recorder: false,\n    canUpdateMetadata: false\n  };\n}\nvar ParticipantPermission = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.canSubscribe === true) {\n      writer2.uint32(8).bool(message.canSubscribe);\n    }\n    if (message.canPublish === true) {\n      writer2.uint32(16).bool(message.canPublish);\n    }\n    if (message.canPublishData === true) {\n      writer2.uint32(24).bool(message.canPublishData);\n    }\n    writer2.uint32(74).fork();\n    for (const v of message.canPublishSources) {\n      writer2.int32(v);\n    }\n    writer2.ldelim();\n    if (message.hidden === true) {\n      writer2.uint32(56).bool(message.hidden);\n    }\n    if (message.recorder === true) {\n      writer2.uint32(64).bool(message.recorder);\n    }\n    if (message.canUpdateMetadata === true) {\n      writer2.uint32(80).bool(message.canUpdateMetadata);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseParticipantPermission();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 8) {\n            break;\n          }\n          message.canSubscribe = reader2.bool();\n          continue;\n        case 2:\n          if (tag != 16) {\n            break;\n          }\n          message.canPublish = reader2.bool();\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.canPublishData = reader2.bool();\n          continue;\n        case 9:\n          if (tag == 72) {\n            message.canPublishSources.push(reader2.int32());\n            continue;\n          }\n          if (tag == 74) {\n            const end22 = reader2.uint32() + reader2.pos;\n            while (reader2.pos < end22) {\n              message.canPublishSources.push(reader2.int32());\n            }\n            continue;\n          }\n          break;\n        case 7:\n          if (tag != 56) {\n            break;\n          }\n          message.hidden = reader2.bool();\n          continue;\n        case 8:\n          if (tag != 64) {\n            break;\n          }\n          message.recorder = reader2.bool();\n          continue;\n        case 10:\n          if (tag != 80) {\n            break;\n          }\n          message.canUpdateMetadata = reader2.bool();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      canSubscribe: isSet$1(object.canSubscribe) ? Boolean(object.canSubscribe) : false,\n      canPublish: isSet$1(object.canPublish) ? Boolean(object.canPublish) : false,\n      canPublishData: isSet$1(object.canPublishData) ? Boolean(object.canPublishData) : false,\n      canPublishSources: Array.isArray(object === null || object === void 0 ? void 0 : object.canPublishSources) ? object.canPublishSources.map((e) => trackSourceFromJSON(e)) : [],\n      hidden: isSet$1(object.hidden) ? Boolean(object.hidden) : false,\n      recorder: isSet$1(object.recorder) ? Boolean(object.recorder) : false,\n      canUpdateMetadata: isSet$1(object.canUpdateMetadata) ? Boolean(object.canUpdateMetadata) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.canSubscribe !== void 0 && (obj.canSubscribe = message.canSubscribe);\n    message.canPublish !== void 0 && (obj.canPublish = message.canPublish);\n    message.canPublishData !== void 0 && (obj.canPublishData = message.canPublishData);\n    if (message.canPublishSources) {\n      obj.canPublishSources = message.canPublishSources.map((e) => trackSourceToJSON(e));\n    } else {\n      obj.canPublishSources = [];\n    }\n    message.hidden !== void 0 && (obj.hidden = message.hidden);\n    message.recorder !== void 0 && (obj.recorder = message.recorder);\n    message.canUpdateMetadata !== void 0 && (obj.canUpdateMetadata = message.canUpdateMetadata);\n    return obj;\n  },\n  create(base) {\n    return ParticipantPermission.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const message = createBaseParticipantPermission();\n    message.canSubscribe = (_a = object.canSubscribe) !== null && _a !== void 0 ? _a : false;\n    message.canPublish = (_b = object.canPublish) !== null && _b !== void 0 ? _b : false;\n    message.canPublishData = (_c = object.canPublishData) !== null && _c !== void 0 ? _c : false;\n    message.canPublishSources = ((_d = object.canPublishSources) === null || _d === void 0 ? void 0 : _d.map((e) => e)) || [];\n    message.hidden = (_e = object.hidden) !== null && _e !== void 0 ? _e : false;\n    message.recorder = (_f = object.recorder) !== null && _f !== void 0 ? _f : false;\n    message.canUpdateMetadata = (_g = object.canUpdateMetadata) !== null && _g !== void 0 ? _g : false;\n    return message;\n  }\n};\nfunction createBaseParticipantInfo() {\n  return {\n    sid: \"\",\n    identity: \"\",\n    state: 0,\n    tracks: [],\n    metadata: \"\",\n    joinedAt: 0,\n    name: \"\",\n    version: 0,\n    permission: void 0,\n    region: \"\",\n    isPublisher: false\n  };\n}\nvar ParticipantInfo = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.sid !== \"\") {\n      writer2.uint32(10).string(message.sid);\n    }\n    if (message.identity !== \"\") {\n      writer2.uint32(18).string(message.identity);\n    }\n    if (message.state !== 0) {\n      writer2.uint32(24).int32(message.state);\n    }\n    for (const v of message.tracks) {\n      TrackInfo.encode(v, writer2.uint32(34).fork()).ldelim();\n    }\n    if (message.metadata !== \"\") {\n      writer2.uint32(42).string(message.metadata);\n    }\n    if (message.joinedAt !== 0) {\n      writer2.uint32(48).int64(message.joinedAt);\n    }\n    if (message.name !== \"\") {\n      writer2.uint32(74).string(message.name);\n    }\n    if (message.version !== 0) {\n      writer2.uint32(80).uint32(message.version);\n    }\n    if (message.permission !== void 0) {\n      ParticipantPermission.encode(message.permission, writer2.uint32(90).fork()).ldelim();\n    }\n    if (message.region !== \"\") {\n      writer2.uint32(98).string(message.region);\n    }\n    if (message.isPublisher === true) {\n      writer2.uint32(104).bool(message.isPublisher);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseParticipantInfo();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.sid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.identity = reader2.string();\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.state = reader2.int32();\n          continue;\n        case 4:\n          if (tag != 34) {\n            break;\n          }\n          message.tracks.push(TrackInfo.decode(reader2, reader2.uint32()));\n          continue;\n        case 5:\n          if (tag != 42) {\n            break;\n          }\n          message.metadata = reader2.string();\n          continue;\n        case 6:\n          if (tag != 48) {\n            break;\n          }\n          message.joinedAt = longToNumber$1(reader2.int64());\n          continue;\n        case 9:\n          if (tag != 74) {\n            break;\n          }\n          message.name = reader2.string();\n          continue;\n        case 10:\n          if (tag != 80) {\n            break;\n          }\n          message.version = reader2.uint32();\n          continue;\n        case 11:\n          if (tag != 90) {\n            break;\n          }\n          message.permission = ParticipantPermission.decode(reader2, reader2.uint32());\n          continue;\n        case 12:\n          if (tag != 98) {\n            break;\n          }\n          message.region = reader2.string();\n          continue;\n        case 13:\n          if (tag != 104) {\n            break;\n          }\n          message.isPublisher = reader2.bool();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      sid: isSet$1(object.sid) ? String(object.sid) : \"\",\n      identity: isSet$1(object.identity) ? String(object.identity) : \"\",\n      state: isSet$1(object.state) ? participantInfo_StateFromJSON(object.state) : 0,\n      tracks: Array.isArray(object === null || object === void 0 ? void 0 : object.tracks) ? object.tracks.map((e) => TrackInfo.fromJSON(e)) : [],\n      metadata: isSet$1(object.metadata) ? String(object.metadata) : \"\",\n      joinedAt: isSet$1(object.joinedAt) ? Number(object.joinedAt) : 0,\n      name: isSet$1(object.name) ? String(object.name) : \"\",\n      version: isSet$1(object.version) ? Number(object.version) : 0,\n      permission: isSet$1(object.permission) ? ParticipantPermission.fromJSON(object.permission) : void 0,\n      region: isSet$1(object.region) ? String(object.region) : \"\",\n      isPublisher: isSet$1(object.isPublisher) ? Boolean(object.isPublisher) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.sid !== void 0 && (obj.sid = message.sid);\n    message.identity !== void 0 && (obj.identity = message.identity);\n    message.state !== void 0 && (obj.state = participantInfo_StateToJSON(message.state));\n    if (message.tracks) {\n      obj.tracks = message.tracks.map((e) => e ? TrackInfo.toJSON(e) : void 0);\n    } else {\n      obj.tracks = [];\n    }\n    message.metadata !== void 0 && (obj.metadata = message.metadata);\n    message.joinedAt !== void 0 && (obj.joinedAt = Math.round(message.joinedAt));\n    message.name !== void 0 && (obj.name = message.name);\n    message.version !== void 0 && (obj.version = Math.round(message.version));\n    message.permission !== void 0 && (obj.permission = message.permission ? ParticipantPermission.toJSON(message.permission) : void 0);\n    message.region !== void 0 && (obj.region = message.region);\n    message.isPublisher !== void 0 && (obj.isPublisher = message.isPublisher);\n    return obj;\n  },\n  create(base) {\n    return ParticipantInfo.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    const message = createBaseParticipantInfo();\n    message.sid = (_a = object.sid) !== null && _a !== void 0 ? _a : \"\";\n    message.identity = (_b = object.identity) !== null && _b !== void 0 ? _b : \"\";\n    message.state = (_c = object.state) !== null && _c !== void 0 ? _c : 0;\n    message.tracks = ((_d = object.tracks) === null || _d === void 0 ? void 0 : _d.map((e) => TrackInfo.fromPartial(e))) || [];\n    message.metadata = (_e = object.metadata) !== null && _e !== void 0 ? _e : \"\";\n    message.joinedAt = (_f = object.joinedAt) !== null && _f !== void 0 ? _f : 0;\n    message.name = (_g = object.name) !== null && _g !== void 0 ? _g : \"\";\n    message.version = (_h = object.version) !== null && _h !== void 0 ? _h : 0;\n    message.permission = object.permission !== void 0 && object.permission !== null ? ParticipantPermission.fromPartial(object.permission) : void 0;\n    message.region = (_j = object.region) !== null && _j !== void 0 ? _j : \"\";\n    message.isPublisher = (_k = object.isPublisher) !== null && _k !== void 0 ? _k : false;\n    return message;\n  }\n};\nfunction createBaseSimulcastCodecInfo() {\n  return {\n    mimeType: \"\",\n    mid: \"\",\n    cid: \"\",\n    layers: []\n  };\n}\nvar SimulcastCodecInfo = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.mimeType !== \"\") {\n      writer2.uint32(10).string(message.mimeType);\n    }\n    if (message.mid !== \"\") {\n      writer2.uint32(18).string(message.mid);\n    }\n    if (message.cid !== \"\") {\n      writer2.uint32(26).string(message.cid);\n    }\n    for (const v of message.layers) {\n      VideoLayer.encode(v, writer2.uint32(34).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseSimulcastCodecInfo();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.mimeType = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.mid = reader2.string();\n          continue;\n        case 3:\n          if (tag != 26) {\n            break;\n          }\n          message.cid = reader2.string();\n          continue;\n        case 4:\n          if (tag != 34) {\n            break;\n          }\n          message.layers.push(VideoLayer.decode(reader2, reader2.uint32()));\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      mimeType: isSet$1(object.mimeType) ? String(object.mimeType) : \"\",\n      mid: isSet$1(object.mid) ? String(object.mid) : \"\",\n      cid: isSet$1(object.cid) ? String(object.cid) : \"\",\n      layers: Array.isArray(object === null || object === void 0 ? void 0 : object.layers) ? object.layers.map((e) => VideoLayer.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.mimeType !== void 0 && (obj.mimeType = message.mimeType);\n    message.mid !== void 0 && (obj.mid = message.mid);\n    message.cid !== void 0 && (obj.cid = message.cid);\n    if (message.layers) {\n      obj.layers = message.layers.map((e) => e ? VideoLayer.toJSON(e) : void 0);\n    } else {\n      obj.layers = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return SimulcastCodecInfo.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseSimulcastCodecInfo();\n    message.mimeType = (_a = object.mimeType) !== null && _a !== void 0 ? _a : \"\";\n    message.mid = (_b = object.mid) !== null && _b !== void 0 ? _b : \"\";\n    message.cid = (_c = object.cid) !== null && _c !== void 0 ? _c : \"\";\n    message.layers = ((_d = object.layers) === null || _d === void 0 ? void 0 : _d.map((e) => VideoLayer.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseTrackInfo() {\n  return {\n    sid: \"\",\n    type: 0,\n    name: \"\",\n    muted: false,\n    width: 0,\n    height: 0,\n    simulcast: false,\n    disableDtx: false,\n    source: 0,\n    layers: [],\n    mimeType: \"\",\n    mid: \"\",\n    codecs: [],\n    stereo: false,\n    disableRed: false,\n    encryption: 0\n  };\n}\nvar TrackInfo = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.sid !== \"\") {\n      writer2.uint32(10).string(message.sid);\n    }\n    if (message.type !== 0) {\n      writer2.uint32(16).int32(message.type);\n    }\n    if (message.name !== \"\") {\n      writer2.uint32(26).string(message.name);\n    }\n    if (message.muted === true) {\n      writer2.uint32(32).bool(message.muted);\n    }\n    if (message.width !== 0) {\n      writer2.uint32(40).uint32(message.width);\n    }\n    if (message.height !== 0) {\n      writer2.uint32(48).uint32(message.height);\n    }\n    if (message.simulcast === true) {\n      writer2.uint32(56).bool(message.simulcast);\n    }\n    if (message.disableDtx === true) {\n      writer2.uint32(64).bool(message.disableDtx);\n    }\n    if (message.source !== 0) {\n      writer2.uint32(72).int32(message.source);\n    }\n    for (const v of message.layers) {\n      VideoLayer.encode(v, writer2.uint32(82).fork()).ldelim();\n    }\n    if (message.mimeType !== \"\") {\n      writer2.uint32(90).string(message.mimeType);\n    }\n    if (message.mid !== \"\") {\n      writer2.uint32(98).string(message.mid);\n    }\n    for (const v of message.codecs) {\n      SimulcastCodecInfo.encode(v, writer2.uint32(106).fork()).ldelim();\n    }\n    if (message.stereo === true) {\n      writer2.uint32(112).bool(message.stereo);\n    }\n    if (message.disableRed === true) {\n      writer2.uint32(120).bool(message.disableRed);\n    }\n    if (message.encryption !== 0) {\n      writer2.uint32(128).int32(message.encryption);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseTrackInfo();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.sid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 16) {\n            break;\n          }\n          message.type = reader2.int32();\n          continue;\n        case 3:\n          if (tag != 26) {\n            break;\n          }\n          message.name = reader2.string();\n          continue;\n        case 4:\n          if (tag != 32) {\n            break;\n          }\n          message.muted = reader2.bool();\n          continue;\n        case 5:\n          if (tag != 40) {\n            break;\n          }\n          message.width = reader2.uint32();\n          continue;\n        case 6:\n          if (tag != 48) {\n            break;\n          }\n          message.height = reader2.uint32();\n          continue;\n        case 7:\n          if (tag != 56) {\n            break;\n          }\n          message.simulcast = reader2.bool();\n          continue;\n        case 8:\n          if (tag != 64) {\n            break;\n          }\n          message.disableDtx = reader2.bool();\n          continue;\n        case 9:\n          if (tag != 72) {\n            break;\n          }\n          message.source = reader2.int32();\n          continue;\n        case 10:\n          if (tag != 82) {\n            break;\n          }\n          message.layers.push(VideoLayer.decode(reader2, reader2.uint32()));\n          continue;\n        case 11:\n          if (tag != 90) {\n            break;\n          }\n          message.mimeType = reader2.string();\n          continue;\n        case 12:\n          if (tag != 98) {\n            break;\n          }\n          message.mid = reader2.string();\n          continue;\n        case 13:\n          if (tag != 106) {\n            break;\n          }\n          message.codecs.push(SimulcastCodecInfo.decode(reader2, reader2.uint32()));\n          continue;\n        case 14:\n          if (tag != 112) {\n            break;\n          }\n          message.stereo = reader2.bool();\n          continue;\n        case 15:\n          if (tag != 120) {\n            break;\n          }\n          message.disableRed = reader2.bool();\n          continue;\n        case 16:\n          if (tag != 128) {\n            break;\n          }\n          message.encryption = reader2.int32();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      sid: isSet$1(object.sid) ? String(object.sid) : \"\",\n      type: isSet$1(object.type) ? trackTypeFromJSON(object.type) : 0,\n      name: isSet$1(object.name) ? String(object.name) : \"\",\n      muted: isSet$1(object.muted) ? Boolean(object.muted) : false,\n      width: isSet$1(object.width) ? Number(object.width) : 0,\n      height: isSet$1(object.height) ? Number(object.height) : 0,\n      simulcast: isSet$1(object.simulcast) ? Boolean(object.simulcast) : false,\n      disableDtx: isSet$1(object.disableDtx) ? Boolean(object.disableDtx) : false,\n      source: isSet$1(object.source) ? trackSourceFromJSON(object.source) : 0,\n      layers: Array.isArray(object === null || object === void 0 ? void 0 : object.layers) ? object.layers.map((e) => VideoLayer.fromJSON(e)) : [],\n      mimeType: isSet$1(object.mimeType) ? String(object.mimeType) : \"\",\n      mid: isSet$1(object.mid) ? String(object.mid) : \"\",\n      codecs: Array.isArray(object === null || object === void 0 ? void 0 : object.codecs) ? object.codecs.map((e) => SimulcastCodecInfo.fromJSON(e)) : [],\n      stereo: isSet$1(object.stereo) ? Boolean(object.stereo) : false,\n      disableRed: isSet$1(object.disableRed) ? Boolean(object.disableRed) : false,\n      encryption: isSet$1(object.encryption) ? encryption_TypeFromJSON(object.encryption) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.sid !== void 0 && (obj.sid = message.sid);\n    message.type !== void 0 && (obj.type = trackTypeToJSON(message.type));\n    message.name !== void 0 && (obj.name = message.name);\n    message.muted !== void 0 && (obj.muted = message.muted);\n    message.width !== void 0 && (obj.width = Math.round(message.width));\n    message.height !== void 0 && (obj.height = Math.round(message.height));\n    message.simulcast !== void 0 && (obj.simulcast = message.simulcast);\n    message.disableDtx !== void 0 && (obj.disableDtx = message.disableDtx);\n    message.source !== void 0 && (obj.source = trackSourceToJSON(message.source));\n    if (message.layers) {\n      obj.layers = message.layers.map((e) => e ? VideoLayer.toJSON(e) : void 0);\n    } else {\n      obj.layers = [];\n    }\n    message.mimeType !== void 0 && (obj.mimeType = message.mimeType);\n    message.mid !== void 0 && (obj.mid = message.mid);\n    if (message.codecs) {\n      obj.codecs = message.codecs.map((e) => e ? SimulcastCodecInfo.toJSON(e) : void 0);\n    } else {\n      obj.codecs = [];\n    }\n    message.stereo !== void 0 && (obj.stereo = message.stereo);\n    message.disableRed !== void 0 && (obj.disableRed = message.disableRed);\n    message.encryption !== void 0 && (obj.encryption = encryption_TypeToJSON(message.encryption));\n    return obj;\n  },\n  create(base) {\n    return TrackInfo.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\n    const message = createBaseTrackInfo();\n    message.sid = (_a = object.sid) !== null && _a !== void 0 ? _a : \"\";\n    message.type = (_b = object.type) !== null && _b !== void 0 ? _b : 0;\n    message.name = (_c = object.name) !== null && _c !== void 0 ? _c : \"\";\n    message.muted = (_d = object.muted) !== null && _d !== void 0 ? _d : false;\n    message.width = (_e = object.width) !== null && _e !== void 0 ? _e : 0;\n    message.height = (_f = object.height) !== null && _f !== void 0 ? _f : 0;\n    message.simulcast = (_g = object.simulcast) !== null && _g !== void 0 ? _g : false;\n    message.disableDtx = (_h = object.disableDtx) !== null && _h !== void 0 ? _h : false;\n    message.source = (_j = object.source) !== null && _j !== void 0 ? _j : 0;\n    message.layers = ((_k = object.layers) === null || _k === void 0 ? void 0 : _k.map((e) => VideoLayer.fromPartial(e))) || [];\n    message.mimeType = (_l = object.mimeType) !== null && _l !== void 0 ? _l : \"\";\n    message.mid = (_m = object.mid) !== null && _m !== void 0 ? _m : \"\";\n    message.codecs = ((_o = object.codecs) === null || _o === void 0 ? void 0 : _o.map((e) => SimulcastCodecInfo.fromPartial(e))) || [];\n    message.stereo = (_p = object.stereo) !== null && _p !== void 0 ? _p : false;\n    message.disableRed = (_q = object.disableRed) !== null && _q !== void 0 ? _q : false;\n    message.encryption = (_r = object.encryption) !== null && _r !== void 0 ? _r : 0;\n    return message;\n  }\n};\nfunction createBaseVideoLayer() {\n  return {\n    quality: 0,\n    width: 0,\n    height: 0,\n    bitrate: 0,\n    ssrc: 0\n  };\n}\nvar VideoLayer = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.quality !== 0) {\n      writer2.uint32(8).int32(message.quality);\n    }\n    if (message.width !== 0) {\n      writer2.uint32(16).uint32(message.width);\n    }\n    if (message.height !== 0) {\n      writer2.uint32(24).uint32(message.height);\n    }\n    if (message.bitrate !== 0) {\n      writer2.uint32(32).uint32(message.bitrate);\n    }\n    if (message.ssrc !== 0) {\n      writer2.uint32(40).uint32(message.ssrc);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseVideoLayer();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 8) {\n            break;\n          }\n          message.quality = reader2.int32();\n          continue;\n        case 2:\n          if (tag != 16) {\n            break;\n          }\n          message.width = reader2.uint32();\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.height = reader2.uint32();\n          continue;\n        case 4:\n          if (tag != 32) {\n            break;\n          }\n          message.bitrate = reader2.uint32();\n          continue;\n        case 5:\n          if (tag != 40) {\n            break;\n          }\n          message.ssrc = reader2.uint32();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      quality: isSet$1(object.quality) ? videoQualityFromJSON(object.quality) : 0,\n      width: isSet$1(object.width) ? Number(object.width) : 0,\n      height: isSet$1(object.height) ? Number(object.height) : 0,\n      bitrate: isSet$1(object.bitrate) ? Number(object.bitrate) : 0,\n      ssrc: isSet$1(object.ssrc) ? Number(object.ssrc) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.quality !== void 0 && (obj.quality = videoQualityToJSON(message.quality));\n    message.width !== void 0 && (obj.width = Math.round(message.width));\n    message.height !== void 0 && (obj.height = Math.round(message.height));\n    message.bitrate !== void 0 && (obj.bitrate = Math.round(message.bitrate));\n    message.ssrc !== void 0 && (obj.ssrc = Math.round(message.ssrc));\n    return obj;\n  },\n  create(base) {\n    return VideoLayer.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e;\n    const message = createBaseVideoLayer();\n    message.quality = (_a = object.quality) !== null && _a !== void 0 ? _a : 0;\n    message.width = (_b = object.width) !== null && _b !== void 0 ? _b : 0;\n    message.height = (_c = object.height) !== null && _c !== void 0 ? _c : 0;\n    message.bitrate = (_d = object.bitrate) !== null && _d !== void 0 ? _d : 0;\n    message.ssrc = (_e = object.ssrc) !== null && _e !== void 0 ? _e : 0;\n    return message;\n  }\n};\nfunction createBaseDataPacket() {\n  return {\n    kind: 0,\n    value: void 0\n  };\n}\nvar DataPacket = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    var _a;\n    if (message.kind !== 0) {\n      writer2.uint32(8).int32(message.kind);\n    }\n    switch ((_a = message.value) === null || _a === void 0 ? void 0 : _a.$case) {\n      case \"user\":\n        UserPacket.encode(message.value.user, writer2.uint32(18).fork()).ldelim();\n        break;\n      case \"speaker\":\n        ActiveSpeakerUpdate.encode(message.value.speaker, writer2.uint32(26).fork()).ldelim();\n        break;\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseDataPacket();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 8) {\n            break;\n          }\n          message.kind = reader2.int32();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.value = {\n            $case: \"user\",\n            user: UserPacket.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 3:\n          if (tag != 26) {\n            break;\n          }\n          message.value = {\n            $case: \"speaker\",\n            speaker: ActiveSpeakerUpdate.decode(reader2, reader2.uint32())\n          };\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      kind: isSet$1(object.kind) ? dataPacket_KindFromJSON(object.kind) : 0,\n      value: isSet$1(object.user) ? {\n        $case: \"user\",\n        user: UserPacket.fromJSON(object.user)\n      } : isSet$1(object.speaker) ? {\n        $case: \"speaker\",\n        speaker: ActiveSpeakerUpdate.fromJSON(object.speaker)\n      } : void 0\n    };\n  },\n  toJSON(message) {\n    var _a, _b, _c, _d, _e, _f;\n    const obj = {};\n    message.kind !== void 0 && (obj.kind = dataPacket_KindToJSON(message.kind));\n    ((_a = message.value) === null || _a === void 0 ? void 0 : _a.$case) === \"user\" && (obj.user = ((_b = message.value) === null || _b === void 0 ? void 0 : _b.user) ? UserPacket.toJSON((_c = message.value) === null || _c === void 0 ? void 0 : _c.user) : void 0);\n    ((_d = message.value) === null || _d === void 0 ? void 0 : _d.$case) === \"speaker\" && (obj.speaker = ((_e = message.value) === null || _e === void 0 ? void 0 : _e.speaker) ? ActiveSpeakerUpdate.toJSON((_f = message.value) === null || _f === void 0 ? void 0 : _f.speaker) : void 0);\n    return obj;\n  },\n  create(base) {\n    return DataPacket.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const message = createBaseDataPacket();\n    message.kind = (_a = object.kind) !== null && _a !== void 0 ? _a : 0;\n    if (((_b = object.value) === null || _b === void 0 ? void 0 : _b.$case) === \"user\" && ((_c = object.value) === null || _c === void 0 ? void 0 : _c.user) !== void 0 && ((_d = object.value) === null || _d === void 0 ? void 0 : _d.user) !== null) {\n      message.value = {\n        $case: \"user\",\n        user: UserPacket.fromPartial(object.value.user)\n      };\n    }\n    if (((_e = object.value) === null || _e === void 0 ? void 0 : _e.$case) === \"speaker\" && ((_f = object.value) === null || _f === void 0 ? void 0 : _f.speaker) !== void 0 && ((_g = object.value) === null || _g === void 0 ? void 0 : _g.speaker) !== null) {\n      message.value = {\n        $case: \"speaker\",\n        speaker: ActiveSpeakerUpdate.fromPartial(object.value.speaker)\n      };\n    }\n    return message;\n  }\n};\nfunction createBaseActiveSpeakerUpdate() {\n  return {\n    speakers: []\n  };\n}\nvar ActiveSpeakerUpdate = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    for (const v of message.speakers) {\n      SpeakerInfo.encode(v, writer2.uint32(10).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseActiveSpeakerUpdate();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.speakers.push(SpeakerInfo.decode(reader2, reader2.uint32()));\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      speakers: Array.isArray(object === null || object === void 0 ? void 0 : object.speakers) ? object.speakers.map((e) => SpeakerInfo.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.speakers) {\n      obj.speakers = message.speakers.map((e) => e ? SpeakerInfo.toJSON(e) : void 0);\n    } else {\n      obj.speakers = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return ActiveSpeakerUpdate.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseActiveSpeakerUpdate();\n    message.speakers = ((_a = object.speakers) === null || _a === void 0 ? void 0 : _a.map((e) => SpeakerInfo.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseSpeakerInfo() {\n  return {\n    sid: \"\",\n    level: 0,\n    active: false\n  };\n}\nvar SpeakerInfo = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.sid !== \"\") {\n      writer2.uint32(10).string(message.sid);\n    }\n    if (message.level !== 0) {\n      writer2.uint32(21).float(message.level);\n    }\n    if (message.active === true) {\n      writer2.uint32(24).bool(message.active);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseSpeakerInfo();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.sid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 21) {\n            break;\n          }\n          message.level = reader2.float();\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.active = reader2.bool();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      sid: isSet$1(object.sid) ? String(object.sid) : \"\",\n      level: isSet$1(object.level) ? Number(object.level) : 0,\n      active: isSet$1(object.active) ? Boolean(object.active) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.sid !== void 0 && (obj.sid = message.sid);\n    message.level !== void 0 && (obj.level = message.level);\n    message.active !== void 0 && (obj.active = message.active);\n    return obj;\n  },\n  create(base) {\n    return SpeakerInfo.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseSpeakerInfo();\n    message.sid = (_a = object.sid) !== null && _a !== void 0 ? _a : \"\";\n    message.level = (_b = object.level) !== null && _b !== void 0 ? _b : 0;\n    message.active = (_c = object.active) !== null && _c !== void 0 ? _c : false;\n    return message;\n  }\n};\nfunction createBaseUserPacket() {\n  return {\n    participantSid: \"\",\n    payload: new Uint8Array(),\n    destinationSids: [],\n    topic: void 0\n  };\n}\nvar UserPacket = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.participantSid !== \"\") {\n      writer2.uint32(10).string(message.participantSid);\n    }\n    if (message.payload.length !== 0) {\n      writer2.uint32(18).bytes(message.payload);\n    }\n    for (const v of message.destinationSids) {\n      writer2.uint32(26).string(v);\n    }\n    if (message.topic !== void 0) {\n      writer2.uint32(34).string(message.topic);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseUserPacket();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.participantSid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.payload = reader2.bytes();\n          continue;\n        case 3:\n          if (tag != 26) {\n            break;\n          }\n          message.destinationSids.push(reader2.string());\n          continue;\n        case 4:\n          if (tag != 34) {\n            break;\n          }\n          message.topic = reader2.string();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      participantSid: isSet$1(object.participantSid) ? String(object.participantSid) : \"\",\n      payload: isSet$1(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(),\n      destinationSids: Array.isArray(object === null || object === void 0 ? void 0 : object.destinationSids) ? object.destinationSids.map((e) => String(e)) : [],\n      topic: isSet$1(object.topic) ? String(object.topic) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.participantSid !== void 0 && (obj.participantSid = message.participantSid);\n    message.payload !== void 0 && (obj.payload = base64FromBytes(message.payload !== void 0 ? message.payload : new Uint8Array()));\n    if (message.destinationSids) {\n      obj.destinationSids = message.destinationSids.map((e) => e);\n    } else {\n      obj.destinationSids = [];\n    }\n    message.topic !== void 0 && (obj.topic = message.topic);\n    return obj;\n  },\n  create(base) {\n    return UserPacket.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseUserPacket();\n    message.participantSid = (_a = object.participantSid) !== null && _a !== void 0 ? _a : \"\";\n    message.payload = (_b = object.payload) !== null && _b !== void 0 ? _b : new Uint8Array();\n    message.destinationSids = ((_c = object.destinationSids) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];\n    message.topic = (_d = object.topic) !== null && _d !== void 0 ? _d : void 0;\n    return message;\n  }\n};\nfunction createBaseParticipantTracks() {\n  return {\n    participantSid: \"\",\n    trackSids: []\n  };\n}\nvar ParticipantTracks = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.participantSid !== \"\") {\n      writer2.uint32(10).string(message.participantSid);\n    }\n    for (const v of message.trackSids) {\n      writer2.uint32(18).string(v);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseParticipantTracks();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.participantSid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.trackSids.push(reader2.string());\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      participantSid: isSet$1(object.participantSid) ? String(object.participantSid) : \"\",\n      trackSids: Array.isArray(object === null || object === void 0 ? void 0 : object.trackSids) ? object.trackSids.map((e) => String(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.participantSid !== void 0 && (obj.participantSid = message.participantSid);\n    if (message.trackSids) {\n      obj.trackSids = message.trackSids.map((e) => e);\n    } else {\n      obj.trackSids = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return ParticipantTracks.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseParticipantTracks();\n    message.participantSid = (_a = object.participantSid) !== null && _a !== void 0 ? _a : \"\";\n    message.trackSids = ((_b = object.trackSids) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];\n    return message;\n  }\n};\nfunction createBaseServerInfo() {\n  return {\n    edition: 0,\n    version: \"\",\n    protocol: 0,\n    region: \"\",\n    nodeId: \"\",\n    debugInfo: \"\"\n  };\n}\nvar ServerInfo = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.edition !== 0) {\n      writer2.uint32(8).int32(message.edition);\n    }\n    if (message.version !== \"\") {\n      writer2.uint32(18).string(message.version);\n    }\n    if (message.protocol !== 0) {\n      writer2.uint32(24).int32(message.protocol);\n    }\n    if (message.region !== \"\") {\n      writer2.uint32(34).string(message.region);\n    }\n    if (message.nodeId !== \"\") {\n      writer2.uint32(42).string(message.nodeId);\n    }\n    if (message.debugInfo !== \"\") {\n      writer2.uint32(50).string(message.debugInfo);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseServerInfo();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 8) {\n            break;\n          }\n          message.edition = reader2.int32();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.version = reader2.string();\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.protocol = reader2.int32();\n          continue;\n        case 4:\n          if (tag != 34) {\n            break;\n          }\n          message.region = reader2.string();\n          continue;\n        case 5:\n          if (tag != 42) {\n            break;\n          }\n          message.nodeId = reader2.string();\n          continue;\n        case 6:\n          if (tag != 50) {\n            break;\n          }\n          message.debugInfo = reader2.string();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      edition: isSet$1(object.edition) ? serverInfo_EditionFromJSON(object.edition) : 0,\n      version: isSet$1(object.version) ? String(object.version) : \"\",\n      protocol: isSet$1(object.protocol) ? Number(object.protocol) : 0,\n      region: isSet$1(object.region) ? String(object.region) : \"\",\n      nodeId: isSet$1(object.nodeId) ? String(object.nodeId) : \"\",\n      debugInfo: isSet$1(object.debugInfo) ? String(object.debugInfo) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.edition !== void 0 && (obj.edition = serverInfo_EditionToJSON(message.edition));\n    message.version !== void 0 && (obj.version = message.version);\n    message.protocol !== void 0 && (obj.protocol = Math.round(message.protocol));\n    message.region !== void 0 && (obj.region = message.region);\n    message.nodeId !== void 0 && (obj.nodeId = message.nodeId);\n    message.debugInfo !== void 0 && (obj.debugInfo = message.debugInfo);\n    return obj;\n  },\n  create(base) {\n    return ServerInfo.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f;\n    const message = createBaseServerInfo();\n    message.edition = (_a = object.edition) !== null && _a !== void 0 ? _a : 0;\n    message.version = (_b = object.version) !== null && _b !== void 0 ? _b : \"\";\n    message.protocol = (_c = object.protocol) !== null && _c !== void 0 ? _c : 0;\n    message.region = (_d = object.region) !== null && _d !== void 0 ? _d : \"\";\n    message.nodeId = (_e = object.nodeId) !== null && _e !== void 0 ? _e : \"\";\n    message.debugInfo = (_f = object.debugInfo) !== null && _f !== void 0 ? _f : \"\";\n    return message;\n  }\n};\nfunction createBaseClientInfo() {\n  return {\n    sdk: 0,\n    version: \"\",\n    protocol: 0,\n    os: \"\",\n    osVersion: \"\",\n    deviceModel: \"\",\n    browser: \"\",\n    browserVersion: \"\",\n    address: \"\",\n    network: \"\"\n  };\n}\nvar ClientInfo = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.sdk !== 0) {\n      writer2.uint32(8).int32(message.sdk);\n    }\n    if (message.version !== \"\") {\n      writer2.uint32(18).string(message.version);\n    }\n    if (message.protocol !== 0) {\n      writer2.uint32(24).int32(message.protocol);\n    }\n    if (message.os !== \"\") {\n      writer2.uint32(34).string(message.os);\n    }\n    if (message.osVersion !== \"\") {\n      writer2.uint32(42).string(message.osVersion);\n    }\n    if (message.deviceModel !== \"\") {\n      writer2.uint32(50).string(message.deviceModel);\n    }\n    if (message.browser !== \"\") {\n      writer2.uint32(58).string(message.browser);\n    }\n    if (message.browserVersion !== \"\") {\n      writer2.uint32(66).string(message.browserVersion);\n    }\n    if (message.address !== \"\") {\n      writer2.uint32(74).string(message.address);\n    }\n    if (message.network !== \"\") {\n      writer2.uint32(82).string(message.network);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseClientInfo();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 8) {\n            break;\n          }\n          message.sdk = reader2.int32();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.version = reader2.string();\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.protocol = reader2.int32();\n          continue;\n        case 4:\n          if (tag != 34) {\n            break;\n          }\n          message.os = reader2.string();\n          continue;\n        case 5:\n          if (tag != 42) {\n            break;\n          }\n          message.osVersion = reader2.string();\n          continue;\n        case 6:\n          if (tag != 50) {\n            break;\n          }\n          message.deviceModel = reader2.string();\n          continue;\n        case 7:\n          if (tag != 58) {\n            break;\n          }\n          message.browser = reader2.string();\n          continue;\n        case 8:\n          if (tag != 66) {\n            break;\n          }\n          message.browserVersion = reader2.string();\n          continue;\n        case 9:\n          if (tag != 74) {\n            break;\n          }\n          message.address = reader2.string();\n          continue;\n        case 10:\n          if (tag != 82) {\n            break;\n          }\n          message.network = reader2.string();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      sdk: isSet$1(object.sdk) ? clientInfo_SDKFromJSON(object.sdk) : 0,\n      version: isSet$1(object.version) ? String(object.version) : \"\",\n      protocol: isSet$1(object.protocol) ? Number(object.protocol) : 0,\n      os: isSet$1(object.os) ? String(object.os) : \"\",\n      osVersion: isSet$1(object.osVersion) ? String(object.osVersion) : \"\",\n      deviceModel: isSet$1(object.deviceModel) ? String(object.deviceModel) : \"\",\n      browser: isSet$1(object.browser) ? String(object.browser) : \"\",\n      browserVersion: isSet$1(object.browserVersion) ? String(object.browserVersion) : \"\",\n      address: isSet$1(object.address) ? String(object.address) : \"\",\n      network: isSet$1(object.network) ? String(object.network) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.sdk !== void 0 && (obj.sdk = clientInfo_SDKToJSON(message.sdk));\n    message.version !== void 0 && (obj.version = message.version);\n    message.protocol !== void 0 && (obj.protocol = Math.round(message.protocol));\n    message.os !== void 0 && (obj.os = message.os);\n    message.osVersion !== void 0 && (obj.osVersion = message.osVersion);\n    message.deviceModel !== void 0 && (obj.deviceModel = message.deviceModel);\n    message.browser !== void 0 && (obj.browser = message.browser);\n    message.browserVersion !== void 0 && (obj.browserVersion = message.browserVersion);\n    message.address !== void 0 && (obj.address = message.address);\n    message.network !== void 0 && (obj.network = message.network);\n    return obj;\n  },\n  create(base) {\n    return ClientInfo.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    const message = createBaseClientInfo();\n    message.sdk = (_a = object.sdk) !== null && _a !== void 0 ? _a : 0;\n    message.version = (_b = object.version) !== null && _b !== void 0 ? _b : \"\";\n    message.protocol = (_c = object.protocol) !== null && _c !== void 0 ? _c : 0;\n    message.os = (_d = object.os) !== null && _d !== void 0 ? _d : \"\";\n    message.osVersion = (_e = object.osVersion) !== null && _e !== void 0 ? _e : \"\";\n    message.deviceModel = (_f = object.deviceModel) !== null && _f !== void 0 ? _f : \"\";\n    message.browser = (_g = object.browser) !== null && _g !== void 0 ? _g : \"\";\n    message.browserVersion = (_h = object.browserVersion) !== null && _h !== void 0 ? _h : \"\";\n    message.address = (_j = object.address) !== null && _j !== void 0 ? _j : \"\";\n    message.network = (_k = object.network) !== null && _k !== void 0 ? _k : \"\";\n    return message;\n  }\n};\nfunction createBaseClientConfiguration() {\n  return {\n    video: void 0,\n    screen: void 0,\n    resumeConnection: 0,\n    disabledCodecs: void 0,\n    forceRelay: 0\n  };\n}\nvar ClientConfiguration = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.video !== void 0) {\n      VideoConfiguration.encode(message.video, writer2.uint32(10).fork()).ldelim();\n    }\n    if (message.screen !== void 0) {\n      VideoConfiguration.encode(message.screen, writer2.uint32(18).fork()).ldelim();\n    }\n    if (message.resumeConnection !== 0) {\n      writer2.uint32(24).int32(message.resumeConnection);\n    }\n    if (message.disabledCodecs !== void 0) {\n      DisabledCodecs.encode(message.disabledCodecs, writer2.uint32(34).fork()).ldelim();\n    }\n    if (message.forceRelay !== 0) {\n      writer2.uint32(40).int32(message.forceRelay);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseClientConfiguration();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.video = VideoConfiguration.decode(reader2, reader2.uint32());\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.screen = VideoConfiguration.decode(reader2, reader2.uint32());\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.resumeConnection = reader2.int32();\n          continue;\n        case 4:\n          if (tag != 34) {\n            break;\n          }\n          message.disabledCodecs = DisabledCodecs.decode(reader2, reader2.uint32());\n          continue;\n        case 5:\n          if (tag != 40) {\n            break;\n          }\n          message.forceRelay = reader2.int32();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      video: isSet$1(object.video) ? VideoConfiguration.fromJSON(object.video) : void 0,\n      screen: isSet$1(object.screen) ? VideoConfiguration.fromJSON(object.screen) : void 0,\n      resumeConnection: isSet$1(object.resumeConnection) ? clientConfigSettingFromJSON(object.resumeConnection) : 0,\n      disabledCodecs: isSet$1(object.disabledCodecs) ? DisabledCodecs.fromJSON(object.disabledCodecs) : void 0,\n      forceRelay: isSet$1(object.forceRelay) ? clientConfigSettingFromJSON(object.forceRelay) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.video !== void 0 && (obj.video = message.video ? VideoConfiguration.toJSON(message.video) : void 0);\n    message.screen !== void 0 && (obj.screen = message.screen ? VideoConfiguration.toJSON(message.screen) : void 0);\n    message.resumeConnection !== void 0 && (obj.resumeConnection = clientConfigSettingToJSON(message.resumeConnection));\n    message.disabledCodecs !== void 0 && (obj.disabledCodecs = message.disabledCodecs ? DisabledCodecs.toJSON(message.disabledCodecs) : void 0);\n    message.forceRelay !== void 0 && (obj.forceRelay = clientConfigSettingToJSON(message.forceRelay));\n    return obj;\n  },\n  create(base) {\n    return ClientConfiguration.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseClientConfiguration();\n    message.video = object.video !== void 0 && object.video !== null ? VideoConfiguration.fromPartial(object.video) : void 0;\n    message.screen = object.screen !== void 0 && object.screen !== null ? VideoConfiguration.fromPartial(object.screen) : void 0;\n    message.resumeConnection = (_a = object.resumeConnection) !== null && _a !== void 0 ? _a : 0;\n    message.disabledCodecs = object.disabledCodecs !== void 0 && object.disabledCodecs !== null ? DisabledCodecs.fromPartial(object.disabledCodecs) : void 0;\n    message.forceRelay = (_b = object.forceRelay) !== null && _b !== void 0 ? _b : 0;\n    return message;\n  }\n};\nfunction createBaseVideoConfiguration() {\n  return {\n    hardwareEncoder: 0\n  };\n}\nvar VideoConfiguration = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.hardwareEncoder !== 0) {\n      writer2.uint32(8).int32(message.hardwareEncoder);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseVideoConfiguration();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 8) {\n            break;\n          }\n          message.hardwareEncoder = reader2.int32();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      hardwareEncoder: isSet$1(object.hardwareEncoder) ? clientConfigSettingFromJSON(object.hardwareEncoder) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.hardwareEncoder !== void 0 && (obj.hardwareEncoder = clientConfigSettingToJSON(message.hardwareEncoder));\n    return obj;\n  },\n  create(base) {\n    return VideoConfiguration.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseVideoConfiguration();\n    message.hardwareEncoder = (_a = object.hardwareEncoder) !== null && _a !== void 0 ? _a : 0;\n    return message;\n  }\n};\nfunction createBaseDisabledCodecs() {\n  return {\n    codecs: []\n  };\n}\nvar DisabledCodecs = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    for (const v of message.codecs) {\n      Codec.encode(v, writer2.uint32(10).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseDisabledCodecs();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.codecs.push(Codec.decode(reader2, reader2.uint32()));\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      codecs: Array.isArray(object === null || object === void 0 ? void 0 : object.codecs) ? object.codecs.map((e) => Codec.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.codecs) {\n      obj.codecs = message.codecs.map((e) => e ? Codec.toJSON(e) : void 0);\n    } else {\n      obj.codecs = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return DisabledCodecs.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseDisabledCodecs();\n    message.codecs = ((_a = object.codecs) === null || _a === void 0 ? void 0 : _a.map((e) => Codec.fromPartial(e))) || [];\n    return message;\n  }\n};\nvar tsProtoGlobalThis$1 = (() => {\n  if (typeof globalThis !== \"undefined\") {\n    return globalThis;\n  }\n  if (typeof self !== \"undefined\") {\n    return self;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n  throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n  if (tsProtoGlobalThis$1.Buffer) {\n    return Uint8Array.from(tsProtoGlobalThis$1.Buffer.from(b64, \"base64\"));\n  } else {\n    const bin = tsProtoGlobalThis$1.atob(b64);\n    const arr = new Uint8Array(bin.length);\n    for (let i = 0; i < bin.length; ++i) {\n      arr[i] = bin.charCodeAt(i);\n    }\n    return arr;\n  }\n}\nfunction base64FromBytes(arr) {\n  if (tsProtoGlobalThis$1.Buffer) {\n    return tsProtoGlobalThis$1.Buffer.from(arr).toString(\"base64\");\n  } else {\n    const bin = [];\n    arr.forEach((byte) => {\n      bin.push(String.fromCharCode(byte));\n    });\n    return tsProtoGlobalThis$1.btoa(bin.join(\"\"));\n  }\n}\nfunction longToNumber$1(long2) {\n  if (long2.gt(Number.MAX_SAFE_INTEGER)) {\n    throw new tsProtoGlobalThis$1.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\n  }\n  return long2.toNumber();\n}\nif (_m0.util.Long !== Long$1) {\n  _m0.util.Long = Long$1;\n  _m0.configure();\n}\nfunction isSet$1(value) {\n  return value !== null && value !== void 0;\n}\nvar maxRetryDelay = 7e3;\nvar DEFAULT_RETRY_DELAYS_IN_MS = [0, 300, 2 * 2 * 300, 3 * 3 * 300, 4 * 4 * 300, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay];\nvar DefaultReconnectPolicy = class {\n  constructor(retryDelays) {\n    this._retryDelays = retryDelays !== void 0 ? [...retryDelays] : DEFAULT_RETRY_DELAYS_IN_MS;\n  }\n  nextRetryDelayInMs(context) {\n    if (context.retryCount >= this._retryDelays.length)\n      return null;\n    const retryDelay = this._retryDelays[context.retryCount];\n    if (context.retryCount <= 1)\n      return retryDelay;\n    return retryDelay + Math.random() * 1e3;\n  }\n};\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\nfunction __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m)\n    return m.call(o);\n  if (o && typeof o.length === \"number\")\n    return {\n      next: function() {\n        if (o && i >= o.length)\n          o = void 0;\n        return { value: o && o[i++], done: !o };\n      }\n    };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __asyncValues(o) {\n  if (!Symbol.asyncIterator)\n    throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n    return this;\n  }, i);\n  function verb(n) {\n    i[n] = o[n] && function(v) {\n      return new Promise(function(resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function(v2) {\n      resolve({ value: v2, done: d });\n    }, reject);\n  }\n}\nvar events = { exports: {} };\nvar R = typeof Reflect === \"object\" ? Reflect : null;\nvar ReflectApply = R && typeof R.apply === \"function\" ? R.apply : function ReflectApply2(target, receiver, args) {\n  return Function.prototype.apply.call(target, receiver, args);\n};\nvar ReflectOwnKeys;\nif (R && typeof R.ownKeys === \"function\") {\n  ReflectOwnKeys = R.ownKeys;\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys2(target) {\n    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys2(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn)\n    console.warn(warning);\n}\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {\n  return value !== value;\n};\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nevents.exports = EventEmitter;\nevents.exports.once = once2;\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.prototype._events = void 0;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = void 0;\nvar defaultMaxListeners = 10;\nfunction checkListener(listener) {\n  if (typeof listener !== \"function\") {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\nObject.defineProperty(EventEmitter, \"defaultMaxListeners\", {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== \"number\" || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + \".\");\n    }\n    defaultMaxListeners = arg;\n  }\n});\nEventEmitter.init = function() {\n  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = /* @__PURE__ */ Object.create(null);\n    this._eventsCount = 0;\n  }\n  this._maxListeners = this._maxListeners || void 0;\n};\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== \"number\" || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + \".\");\n  }\n  this._maxListeners = n;\n  return this;\n};\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === void 0)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++)\n    args.push(arguments[i]);\n  var doError = type === \"error\";\n  var events2 = this._events;\n  if (events2 !== void 0)\n    doError = doError && events2.error === void 0;\n  else if (!doError)\n    return false;\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      throw er;\n    }\n    var err = new Error(\"Unhandled error.\" + (er ? \" (\" + er.message + \")\" : \"\"));\n    err.context = er;\n    throw err;\n  }\n  var handler = events2[type];\n  if (handler === void 0)\n    return false;\n  if (typeof handler === \"function\") {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners2 = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners2[i], this, args);\n  }\n  return true;\n};\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events2;\n  var existing;\n  checkListener(listener);\n  events2 = target._events;\n  if (events2 === void 0) {\n    events2 = target._events = /* @__PURE__ */ Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    if (events2.newListener !== void 0) {\n      target.emit(\"newListener\", type, listener.listener ? listener.listener : listener);\n      events2 = target._events;\n    }\n    existing = events2[type];\n  }\n  if (existing === void 0) {\n    existing = events2[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === \"function\") {\n      existing = events2[type] = prepend ? [listener, existing] : [existing, listener];\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      var w = new Error(\"Possible EventEmitter memory leak detected. \" + existing.length + \" \" + String(type) + \" listeners added. Use emitter.setMaxListeners() to increase limit\");\n      w.name = \"MaxListenersExceededWarning\";\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n  return target;\n}\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n  return _addListener(this, type, listener, true);\n};\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\nfunction _onceWrap(target, type, listener) {\n  var state = {\n    fired: false,\n    wrapFn: void 0,\n    target,\n    type,\n    listener\n  };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n  checkListener(listener);\n  this.prependListener(type, _onceWrap(this, type, listener));\n  return this;\n};\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n  var list, events2, position, i, originalListener;\n  checkListener(listener);\n  events2 = this._events;\n  if (events2 === void 0)\n    return this;\n  list = events2[type];\n  if (list === void 0)\n    return this;\n  if (list === listener || list.listener === listener) {\n    if (--this._eventsCount === 0)\n      this._events = /* @__PURE__ */ Object.create(null);\n    else {\n      delete events2[type];\n      if (events2.removeListener)\n        this.emit(\"removeListener\", type, list.listener || listener);\n    }\n  } else if (typeof list !== \"function\") {\n    position = -1;\n    for (i = list.length - 1; i >= 0; i--) {\n      if (list[i] === listener || list[i].listener === listener) {\n        originalListener = list[i].listener;\n        position = i;\n        break;\n      }\n    }\n    if (position < 0)\n      return this;\n    if (position === 0)\n      list.shift();\n    else {\n      spliceOne(list, position);\n    }\n    if (list.length === 1)\n      events2[type] = list[0];\n    if (events2.removeListener !== void 0)\n      this.emit(\"removeListener\", type, originalListener || listener);\n  }\n  return this;\n};\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n  var listeners2, events2, i;\n  events2 = this._events;\n  if (events2 === void 0)\n    return this;\n  if (events2.removeListener === void 0) {\n    if (arguments.length === 0) {\n      this._events = /* @__PURE__ */ Object.create(null);\n      this._eventsCount = 0;\n    } else if (events2[type] !== void 0) {\n      if (--this._eventsCount === 0)\n        this._events = /* @__PURE__ */ Object.create(null);\n      else\n        delete events2[type];\n    }\n    return this;\n  }\n  if (arguments.length === 0) {\n    var keys = Object.keys(events2);\n    var key;\n    for (i = 0; i < keys.length; ++i) {\n      key = keys[i];\n      if (key === \"removeListener\")\n        continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners(\"removeListener\");\n    this._events = /* @__PURE__ */ Object.create(null);\n    this._eventsCount = 0;\n    return this;\n  }\n  listeners2 = events2[type];\n  if (typeof listeners2 === \"function\") {\n    this.removeListener(type, listeners2);\n  } else if (listeners2 !== void 0) {\n    for (i = listeners2.length - 1; i >= 0; i--) {\n      this.removeListener(type, listeners2[i]);\n    }\n  }\n  return this;\n};\nfunction _listeners(target, type, unwrap) {\n  var events2 = target._events;\n  if (events2 === void 0)\n    return [];\n  var evlistener = events2[type];\n  if (evlistener === void 0)\n    return [];\n  if (typeof evlistener === \"function\")\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === \"function\") {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events2 = this._events;\n  if (events2 !== void 0) {\n    var evlistener = events2[type];\n    if (typeof evlistener === \"function\") {\n      return 1;\n    } else if (evlistener !== void 0) {\n      return evlistener.length;\n    }\n  }\n  return 0;\n}\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\nfunction once2(emitter, name) {\n  return new Promise(function(resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n    function resolver() {\n      if (typeof emitter.removeListener === \"function\") {\n        emitter.removeListener(\"error\", errorListener);\n      }\n      resolve([].slice.call(arguments));\n    }\n    eventTargetAgnosticAddListener(emitter, name, resolver, {\n      once: true\n    });\n    if (name !== \"error\") {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, {\n        once: true\n      });\n    }\n  });\n}\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === \"function\") {\n    eventTargetAgnosticAddListener(emitter, \"error\", handler, flags);\n  }\n}\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === \"function\") {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === \"function\") {\n    emitter.addEventListener(name, function wrapListener(arg) {\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\nvar eventsExports = events.exports;\nvar logDisabled_ = true;\nvar deprecationWarnings_ = true;\nfunction extractVersion(uastring, expr, pos) {\n  const match = uastring.match(expr);\n  return match && match.length >= pos && parseInt(match[pos], 10);\n}\nfunction wrapPeerConnectionEvent(window2, eventNameToWrap, wrapper) {\n  if (!window2.RTCPeerConnection) {\n    return;\n  }\n  const proto = window2.RTCPeerConnection.prototype;\n  const nativeAddEventListener = proto.addEventListener;\n  proto.addEventListener = function(nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap) {\n      return nativeAddEventListener.apply(this, arguments);\n    }\n    const wrappedCallback = (e) => {\n      const modifiedEvent = wrapper(e);\n      if (modifiedEvent) {\n        if (cb.handleEvent) {\n          cb.handleEvent(modifiedEvent);\n        } else {\n          cb(modifiedEvent);\n        }\n      }\n    };\n    this._eventMap = this._eventMap || {};\n    if (!this._eventMap[eventNameToWrap]) {\n      this._eventMap[eventNameToWrap] = /* @__PURE__ */ new Map();\n    }\n    this._eventMap[eventNameToWrap].set(cb, wrappedCallback);\n    return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);\n  };\n  const nativeRemoveEventListener = proto.removeEventListener;\n  proto.removeEventListener = function(nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {\n      return nativeRemoveEventListener.apply(this, arguments);\n    }\n    if (!this._eventMap[eventNameToWrap].has(cb)) {\n      return nativeRemoveEventListener.apply(this, arguments);\n    }\n    const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);\n    this._eventMap[eventNameToWrap].delete(cb);\n    if (this._eventMap[eventNameToWrap].size === 0) {\n      delete this._eventMap[eventNameToWrap];\n    }\n    if (Object.keys(this._eventMap).length === 0) {\n      delete this._eventMap;\n    }\n    return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);\n  };\n  Object.defineProperty(proto, \"on\" + eventNameToWrap, {\n    get() {\n      return this[\"_on\" + eventNameToWrap];\n    },\n    set(cb) {\n      if (this[\"_on\" + eventNameToWrap]) {\n        this.removeEventListener(eventNameToWrap, this[\"_on\" + eventNameToWrap]);\n        delete this[\"_on\" + eventNameToWrap];\n      }\n      if (cb) {\n        this.addEventListener(eventNameToWrap, this[\"_on\" + eventNameToWrap] = cb);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n}\nfunction disableLog(bool) {\n  if (typeof bool !== \"boolean\") {\n    return new Error(\"Argument type: \" + typeof bool + \". Please use a boolean.\");\n  }\n  logDisabled_ = bool;\n  return bool ? \"adapter.js logging disabled\" : \"adapter.js logging enabled\";\n}\nfunction disableWarnings(bool) {\n  if (typeof bool !== \"boolean\") {\n    return new Error(\"Argument type: \" + typeof bool + \". Please use a boolean.\");\n  }\n  deprecationWarnings_ = !bool;\n  return \"adapter.js deprecation warnings \" + (bool ? \"disabled\" : \"enabled\");\n}\nfunction log() {\n  if (typeof window === \"object\") {\n    if (logDisabled_) {\n      return;\n    }\n    if (typeof console !== \"undefined\" && typeof console.log === \"function\") {\n      console.log.apply(console, arguments);\n    }\n  }\n}\nfunction deprecated(oldMethod, newMethod) {\n  if (!deprecationWarnings_) {\n    return;\n  }\n  console.warn(oldMethod + \" is deprecated, please use \" + newMethod + \" instead.\");\n}\nfunction detectBrowser(window2) {\n  const result = {\n    browser: null,\n    version: null\n  };\n  if (typeof window2 === \"undefined\" || !window2.navigator) {\n    result.browser = \"Not a browser.\";\n    return result;\n  }\n  const {\n    navigator: navigator2\n  } = window2;\n  if (navigator2.mozGetUserMedia) {\n    result.browser = \"firefox\";\n    result.version = extractVersion(navigator2.userAgent, /Firefox\\/(\\d+)\\./, 1);\n  } else if (navigator2.webkitGetUserMedia || window2.isSecureContext === false && window2.webkitRTCPeerConnection) {\n    result.browser = \"chrome\";\n    result.version = extractVersion(navigator2.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2);\n  } else if (window2.RTCPeerConnection && navigator2.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) {\n    result.browser = \"safari\";\n    result.version = extractVersion(navigator2.userAgent, /AppleWebKit\\/(\\d+)\\./, 1);\n    result.supportsUnifiedPlan = window2.RTCRtpTransceiver && \"currentDirection\" in window2.RTCRtpTransceiver.prototype;\n  } else {\n    result.browser = \"Not a supported browser.\";\n    return result;\n  }\n  return result;\n}\nfunction isObject(val) {\n  return Object.prototype.toString.call(val) === \"[object Object]\";\n}\nfunction compactObject(data) {\n  if (!isObject(data)) {\n    return data;\n  }\n  return Object.keys(data).reduce(function(accumulator, key) {\n    const isObj = isObject(data[key]);\n    const value = isObj ? compactObject(data[key]) : data[key];\n    const isEmptyObject = isObj && !Object.keys(value).length;\n    if (value === void 0 || isEmptyObject) {\n      return accumulator;\n    }\n    return Object.assign(accumulator, {\n      [key]: value\n    });\n  }, {});\n}\nfunction walkStats(stats, base, resultSet) {\n  if (!base || resultSet.has(base.id)) {\n    return;\n  }\n  resultSet.set(base.id, base);\n  Object.keys(base).forEach((name) => {\n    if (name.endsWith(\"Id\")) {\n      walkStats(stats, stats.get(base[name]), resultSet);\n    } else if (name.endsWith(\"Ids\")) {\n      base[name].forEach((id) => {\n        walkStats(stats, stats.get(id), resultSet);\n      });\n    }\n  });\n}\nfunction filterStats(result, track, outbound) {\n  const streamStatsType = outbound ? \"outbound-rtp\" : \"inbound-rtp\";\n  const filteredResult = /* @__PURE__ */ new Map();\n  if (track === null) {\n    return filteredResult;\n  }\n  const trackStats = [];\n  result.forEach((value) => {\n    if (value.type === \"track\" && value.trackIdentifier === track.id) {\n      trackStats.push(value);\n    }\n  });\n  trackStats.forEach((trackStat) => {\n    result.forEach((stats) => {\n      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {\n        walkStats(result, stats, filteredResult);\n      }\n    });\n  });\n  return filteredResult;\n}\nvar logging = log;\nfunction shimGetUserMedia$2(window2, browserDetails) {\n  const navigator2 = window2 && window2.navigator;\n  if (!navigator2.mediaDevices) {\n    return;\n  }\n  const constraintsToChrome_ = function(c) {\n    if (typeof c !== \"object\" || c.mandatory || c.optional) {\n      return c;\n    }\n    const cc = {};\n    Object.keys(c).forEach((key) => {\n      if (key === \"require\" || key === \"advanced\" || key === \"mediaSource\") {\n        return;\n      }\n      const r2 = typeof c[key] === \"object\" ? c[key] : {\n        ideal: c[key]\n      };\n      if (r2.exact !== void 0 && typeof r2.exact === \"number\") {\n        r2.min = r2.max = r2.exact;\n      }\n      const oldname_ = function(prefix, name) {\n        if (prefix) {\n          return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n        }\n        return name === \"deviceId\" ? \"sourceId\" : name;\n      };\n      if (r2.ideal !== void 0) {\n        cc.optional = cc.optional || [];\n        let oc = {};\n        if (typeof r2.ideal === \"number\") {\n          oc[oldname_(\"min\", key)] = r2.ideal;\n          cc.optional.push(oc);\n          oc = {};\n          oc[oldname_(\"max\", key)] = r2.ideal;\n          cc.optional.push(oc);\n        } else {\n          oc[oldname_(\"\", key)] = r2.ideal;\n          cc.optional.push(oc);\n        }\n      }\n      if (r2.exact !== void 0 && typeof r2.exact !== \"number\") {\n        cc.mandatory = cc.mandatory || {};\n        cc.mandatory[oldname_(\"\", key)] = r2.exact;\n      } else {\n        [\"min\", \"max\"].forEach((mix) => {\n          if (r2[mix] !== void 0) {\n            cc.mandatory = cc.mandatory || {};\n            cc.mandatory[oldname_(mix, key)] = r2[mix];\n          }\n        });\n      }\n    });\n    if (c.advanced) {\n      cc.optional = (cc.optional || []).concat(c.advanced);\n    }\n    return cc;\n  };\n  const shimConstraints_ = function(constraints, func) {\n    if (browserDetails.version >= 61) {\n      return func(constraints);\n    }\n    constraints = JSON.parse(JSON.stringify(constraints));\n    if (constraints && typeof constraints.audio === \"object\") {\n      const remap = function(obj, a, b) {\n        if (a in obj && !(b in obj)) {\n          obj[b] = obj[a];\n          delete obj[a];\n        }\n      };\n      constraints = JSON.parse(JSON.stringify(constraints));\n      remap(constraints.audio, \"autoGainControl\", \"googAutoGainControl\");\n      remap(constraints.audio, \"noiseSuppression\", \"googNoiseSuppression\");\n      constraints.audio = constraintsToChrome_(constraints.audio);\n    }\n    if (constraints && typeof constraints.video === \"object\") {\n      let face = constraints.video.facingMode;\n      face = face && (typeof face === \"object\" ? face : {\n        ideal: face\n      });\n      const getSupportedFacingModeLies = browserDetails.version < 66;\n      if (face && (face.exact === \"user\" || face.exact === \"environment\" || face.ideal === \"user\" || face.ideal === \"environment\") && !(navigator2.mediaDevices.getSupportedConstraints && navigator2.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {\n        delete constraints.video.facingMode;\n        let matches;\n        if (face.exact === \"environment\" || face.ideal === \"environment\") {\n          matches = [\"back\", \"rear\"];\n        } else if (face.exact === \"user\" || face.ideal === \"user\") {\n          matches = [\"front\"];\n        }\n        if (matches) {\n          return navigator2.mediaDevices.enumerateDevices().then((devices) => {\n            devices = devices.filter((d) => d.kind === \"videoinput\");\n            let dev = devices.find((d) => matches.some((match) => d.label.toLowerCase().includes(match)));\n            if (!dev && devices.length && matches.includes(\"back\")) {\n              dev = devices[devices.length - 1];\n            }\n            if (dev) {\n              constraints.video.deviceId = face.exact ? {\n                exact: dev.deviceId\n              } : {\n                ideal: dev.deviceId\n              };\n            }\n            constraints.video = constraintsToChrome_(constraints.video);\n            logging(\"chrome: \" + JSON.stringify(constraints));\n            return func(constraints);\n          });\n        }\n      }\n      constraints.video = constraintsToChrome_(constraints.video);\n    }\n    logging(\"chrome: \" + JSON.stringify(constraints));\n    return func(constraints);\n  };\n  const shimError_ = function(e) {\n    if (browserDetails.version >= 64) {\n      return e;\n    }\n    return {\n      name: {\n        PermissionDeniedError: \"NotAllowedError\",\n        PermissionDismissedError: \"NotAllowedError\",\n        InvalidStateError: \"NotAllowedError\",\n        DevicesNotFoundError: \"NotFoundError\",\n        ConstraintNotSatisfiedError: \"OverconstrainedError\",\n        TrackStartError: \"NotReadableError\",\n        MediaDeviceFailedDueToShutdown: \"NotAllowedError\",\n        MediaDeviceKillSwitchOn: \"NotAllowedError\",\n        TabCaptureError: \"AbortError\",\n        ScreenCaptureError: \"AbortError\",\n        DeviceCaptureError: \"AbortError\"\n      }[e.name] || e.name,\n      message: e.message,\n      constraint: e.constraint || e.constraintName,\n      toString() {\n        return this.name + (this.message && \": \") + this.message;\n      }\n    };\n  };\n  const getUserMedia_ = function(constraints, onSuccess, onError) {\n    shimConstraints_(constraints, (c) => {\n      navigator2.webkitGetUserMedia(c, onSuccess, (e) => {\n        if (onError) {\n          onError(shimError_(e));\n        }\n      });\n    });\n  };\n  navigator2.getUserMedia = getUserMedia_.bind(navigator2);\n  if (navigator2.mediaDevices.getUserMedia) {\n    const origGetUserMedia = navigator2.mediaDevices.getUserMedia.bind(navigator2.mediaDevices);\n    navigator2.mediaDevices.getUserMedia = function(cs) {\n      return shimConstraints_(cs, (c) => origGetUserMedia(c).then((stream) => {\n        if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {\n          stream.getTracks().forEach((track) => {\n            track.stop();\n          });\n          throw new DOMException(\"\", \"NotFoundError\");\n        }\n        return stream;\n      }, (e) => Promise.reject(shimError_(e))));\n    };\n  }\n}\nfunction shimGetDisplayMedia$1(window2, getSourceId) {\n  if (window2.navigator.mediaDevices && \"getDisplayMedia\" in window2.navigator.mediaDevices) {\n    return;\n  }\n  if (!window2.navigator.mediaDevices) {\n    return;\n  }\n  if (typeof getSourceId !== \"function\") {\n    console.error(\"shimGetDisplayMedia: getSourceId argument is not a function\");\n    return;\n  }\n  window2.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {\n    return getSourceId(constraints).then((sourceId) => {\n      const widthSpecified = constraints.video && constraints.video.width;\n      const heightSpecified = constraints.video && constraints.video.height;\n      const frameRateSpecified = constraints.video && constraints.video.frameRate;\n      constraints.video = {\n        mandatory: {\n          chromeMediaSource: \"desktop\",\n          chromeMediaSourceId: sourceId,\n          maxFrameRate: frameRateSpecified || 3\n        }\n      };\n      if (widthSpecified) {\n        constraints.video.mandatory.maxWidth = widthSpecified;\n      }\n      if (heightSpecified) {\n        constraints.video.mandatory.maxHeight = heightSpecified;\n      }\n      return window2.navigator.mediaDevices.getUserMedia(constraints);\n    });\n  };\n}\nfunction shimMediaStream(window2) {\n  window2.MediaStream = window2.MediaStream || window2.webkitMediaStream;\n}\nfunction shimOnTrack$1(window2) {\n  if (typeof window2 === \"object\" && window2.RTCPeerConnection && !(\"ontrack\" in window2.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window2.RTCPeerConnection.prototype, \"ontrack\", {\n      get() {\n        return this._ontrack;\n      },\n      set(f) {\n        if (this._ontrack) {\n          this.removeEventListener(\"track\", this._ontrack);\n        }\n        this.addEventListener(\"track\", this._ontrack = f);\n      },\n      enumerable: true,\n      configurable: true\n    });\n    const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;\n    window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n      if (!this._ontrackpoly) {\n        this._ontrackpoly = (e) => {\n          e.stream.addEventListener(\"addtrack\", (te) => {\n            let receiver;\n            if (window2.RTCPeerConnection.prototype.getReceivers) {\n              receiver = this.getReceivers().find((r2) => r2.track && r2.track.id === te.track.id);\n            } else {\n              receiver = {\n                track: te.track\n              };\n            }\n            const event = new Event(\"track\");\n            event.track = te.track;\n            event.receiver = receiver;\n            event.transceiver = {\n              receiver\n            };\n            event.streams = [e.stream];\n            this.dispatchEvent(event);\n          });\n          e.stream.getTracks().forEach((track) => {\n            let receiver;\n            if (window2.RTCPeerConnection.prototype.getReceivers) {\n              receiver = this.getReceivers().find((r2) => r2.track && r2.track.id === track.id);\n            } else {\n              receiver = {\n                track\n              };\n            }\n            const event = new Event(\"track\");\n            event.track = track;\n            event.receiver = receiver;\n            event.transceiver = {\n              receiver\n            };\n            event.streams = [e.stream];\n            this.dispatchEvent(event);\n          });\n        };\n        this.addEventListener(\"addstream\", this._ontrackpoly);\n      }\n      return origSetRemoteDescription.apply(this, arguments);\n    };\n  } else {\n    wrapPeerConnectionEvent(window2, \"track\", (e) => {\n      if (!e.transceiver) {\n        Object.defineProperty(e, \"transceiver\", {\n          value: {\n            receiver: e.receiver\n          }\n        });\n      }\n      return e;\n    });\n  }\n}\nfunction shimGetSendersWithDtmf(window2) {\n  if (typeof window2 === \"object\" && window2.RTCPeerConnection && !(\"getSenders\" in window2.RTCPeerConnection.prototype) && \"createDTMFSender\" in window2.RTCPeerConnection.prototype) {\n    const shimSenderWithDtmf = function(pc, track) {\n      return {\n        track,\n        get dtmf() {\n          if (this._dtmf === void 0) {\n            if (track.kind === \"audio\") {\n              this._dtmf = pc.createDTMFSender(track);\n            } else {\n              this._dtmf = null;\n            }\n          }\n          return this._dtmf;\n        },\n        _pc: pc\n      };\n    };\n    if (!window2.RTCPeerConnection.prototype.getSenders) {\n      window2.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        this._senders = this._senders || [];\n        return this._senders.slice();\n      };\n      const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;\n      window2.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n        let sender = origAddTrack.apply(this, arguments);\n        if (!sender) {\n          sender = shimSenderWithDtmf(this, track);\n          this._senders.push(sender);\n        }\n        return sender;\n      };\n      const origRemoveTrack = window2.RTCPeerConnection.prototype.removeTrack;\n      window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n        origRemoveTrack.apply(this, arguments);\n        const idx = this._senders.indexOf(sender);\n        if (idx !== -1) {\n          this._senders.splice(idx, 1);\n        }\n      };\n    }\n    const origAddStream = window2.RTCPeerConnection.prototype.addStream;\n    window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      this._senders = this._senders || [];\n      origAddStream.apply(this, [stream]);\n      stream.getTracks().forEach((track) => {\n        this._senders.push(shimSenderWithDtmf(this, track));\n      });\n    };\n    const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;\n    window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n      this._senders = this._senders || [];\n      origRemoveStream.apply(this, [stream]);\n      stream.getTracks().forEach((track) => {\n        const sender = this._senders.find((s) => s.track === track);\n        if (sender) {\n          this._senders.splice(this._senders.indexOf(sender), 1);\n        }\n      });\n    };\n  } else if (typeof window2 === \"object\" && window2.RTCPeerConnection && \"getSenders\" in window2.RTCPeerConnection.prototype && \"createDTMFSender\" in window2.RTCPeerConnection.prototype && window2.RTCRtpSender && !(\"dtmf\" in window2.RTCRtpSender.prototype)) {\n    const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;\n    window2.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach((sender) => sender._pc = this);\n      return senders;\n    };\n    Object.defineProperty(window2.RTCRtpSender.prototype, \"dtmf\", {\n      get() {\n        if (this._dtmf === void 0) {\n          if (this.track.kind === \"audio\") {\n            this._dtmf = this._pc.createDTMFSender(this.track);\n          } else {\n            this._dtmf = null;\n          }\n        }\n        return this._dtmf;\n      }\n    });\n  }\n}\nfunction shimGetStats(window2) {\n  if (!window2.RTCPeerConnection) {\n    return;\n  }\n  const origGetStats = window2.RTCPeerConnection.prototype.getStats;\n  window2.RTCPeerConnection.prototype.getStats = function getStats() {\n    const [selector, onSucc, onErr] = arguments;\n    if (arguments.length > 0 && typeof selector === \"function\") {\n      return origGetStats.apply(this, arguments);\n    }\n    if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== \"function\")) {\n      return origGetStats.apply(this, []);\n    }\n    const fixChromeStats_ = function(response) {\n      const standardReport = {};\n      const reports = response.result();\n      reports.forEach((report) => {\n        const standardStats = {\n          id: report.id,\n          timestamp: report.timestamp,\n          type: {\n            localcandidate: \"local-candidate\",\n            remotecandidate: \"remote-candidate\"\n          }[report.type] || report.type\n        };\n        report.names().forEach((name) => {\n          standardStats[name] = report.stat(name);\n        });\n        standardReport[standardStats.id] = standardStats;\n      });\n      return standardReport;\n    };\n    const makeMapStats = function(stats) {\n      return new Map(Object.keys(stats).map((key) => [key, stats[key]]));\n    };\n    if (arguments.length >= 2) {\n      const successCallbackWrapper_ = function(response) {\n        onSucc(makeMapStats(fixChromeStats_(response)));\n      };\n      return origGetStats.apply(this, [successCallbackWrapper_, selector]);\n    }\n    return new Promise((resolve, reject) => {\n      origGetStats.apply(this, [function(response) {\n        resolve(makeMapStats(fixChromeStats_(response)));\n      }, reject]);\n    }).then(onSucc, onErr);\n  };\n}\nfunction shimSenderReceiverGetStats(window2) {\n  if (!(typeof window2 === \"object\" && window2.RTCPeerConnection && window2.RTCRtpSender && window2.RTCRtpReceiver)) {\n    return;\n  }\n  if (!(\"getStats\" in window2.RTCRtpSender.prototype)) {\n    const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n      window2.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        const senders = origGetSenders.apply(this, []);\n        senders.forEach((sender) => sender._pc = this);\n        return senders;\n      };\n    }\n    const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n      window2.RTCPeerConnection.prototype.addTrack = function addTrack() {\n        const sender = origAddTrack.apply(this, arguments);\n        sender._pc = this;\n        return sender;\n      };\n    }\n    window2.RTCRtpSender.prototype.getStats = function getStats() {\n      const sender = this;\n      return this._pc.getStats().then((result) => (\n        /* Note: this will include stats of all senders that\n         *   send a track with the same id as sender.track as\n         *   it is not possible to identify the RTCRtpSender.\n         */\n        filterStats(result, sender.track, true)\n      ));\n    };\n  }\n  if (!(\"getStats\" in window2.RTCRtpReceiver.prototype)) {\n    const origGetReceivers = window2.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n      window2.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n        const receivers = origGetReceivers.apply(this, []);\n        receivers.forEach((receiver) => receiver._pc = this);\n        return receivers;\n      };\n    }\n    wrapPeerConnectionEvent(window2, \"track\", (e) => {\n      e.receiver._pc = e.srcElement;\n      return e;\n    });\n    window2.RTCRtpReceiver.prototype.getStats = function getStats() {\n      const receiver = this;\n      return this._pc.getStats().then((result) => filterStats(result, receiver.track, false));\n    };\n  }\n  if (!(\"getStats\" in window2.RTCRtpSender.prototype && \"getStats\" in window2.RTCRtpReceiver.prototype)) {\n    return;\n  }\n  const origGetStats = window2.RTCPeerConnection.prototype.getStats;\n  window2.RTCPeerConnection.prototype.getStats = function getStats() {\n    if (arguments.length > 0 && arguments[0] instanceof window2.MediaStreamTrack) {\n      const track = arguments[0];\n      let sender;\n      let receiver;\n      let err;\n      this.getSenders().forEach((s) => {\n        if (s.track === track) {\n          if (sender) {\n            err = true;\n          } else {\n            sender = s;\n          }\n        }\n      });\n      this.getReceivers().forEach((r2) => {\n        if (r2.track === track) {\n          if (receiver) {\n            err = true;\n          } else {\n            receiver = r2;\n          }\n        }\n        return r2.track === track;\n      });\n      if (err || sender && receiver) {\n        return Promise.reject(new DOMException(\"There are more than one sender or receiver for the track.\", \"InvalidAccessError\"));\n      } else if (sender) {\n        return sender.getStats();\n      } else if (receiver) {\n        return receiver.getStats();\n      }\n      return Promise.reject(new DOMException(\"There is no sender or receiver for the track.\", \"InvalidAccessError\"));\n    }\n    return origGetStats.apply(this, arguments);\n  };\n}\nfunction shimAddTrackRemoveTrackWithNative(window2) {\n  window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    return Object.keys(this._shimmedLocalStreams).map((streamId) => this._shimmedLocalStreams[streamId][0]);\n  };\n  const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;\n  window2.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n    if (!stream) {\n      return origAddTrack.apply(this, arguments);\n    }\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    const sender = origAddTrack.apply(this, arguments);\n    if (!this._shimmedLocalStreams[stream.id]) {\n      this._shimmedLocalStreams[stream.id] = [stream, sender];\n    } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n      this._shimmedLocalStreams[stream.id].push(sender);\n    }\n    return sender;\n  };\n  const origAddStream = window2.RTCPeerConnection.prototype.addStream;\n  window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    stream.getTracks().forEach((track) => {\n      const alreadyExists = this.getSenders().find((s) => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n      }\n    });\n    const existingSenders = this.getSenders();\n    origAddStream.apply(this, arguments);\n    const newSenders = this.getSenders().filter((newSender) => existingSenders.indexOf(newSender) === -1);\n    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);\n  };\n  const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;\n  window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    delete this._shimmedLocalStreams[stream.id];\n    return origRemoveStream.apply(this, arguments);\n  };\n  const origRemoveTrack = window2.RTCPeerConnection.prototype.removeTrack;\n  window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    if (sender) {\n      Object.keys(this._shimmedLocalStreams).forEach((streamId) => {\n        const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\n        if (idx !== -1) {\n          this._shimmedLocalStreams[streamId].splice(idx, 1);\n        }\n        if (this._shimmedLocalStreams[streamId].length === 1) {\n          delete this._shimmedLocalStreams[streamId];\n        }\n      });\n    }\n    return origRemoveTrack.apply(this, arguments);\n  };\n}\nfunction shimAddTrackRemoveTrack(window2, browserDetails) {\n  if (!window2.RTCPeerConnection) {\n    return;\n  }\n  if (window2.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {\n    return shimAddTrackRemoveTrackWithNative(window2);\n  }\n  const origGetLocalStreams = window2.RTCPeerConnection.prototype.getLocalStreams;\n  window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n    const nativeStreams = origGetLocalStreams.apply(this);\n    this._reverseStreams = this._reverseStreams || {};\n    return nativeStreams.map((stream) => this._reverseStreams[stream.id]);\n  };\n  const origAddStream = window2.RTCPeerConnection.prototype.addStream;\n  window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    stream.getTracks().forEach((track) => {\n      const alreadyExists = this.getSenders().find((s) => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n      }\n    });\n    if (!this._reverseStreams[stream.id]) {\n      const newStream = new window2.MediaStream(stream.getTracks());\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      stream = newStream;\n    }\n    origAddStream.apply(this, [stream]);\n  };\n  const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;\n  window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    origRemoveStream.apply(this, [this._streams[stream.id] || stream]);\n    delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];\n    delete this._streams[stream.id];\n  };\n  window2.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n    if (this.signalingState === \"closed\") {\n      throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\", \"InvalidStateError\");\n    }\n    const streams = [].slice.call(arguments, 1);\n    if (streams.length !== 1 || !streams[0].getTracks().find((t) => t === track)) {\n      throw new DOMException(\"The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.\", \"NotSupportedError\");\n    }\n    const alreadyExists = this.getSenders().find((s) => s.track === track);\n    if (alreadyExists) {\n      throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n    }\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    const oldStream = this._streams[stream.id];\n    if (oldStream) {\n      oldStream.addTrack(track);\n      Promise.resolve().then(() => {\n        this.dispatchEvent(new Event(\"negotiationneeded\"));\n      });\n    } else {\n      const newStream = new window2.MediaStream([track]);\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      this.addStream(newStream);\n    }\n    return this.getSenders().find((s) => s.track === track);\n  };\n  function replaceInternalStreamId(pc, description) {\n    let sdp2 = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach((internalId) => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp2 = sdp2.replace(new RegExp(internalStream.id, \"g\"), externalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp: sdp2\n    });\n  }\n  function replaceExternalStreamId(pc, description) {\n    let sdp2 = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach((internalId) => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp2 = sdp2.replace(new RegExp(externalStream.id, \"g\"), internalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp: sdp2\n    });\n  }\n  [\"createOffer\", \"createAnswer\"].forEach(function(method) {\n    const nativeMethod = window2.RTCPeerConnection.prototype[method];\n    const methodObj = {\n      [method]() {\n        const args = arguments;\n        const isLegacyCall = arguments.length && typeof arguments[0] === \"function\";\n        if (isLegacyCall) {\n          return nativeMethod.apply(this, [(description) => {\n            const desc = replaceInternalStreamId(this, description);\n            args[0].apply(null, [desc]);\n          }, (err) => {\n            if (args[1]) {\n              args[1].apply(null, err);\n            }\n          }, arguments[2]]);\n        }\n        return nativeMethod.apply(this, arguments).then((description) => replaceInternalStreamId(this, description));\n      }\n    };\n    window2.RTCPeerConnection.prototype[method] = methodObj[method];\n  });\n  const origSetLocalDescription = window2.RTCPeerConnection.prototype.setLocalDescription;\n  window2.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n    if (!arguments.length || !arguments[0].type) {\n      return origSetLocalDescription.apply(this, arguments);\n    }\n    arguments[0] = replaceExternalStreamId(this, arguments[0]);\n    return origSetLocalDescription.apply(this, arguments);\n  };\n  const origLocalDescription = Object.getOwnPropertyDescriptor(window2.RTCPeerConnection.prototype, \"localDescription\");\n  Object.defineProperty(window2.RTCPeerConnection.prototype, \"localDescription\", {\n    get() {\n      const description = origLocalDescription.get.apply(this);\n      if (description.type === \"\") {\n        return description;\n      }\n      return replaceInternalStreamId(this, description);\n    }\n  });\n  window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    if (this.signalingState === \"closed\") {\n      throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\", \"InvalidStateError\");\n    }\n    if (!sender._pc) {\n      throw new DOMException(\"Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.\", \"TypeError\");\n    }\n    const isLocal = sender._pc === this;\n    if (!isLocal) {\n      throw new DOMException(\"Sender was not created by this connection.\", \"InvalidAccessError\");\n    }\n    this._streams = this._streams || {};\n    let stream;\n    Object.keys(this._streams).forEach((streamid) => {\n      const hasTrack = this._streams[streamid].getTracks().find((track) => sender.track === track);\n      if (hasTrack) {\n        stream = this._streams[streamid];\n      }\n    });\n    if (stream) {\n      if (stream.getTracks().length === 1) {\n        this.removeStream(this._reverseStreams[stream.id]);\n      } else {\n        stream.removeTrack(sender.track);\n      }\n      this.dispatchEvent(new Event(\"negotiationneeded\"));\n    }\n  };\n}\nfunction shimPeerConnection$1(window2, browserDetails) {\n  if (!window2.RTCPeerConnection && window2.webkitRTCPeerConnection) {\n    window2.RTCPeerConnection = window2.webkitRTCPeerConnection;\n  }\n  if (!window2.RTCPeerConnection) {\n    return;\n  }\n  if (browserDetails.version < 53) {\n    [\"setLocalDescription\", \"setRemoteDescription\", \"addIceCandidate\"].forEach(function(method) {\n      const nativeMethod = window2.RTCPeerConnection.prototype[method];\n      const methodObj = {\n        [method]() {\n          arguments[0] = new (method === \"addIceCandidate\" ? window2.RTCIceCandidate : window2.RTCSessionDescription)(arguments[0]);\n          return nativeMethod.apply(this, arguments);\n        }\n      };\n      window2.RTCPeerConnection.prototype[method] = methodObj[method];\n    });\n  }\n}\nfunction fixNegotiationNeeded(window2, browserDetails) {\n  wrapPeerConnectionEvent(window2, \"negotiationneeded\", (e) => {\n    const pc = e.target;\n    if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === \"plan-b\") {\n      if (pc.signalingState !== \"stable\") {\n        return;\n      }\n    }\n    return e;\n  });\n}\nvar chromeShim = Object.freeze({\n  __proto__: null,\n  fixNegotiationNeeded,\n  shimAddTrackRemoveTrack,\n  shimAddTrackRemoveTrackWithNative,\n  shimGetDisplayMedia: shimGetDisplayMedia$1,\n  shimGetSendersWithDtmf,\n  shimGetStats,\n  shimGetUserMedia: shimGetUserMedia$2,\n  shimMediaStream,\n  shimOnTrack: shimOnTrack$1,\n  shimPeerConnection: shimPeerConnection$1,\n  shimSenderReceiverGetStats\n});\nfunction shimGetUserMedia$1(window2, browserDetails) {\n  const navigator2 = window2 && window2.navigator;\n  const MediaStreamTrack2 = window2 && window2.MediaStreamTrack;\n  navigator2.getUserMedia = function(constraints, onSuccess, onError) {\n    deprecated(\"navigator.getUserMedia\", \"navigator.mediaDevices.getUserMedia\");\n    navigator2.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\n  };\n  if (!(browserDetails.version > 55 && \"autoGainControl\" in navigator2.mediaDevices.getSupportedConstraints())) {\n    const remap = function(obj, a, b) {\n      if (a in obj && !(b in obj)) {\n        obj[b] = obj[a];\n        delete obj[a];\n      }\n    };\n    const nativeGetUserMedia = navigator2.mediaDevices.getUserMedia.bind(navigator2.mediaDevices);\n    navigator2.mediaDevices.getUserMedia = function(c) {\n      if (typeof c === \"object\" && typeof c.audio === \"object\") {\n        c = JSON.parse(JSON.stringify(c));\n        remap(c.audio, \"autoGainControl\", \"mozAutoGainControl\");\n        remap(c.audio, \"noiseSuppression\", \"mozNoiseSuppression\");\n      }\n      return nativeGetUserMedia(c);\n    };\n    if (MediaStreamTrack2 && MediaStreamTrack2.prototype.getSettings) {\n      const nativeGetSettings = MediaStreamTrack2.prototype.getSettings;\n      MediaStreamTrack2.prototype.getSettings = function() {\n        const obj = nativeGetSettings.apply(this, arguments);\n        remap(obj, \"mozAutoGainControl\", \"autoGainControl\");\n        remap(obj, \"mozNoiseSuppression\", \"noiseSuppression\");\n        return obj;\n      };\n    }\n    if (MediaStreamTrack2 && MediaStreamTrack2.prototype.applyConstraints) {\n      const nativeApplyConstraints = MediaStreamTrack2.prototype.applyConstraints;\n      MediaStreamTrack2.prototype.applyConstraints = function(c) {\n        if (this.kind === \"audio\" && typeof c === \"object\") {\n          c = JSON.parse(JSON.stringify(c));\n          remap(c, \"autoGainControl\", \"mozAutoGainControl\");\n          remap(c, \"noiseSuppression\", \"mozNoiseSuppression\");\n        }\n        return nativeApplyConstraints.apply(this, [c]);\n      };\n    }\n  }\n}\nfunction shimGetDisplayMedia(window2, preferredMediaSource) {\n  if (window2.navigator.mediaDevices && \"getDisplayMedia\" in window2.navigator.mediaDevices) {\n    return;\n  }\n  if (!window2.navigator.mediaDevices) {\n    return;\n  }\n  window2.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {\n    if (!(constraints && constraints.video)) {\n      const err = new DOMException(\"getDisplayMedia without video constraints is undefined\");\n      err.name = \"NotFoundError\";\n      err.code = 8;\n      return Promise.reject(err);\n    }\n    if (constraints.video === true) {\n      constraints.video = {\n        mediaSource: preferredMediaSource\n      };\n    } else {\n      constraints.video.mediaSource = preferredMediaSource;\n    }\n    return window2.navigator.mediaDevices.getUserMedia(constraints);\n  };\n}\nfunction shimOnTrack(window2) {\n  if (typeof window2 === \"object\" && window2.RTCTrackEvent && \"receiver\" in window2.RTCTrackEvent.prototype && !(\"transceiver\" in window2.RTCTrackEvent.prototype)) {\n    Object.defineProperty(window2.RTCTrackEvent.prototype, \"transceiver\", {\n      get() {\n        return {\n          receiver: this.receiver\n        };\n      }\n    });\n  }\n}\nfunction shimPeerConnection(window2, browserDetails) {\n  if (typeof window2 !== \"object\" || !(window2.RTCPeerConnection || window2.mozRTCPeerConnection)) {\n    return;\n  }\n  if (!window2.RTCPeerConnection && window2.mozRTCPeerConnection) {\n    window2.RTCPeerConnection = window2.mozRTCPeerConnection;\n  }\n  if (browserDetails.version < 53) {\n    [\"setLocalDescription\", \"setRemoteDescription\", \"addIceCandidate\"].forEach(function(method) {\n      const nativeMethod = window2.RTCPeerConnection.prototype[method];\n      const methodObj = {\n        [method]() {\n          arguments[0] = new (method === \"addIceCandidate\" ? window2.RTCIceCandidate : window2.RTCSessionDescription)(arguments[0]);\n          return nativeMethod.apply(this, arguments);\n        }\n      };\n      window2.RTCPeerConnection.prototype[method] = methodObj[method];\n    });\n  }\n  const modernStatsTypes = {\n    inboundrtp: \"inbound-rtp\",\n    outboundrtp: \"outbound-rtp\",\n    candidatepair: \"candidate-pair\",\n    localcandidate: \"local-candidate\",\n    remotecandidate: \"remote-candidate\"\n  };\n  const nativeGetStats = window2.RTCPeerConnection.prototype.getStats;\n  window2.RTCPeerConnection.prototype.getStats = function getStats() {\n    const [selector, onSucc, onErr] = arguments;\n    return nativeGetStats.apply(this, [selector || null]).then((stats) => {\n      if (browserDetails.version < 53 && !onSucc) {\n        try {\n          stats.forEach((stat) => {\n            stat.type = modernStatsTypes[stat.type] || stat.type;\n          });\n        } catch (e) {\n          if (e.name !== \"TypeError\") {\n            throw e;\n          }\n          stats.forEach((stat, i) => {\n            stats.set(i, Object.assign({}, stat, {\n              type: modernStatsTypes[stat.type] || stat.type\n            }));\n          });\n        }\n      }\n      return stats;\n    }).then(onSucc, onErr);\n  };\n}\nfunction shimSenderGetStats(window2) {\n  if (!(typeof window2 === \"object\" && window2.RTCPeerConnection && window2.RTCRtpSender)) {\n    return;\n  }\n  if (window2.RTCRtpSender && \"getStats\" in window2.RTCRtpSender.prototype) {\n    return;\n  }\n  const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;\n  if (origGetSenders) {\n    window2.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach((sender) => sender._pc = this);\n      return senders;\n    };\n  }\n  const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;\n  if (origAddTrack) {\n    window2.RTCPeerConnection.prototype.addTrack = function addTrack() {\n      const sender = origAddTrack.apply(this, arguments);\n      sender._pc = this;\n      return sender;\n    };\n  }\n  window2.RTCRtpSender.prototype.getStats = function getStats() {\n    return this.track ? this._pc.getStats(this.track) : Promise.resolve(/* @__PURE__ */ new Map());\n  };\n}\nfunction shimReceiverGetStats(window2) {\n  if (!(typeof window2 === \"object\" && window2.RTCPeerConnection && window2.RTCRtpSender)) {\n    return;\n  }\n  if (window2.RTCRtpSender && \"getStats\" in window2.RTCRtpReceiver.prototype) {\n    return;\n  }\n  const origGetReceivers = window2.RTCPeerConnection.prototype.getReceivers;\n  if (origGetReceivers) {\n    window2.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n      const receivers = origGetReceivers.apply(this, []);\n      receivers.forEach((receiver) => receiver._pc = this);\n      return receivers;\n    };\n  }\n  wrapPeerConnectionEvent(window2, \"track\", (e) => {\n    e.receiver._pc = e.srcElement;\n    return e;\n  });\n  window2.RTCRtpReceiver.prototype.getStats = function getStats() {\n    return this._pc.getStats(this.track);\n  };\n}\nfunction shimRemoveStream(window2) {\n  if (!window2.RTCPeerConnection || \"removeStream\" in window2.RTCPeerConnection.prototype) {\n    return;\n  }\n  window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n    deprecated(\"removeStream\", \"removeTrack\");\n    this.getSenders().forEach((sender) => {\n      if (sender.track && stream.getTracks().includes(sender.track)) {\n        this.removeTrack(sender);\n      }\n    });\n  };\n}\nfunction shimRTCDataChannel(window2) {\n  if (window2.DataChannel && !window2.RTCDataChannel) {\n    window2.RTCDataChannel = window2.DataChannel;\n  }\n}\nfunction shimAddTransceiver(window2) {\n  if (!(typeof window2 === \"object\" && window2.RTCPeerConnection)) {\n    return;\n  }\n  const origAddTransceiver = window2.RTCPeerConnection.prototype.addTransceiver;\n  if (origAddTransceiver) {\n    window2.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {\n      this.setParametersPromises = [];\n      let sendEncodings = arguments[1] && arguments[1].sendEncodings;\n      if (sendEncodings === void 0) {\n        sendEncodings = [];\n      }\n      sendEncodings = [...sendEncodings];\n      const shouldPerformCheck = sendEncodings.length > 0;\n      if (shouldPerformCheck) {\n        sendEncodings.forEach((encodingParam) => {\n          if (\"rid\" in encodingParam) {\n            const ridRegex = /^[a-z0-9]{0,16}$/i;\n            if (!ridRegex.test(encodingParam.rid)) {\n              throw new TypeError(\"Invalid RID value provided.\");\n            }\n          }\n          if (\"scaleResolutionDownBy\" in encodingParam) {\n            if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1)) {\n              throw new RangeError(\"scale_resolution_down_by must be >= 1.0\");\n            }\n          }\n          if (\"maxFramerate\" in encodingParam) {\n            if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {\n              throw new RangeError(\"max_framerate must be >= 0.0\");\n            }\n          }\n        });\n      }\n      const transceiver = origAddTransceiver.apply(this, arguments);\n      if (shouldPerformCheck) {\n        const {\n          sender\n        } = transceiver;\n        const params = sender.getParameters();\n        if (!(\"encodings\" in params) || // Avoid being fooled by patched getParameters() below.\n        params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {\n          params.encodings = sendEncodings;\n          sender.sendEncodings = sendEncodings;\n          this.setParametersPromises.push(sender.setParameters(params).then(() => {\n            delete sender.sendEncodings;\n          }).catch(() => {\n            delete sender.sendEncodings;\n          }));\n        }\n      }\n      return transceiver;\n    };\n  }\n}\nfunction shimGetParameters(window2) {\n  if (!(typeof window2 === \"object\" && window2.RTCRtpSender)) {\n    return;\n  }\n  const origGetParameters = window2.RTCRtpSender.prototype.getParameters;\n  if (origGetParameters) {\n    window2.RTCRtpSender.prototype.getParameters = function getParameters() {\n      const params = origGetParameters.apply(this, arguments);\n      if (!(\"encodings\" in params)) {\n        params.encodings = [].concat(this.sendEncodings || [{}]);\n      }\n      return params;\n    };\n  }\n}\nfunction shimCreateOffer(window2) {\n  if (!(typeof window2 === \"object\" && window2.RTCPeerConnection)) {\n    return;\n  }\n  const origCreateOffer = window2.RTCPeerConnection.prototype.createOffer;\n  window2.RTCPeerConnection.prototype.createOffer = function createOffer() {\n    if (this.setParametersPromises && this.setParametersPromises.length) {\n      return Promise.all(this.setParametersPromises).then(() => {\n        return origCreateOffer.apply(this, arguments);\n      }).finally(() => {\n        this.setParametersPromises = [];\n      });\n    }\n    return origCreateOffer.apply(this, arguments);\n  };\n}\nfunction shimCreateAnswer(window2) {\n  if (!(typeof window2 === \"object\" && window2.RTCPeerConnection)) {\n    return;\n  }\n  const origCreateAnswer = window2.RTCPeerConnection.prototype.createAnswer;\n  window2.RTCPeerConnection.prototype.createAnswer = function createAnswer() {\n    if (this.setParametersPromises && this.setParametersPromises.length) {\n      return Promise.all(this.setParametersPromises).then(() => {\n        return origCreateAnswer.apply(this, arguments);\n      }).finally(() => {\n        this.setParametersPromises = [];\n      });\n    }\n    return origCreateAnswer.apply(this, arguments);\n  };\n}\nvar firefoxShim = Object.freeze({\n  __proto__: null,\n  shimAddTransceiver,\n  shimCreateAnswer,\n  shimCreateOffer,\n  shimGetDisplayMedia,\n  shimGetParameters,\n  shimGetUserMedia: shimGetUserMedia$1,\n  shimOnTrack,\n  shimPeerConnection,\n  shimRTCDataChannel,\n  shimReceiverGetStats,\n  shimRemoveStream,\n  shimSenderGetStats\n});\nfunction shimLocalStreamsAPI(window2) {\n  if (typeof window2 !== \"object\" || !window2.RTCPeerConnection) {\n    return;\n  }\n  if (!(\"getLocalStreams\" in window2.RTCPeerConnection.prototype)) {\n    window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n      if (!this._localStreams) {\n        this._localStreams = [];\n      }\n      return this._localStreams;\n    };\n  }\n  if (!(\"addStream\" in window2.RTCPeerConnection.prototype)) {\n    const _addTrack = window2.RTCPeerConnection.prototype.addTrack;\n    window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      if (!this._localStreams) {\n        this._localStreams = [];\n      }\n      if (!this._localStreams.includes(stream)) {\n        this._localStreams.push(stream);\n      }\n      stream.getAudioTracks().forEach((track) => _addTrack.call(this, track, stream));\n      stream.getVideoTracks().forEach((track) => _addTrack.call(this, track, stream));\n    };\n    window2.RTCPeerConnection.prototype.addTrack = function addTrack(track) {\n      for (var _len = arguments.length, streams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        streams[_key - 1] = arguments[_key];\n      }\n      if (streams) {\n        streams.forEach((stream) => {\n          if (!this._localStreams) {\n            this._localStreams = [stream];\n          } else if (!this._localStreams.includes(stream)) {\n            this._localStreams.push(stream);\n          }\n        });\n      }\n      return _addTrack.apply(this, arguments);\n    };\n  }\n  if (!(\"removeStream\" in window2.RTCPeerConnection.prototype)) {\n    window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n      if (!this._localStreams) {\n        this._localStreams = [];\n      }\n      const index = this._localStreams.indexOf(stream);\n      if (index === -1) {\n        return;\n      }\n      this._localStreams.splice(index, 1);\n      const tracks = stream.getTracks();\n      this.getSenders().forEach((sender) => {\n        if (tracks.includes(sender.track)) {\n          this.removeTrack(sender);\n        }\n      });\n    };\n  }\n}\nfunction shimRemoteStreamsAPI(window2) {\n  if (typeof window2 !== \"object\" || !window2.RTCPeerConnection) {\n    return;\n  }\n  if (!(\"getRemoteStreams\" in window2.RTCPeerConnection.prototype)) {\n    window2.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {\n      return this._remoteStreams ? this._remoteStreams : [];\n    };\n  }\n  if (!(\"onaddstream\" in window2.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window2.RTCPeerConnection.prototype, \"onaddstream\", {\n      get() {\n        return this._onaddstream;\n      },\n      set(f) {\n        if (this._onaddstream) {\n          this.removeEventListener(\"addstream\", this._onaddstream);\n          this.removeEventListener(\"track\", this._onaddstreampoly);\n        }\n        this.addEventListener(\"addstream\", this._onaddstream = f);\n        this.addEventListener(\"track\", this._onaddstreampoly = (e) => {\n          e.streams.forEach((stream) => {\n            if (!this._remoteStreams) {\n              this._remoteStreams = [];\n            }\n            if (this._remoteStreams.includes(stream)) {\n              return;\n            }\n            this._remoteStreams.push(stream);\n            const event = new Event(\"addstream\");\n            event.stream = stream;\n            this.dispatchEvent(event);\n          });\n        });\n      }\n    });\n    const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;\n    window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n      const pc = this;\n      if (!this._onaddstreampoly) {\n        this.addEventListener(\"track\", this._onaddstreampoly = function(e) {\n          e.streams.forEach((stream) => {\n            if (!pc._remoteStreams) {\n              pc._remoteStreams = [];\n            }\n            if (pc._remoteStreams.indexOf(stream) >= 0) {\n              return;\n            }\n            pc._remoteStreams.push(stream);\n            const event = new Event(\"addstream\");\n            event.stream = stream;\n            pc.dispatchEvent(event);\n          });\n        });\n      }\n      return origSetRemoteDescription.apply(pc, arguments);\n    };\n  }\n}\nfunction shimCallbacksAPI(window2) {\n  if (typeof window2 !== \"object\" || !window2.RTCPeerConnection) {\n    return;\n  }\n  const prototype = window2.RTCPeerConnection.prototype;\n  const origCreateOffer = prototype.createOffer;\n  const origCreateAnswer = prototype.createAnswer;\n  const setLocalDescription = prototype.setLocalDescription;\n  const setRemoteDescription = prototype.setRemoteDescription;\n  const addIceCandidate = prototype.addIceCandidate;\n  prototype.createOffer = function createOffer(successCallback, failureCallback) {\n    const options = arguments.length >= 2 ? arguments[2] : arguments[0];\n    const promise = origCreateOffer.apply(this, [options]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.createAnswer = function createAnswer(successCallback, failureCallback) {\n    const options = arguments.length >= 2 ? arguments[2] : arguments[0];\n    const promise = origCreateAnswer.apply(this, [options]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  let withCallback = function(description, successCallback, failureCallback) {\n    const promise = setLocalDescription.apply(this, [description]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.setLocalDescription = withCallback;\n  withCallback = function(description, successCallback, failureCallback) {\n    const promise = setRemoteDescription.apply(this, [description]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.setRemoteDescription = withCallback;\n  withCallback = function(candidate, successCallback, failureCallback) {\n    const promise = addIceCandidate.apply(this, [candidate]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.addIceCandidate = withCallback;\n}\nfunction shimGetUserMedia(window2) {\n  const navigator2 = window2 && window2.navigator;\n  if (navigator2.mediaDevices && navigator2.mediaDevices.getUserMedia) {\n    const mediaDevices = navigator2.mediaDevices;\n    const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);\n    navigator2.mediaDevices.getUserMedia = (constraints) => {\n      return _getUserMedia(shimConstraints(constraints));\n    };\n  }\n  if (!navigator2.getUserMedia && navigator2.mediaDevices && navigator2.mediaDevices.getUserMedia) {\n    navigator2.getUserMedia = function getUserMedia(constraints, cb, errcb) {\n      navigator2.mediaDevices.getUserMedia(constraints).then(cb, errcb);\n    }.bind(navigator2);\n  }\n}\nfunction shimConstraints(constraints) {\n  if (constraints && constraints.video !== void 0) {\n    return Object.assign({}, constraints, {\n      video: compactObject(constraints.video)\n    });\n  }\n  return constraints;\n}\nfunction shimRTCIceServerUrls(window2) {\n  if (!window2.RTCPeerConnection) {\n    return;\n  }\n  const OrigPeerConnection = window2.RTCPeerConnection;\n  window2.RTCPeerConnection = function RTCPeerConnection2(pcConfig, pcConstraints) {\n    if (pcConfig && pcConfig.iceServers) {\n      const newIceServers = [];\n      for (let i = 0; i < pcConfig.iceServers.length; i++) {\n        let server = pcConfig.iceServers[i];\n        if (server.urls === void 0 && server.url) {\n          deprecated(\"RTCIceServer.url\", \"RTCIceServer.urls\");\n          server = JSON.parse(JSON.stringify(server));\n          server.urls = server.url;\n          delete server.url;\n          newIceServers.push(server);\n        } else {\n          newIceServers.push(pcConfig.iceServers[i]);\n        }\n      }\n      pcConfig.iceServers = newIceServers;\n    }\n    return new OrigPeerConnection(pcConfig, pcConstraints);\n  };\n  window2.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\n  if (\"generateCertificate\" in OrigPeerConnection) {\n    Object.defineProperty(window2.RTCPeerConnection, \"generateCertificate\", {\n      get() {\n        return OrigPeerConnection.generateCertificate;\n      }\n    });\n  }\n}\nfunction shimTrackEventTransceiver(window2) {\n  if (typeof window2 === \"object\" && window2.RTCTrackEvent && \"receiver\" in window2.RTCTrackEvent.prototype && !(\"transceiver\" in window2.RTCTrackEvent.prototype)) {\n    Object.defineProperty(window2.RTCTrackEvent.prototype, \"transceiver\", {\n      get() {\n        return {\n          receiver: this.receiver\n        };\n      }\n    });\n  }\n}\nfunction shimCreateOfferLegacy(window2) {\n  const origCreateOffer = window2.RTCPeerConnection.prototype.createOffer;\n  window2.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {\n    if (offerOptions) {\n      if (typeof offerOptions.offerToReceiveAudio !== \"undefined\") {\n        offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;\n      }\n      const audioTransceiver = this.getTransceivers().find((transceiver) => transceiver.receiver.track.kind === \"audio\");\n      if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {\n        if (audioTransceiver.direction === \"sendrecv\") {\n          if (audioTransceiver.setDirection) {\n            audioTransceiver.setDirection(\"sendonly\");\n          } else {\n            audioTransceiver.direction = \"sendonly\";\n          }\n        } else if (audioTransceiver.direction === \"recvonly\") {\n          if (audioTransceiver.setDirection) {\n            audioTransceiver.setDirection(\"inactive\");\n          } else {\n            audioTransceiver.direction = \"inactive\";\n          }\n        }\n      } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {\n        this.addTransceiver(\"audio\", {\n          direction: \"recvonly\"\n        });\n      }\n      if (typeof offerOptions.offerToReceiveVideo !== \"undefined\") {\n        offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;\n      }\n      const videoTransceiver = this.getTransceivers().find((transceiver) => transceiver.receiver.track.kind === \"video\");\n      if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {\n        if (videoTransceiver.direction === \"sendrecv\") {\n          if (videoTransceiver.setDirection) {\n            videoTransceiver.setDirection(\"sendonly\");\n          } else {\n            videoTransceiver.direction = \"sendonly\";\n          }\n        } else if (videoTransceiver.direction === \"recvonly\") {\n          if (videoTransceiver.setDirection) {\n            videoTransceiver.setDirection(\"inactive\");\n          } else {\n            videoTransceiver.direction = \"inactive\";\n          }\n        }\n      } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {\n        this.addTransceiver(\"video\", {\n          direction: \"recvonly\"\n        });\n      }\n    }\n    return origCreateOffer.apply(this, arguments);\n  };\n}\nfunction shimAudioContext(window2) {\n  if (typeof window2 !== \"object\" || window2.AudioContext) {\n    return;\n  }\n  window2.AudioContext = window2.webkitAudioContext;\n}\nvar safariShim = Object.freeze({\n  __proto__: null,\n  shimAudioContext,\n  shimCallbacksAPI,\n  shimConstraints,\n  shimCreateOfferLegacy,\n  shimGetUserMedia,\n  shimLocalStreamsAPI,\n  shimRTCIceServerUrls,\n  shimRemoteStreamsAPI,\n  shimTrackEventTransceiver\n});\nvar sdp$1 = { exports: {} };\n(function(module) {\n  const SDPUtils2 = {};\n  SDPUtils2.generateIdentifier = function() {\n    return Math.random().toString(36).substring(2, 12);\n  };\n  SDPUtils2.localCName = SDPUtils2.generateIdentifier();\n  SDPUtils2.splitLines = function(blob) {\n    return blob.trim().split(\"\\n\").map((line) => line.trim());\n  };\n  SDPUtils2.splitSections = function(blob) {\n    const parts = blob.split(\"\\nm=\");\n    return parts.map((part, index) => (index > 0 ? \"m=\" + part : part).trim() + \"\\r\\n\");\n  };\n  SDPUtils2.getDescription = function(blob) {\n    const sections = SDPUtils2.splitSections(blob);\n    return sections && sections[0];\n  };\n  SDPUtils2.getMediaSections = function(blob) {\n    const sections = SDPUtils2.splitSections(blob);\n    sections.shift();\n    return sections;\n  };\n  SDPUtils2.matchPrefix = function(blob, prefix) {\n    return SDPUtils2.splitLines(blob).filter((line) => line.indexOf(prefix) === 0);\n  };\n  SDPUtils2.parseCandidate = function(line) {\n    let parts;\n    if (line.indexOf(\"a=candidate:\") === 0) {\n      parts = line.substring(12).split(\" \");\n    } else {\n      parts = line.substring(10).split(\" \");\n    }\n    const candidate = {\n      foundation: parts[0],\n      component: {\n        1: \"rtp\",\n        2: \"rtcp\"\n      }[parts[1]] || parts[1],\n      protocol: parts[2].toLowerCase(),\n      priority: parseInt(parts[3], 10),\n      ip: parts[4],\n      address: parts[4],\n      // address is an alias for ip.\n      port: parseInt(parts[5], 10),\n      // skip parts[6] == 'typ'\n      type: parts[7]\n    };\n    for (let i = 8; i < parts.length; i += 2) {\n      switch (parts[i]) {\n        case \"raddr\":\n          candidate.relatedAddress = parts[i + 1];\n          break;\n        case \"rport\":\n          candidate.relatedPort = parseInt(parts[i + 1], 10);\n          break;\n        case \"tcptype\":\n          candidate.tcpType = parts[i + 1];\n          break;\n        case \"ufrag\":\n          candidate.ufrag = parts[i + 1];\n          candidate.usernameFragment = parts[i + 1];\n          break;\n        default:\n          if (candidate[parts[i]] === void 0) {\n            candidate[parts[i]] = parts[i + 1];\n          }\n          break;\n      }\n    }\n    return candidate;\n  };\n  SDPUtils2.writeCandidate = function(candidate) {\n    const sdp2 = [];\n    sdp2.push(candidate.foundation);\n    const component = candidate.component;\n    if (component === \"rtp\") {\n      sdp2.push(1);\n    } else if (component === \"rtcp\") {\n      sdp2.push(2);\n    } else {\n      sdp2.push(component);\n    }\n    sdp2.push(candidate.protocol.toUpperCase());\n    sdp2.push(candidate.priority);\n    sdp2.push(candidate.address || candidate.ip);\n    sdp2.push(candidate.port);\n    const type = candidate.type;\n    sdp2.push(\"typ\");\n    sdp2.push(type);\n    if (type !== \"host\" && candidate.relatedAddress && candidate.relatedPort) {\n      sdp2.push(\"raddr\");\n      sdp2.push(candidate.relatedAddress);\n      sdp2.push(\"rport\");\n      sdp2.push(candidate.relatedPort);\n    }\n    if (candidate.tcpType && candidate.protocol.toLowerCase() === \"tcp\") {\n      sdp2.push(\"tcptype\");\n      sdp2.push(candidate.tcpType);\n    }\n    if (candidate.usernameFragment || candidate.ufrag) {\n      sdp2.push(\"ufrag\");\n      sdp2.push(candidate.usernameFragment || candidate.ufrag);\n    }\n    return \"candidate:\" + sdp2.join(\" \");\n  };\n  SDPUtils2.parseIceOptions = function(line) {\n    return line.substring(14).split(\" \");\n  };\n  SDPUtils2.parseRtpMap = function(line) {\n    let parts = line.substring(9).split(\" \");\n    const parsed = {\n      payloadType: parseInt(parts.shift(), 10)\n      // was: id\n    };\n    parts = parts[0].split(\"/\");\n    parsed.name = parts[0];\n    parsed.clockRate = parseInt(parts[1], 10);\n    parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n    parsed.numChannels = parsed.channels;\n    return parsed;\n  };\n  SDPUtils2.writeRtpMap = function(codec) {\n    let pt = codec.payloadType;\n    if (codec.preferredPayloadType !== void 0) {\n      pt = codec.preferredPayloadType;\n    }\n    const channels = codec.channels || codec.numChannels || 1;\n    return \"a=rtpmap:\" + pt + \" \" + codec.name + \"/\" + codec.clockRate + (channels !== 1 ? \"/\" + channels : \"\") + \"\\r\\n\";\n  };\n  SDPUtils2.parseExtmap = function(line) {\n    const parts = line.substring(9).split(\" \");\n    return {\n      id: parseInt(parts[0], 10),\n      direction: parts[0].indexOf(\"/\") > 0 ? parts[0].split(\"/\")[1] : \"sendrecv\",\n      uri: parts[1],\n      attributes: parts.slice(2).join(\" \")\n    };\n  };\n  SDPUtils2.writeExtmap = function(headerExtension) {\n    return \"a=extmap:\" + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== \"sendrecv\" ? \"/\" + headerExtension.direction : \"\") + \" \" + headerExtension.uri + (headerExtension.attributes ? \" \" + headerExtension.attributes : \"\") + \"\\r\\n\";\n  };\n  SDPUtils2.parseFmtp = function(line) {\n    const parsed = {};\n    let kv;\n    const parts = line.substring(line.indexOf(\" \") + 1).split(\";\");\n    for (let j = 0; j < parts.length; j++) {\n      kv = parts[j].trim().split(\"=\");\n      parsed[kv[0].trim()] = kv[1];\n    }\n    return parsed;\n  };\n  SDPUtils2.writeFmtp = function(codec) {\n    let line = \"\";\n    let pt = codec.payloadType;\n    if (codec.preferredPayloadType !== void 0) {\n      pt = codec.preferredPayloadType;\n    }\n    if (codec.parameters && Object.keys(codec.parameters).length) {\n      const params = [];\n      Object.keys(codec.parameters).forEach((param) => {\n        if (codec.parameters[param] !== void 0) {\n          params.push(param + \"=\" + codec.parameters[param]);\n        } else {\n          params.push(param);\n        }\n      });\n      line += \"a=fmtp:\" + pt + \" \" + params.join(\";\") + \"\\r\\n\";\n    }\n    return line;\n  };\n  SDPUtils2.parseRtcpFb = function(line) {\n    const parts = line.substring(line.indexOf(\" \") + 1).split(\" \");\n    return {\n      type: parts.shift(),\n      parameter: parts.join(\" \")\n    };\n  };\n  SDPUtils2.writeRtcpFb = function(codec) {\n    let lines = \"\";\n    let pt = codec.payloadType;\n    if (codec.preferredPayloadType !== void 0) {\n      pt = codec.preferredPayloadType;\n    }\n    if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n      codec.rtcpFeedback.forEach((fb) => {\n        lines += \"a=rtcp-fb:\" + pt + \" \" + fb.type + (fb.parameter && fb.parameter.length ? \" \" + fb.parameter : \"\") + \"\\r\\n\";\n      });\n    }\n    return lines;\n  };\n  SDPUtils2.parseSsrcMedia = function(line) {\n    const sp = line.indexOf(\" \");\n    const parts = {\n      ssrc: parseInt(line.substring(7, sp), 10)\n    };\n    const colon = line.indexOf(\":\", sp);\n    if (colon > -1) {\n      parts.attribute = line.substring(sp + 1, colon);\n      parts.value = line.substring(colon + 1);\n    } else {\n      parts.attribute = line.substring(sp + 1);\n    }\n    return parts;\n  };\n  SDPUtils2.parseSsrcGroup = function(line) {\n    const parts = line.substring(13).split(\" \");\n    return {\n      semantics: parts.shift(),\n      ssrcs: parts.map((ssrc) => parseInt(ssrc, 10))\n    };\n  };\n  SDPUtils2.getMid = function(mediaSection) {\n    const mid = SDPUtils2.matchPrefix(mediaSection, \"a=mid:\")[0];\n    if (mid) {\n      return mid.substring(6);\n    }\n  };\n  SDPUtils2.parseFingerprint = function(line) {\n    const parts = line.substring(14).split(\" \");\n    return {\n      algorithm: parts[0].toLowerCase(),\n      // algorithm is case-sensitive in Edge.\n      value: parts[1].toUpperCase()\n      // the definition is upper-case in RFC 4572.\n    };\n  };\n  SDPUtils2.getDtlsParameters = function(mediaSection, sessionpart) {\n    const lines = SDPUtils2.matchPrefix(mediaSection + sessionpart, \"a=fingerprint:\");\n    return {\n      role: \"auto\",\n      fingerprints: lines.map(SDPUtils2.parseFingerprint)\n    };\n  };\n  SDPUtils2.writeDtlsParameters = function(params, setupType) {\n    let sdp2 = \"a=setup:\" + setupType + \"\\r\\n\";\n    params.fingerprints.forEach((fp) => {\n      sdp2 += \"a=fingerprint:\" + fp.algorithm + \" \" + fp.value + \"\\r\\n\";\n    });\n    return sdp2;\n  };\n  SDPUtils2.parseCryptoLine = function(line) {\n    const parts = line.substring(9).split(\" \");\n    return {\n      tag: parseInt(parts[0], 10),\n      cryptoSuite: parts[1],\n      keyParams: parts[2],\n      sessionParams: parts.slice(3)\n    };\n  };\n  SDPUtils2.writeCryptoLine = function(parameters) {\n    return \"a=crypto:\" + parameters.tag + \" \" + parameters.cryptoSuite + \" \" + (typeof parameters.keyParams === \"object\" ? SDPUtils2.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? \" \" + parameters.sessionParams.join(\" \") : \"\") + \"\\r\\n\";\n  };\n  SDPUtils2.parseCryptoKeyParams = function(keyParams) {\n    if (keyParams.indexOf(\"inline:\") !== 0) {\n      return null;\n    }\n    const parts = keyParams.substring(7).split(\"|\");\n    return {\n      keyMethod: \"inline\",\n      keySalt: parts[0],\n      lifeTime: parts[1],\n      mkiValue: parts[2] ? parts[2].split(\":\")[0] : void 0,\n      mkiLength: parts[2] ? parts[2].split(\":\")[1] : void 0\n    };\n  };\n  SDPUtils2.writeCryptoKeyParams = function(keyParams) {\n    return keyParams.keyMethod + \":\" + keyParams.keySalt + (keyParams.lifeTime ? \"|\" + keyParams.lifeTime : \"\") + (keyParams.mkiValue && keyParams.mkiLength ? \"|\" + keyParams.mkiValue + \":\" + keyParams.mkiLength : \"\");\n  };\n  SDPUtils2.getCryptoParameters = function(mediaSection, sessionpart) {\n    const lines = SDPUtils2.matchPrefix(mediaSection + sessionpart, \"a=crypto:\");\n    return lines.map(SDPUtils2.parseCryptoLine);\n  };\n  SDPUtils2.getIceParameters = function(mediaSection, sessionpart) {\n    const ufrag = SDPUtils2.matchPrefix(mediaSection + sessionpart, \"a=ice-ufrag:\")[0];\n    const pwd = SDPUtils2.matchPrefix(mediaSection + sessionpart, \"a=ice-pwd:\")[0];\n    if (!(ufrag && pwd)) {\n      return null;\n    }\n    return {\n      usernameFragment: ufrag.substring(12),\n      password: pwd.substring(10)\n    };\n  };\n  SDPUtils2.writeIceParameters = function(params) {\n    let sdp2 = \"a=ice-ufrag:\" + params.usernameFragment + \"\\r\\na=ice-pwd:\" + params.password + \"\\r\\n\";\n    if (params.iceLite) {\n      sdp2 += \"a=ice-lite\\r\\n\";\n    }\n    return sdp2;\n  };\n  SDPUtils2.parseRtpParameters = function(mediaSection) {\n    const description = {\n      codecs: [],\n      headerExtensions: [],\n      fecMechanisms: [],\n      rtcp: []\n    };\n    const lines = SDPUtils2.splitLines(mediaSection);\n    const mline = lines[0].split(\" \");\n    description.profile = mline[2];\n    for (let i = 3; i < mline.length; i++) {\n      const pt = mline[i];\n      const rtpmapline = SDPUtils2.matchPrefix(mediaSection, \"a=rtpmap:\" + pt + \" \")[0];\n      if (rtpmapline) {\n        const codec = SDPUtils2.parseRtpMap(rtpmapline);\n        const fmtps = SDPUtils2.matchPrefix(mediaSection, \"a=fmtp:\" + pt + \" \");\n        codec.parameters = fmtps.length ? SDPUtils2.parseFmtp(fmtps[0]) : {};\n        codec.rtcpFeedback = SDPUtils2.matchPrefix(mediaSection, \"a=rtcp-fb:\" + pt + \" \").map(SDPUtils2.parseRtcpFb);\n        description.codecs.push(codec);\n        switch (codec.name.toUpperCase()) {\n          case \"RED\":\n          case \"ULPFEC\":\n            description.fecMechanisms.push(codec.name.toUpperCase());\n            break;\n        }\n      }\n    }\n    SDPUtils2.matchPrefix(mediaSection, \"a=extmap:\").forEach((line) => {\n      description.headerExtensions.push(SDPUtils2.parseExtmap(line));\n    });\n    const wildcardRtcpFb = SDPUtils2.matchPrefix(mediaSection, \"a=rtcp-fb:* \").map(SDPUtils2.parseRtcpFb);\n    description.codecs.forEach((codec) => {\n      wildcardRtcpFb.forEach((fb) => {\n        const duplicate = codec.rtcpFeedback.find((existingFeedback) => {\n          return existingFeedback.type === fb.type && existingFeedback.parameter === fb.parameter;\n        });\n        if (!duplicate) {\n          codec.rtcpFeedback.push(fb);\n        }\n      });\n    });\n    return description;\n  };\n  SDPUtils2.writeRtpDescription = function(kind, caps) {\n    let sdp2 = \"\";\n    sdp2 += \"m=\" + kind + \" \";\n    sdp2 += caps.codecs.length > 0 ? \"9\" : \"0\";\n    sdp2 += \" \" + (caps.profile || \"UDP/TLS/RTP/SAVPF\") + \" \";\n    sdp2 += caps.codecs.map((codec) => {\n      if (codec.preferredPayloadType !== void 0) {\n        return codec.preferredPayloadType;\n      }\n      return codec.payloadType;\n    }).join(\" \") + \"\\r\\n\";\n    sdp2 += \"c=IN IP4 0.0.0.0\\r\\n\";\n    sdp2 += \"a=rtcp:9 IN IP4 0.0.0.0\\r\\n\";\n    caps.codecs.forEach((codec) => {\n      sdp2 += SDPUtils2.writeRtpMap(codec);\n      sdp2 += SDPUtils2.writeFmtp(codec);\n      sdp2 += SDPUtils2.writeRtcpFb(codec);\n    });\n    let maxptime = 0;\n    caps.codecs.forEach((codec) => {\n      if (codec.maxptime > maxptime) {\n        maxptime = codec.maxptime;\n      }\n    });\n    if (maxptime > 0) {\n      sdp2 += \"a=maxptime:\" + maxptime + \"\\r\\n\";\n    }\n    if (caps.headerExtensions) {\n      caps.headerExtensions.forEach((extension) => {\n        sdp2 += SDPUtils2.writeExtmap(extension);\n      });\n    }\n    return sdp2;\n  };\n  SDPUtils2.parseRtpEncodingParameters = function(mediaSection) {\n    const encodingParameters = [];\n    const description = SDPUtils2.parseRtpParameters(mediaSection);\n    const hasRed = description.fecMechanisms.indexOf(\"RED\") !== -1;\n    const hasUlpfec = description.fecMechanisms.indexOf(\"ULPFEC\") !== -1;\n    const ssrcs = SDPUtils2.matchPrefix(mediaSection, \"a=ssrc:\").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((parts) => parts.attribute === \"cname\");\n    const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n    let secondarySsrc;\n    const flows = SDPUtils2.matchPrefix(mediaSection, \"a=ssrc-group:FID\").map((line) => {\n      const parts = line.substring(17).split(\" \");\n      return parts.map((part) => parseInt(part, 10));\n    });\n    if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n      secondarySsrc = flows[0][1];\n    }\n    description.codecs.forEach((codec) => {\n      if (codec.name.toUpperCase() === \"RTX\" && codec.parameters.apt) {\n        let encParam = {\n          ssrc: primarySsrc,\n          codecPayloadType: parseInt(codec.parameters.apt, 10)\n        };\n        if (primarySsrc && secondarySsrc) {\n          encParam.rtx = {\n            ssrc: secondarySsrc\n          };\n        }\n        encodingParameters.push(encParam);\n        if (hasRed) {\n          encParam = JSON.parse(JSON.stringify(encParam));\n          encParam.fec = {\n            ssrc: primarySsrc,\n            mechanism: hasUlpfec ? \"red+ulpfec\" : \"red\"\n          };\n          encodingParameters.push(encParam);\n        }\n      }\n    });\n    if (encodingParameters.length === 0 && primarySsrc) {\n      encodingParameters.push({\n        ssrc: primarySsrc\n      });\n    }\n    let bandwidth = SDPUtils2.matchPrefix(mediaSection, \"b=\");\n    if (bandwidth.length) {\n      if (bandwidth[0].indexOf(\"b=TIAS:\") === 0) {\n        bandwidth = parseInt(bandwidth[0].substring(7), 10);\n      } else if (bandwidth[0].indexOf(\"b=AS:\") === 0) {\n        bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1e3 * 0.95 - 50 * 40 * 8;\n      } else {\n        bandwidth = void 0;\n      }\n      encodingParameters.forEach((params) => {\n        params.maxBitrate = bandwidth;\n      });\n    }\n    return encodingParameters;\n  };\n  SDPUtils2.parseRtcpParameters = function(mediaSection) {\n    const rtcpParameters = {};\n    const remoteSsrc = SDPUtils2.matchPrefix(mediaSection, \"a=ssrc:\").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((obj) => obj.attribute === \"cname\")[0];\n    if (remoteSsrc) {\n      rtcpParameters.cname = remoteSsrc.value;\n      rtcpParameters.ssrc = remoteSsrc.ssrc;\n    }\n    const rsize = SDPUtils2.matchPrefix(mediaSection, \"a=rtcp-rsize\");\n    rtcpParameters.reducedSize = rsize.length > 0;\n    rtcpParameters.compound = rsize.length === 0;\n    const mux = SDPUtils2.matchPrefix(mediaSection, \"a=rtcp-mux\");\n    rtcpParameters.mux = mux.length > 0;\n    return rtcpParameters;\n  };\n  SDPUtils2.writeRtcpParameters = function(rtcpParameters) {\n    let sdp2 = \"\";\n    if (rtcpParameters.reducedSize) {\n      sdp2 += \"a=rtcp-rsize\\r\\n\";\n    }\n    if (rtcpParameters.mux) {\n      sdp2 += \"a=rtcp-mux\\r\\n\";\n    }\n    if (rtcpParameters.ssrc !== void 0 && rtcpParameters.cname) {\n      sdp2 += \"a=ssrc:\" + rtcpParameters.ssrc + \" cname:\" + rtcpParameters.cname + \"\\r\\n\";\n    }\n    return sdp2;\n  };\n  SDPUtils2.parseMsid = function(mediaSection) {\n    let parts;\n    const spec = SDPUtils2.matchPrefix(mediaSection, \"a=msid:\");\n    if (spec.length === 1) {\n      parts = spec[0].substring(7).split(\" \");\n      return {\n        stream: parts[0],\n        track: parts[1]\n      };\n    }\n    const planB = SDPUtils2.matchPrefix(mediaSection, \"a=ssrc:\").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((msidParts) => msidParts.attribute === \"msid\");\n    if (planB.length > 0) {\n      parts = planB[0].value.split(\" \");\n      return {\n        stream: parts[0],\n        track: parts[1]\n      };\n    }\n  };\n  SDPUtils2.parseSctpDescription = function(mediaSection) {\n    const mline = SDPUtils2.parseMLine(mediaSection);\n    const maxSizeLine = SDPUtils2.matchPrefix(mediaSection, \"a=max-message-size:\");\n    let maxMessageSize;\n    if (maxSizeLine.length > 0) {\n      maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);\n    }\n    if (isNaN(maxMessageSize)) {\n      maxMessageSize = 65536;\n    }\n    const sctpPort = SDPUtils2.matchPrefix(mediaSection, \"a=sctp-port:\");\n    if (sctpPort.length > 0) {\n      return {\n        port: parseInt(sctpPort[0].substring(12), 10),\n        protocol: mline.fmt,\n        maxMessageSize\n      };\n    }\n    const sctpMapLines = SDPUtils2.matchPrefix(mediaSection, \"a=sctpmap:\");\n    if (sctpMapLines.length > 0) {\n      const parts = sctpMapLines[0].substring(10).split(\" \");\n      return {\n        port: parseInt(parts[0], 10),\n        protocol: parts[1],\n        maxMessageSize\n      };\n    }\n  };\n  SDPUtils2.writeSctpDescription = function(media, sctp) {\n    let output = [];\n    if (media.protocol !== \"DTLS/SCTP\") {\n      output = [\"m=\" + media.kind + \" 9 \" + media.protocol + \" \" + sctp.protocol + \"\\r\\n\", \"c=IN IP4 0.0.0.0\\r\\n\", \"a=sctp-port:\" + sctp.port + \"\\r\\n\"];\n    } else {\n      output = [\"m=\" + media.kind + \" 9 \" + media.protocol + \" \" + sctp.port + \"\\r\\n\", \"c=IN IP4 0.0.0.0\\r\\n\", \"a=sctpmap:\" + sctp.port + \" \" + sctp.protocol + \" 65535\\r\\n\"];\n    }\n    if (sctp.maxMessageSize !== void 0) {\n      output.push(\"a=max-message-size:\" + sctp.maxMessageSize + \"\\r\\n\");\n    }\n    return output.join(\"\");\n  };\n  SDPUtils2.generateSessionId = function() {\n    return Math.random().toString().substr(2, 22);\n  };\n  SDPUtils2.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {\n    let sessionId;\n    const version2 = sessVer !== void 0 ? sessVer : 2;\n    if (sessId) {\n      sessionId = sessId;\n    } else {\n      sessionId = SDPUtils2.generateSessionId();\n    }\n    const user = sessUser || \"thisisadapterortc\";\n    return \"v=0\\r\\no=\" + user + \" \" + sessionId + \" \" + version2 + \" IN IP4 127.0.0.1\\r\\ns=-\\r\\nt=0 0\\r\\n\";\n  };\n  SDPUtils2.getDirection = function(mediaSection, sessionpart) {\n    const lines = SDPUtils2.splitLines(mediaSection);\n    for (let i = 0; i < lines.length; i++) {\n      switch (lines[i]) {\n        case \"a=sendrecv\":\n        case \"a=sendonly\":\n        case \"a=recvonly\":\n        case \"a=inactive\":\n          return lines[i].substring(2);\n      }\n    }\n    if (sessionpart) {\n      return SDPUtils2.getDirection(sessionpart);\n    }\n    return \"sendrecv\";\n  };\n  SDPUtils2.getKind = function(mediaSection) {\n    const lines = SDPUtils2.splitLines(mediaSection);\n    const mline = lines[0].split(\" \");\n    return mline[0].substring(2);\n  };\n  SDPUtils2.isRejected = function(mediaSection) {\n    return mediaSection.split(\" \", 2)[1] === \"0\";\n  };\n  SDPUtils2.parseMLine = function(mediaSection) {\n    const lines = SDPUtils2.splitLines(mediaSection);\n    const parts = lines[0].substring(2).split(\" \");\n    return {\n      kind: parts[0],\n      port: parseInt(parts[1], 10),\n      protocol: parts[2],\n      fmt: parts.slice(3).join(\" \")\n    };\n  };\n  SDPUtils2.parseOLine = function(mediaSection) {\n    const line = SDPUtils2.matchPrefix(mediaSection, \"o=\")[0];\n    const parts = line.substring(2).split(\" \");\n    return {\n      username: parts[0],\n      sessionId: parts[1],\n      sessionVersion: parseInt(parts[2], 10),\n      netType: parts[3],\n      addressType: parts[4],\n      address: parts[5]\n    };\n  };\n  SDPUtils2.isValidSDP = function(blob) {\n    if (typeof blob !== \"string\" || blob.length === 0) {\n      return false;\n    }\n    const lines = SDPUtils2.splitLines(blob);\n    for (let i = 0; i < lines.length; i++) {\n      if (lines[i].length < 2 || lines[i].charAt(1) !== \"=\") {\n        return false;\n      }\n    }\n    return true;\n  };\n  {\n    module.exports = SDPUtils2;\n  }\n})(sdp$1);\nvar sdpExports = sdp$1.exports;\nvar SDPUtils = getDefaultExportFromCjs(sdpExports);\nvar sdp = _mergeNamespaces({\n  __proto__: null,\n  default: SDPUtils\n}, [sdpExports]);\nfunction shimRTCIceCandidate(window2) {\n  if (!window2.RTCIceCandidate || window2.RTCIceCandidate && \"foundation\" in window2.RTCIceCandidate.prototype) {\n    return;\n  }\n  const NativeRTCIceCandidate = window2.RTCIceCandidate;\n  window2.RTCIceCandidate = function RTCIceCandidate(args) {\n    if (typeof args === \"object\" && args.candidate && args.candidate.indexOf(\"a=\") === 0) {\n      args = JSON.parse(JSON.stringify(args));\n      args.candidate = args.candidate.substring(2);\n    }\n    if (args.candidate && args.candidate.length) {\n      const nativeCandidate = new NativeRTCIceCandidate(args);\n      const parsedCandidate = SDPUtils.parseCandidate(args.candidate);\n      for (const key in parsedCandidate) {\n        if (!(key in nativeCandidate)) {\n          Object.defineProperty(nativeCandidate, key, {\n            value: parsedCandidate[key]\n          });\n        }\n      }\n      nativeCandidate.toJSON = function toJSON() {\n        return {\n          candidate: nativeCandidate.candidate,\n          sdpMid: nativeCandidate.sdpMid,\n          sdpMLineIndex: nativeCandidate.sdpMLineIndex,\n          usernameFragment: nativeCandidate.usernameFragment\n        };\n      };\n      return nativeCandidate;\n    }\n    return new NativeRTCIceCandidate(args);\n  };\n  window2.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;\n  wrapPeerConnectionEvent(window2, \"icecandidate\", (e) => {\n    if (e.candidate) {\n      Object.defineProperty(e, \"candidate\", {\n        value: new window2.RTCIceCandidate(e.candidate),\n        writable: \"false\"\n      });\n    }\n    return e;\n  });\n}\nfunction shimRTCIceCandidateRelayProtocol(window2) {\n  if (!window2.RTCIceCandidate || window2.RTCIceCandidate && \"relayProtocol\" in window2.RTCIceCandidate.prototype) {\n    return;\n  }\n  wrapPeerConnectionEvent(window2, \"icecandidate\", (e) => {\n    if (e.candidate) {\n      const parsedCandidate = SDPUtils.parseCandidate(e.candidate.candidate);\n      if (parsedCandidate.type === \"relay\") {\n        e.candidate.relayProtocol = {\n          0: \"tls\",\n          1: \"tcp\",\n          2: \"udp\"\n        }[parsedCandidate.priority >> 24];\n      }\n    }\n    return e;\n  });\n}\nfunction shimMaxMessageSize(window2, browserDetails) {\n  if (!window2.RTCPeerConnection) {\n    return;\n  }\n  if (!(\"sctp\" in window2.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window2.RTCPeerConnection.prototype, \"sctp\", {\n      get() {\n        return typeof this._sctp === \"undefined\" ? null : this._sctp;\n      }\n    });\n  }\n  const sctpInDescription = function(description) {\n    if (!description || !description.sdp) {\n      return false;\n    }\n    const sections = SDPUtils.splitSections(description.sdp);\n    sections.shift();\n    return sections.some((mediaSection) => {\n      const mLine = SDPUtils.parseMLine(mediaSection);\n      return mLine && mLine.kind === \"application\" && mLine.protocol.indexOf(\"SCTP\") !== -1;\n    });\n  };\n  const getRemoteFirefoxVersion = function(description) {\n    const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n    if (match === null || match.length < 2) {\n      return -1;\n    }\n    const version2 = parseInt(match[1], 10);\n    return version2 !== version2 ? -1 : version2;\n  };\n  const getCanSendMaxMessageSize = function(remoteIsFirefox) {\n    let canSendMaxMessageSize = 65536;\n    if (browserDetails.browser === \"firefox\") {\n      if (browserDetails.version < 57) {\n        if (remoteIsFirefox === -1) {\n          canSendMaxMessageSize = 16384;\n        } else {\n          canSendMaxMessageSize = 2147483637;\n        }\n      } else if (browserDetails.version < 60) {\n        canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;\n      } else {\n        canSendMaxMessageSize = 2147483637;\n      }\n    }\n    return canSendMaxMessageSize;\n  };\n  const getMaxMessageSize = function(description, remoteIsFirefox) {\n    let maxMessageSize = 65536;\n    if (browserDetails.browser === \"firefox\" && browserDetails.version === 57) {\n      maxMessageSize = 65535;\n    }\n    const match = SDPUtils.matchPrefix(description.sdp, \"a=max-message-size:\");\n    if (match.length > 0) {\n      maxMessageSize = parseInt(match[0].substring(19), 10);\n    } else if (browserDetails.browser === \"firefox\" && remoteIsFirefox !== -1) {\n      maxMessageSize = 2147483637;\n    }\n    return maxMessageSize;\n  };\n  const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;\n  window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n    this._sctp = null;\n    if (browserDetails.browser === \"chrome\" && browserDetails.version >= 76) {\n      const {\n        sdpSemantics\n      } = this.getConfiguration();\n      if (sdpSemantics === \"plan-b\") {\n        Object.defineProperty(this, \"sctp\", {\n          get() {\n            return typeof this._sctp === \"undefined\" ? null : this._sctp;\n          },\n          enumerable: true,\n          configurable: true\n        });\n      }\n    }\n    if (sctpInDescription(arguments[0])) {\n      const isFirefox = getRemoteFirefoxVersion(arguments[0]);\n      const canSendMMS = getCanSendMaxMessageSize(isFirefox);\n      const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);\n      let maxMessageSize;\n      if (canSendMMS === 0 && remoteMMS === 0) {\n        maxMessageSize = Number.POSITIVE_INFINITY;\n      } else if (canSendMMS === 0 || remoteMMS === 0) {\n        maxMessageSize = Math.max(canSendMMS, remoteMMS);\n      } else {\n        maxMessageSize = Math.min(canSendMMS, remoteMMS);\n      }\n      const sctp = {};\n      Object.defineProperty(sctp, \"maxMessageSize\", {\n        get() {\n          return maxMessageSize;\n        }\n      });\n      this._sctp = sctp;\n    }\n    return origSetRemoteDescription.apply(this, arguments);\n  };\n}\nfunction shimSendThrowTypeError(window2) {\n  if (!(window2.RTCPeerConnection && \"createDataChannel\" in window2.RTCPeerConnection.prototype)) {\n    return;\n  }\n  function wrapDcSend(dc, pc) {\n    const origDataChannelSend = dc.send;\n    dc.send = function send() {\n      const data = arguments[0];\n      const length = data.length || data.size || data.byteLength;\n      if (dc.readyState === \"open\" && pc.sctp && length > pc.sctp.maxMessageSize) {\n        throw new TypeError(\"Message too large (can send a maximum of \" + pc.sctp.maxMessageSize + \" bytes)\");\n      }\n      return origDataChannelSend.apply(dc, arguments);\n    };\n  }\n  const origCreateDataChannel = window2.RTCPeerConnection.prototype.createDataChannel;\n  window2.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {\n    const dataChannel = origCreateDataChannel.apply(this, arguments);\n    wrapDcSend(dataChannel, this);\n    return dataChannel;\n  };\n  wrapPeerConnectionEvent(window2, \"datachannel\", (e) => {\n    wrapDcSend(e.channel, e.target);\n    return e;\n  });\n}\nfunction shimConnectionState(window2) {\n  if (!window2.RTCPeerConnection || \"connectionState\" in window2.RTCPeerConnection.prototype) {\n    return;\n  }\n  const proto = window2.RTCPeerConnection.prototype;\n  Object.defineProperty(proto, \"connectionState\", {\n    get() {\n      return {\n        completed: \"connected\",\n        checking: \"connecting\"\n      }[this.iceConnectionState] || this.iceConnectionState;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(proto, \"onconnectionstatechange\", {\n    get() {\n      return this._onconnectionstatechange || null;\n    },\n    set(cb) {\n      if (this._onconnectionstatechange) {\n        this.removeEventListener(\"connectionstatechange\", this._onconnectionstatechange);\n        delete this._onconnectionstatechange;\n      }\n      if (cb) {\n        this.addEventListener(\"connectionstatechange\", this._onconnectionstatechange = cb);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  [\"setLocalDescription\", \"setRemoteDescription\"].forEach((method) => {\n    const origMethod = proto[method];\n    proto[method] = function() {\n      if (!this._connectionstatechangepoly) {\n        this._connectionstatechangepoly = (e) => {\n          const pc = e.target;\n          if (pc._lastConnectionState !== pc.connectionState) {\n            pc._lastConnectionState = pc.connectionState;\n            const newEvent = new Event(\"connectionstatechange\", e);\n            pc.dispatchEvent(newEvent);\n          }\n          return e;\n        };\n        this.addEventListener(\"iceconnectionstatechange\", this._connectionstatechangepoly);\n      }\n      return origMethod.apply(this, arguments);\n    };\n  });\n}\nfunction removeExtmapAllowMixed(window2, browserDetails) {\n  if (!window2.RTCPeerConnection) {\n    return;\n  }\n  if (browserDetails.browser === \"chrome\" && browserDetails.version >= 71) {\n    return;\n  }\n  if (browserDetails.browser === \"safari\" && browserDetails.version >= 605) {\n    return;\n  }\n  const nativeSRD = window2.RTCPeerConnection.prototype.setRemoteDescription;\n  window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {\n    if (desc && desc.sdp && desc.sdp.indexOf(\"\\na=extmap-allow-mixed\") !== -1) {\n      const sdp2 = desc.sdp.split(\"\\n\").filter((line) => {\n        return line.trim() !== \"a=extmap-allow-mixed\";\n      }).join(\"\\n\");\n      if (window2.RTCSessionDescription && desc instanceof window2.RTCSessionDescription) {\n        arguments[0] = new window2.RTCSessionDescription({\n          type: desc.type,\n          sdp: sdp2\n        });\n      } else {\n        desc.sdp = sdp2;\n      }\n    }\n    return nativeSRD.apply(this, arguments);\n  };\n}\nfunction shimAddIceCandidateNullOrEmpty(window2, browserDetails) {\n  if (!(window2.RTCPeerConnection && window2.RTCPeerConnection.prototype)) {\n    return;\n  }\n  const nativeAddIceCandidate = window2.RTCPeerConnection.prototype.addIceCandidate;\n  if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {\n    return;\n  }\n  window2.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {\n    if (!arguments[0]) {\n      if (arguments[1]) {\n        arguments[1].apply(null);\n      }\n      return Promise.resolve();\n    }\n    if ((browserDetails.browser === \"chrome\" && browserDetails.version < 78 || browserDetails.browser === \"firefox\" && browserDetails.version < 68 || browserDetails.browser === \"safari\") && arguments[0] && arguments[0].candidate === \"\") {\n      return Promise.resolve();\n    }\n    return nativeAddIceCandidate.apply(this, arguments);\n  };\n}\nfunction shimParameterlessSetLocalDescription(window2, browserDetails) {\n  if (!(window2.RTCPeerConnection && window2.RTCPeerConnection.prototype)) {\n    return;\n  }\n  const nativeSetLocalDescription = window2.RTCPeerConnection.prototype.setLocalDescription;\n  if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {\n    return;\n  }\n  window2.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n    let desc = arguments[0] || {};\n    if (typeof desc !== \"object\" || desc.type && desc.sdp) {\n      return nativeSetLocalDescription.apply(this, arguments);\n    }\n    desc = {\n      type: desc.type,\n      sdp: desc.sdp\n    };\n    if (!desc.type) {\n      switch (this.signalingState) {\n        case \"stable\":\n        case \"have-local-offer\":\n        case \"have-remote-pranswer\":\n          desc.type = \"offer\";\n          break;\n        default:\n          desc.type = \"answer\";\n          break;\n      }\n    }\n    if (desc.sdp || desc.type !== \"offer\" && desc.type !== \"answer\") {\n      return nativeSetLocalDescription.apply(this, [desc]);\n    }\n    const func = desc.type === \"offer\" ? this.createOffer : this.createAnswer;\n    return func.apply(this).then((d) => nativeSetLocalDescription.apply(this, [d]));\n  };\n}\nvar commonShim = Object.freeze({\n  __proto__: null,\n  removeExtmapAllowMixed,\n  shimAddIceCandidateNullOrEmpty,\n  shimConnectionState,\n  shimMaxMessageSize,\n  shimParameterlessSetLocalDescription,\n  shimRTCIceCandidate,\n  shimRTCIceCandidateRelayProtocol,\n  shimSendThrowTypeError\n});\nfunction adapterFactory() {\n  let {\n    window: window2\n  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n    shimChrome: true,\n    shimFirefox: true,\n    shimSafari: true\n  };\n  const logging2 = log;\n  const browserDetails = detectBrowser(window2);\n  const adapter = {\n    browserDetails,\n    commonShim,\n    extractVersion,\n    disableLog,\n    disableWarnings,\n    // Expose sdp as a convenience. For production apps include directly.\n    sdp\n  };\n  switch (browserDetails.browser) {\n    case \"chrome\":\n      if (!chromeShim || !shimPeerConnection$1 || !options.shimChrome) {\n        logging2(\"Chrome shim is not included in this adapter release.\");\n        return adapter;\n      }\n      if (browserDetails.version === null) {\n        logging2(\"Chrome shim can not determine version, not shimming.\");\n        return adapter;\n      }\n      logging2(\"adapter.js shimming chrome.\");\n      adapter.browserShim = chromeShim;\n      shimAddIceCandidateNullOrEmpty(window2, browserDetails);\n      shimParameterlessSetLocalDescription(window2);\n      shimGetUserMedia$2(window2, browserDetails);\n      shimMediaStream(window2);\n      shimPeerConnection$1(window2, browserDetails);\n      shimOnTrack$1(window2);\n      shimAddTrackRemoveTrack(window2, browserDetails);\n      shimGetSendersWithDtmf(window2);\n      shimGetStats(window2);\n      shimSenderReceiverGetStats(window2);\n      fixNegotiationNeeded(window2, browserDetails);\n      shimRTCIceCandidate(window2);\n      shimRTCIceCandidateRelayProtocol(window2);\n      shimConnectionState(window2);\n      shimMaxMessageSize(window2, browserDetails);\n      shimSendThrowTypeError(window2);\n      removeExtmapAllowMixed(window2, browserDetails);\n      break;\n    case \"firefox\":\n      if (!firefoxShim || !shimPeerConnection || !options.shimFirefox) {\n        logging2(\"Firefox shim is not included in this adapter release.\");\n        return adapter;\n      }\n      logging2(\"adapter.js shimming firefox.\");\n      adapter.browserShim = firefoxShim;\n      shimAddIceCandidateNullOrEmpty(window2, browserDetails);\n      shimParameterlessSetLocalDescription(window2);\n      shimGetUserMedia$1(window2, browserDetails);\n      shimPeerConnection(window2, browserDetails);\n      shimOnTrack(window2);\n      shimRemoveStream(window2);\n      shimSenderGetStats(window2);\n      shimReceiverGetStats(window2);\n      shimRTCDataChannel(window2);\n      shimAddTransceiver(window2);\n      shimGetParameters(window2);\n      shimCreateOffer(window2);\n      shimCreateAnswer(window2);\n      shimRTCIceCandidate(window2);\n      shimConnectionState(window2);\n      shimMaxMessageSize(window2, browserDetails);\n      shimSendThrowTypeError(window2);\n      break;\n    case \"safari\":\n      if (!safariShim || !options.shimSafari) {\n        logging2(\"Safari shim is not included in this adapter release.\");\n        return adapter;\n      }\n      logging2(\"adapter.js shimming safari.\");\n      adapter.browserShim = safariShim;\n      shimAddIceCandidateNullOrEmpty(window2, browserDetails);\n      shimParameterlessSetLocalDescription(window2);\n      shimRTCIceServerUrls(window2);\n      shimCreateOfferLegacy(window2);\n      shimCallbacksAPI(window2);\n      shimLocalStreamsAPI(window2);\n      shimRemoteStreamsAPI(window2);\n      shimTrackEventTransceiver(window2);\n      shimGetUserMedia(window2);\n      shimAudioContext(window2);\n      shimRTCIceCandidate(window2);\n      shimRTCIceCandidateRelayProtocol(window2);\n      shimMaxMessageSize(window2, browserDetails);\n      shimSendThrowTypeError(window2);\n      removeExtmapAllowMixed(window2, browserDetails);\n      break;\n    default:\n      logging2(\"Unsupported browser!\");\n      break;\n  }\n  return adapter;\n}\nadapterFactory({\n  window: typeof window === \"undefined\" ? void 0 : window\n});\nvar uaParser = { exports: {} };\n(function(module, exports) {\n  (function(window2, undefined$1) {\n    var LIBVERSION = \"1.0.35\", EMPTY = \"\", UNKNOWN = \"?\", FUNC_TYPE = \"function\", UNDEF_TYPE = \"undefined\", OBJ_TYPE = \"object\", STR_TYPE = \"string\", MAJOR = \"major\", MODEL = \"model\", NAME = \"name\", TYPE = \"type\", VENDOR = \"vendor\", VERSION = \"version\", ARCHITECTURE = \"architecture\", CONSOLE = \"console\", MOBILE = \"mobile\", TABLET = \"tablet\", SMARTTV = \"smarttv\", WEARABLE = \"wearable\", EMBEDDED = \"embedded\", UA_MAX_LENGTH = 350;\n    var AMAZON = \"Amazon\", APPLE = \"Apple\", ASUS = \"ASUS\", BLACKBERRY = \"BlackBerry\", BROWSER = \"Browser\", CHROME = \"Chrome\", EDGE = \"Edge\", FIREFOX = \"Firefox\", GOOGLE = \"Google\", HUAWEI = \"Huawei\", LG = \"LG\", MICROSOFT = \"Microsoft\", MOTOROLA = \"Motorola\", OPERA = \"Opera\", SAMSUNG = \"Samsung\", SHARP = \"Sharp\", SONY = \"Sony\", XIAOMI = \"Xiaomi\", ZEBRA = \"Zebra\", FACEBOOK = \"Facebook\", CHROMIUM_OS = \"Chromium OS\", MAC_OS = \"Mac OS\";\n    var extend = function(regexes2, extensions) {\n      var mergedRegexes = {};\n      for (var i in regexes2) {\n        if (extensions[i] && extensions[i].length % 2 === 0) {\n          mergedRegexes[i] = extensions[i].concat(regexes2[i]);\n        } else {\n          mergedRegexes[i] = regexes2[i];\n        }\n      }\n      return mergedRegexes;\n    }, enumerize = function(arr) {\n      var enums = {};\n      for (var i = 0; i < arr.length; i++) {\n        enums[arr[i].toUpperCase()] = arr[i];\n      }\n      return enums;\n    }, has = function(str1, str2) {\n      return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;\n    }, lowerize = function(str) {\n      return str.toLowerCase();\n    }, majorize = function(version2) {\n      return typeof version2 === STR_TYPE ? version2.replace(/[^\\d\\.]/g, EMPTY).split(\".\")[0] : undefined$1;\n    }, trim = function(str, len) {\n      if (typeof str === STR_TYPE) {\n        str = str.replace(/^\\s\\s*/, EMPTY);\n        return typeof len === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);\n      }\n    };\n    var rgxMapper = function(ua, arrays) {\n      var i = 0, j, k, p, q, matches, match;\n      while (i < arrays.length && !matches) {\n        var regex = arrays[i], props = arrays[i + 1];\n        j = k = 0;\n        while (j < regex.length && !matches) {\n          if (!regex[j]) {\n            break;\n          }\n          matches = regex[j++].exec(ua);\n          if (!!matches) {\n            for (p = 0; p < props.length; p++) {\n              match = matches[++k];\n              q = props[p];\n              if (typeof q === OBJ_TYPE && q.length > 0) {\n                if (q.length === 2) {\n                  if (typeof q[1] == FUNC_TYPE) {\n                    this[q[0]] = q[1].call(this, match);\n                  } else {\n                    this[q[0]] = q[1];\n                  }\n                } else if (q.length === 3) {\n                  if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {\n                    this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined$1;\n                  } else {\n                    this[q[0]] = match ? match.replace(q[1], q[2]) : undefined$1;\n                  }\n                } else if (q.length === 4) {\n                  this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined$1;\n                }\n              } else {\n                this[q] = match ? match : undefined$1;\n              }\n            }\n          }\n        }\n        i += 2;\n      }\n    }, strMapper = function(str, map) {\n      for (var i in map) {\n        if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {\n          for (var j = 0; j < map[i].length; j++) {\n            if (has(map[i][j], str)) {\n              return i === UNKNOWN ? undefined$1 : i;\n            }\n          }\n        } else if (has(map[i], str)) {\n          return i === UNKNOWN ? undefined$1 : i;\n        }\n      }\n      return str;\n    };\n    var oldSafariMap = {\n      \"1.0\": \"/8\",\n      \"1.2\": \"/1\",\n      \"1.3\": \"/3\",\n      \"2.0\": \"/412\",\n      \"2.0.2\": \"/416\",\n      \"2.0.3\": \"/417\",\n      \"2.0.4\": \"/419\",\n      \"?\": \"/\"\n    }, windowsVersionMap = {\n      \"ME\": \"4.90\",\n      \"NT 3.11\": \"NT3.51\",\n      \"NT 4.0\": \"NT4.0\",\n      \"2000\": \"NT 5.0\",\n      \"XP\": [\"NT 5.1\", \"NT 5.2\"],\n      \"Vista\": \"NT 6.0\",\n      \"7\": \"NT 6.1\",\n      \"8\": \"NT 6.2\",\n      \"8.1\": \"NT 6.3\",\n      \"10\": [\"NT 6.4\", \"NT 10.0\"],\n      \"RT\": \"ARM\"\n    };\n    var regexes = {\n      browser: [[\n        /\\b(?:crmo|crios)\\/([\\w\\.]+)/i\n        // Chrome for Android/iOS\n      ], [VERSION, [NAME, \"Chrome\"]], [\n        /edg(?:e|ios|a)?\\/([\\w\\.]+)/i\n        // Microsoft Edge\n      ], [VERSION, [NAME, \"Edge\"]], [\n        // Presto based\n        /(opera mini)\\/([-\\w\\.]+)/i,\n        // Opera Mini\n        /(opera [mobiletab]{3,6})\\b.+version\\/([-\\w\\.]+)/i,\n        // Opera Mobi/Tablet\n        /(opera)(?:.+version\\/|[\\/ ]+)([\\w\\.]+)/i\n        // Opera\n      ], [NAME, VERSION], [\n        /opios[\\/ ]+([\\w\\.]+)/i\n        // Opera mini on iphone >= 8.0\n      ], [VERSION, [NAME, OPERA + \" Mini\"]], [\n        /\\bopr\\/([\\w\\.]+)/i\n        // Opera Webkit\n      ], [VERSION, [NAME, OPERA]], [\n        // Mixed\n        /(kindle)\\/([\\w\\.]+)/i,\n        // Kindle\n        /(lunascape|maxthon|netfront|jasmine|blazer)[\\/ ]?([\\w\\.]*)/i,\n        // Lunascape/Maxthon/Netfront/Jasmine/Blazer\n        // Trident based\n        /(avant |iemobile|slim)(?:browser)?[\\/ ]?([\\w\\.]*)/i,\n        // Avant/IEMobile/SlimBrowser\n        /(ba?idubrowser)[\\/ ]?([\\w\\.]+)/i,\n        // Baidu Browser\n        /(?:ms|\\()(ie) ([\\w\\.]+)/i,\n        // Internet Explorer\n        // Webkit/KHTML based                                               // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon\n        /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\\/([-\\w\\.]+)/i,\n        // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ, aka ShouQ\n        /(heytap|ovi)browser\\/([\\d\\.]+)/i,\n        // Heytap/Ovi\n        /(weibo)__([\\d\\.]+)/i\n        // Weibo\n      ], [NAME, VERSION], [\n        /(?:\\buc? ?browser|(?:juc.+)ucweb)[\\/ ]?([\\w\\.]+)/i\n        // UCBrowser\n      ], [VERSION, [NAME, \"UC\" + BROWSER]], [\n        /microm.+\\bqbcore\\/([\\w\\.]+)/i,\n        // WeChat Desktop for Windows Built-in Browser\n        /\\bqbcore\\/([\\w\\.]+).+microm/i\n      ], [VERSION, [NAME, \"WeChat(Win) Desktop\"]], [\n        /micromessenger\\/([\\w\\.]+)/i\n        // WeChat\n      ], [VERSION, [NAME, \"WeChat\"]], [\n        /konqueror\\/([\\w\\.]+)/i\n        // Konqueror\n      ], [VERSION, [NAME, \"Konqueror\"]], [\n        /trident.+rv[: ]([\\w\\.]{1,9})\\b.+like gecko/i\n        // IE11\n      ], [VERSION, [NAME, \"IE\"]], [\n        /ya(?:search)?browser\\/([\\w\\.]+)/i\n        // Yandex\n      ], [VERSION, [NAME, \"Yandex\"]], [\n        /(avast|avg)\\/([\\w\\.]+)/i\n        // Avast/AVG Secure Browser\n      ], [[NAME, /(.+)/, \"$1 Secure \" + BROWSER], VERSION], [\n        /\\bfocus\\/([\\w\\.]+)/i\n        // Firefox Focus\n      ], [VERSION, [NAME, FIREFOX + \" Focus\"]], [\n        /\\bopt\\/([\\w\\.]+)/i\n        // Opera Touch\n      ], [VERSION, [NAME, OPERA + \" Touch\"]], [\n        /coc_coc\\w+\\/([\\w\\.]+)/i\n        // Coc Coc Browser\n      ], [VERSION, [NAME, \"Coc Coc\"]], [\n        /dolfin\\/([\\w\\.]+)/i\n        // Dolphin\n      ], [VERSION, [NAME, \"Dolphin\"]], [\n        /coast\\/([\\w\\.]+)/i\n        // Opera Coast\n      ], [VERSION, [NAME, OPERA + \" Coast\"]], [\n        /miuibrowser\\/([\\w\\.]+)/i\n        // MIUI Browser\n      ], [VERSION, [NAME, \"MIUI \" + BROWSER]], [\n        /fxios\\/([-\\w\\.]+)/i\n        // Firefox for iOS\n      ], [VERSION, [NAME, FIREFOX]], [\n        /\\bqihu|(qi?ho?o?|360)browser/i\n        // 360\n      ], [[NAME, \"360 \" + BROWSER]], [/(oculus|samsung|sailfish|huawei)browser\\/([\\w\\.]+)/i], [[NAME, /(.+)/, \"$1 \" + BROWSER], VERSION], [\n        // Oculus/Samsung/Sailfish/Huawei Browser\n        /(comodo_dragon)\\/([\\w\\.]+)/i\n        // Comodo Dragon\n      ], [[NAME, /_/g, \" \"], VERSION], [\n        /(electron)\\/([\\w\\.]+) safari/i,\n        // Electron-based App\n        /(tesla)(?: qtcarbrowser|\\/(20\\d\\d\\.[-\\w\\.]+))/i,\n        // Tesla\n        /m?(qqbrowser|baiduboxapp|2345Explorer)[\\/ ]?([\\w\\.]+)/i\n        // QQBrowser/Baidu App/2345 Browser\n      ], [NAME, VERSION], [\n        /(metasr)[\\/ ]?([\\w\\.]+)/i,\n        // SouGouBrowser\n        /(lbbrowser)/i,\n        // LieBao Browser\n        /\\[(linkedin)app\\]/i\n        // LinkedIn App for iOS & Android\n      ], [NAME], [\n        // WebView\n        /((?:fban\\/fbios|fb_iab\\/fb4a)(?!.+fbav)|;fbav\\/([\\w\\.]+);)/i\n        // Facebook App for iOS & Android\n      ], [[NAME, FACEBOOK], VERSION], [\n        /(kakao(?:talk|story))[\\/ ]([\\w\\.]+)/i,\n        // Kakao App\n        /(naver)\\(.*?(\\d+\\.[\\w\\.]+).*\\)/i,\n        // Naver InApp\n        /safari (line)\\/([\\w\\.]+)/i,\n        // Line App for iOS\n        /\\b(line)\\/([\\w\\.]+)\\/iab/i,\n        // Line App for Android\n        /(chromium|instagram)[\\/ ]([-\\w\\.]+)/i\n        // Chromium/Instagram\n      ], [NAME, VERSION], [\n        /\\bgsa\\/([\\w\\.]+) .*safari\\//i\n        // Google Search Appliance on iOS\n      ], [VERSION, [NAME, \"GSA\"]], [\n        /musical_ly(?:.+app_?version\\/|_)([\\w\\.]+)/i\n        // TikTok\n      ], [VERSION, [NAME, \"TikTok\"]], [\n        /headlesschrome(?:\\/([\\w\\.]+)| )/i\n        // Chrome Headless\n      ], [VERSION, [NAME, CHROME + \" Headless\"]], [\n        / wv\\).+(chrome)\\/([\\w\\.]+)/i\n        // Chrome WebView\n      ], [[NAME, CHROME + \" WebView\"], VERSION], [\n        /droid.+ version\\/([\\w\\.]+)\\b.+(?:mobile safari|safari)/i\n        // Android Browser\n      ], [VERSION, [NAME, \"Android \" + BROWSER]], [\n        /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\\/v?([\\w\\.]+)/i\n        // Chrome/OmniWeb/Arora/Tizen/Nokia\n      ], [NAME, VERSION], [\n        /version\\/([\\w\\.\\,]+) .*mobile\\/\\w+ (safari)/i\n        // Mobile Safari\n      ], [VERSION, [NAME, \"Mobile Safari\"]], [\n        /version\\/([\\w(\\.|\\,)]+) .*(mobile ?safari|safari)/i\n        // Safari & Safari Mobile\n      ], [VERSION, NAME], [\n        /webkit.+?(mobile ?safari|safari)(\\/[\\w\\.]+)/i\n        // Safari < 3.0\n      ], [NAME, [VERSION, strMapper, oldSafariMap]], [/(webkit|khtml)\\/([\\w\\.]+)/i], [NAME, VERSION], [\n        // Gecko based\n        /(navigator|netscape\\d?)\\/([-\\w\\.]+)/i\n        // Netscape\n      ], [[NAME, \"Netscape\"], VERSION], [\n        /mobile vr; rv:([\\w\\.]+)\\).+firefox/i\n        // Firefox Reality\n      ], [VERSION, [NAME, FIREFOX + \" Reality\"]], [\n        /ekiohf.+(flow)\\/([\\w\\.]+)/i,\n        // Flow\n        /(swiftfox)/i,\n        // Swiftfox\n        /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\\/ ]?([\\w\\.\\+]+)/i,\n        // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror/Klar\n        /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\\/([-\\w\\.]+)$/i,\n        // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix\n        /(firefox)\\/([\\w\\.]+)/i,\n        // Other Firefox-based\n        /(mozilla)\\/([\\w\\.]+) .+rv\\:.+gecko\\/\\d+/i,\n        // Mozilla\n        // Other\n        /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\\. ]?browser)[-\\/ ]?v?([\\w\\.]+)/i,\n        // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir/Obigo/Mosaic/Go/ICE/UP.Browser\n        /(links) \\(([\\w\\.]+)/i,\n        // Links\n        /panasonic;(viera)/i\n        // Panasonic Viera\n      ], [NAME, VERSION], [\n        /(cobalt)\\/([\\w\\.]+)/i\n        // Cobalt\n      ], [NAME, [VERSION, /master.|lts./, \"\"]]],\n      cpu: [[\n        /(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\\)]/i\n        // AMD64 (x64)\n      ], [[ARCHITECTURE, \"amd64\"]], [\n        /(ia32(?=;))/i\n        // IA32 (quicktime)\n      ], [[ARCHITECTURE, lowerize]], [\n        /((?:i[346]|x)86)[;\\)]/i\n        // IA32 (x86)\n      ], [[ARCHITECTURE, \"ia32\"]], [\n        /\\b(aarch64|arm(v?8e?l?|_?64))\\b/i\n        // ARM64\n      ], [[ARCHITECTURE, \"arm64\"]], [\n        /\\b(arm(?:v[67])?ht?n?[fl]p?)\\b/i\n        // ARMHF\n      ], [[ARCHITECTURE, \"armhf\"]], [\n        // PocketPC mistakenly identified as PowerPC\n        /windows (ce|mobile); ppc;/i\n      ], [[ARCHITECTURE, \"arm\"]], [\n        /((?:ppc|powerpc)(?:64)?)(?: mac|;|\\))/i\n        // PowerPC\n      ], [[ARCHITECTURE, /ower/, EMPTY, lowerize]], [\n        /(sun4\\w)[;\\)]/i\n        // SPARC\n      ], [[ARCHITECTURE, \"sparc\"]], [\n        /((?:avr32|ia64(?=;))|68k(?=\\))|\\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\\b|pa-risc)/i\n        // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC\n      ], [[ARCHITECTURE, lowerize]]],\n      device: [[\n        //////////////////////////\n        // MOBILES & TABLETS\n        /////////////////////////\n        // Samsung\n        /\\b(sch-i[89]0\\d|shw-m380s|sm-[ptx]\\w{2,4}|gt-[pn]\\d{2,4}|sgh-t8[56]9|nexus 10)/i\n      ], [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]], [/\\b((?:s[cgp]h|gt|sm)-\\w+|sc[g-]?[\\d]+a?|galaxy nexus)/i, /samsung[- ]([-\\w]+)/i, /sec-(sgh\\w+)/i], [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]], [\n        // Apple\n        /(?:\\/|\\()(ip(?:hone|od)[\\w, ]*)(?:\\/|;)/i\n        // iPod/iPhone\n      ], [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]], [\n        /\\((ipad);[-\\w\\),; ]+apple/i,\n        // iPad\n        /applecoremedia\\/[\\w\\.]+ \\((ipad)/i,\n        /\\b(ipad)\\d\\d?,\\d\\d?[;\\]].+ios/i\n      ], [MODEL, [VENDOR, APPLE], [TYPE, TABLET]], [/(macintosh);/i], [MODEL, [VENDOR, APPLE]], [\n        // Sharp\n        /\\b(sh-?[altvz]?\\d\\d[a-ekm]?)/i\n      ], [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]], [\n        // Huawei\n        /\\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\\d{2})\\b(?!.+d\\/s)/i\n      ], [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]], [/(?:huawei|honor)([-\\w ]+)[;\\)]/i, /\\b(nexus 6p|\\w{2,4}e?-[atu]?[ln][\\dx][012359c][adn]?)\\b(?!.+d\\/s)/i], [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]], [\n        // Xiaomi\n        /\\b(poco[\\w ]+)(?: bui|\\))/i,\n        // Xiaomi POCO\n        /\\b; (\\w+) build\\/hm\\1/i,\n        // Xiaomi Hongmi 'numeric' models\n        /\\b(hm[-_ ]?note?[_ ]?(?:\\d\\w)?) bui/i,\n        // Xiaomi Hongmi\n        /\\b(redmi[\\-_ ]?(?:note|k)?[\\w_ ]+)(?: bui|\\))/i,\n        // Xiaomi Redmi\n        /\\b(mi[-_ ]?(?:a\\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\\d?\\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\\))/i\n        // Xiaomi Mi\n      ], [[MODEL, /_/g, \" \"], [VENDOR, XIAOMI], [TYPE, MOBILE]], [\n        /\\b(mi[-_ ]?(?:pad)(?:[\\w_ ]+))(?: bui|\\))/i\n        // Mi Pad tablets\n      ], [[MODEL, /_/g, \" \"], [VENDOR, XIAOMI], [TYPE, TABLET]], [\n        // OPPO\n        /; (\\w+) bui.+ oppo/i,\n        /\\b(cph[12]\\d{3}|p(?:af|c[al]|d\\w|e[ar])[mt]\\d0|x9007|a101op)\\b/i\n      ], [MODEL, [VENDOR, \"OPPO\"], [TYPE, MOBILE]], [\n        // Vivo\n        /vivo (\\w+)(?: bui|\\))/i,\n        /\\b(v[12]\\d{3}\\w?[at])(?: bui|;)/i\n      ], [MODEL, [VENDOR, \"Vivo\"], [TYPE, MOBILE]], [\n        // Realme\n        /\\b(rmx[12]\\d{3})(?: bui|;|\\))/i\n      ], [MODEL, [VENDOR, \"Realme\"], [TYPE, MOBILE]], [\n        // Motorola\n        /\\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\\b[\\w ]+build\\//i,\n        /\\bmot(?:orola)?[- ](\\w*)/i,\n        /((?:moto[\\w\\(\\) ]+|xt\\d{3,4}|nexus 6)(?= bui|\\)))/i\n      ], [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]], [/\\b(mz60\\d|xoom[2 ]{0,2}) build\\//i], [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]], [\n        // LG\n        /((?=lg)?[vl]k\\-?\\d{3}) bui| 3\\.[-\\w; ]{10}lg?-([06cv9]{3,4})/i\n      ], [MODEL, [VENDOR, LG], [TYPE, TABLET]], [/(lm(?:-?f100[nv]?|-[\\w\\.]+)(?= bui|\\))|nexus [45])/i, /\\blg[-e;\\/ ]+((?!browser|netcast|android tv)\\w+)/i, /\\blg-?([\\d\\w]+) bui/i], [MODEL, [VENDOR, LG], [TYPE, MOBILE]], [\n        // Lenovo\n        /(ideatab[-\\w ]+)/i,\n        /lenovo ?(s[56]000[-\\w]+|tab(?:[\\w ]+)|yt[-\\d\\w]{6}|tb[-\\d\\w]{6})/i\n      ], [MODEL, [VENDOR, \"Lenovo\"], [TYPE, TABLET]], [\n        // Nokia\n        /(?:maemo|nokia).*(n900|lumia \\d+)/i,\n        /nokia[-_ ]?([-\\w\\.]*)/i\n      ], [[MODEL, /_/g, \" \"], [VENDOR, \"Nokia\"], [TYPE, MOBILE]], [\n        // Google\n        /(pixel c)\\b/i\n        // Google Pixel C\n      ], [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]], [\n        /droid.+; (pixel[\\daxl ]{0,6})(?: bui|\\))/i\n        // Google Pixel\n      ], [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]], [\n        // Sony\n        /droid.+ (a?\\d[0-2]{2}so|[c-g]\\d{4}|so[-gl]\\w+|xq-a\\w[4-7][12])(?= bui|\\).+chrome\\/(?![1-6]{0,1}\\d\\.))/i\n      ], [MODEL, [VENDOR, SONY], [TYPE, MOBILE]], [/sony tablet [ps]/i, /\\b(?:sony)?sgp\\w+(?: bui|\\))/i], [[MODEL, \"Xperia Tablet\"], [VENDOR, SONY], [TYPE, TABLET]], [\n        // OnePlus\n        / (kb2005|in20[12]5|be20[12][59])\\b/i,\n        /(?:one)?(?:plus)? (a\\d0\\d\\d)(?: b|\\))/i\n      ], [MODEL, [VENDOR, \"OnePlus\"], [TYPE, MOBILE]], [\n        // Amazon\n        /(alexa)webm/i,\n        /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\\))/i,\n        // Kindle Fire without Silk / Echo Show\n        /(kf[a-z]+)( bui|\\)).+silk\\//i\n        // Kindle Fire HD\n      ], [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]], [\n        /((?:sd|kf)[0349hijorstuw]+)( bui|\\)).+silk\\//i\n        // Fire Phone\n      ], [[MODEL, /(.+)/g, \"Fire Phone $1\"], [VENDOR, AMAZON], [TYPE, MOBILE]], [\n        // BlackBerry\n        /(playbook);[-\\w\\),; ]+(rim)/i\n        // BlackBerry PlayBook\n      ], [MODEL, VENDOR, [TYPE, TABLET]], [\n        /\\b((?:bb[a-f]|st[hv])100-\\d)/i,\n        /\\(bb10; (\\w+)/i\n        // BlackBerry 10\n      ], [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]], [\n        // Asus\n        /(?:\\b|asus_)(transfo[prime ]{4,10} \\w+|eeepc|slider \\w+|nexus 7|padfone|p00[cj])/i\n      ], [MODEL, [VENDOR, ASUS], [TYPE, TABLET]], [/ (z[bes]6[027][012][km][ls]|zenfone \\d\\w?)\\b/i], [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]], [\n        // HTC\n        /(nexus 9)/i\n        // HTC Nexus 9\n      ], [MODEL, [VENDOR, \"HTC\"], [TYPE, TABLET]], [\n        /(htc)[-;_ ]{1,2}([\\w ]+(?=\\)| bui)|\\w+)/i,\n        // HTC\n        // ZTE\n        /(zte)[- ]([\\w ]+?)(?: bui|\\/|\\))/i,\n        /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\\.))|sony(?!-bra))[-_ ]?([-\\w]*)/i\n        // Alcatel/GeeksPhone/Nexian/Panasonic/Sony\n      ], [VENDOR, [MODEL, /_/g, \" \"], [TYPE, MOBILE]], [\n        // Acer\n        /droid.+; ([ab][1-7]-?[0178a]\\d\\d?)/i\n      ], [MODEL, [VENDOR, \"Acer\"], [TYPE, TABLET]], [\n        // Meizu\n        /droid.+; (m[1-5] note) bui/i,\n        /\\bmz-([-\\w]{2,})/i\n      ], [MODEL, [VENDOR, \"Meizu\"], [TYPE, MOBILE]], [\n        // MIXED\n        /(blackberry|benq|palm(?=\\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\\w]*)/i,\n        // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron\n        /(hp) ([\\w ]+\\w)/i,\n        // HP iPAQ\n        /(asus)-?(\\w+)/i,\n        // Asus\n        /(microsoft); (lumia[\\w ]+)/i,\n        // Microsoft Lumia\n        /(lenovo)[-_ ]?([-\\w]+)/i,\n        // Lenovo\n        /(jolla)/i,\n        // Jolla\n        /(oppo) ?([\\w ]+) bui/i\n        // OPPO\n      ], [VENDOR, MODEL, [TYPE, MOBILE]], [\n        /(kobo)\\s(ereader|touch)/i,\n        // Kobo\n        /(archos) (gamepad2?)/i,\n        // Archos\n        /(hp).+(touchpad(?!.+tablet)|tablet)/i,\n        // HP TouchPad\n        /(kindle)\\/([\\w\\.]+)/i,\n        // Kindle\n        /(nook)[\\w ]+build\\/(\\w+)/i,\n        // Nook\n        /(dell) (strea[kpr\\d ]*[\\dko])/i,\n        // Dell Streak\n        /(le[- ]+pan)[- ]+(\\w{1,9}) bui/i,\n        // Le Pan Tablets\n        /(trinity)[- ]*(t\\d{3}) bui/i,\n        // Trinity Tablets\n        /(gigaset)[- ]+(q\\w{1,9}) bui/i,\n        // Gigaset Tablets\n        /(vodafone) ([\\w ]+)(?:\\)| bui)/i\n        // Vodafone\n      ], [VENDOR, MODEL, [TYPE, TABLET]], [\n        /(surface duo)/i\n        // Surface Duo\n      ], [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]], [\n        /droid [\\d\\.]+; (fp\\du?)(?: b|\\))/i\n        // Fairphone\n      ], [MODEL, [VENDOR, \"Fairphone\"], [TYPE, MOBILE]], [\n        /(u304aa)/i\n        // AT&T\n      ], [MODEL, [VENDOR, \"AT&T\"], [TYPE, MOBILE]], [\n        /\\bsie-(\\w*)/i\n        // Siemens\n      ], [MODEL, [VENDOR, \"Siemens\"], [TYPE, MOBILE]], [\n        /\\b(rct\\w+) b/i\n        // RCA Tablets\n      ], [MODEL, [VENDOR, \"RCA\"], [TYPE, TABLET]], [\n        /\\b(venue[\\d ]{2,7}) b/i\n        // Dell Venue Tablets\n      ], [MODEL, [VENDOR, \"Dell\"], [TYPE, TABLET]], [\n        /\\b(q(?:mv|ta)\\w+) b/i\n        // Verizon Tablet\n      ], [MODEL, [VENDOR, \"Verizon\"], [TYPE, TABLET]], [\n        /\\b(?:barnes[& ]+noble |bn[rt])([\\w\\+ ]*) b/i\n        // Barnes & Noble Tablet\n      ], [MODEL, [VENDOR, \"Barnes & Noble\"], [TYPE, TABLET]], [/\\b(tm\\d{3}\\w+) b/i], [MODEL, [VENDOR, \"NuVision\"], [TYPE, TABLET]], [\n        /\\b(k88) b/i\n        // ZTE K Series Tablet\n      ], [MODEL, [VENDOR, \"ZTE\"], [TYPE, TABLET]], [\n        /\\b(nx\\d{3}j) b/i\n        // ZTE Nubia\n      ], [MODEL, [VENDOR, \"ZTE\"], [TYPE, MOBILE]], [\n        /\\b(gen\\d{3}) b.+49h/i\n        // Swiss GEN Mobile\n      ], [MODEL, [VENDOR, \"Swiss\"], [TYPE, MOBILE]], [\n        /\\b(zur\\d{3}) b/i\n        // Swiss ZUR Tablet\n      ], [MODEL, [VENDOR, \"Swiss\"], [TYPE, TABLET]], [\n        /\\b((zeki)?tb.*\\b) b/i\n        // Zeki Tablets\n      ], [MODEL, [VENDOR, \"Zeki\"], [TYPE, TABLET]], [\n        /\\b([yr]\\d{2}) b/i,\n        /\\b(dragon[- ]+touch |dt)(\\w{5}) b/i\n        // Dragon Touch Tablet\n      ], [[VENDOR, \"Dragon Touch\"], MODEL, [TYPE, TABLET]], [\n        /\\b(ns-?\\w{0,9}) b/i\n        // Insignia Tablets\n      ], [MODEL, [VENDOR, \"Insignia\"], [TYPE, TABLET]], [\n        /\\b((nxa|next)-?\\w{0,9}) b/i\n        // NextBook Tablets\n      ], [MODEL, [VENDOR, \"NextBook\"], [TYPE, TABLET]], [\n        /\\b(xtreme\\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i\n        // Voice Xtreme Phones\n      ], [[VENDOR, \"Voice\"], MODEL, [TYPE, MOBILE]], [\n        /\\b(lvtel\\-)?(v1[12]) b/i\n        // LvTel Phones\n      ], [[VENDOR, \"LvTel\"], MODEL, [TYPE, MOBILE]], [\n        /\\b(ph-1) /i\n        // Essential PH-1\n      ], [MODEL, [VENDOR, \"Essential\"], [TYPE, MOBILE]], [\n        /\\b(v(100md|700na|7011|917g).*\\b) b/i\n        // Envizen Tablets\n      ], [MODEL, [VENDOR, \"Envizen\"], [TYPE, TABLET]], [\n        /\\b(trio[-\\w\\. ]+) b/i\n        // MachSpeed Tablets\n      ], [MODEL, [VENDOR, \"MachSpeed\"], [TYPE, TABLET]], [\n        /\\btu_(1491) b/i\n        // Rotor Tablets\n      ], [MODEL, [VENDOR, \"Rotor\"], [TYPE, TABLET]], [\n        /(shield[\\w ]+) b/i\n        // Nvidia Shield Tablets\n      ], [MODEL, [VENDOR, \"Nvidia\"], [TYPE, TABLET]], [\n        /(sprint) (\\w+)/i\n        // Sprint Phones\n      ], [VENDOR, MODEL, [TYPE, MOBILE]], [\n        /(kin\\.[onetw]{3})/i\n        // Microsoft Kin\n      ], [[MODEL, /\\./g, \" \"], [VENDOR, MICROSOFT], [TYPE, MOBILE]], [\n        /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\\)/i\n        // Zebra\n      ], [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]], [/droid.+; (ec30|ps20|tc[2-8]\\d[kx])\\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]], [\n        ///////////////////\n        // SMARTTVS\n        ///////////////////\n        /smart-tv.+(samsung)/i\n        // Samsung\n      ], [VENDOR, [TYPE, SMARTTV]], [/hbbtv.+maple;(\\d+)/i], [[MODEL, /^/, \"SmartTV\"], [VENDOR, SAMSUNG], [TYPE, SMARTTV]], [\n        /(nux; netcast.+smarttv|lg (netcast\\.tv-201\\d|android tv))/i\n        // LG SmartTV\n      ], [[VENDOR, LG], [TYPE, SMARTTV]], [\n        /(apple) ?tv/i\n        // Apple TV\n      ], [VENDOR, [MODEL, APPLE + \" TV\"], [TYPE, SMARTTV]], [\n        /crkey/i\n        // Google Chromecast\n      ], [[MODEL, CHROME + \"cast\"], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [\n        /droid.+aft(\\w)( bui|\\))/i\n        // Fire TV\n      ], [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]], [\n        /\\(dtv[\\);].+(aquos)/i,\n        /(aquos-tv[\\w ]+)\\)/i\n        // Sharp\n      ], [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]], [\n        /(bravia[\\w ]+)( bui|\\))/i\n        // Sony\n      ], [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]], [\n        /(mitv-\\w{5}) bui/i\n        // Xiaomi\n      ], [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]], [\n        /Hbbtv.*(technisat) (.*);/i\n        // TechniSAT\n      ], [VENDOR, MODEL, [TYPE, SMARTTV]], [\n        /\\b(roku)[\\dx]*[\\)\\/]((?:dvp-)?[\\d\\.]*)/i,\n        // Roku\n        /hbbtv\\/\\d+\\.\\d+\\.\\d+ +\\([\\w\\+ ]*; *([\\w\\d][^;]*);([^;]*)/i\n        // HbbTV devices\n      ], [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]], [\n        /\\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\\b/i\n        // SmartTV from Unidentified Vendors\n      ], [[TYPE, SMARTTV]], [\n        ///////////////////\n        // CONSOLES\n        ///////////////////\n        /(ouya)/i,\n        // Ouya\n        /(nintendo) ([wids3utch]+)/i\n        // Nintendo\n      ], [VENDOR, MODEL, [TYPE, CONSOLE]], [\n        /droid.+; (shield) bui/i\n        // Nvidia\n      ], [MODEL, [VENDOR, \"Nvidia\"], [TYPE, CONSOLE]], [\n        /(playstation [345portablevi]+)/i\n        // Playstation\n      ], [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]], [\n        /\\b(xbox(?: one)?(?!; xbox))[\\); ]/i\n        // Microsoft Xbox\n      ], [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]], [\n        ///////////////////\n        // WEARABLES\n        ///////////////////\n        /((pebble))app/i\n        // Pebble\n      ], [VENDOR, MODEL, [TYPE, WEARABLE]], [\n        /(watch)(?: ?os[,\\/]|\\d,\\d\\/)[\\d\\.]+/i\n        // Apple Watch\n      ], [MODEL, [VENDOR, APPLE], [TYPE, WEARABLE]], [\n        /droid.+; (glass) \\d/i\n        // Google Glass\n      ], [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]], [/droid.+; (wt63?0{2,3})\\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]], [\n        /(quest( 2| pro)?)/i\n        // Oculus Quest\n      ], [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]], [\n        ///////////////////\n        // EMBEDDED\n        ///////////////////\n        /(tesla)(?: qtcarbrowser|\\/[-\\w\\.]+)/i\n        // Tesla\n      ], [VENDOR, [TYPE, EMBEDDED]], [\n        /(aeobc)\\b/i\n        // Echo Dot\n      ], [MODEL, [VENDOR, AMAZON], [TYPE, EMBEDDED]], [\n        ////////////////////\n        // MIXED (GENERIC)\n        ///////////////////\n        /droid .+?; ([^;]+?)(?: bui|\\) applew).+? mobile safari/i\n        // Android Phones from Unidentified Vendors\n      ], [MODEL, [TYPE, MOBILE]], [\n        /droid .+?; ([^;]+?)(?: bui|\\) applew).+?(?! mobile) safari/i\n        // Android Tablets from Unidentified Vendors\n      ], [MODEL, [TYPE, TABLET]], [\n        /\\b((tablet|tab)[;\\/]|focus\\/\\d(?!.+mobile))/i\n        // Unidentifiable Tablet\n      ], [[TYPE, TABLET]], [\n        /(phone|mobile(?:[;\\/]| [ \\w\\/\\.]*safari)|pda(?=.+windows ce))/i\n        // Unidentifiable Mobile\n      ], [[TYPE, MOBILE]], [\n        /(android[-\\w\\. ]{0,9});.+buil/i\n        // Generic Android Device\n      ], [MODEL, [VENDOR, \"Generic\"]]],\n      engine: [[\n        /windows.+ edge\\/([\\w\\.]+)/i\n        // EdgeHTML\n      ], [VERSION, [NAME, EDGE + \"HTML\"]], [\n        /webkit\\/537\\.36.+chrome\\/(?!27)([\\w\\.]+)/i\n        // Blink\n      ], [VERSION, [NAME, \"Blink\"]], [\n        /(presto)\\/([\\w\\.]+)/i,\n        // Presto\n        /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\\/([\\w\\.]+)/i,\n        // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna\n        /ekioh(flow)\\/([\\w\\.]+)/i,\n        // Flow\n        /(khtml|tasman|links)[\\/ ]\\(?([\\w\\.]+)/i,\n        // KHTML/Tasman/Links\n        /(icab)[\\/ ]([23]\\.[\\d\\.]+)/i,\n        // iCab\n        /\\b(libweb)/i\n      ], [NAME, VERSION], [\n        /rv\\:([\\w\\.]{1,9})\\b.+(gecko)/i\n        // Gecko\n      ], [VERSION, NAME]],\n      os: [[\n        // Windows\n        /microsoft (windows) (vista|xp)/i\n        // Windows (iTunes)\n      ], [NAME, VERSION], [\n        /(windows) nt 6\\.2; (arm)/i,\n        // Windows RT\n        /(windows (?:phone(?: os)?|mobile))[\\/ ]?([\\d\\.\\w ]*)/i,\n        // Windows Phone\n        /(windows)[\\/ ]?([ntce\\d\\. ]+\\w)(?!.+xbox)/i\n      ], [NAME, [VERSION, strMapper, windowsVersionMap]], [/(win(?=3|9|n)|win 9x )([nt\\d\\.]+)/i], [[NAME, \"Windows\"], [VERSION, strMapper, windowsVersionMap]], [\n        // iOS/macOS\n        /ip[honead]{2,4}\\b(?:.*os ([\\w]+) like mac|; opera)/i,\n        // iOS\n        /ios;fbsv\\/([\\d\\.]+)/i,\n        /cfnetwork\\/.+darwin/i\n      ], [[VERSION, /_/g, \".\"], [NAME, \"iOS\"]], [\n        /(mac os x) ?([\\w\\. ]*)/i,\n        /(macintosh|mac_powerpc\\b)(?!.+haiku)/i\n        // Mac OS\n      ], [[NAME, MAC_OS], [VERSION, /_/g, \".\"]], [\n        // Mobile OSes\n        /droid ([\\w\\.]+)\\b.+(android[- ]x86|harmonyos)/i\n        // Android-x86/HarmonyOS\n      ], [VERSION, NAME], [\n        // Android/WebOS/QNX/Bada/RIM/Maemo/MeeGo/Sailfish OS\n        /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\\/ ]?([\\w\\.]*)/i,\n        /(blackberry)\\w*\\/([\\w\\.]*)/i,\n        // Blackberry\n        /(tizen|kaios)[\\/ ]([\\w\\.]+)/i,\n        // Tizen/KaiOS\n        /\\((series40);/i\n        // Series 40\n      ], [NAME, VERSION], [\n        /\\(bb(10);/i\n        // BlackBerry 10\n      ], [VERSION, [NAME, BLACKBERRY]], [\n        /(?:symbian ?os|symbos|s60(?=;)|series60)[-\\/ ]?([\\w\\.]*)/i\n        // Symbian\n      ], [VERSION, [NAME, \"Symbian\"]], [\n        /mozilla\\/[\\d\\.]+ \\((?:mobile|tablet|tv|mobile; [\\w ]+); rv:.+ gecko\\/([\\w\\.]+)/i\n        // Firefox OS\n      ], [VERSION, [NAME, FIREFOX + \" OS\"]], [\n        /web0s;.+rt(tv)/i,\n        /\\b(?:hp)?wos(?:browser)?\\/([\\w\\.]+)/i\n        // WebOS\n      ], [VERSION, [NAME, \"webOS\"]], [\n        /watch(?: ?os[,\\/]|\\d,\\d\\/)([\\d\\.]+)/i\n        // watchOS\n      ], [VERSION, [NAME, \"watchOS\"]], [\n        // Google Chromecast\n        /crkey\\/([\\d\\.]+)/i\n        // Google Chromecast\n      ], [VERSION, [NAME, CHROME + \"cast\"]], [\n        /(cros) [\\w]+(?:\\)| ([\\w\\.]+)\\b)/i\n        // Chromium OS\n      ], [[NAME, CHROMIUM_OS], VERSION], [\n        // Smart TVs\n        /panasonic;(viera)/i,\n        // Panasonic Viera\n        /(netrange)mmh/i,\n        // Netrange\n        /(nettv)\\/(\\d+\\.[\\w\\.]+)/i,\n        // NetTV\n        // Console\n        /(nintendo|playstation) ([wids345portablevuch]+)/i,\n        // Nintendo/Playstation\n        /(xbox); +xbox ([^\\);]+)/i,\n        // Microsoft Xbox (360, One, X, S, Series X, Series S)\n        // Other\n        /\\b(joli|palm)\\b ?(?:os)?\\/?([\\w\\.]*)/i,\n        // Joli/Palm\n        /(mint)[\\/\\(\\) ]?(\\w*)/i,\n        // Mint\n        /(mageia|vectorlinux)[; ]/i,\n        // Mageia/VectorLinux\n        /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\\/ ]?(?!chrom|package)([-\\w\\.]*)/i,\n        // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire\n        /(hurd|linux) ?([\\w\\.]*)/i,\n        // Hurd/Linux\n        /(gnu) ?([\\w\\.]*)/i,\n        // GNU\n        /\\b([-frentopcghs]{0,5}bsd|dragonfly)[\\/ ]?(?!amd|[ix346]{1,2}86)([\\w\\.]*)/i,\n        // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly\n        /(haiku) (\\w+)/i\n        // Haiku\n      ], [NAME, VERSION], [\n        /(sunos) ?([\\w\\.\\d]*)/i\n        // Solaris\n      ], [[NAME, \"Solaris\"], VERSION], [\n        /((?:open)?solaris)[-\\/ ]?([\\w\\.]*)/i,\n        // Solaris\n        /(aix) ((\\d)(?=\\.|\\)| )[\\w\\.])*/i,\n        // AIX\n        /\\b(beos|os\\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i,\n        // BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX/SerenityOS\n        /(unix) ?([\\w\\.]*)/i\n        // UNIX\n      ], [NAME, VERSION]]\n    };\n    var UAParser2 = function(ua, extensions) {\n      if (typeof ua === OBJ_TYPE) {\n        extensions = ua;\n        ua = undefined$1;\n      }\n      if (!(this instanceof UAParser2)) {\n        return new UAParser2(ua, extensions).getResult();\n      }\n      var _navigator = typeof window2 !== UNDEF_TYPE && window2.navigator ? window2.navigator : undefined$1;\n      var _ua = ua || (_navigator && _navigator.userAgent ? _navigator.userAgent : EMPTY);\n      var _uach = _navigator && _navigator.userAgentData ? _navigator.userAgentData : undefined$1;\n      var _rgxmap = extensions ? extend(regexes, extensions) : regexes;\n      var _isSelfNav = _navigator && _navigator.userAgent == _ua;\n      this.getBrowser = function() {\n        var _browser = {};\n        _browser[NAME] = undefined$1;\n        _browser[VERSION] = undefined$1;\n        rgxMapper.call(_browser, _ua, _rgxmap.browser);\n        _browser[MAJOR] = majorize(_browser[VERSION]);\n        if (_isSelfNav && _navigator && _navigator.brave && typeof _navigator.brave.isBrave == FUNC_TYPE) {\n          _browser[NAME] = \"Brave\";\n        }\n        return _browser;\n      };\n      this.getCPU = function() {\n        var _cpu = {};\n        _cpu[ARCHITECTURE] = undefined$1;\n        rgxMapper.call(_cpu, _ua, _rgxmap.cpu);\n        return _cpu;\n      };\n      this.getDevice = function() {\n        var _device = {};\n        _device[VENDOR] = undefined$1;\n        _device[MODEL] = undefined$1;\n        _device[TYPE] = undefined$1;\n        rgxMapper.call(_device, _ua, _rgxmap.device);\n        if (_isSelfNav && !_device[TYPE] && _uach && _uach.mobile) {\n          _device[TYPE] = MOBILE;\n        }\n        if (_isSelfNav && _device[MODEL] == \"Macintosh\" && _navigator && typeof _navigator.standalone !== UNDEF_TYPE && _navigator.maxTouchPoints && _navigator.maxTouchPoints > 2) {\n          _device[MODEL] = \"iPad\";\n          _device[TYPE] = TABLET;\n        }\n        return _device;\n      };\n      this.getEngine = function() {\n        var _engine = {};\n        _engine[NAME] = undefined$1;\n        _engine[VERSION] = undefined$1;\n        rgxMapper.call(_engine, _ua, _rgxmap.engine);\n        return _engine;\n      };\n      this.getOS = function() {\n        var _os = {};\n        _os[NAME] = undefined$1;\n        _os[VERSION] = undefined$1;\n        rgxMapper.call(_os, _ua, _rgxmap.os);\n        if (_isSelfNav && !_os[NAME] && _uach && _uach.platform != \"Unknown\") {\n          _os[NAME] = _uach.platform.replace(/chrome os/i, CHROMIUM_OS).replace(/macos/i, MAC_OS);\n        }\n        return _os;\n      };\n      this.getResult = function() {\n        return {\n          ua: this.getUA(),\n          browser: this.getBrowser(),\n          engine: this.getEngine(),\n          os: this.getOS(),\n          device: this.getDevice(),\n          cpu: this.getCPU()\n        };\n      };\n      this.getUA = function() {\n        return _ua;\n      };\n      this.setUA = function(ua2) {\n        _ua = typeof ua2 === STR_TYPE && ua2.length > UA_MAX_LENGTH ? trim(ua2, UA_MAX_LENGTH) : ua2;\n        return this;\n      };\n      this.setUA(_ua);\n      return this;\n    };\n    UAParser2.VERSION = LIBVERSION;\n    UAParser2.BROWSER = enumerize([NAME, VERSION, MAJOR]);\n    UAParser2.CPU = enumerize([ARCHITECTURE]);\n    UAParser2.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);\n    UAParser2.ENGINE = UAParser2.OS = enumerize([NAME, VERSION]);\n    {\n      if (module.exports) {\n        exports = module.exports = UAParser2;\n      }\n      exports.UAParser = UAParser2;\n    }\n    var $ = typeof window2 !== UNDEF_TYPE && (window2.jQuery || window2.Zepto);\n    if ($ && !$.ua) {\n      var parser2 = new UAParser2();\n      $.ua = parser2.getResult();\n      $.ua.get = function() {\n        return parser2.getUA();\n      };\n      $.ua.set = function(ua) {\n        parser2.setUA(ua);\n        var result = parser2.getResult();\n        for (var prop in result) {\n          $.ua[prop] = result[prop];\n        }\n      };\n    }\n  })(typeof window === \"object\" ? window : commonjsGlobal);\n})(uaParser, uaParser.exports);\nvar uaParserExports = uaParser.exports;\nvar UAParser = getDefaultExportFromCjs(uaParserExports);\nvar version$1 = \"1.9.4\";\nvar version = version$1;\nvar protocolVersion = 9;\nfunction mergeDefaultOptions(options, audioDefaults2, videoDefaults2) {\n  const opts = Object.assign({}, options);\n  if (opts.audio === true)\n    opts.audio = {};\n  if (opts.video === true)\n    opts.video = {};\n  if (opts.audio) {\n    mergeObjectWithoutOverwriting(opts.audio, audioDefaults2);\n  }\n  if (opts.video) {\n    mergeObjectWithoutOverwriting(opts.video, videoDefaults2);\n  }\n  return opts;\n}\nfunction mergeObjectWithoutOverwriting(mainObject, objectToMerge) {\n  Object.keys(objectToMerge).forEach((key) => {\n    if (mainObject[key] === void 0)\n      mainObject[key] = objectToMerge[key];\n  });\n  return mainObject;\n}\nfunction constraintsForOptions(options) {\n  const constraints = {};\n  if (options.video) {\n    if (typeof options.video === \"object\") {\n      const videoOptions = {};\n      const target = videoOptions;\n      const source = options.video;\n      Object.keys(source).forEach((key) => {\n        switch (key) {\n          case \"resolution\":\n            mergeObjectWithoutOverwriting(target, source.resolution);\n            break;\n          default:\n            target[key] = source[key];\n        }\n      });\n      constraints.video = videoOptions;\n    } else {\n      constraints.video = options.video;\n    }\n  } else {\n    constraints.video = false;\n  }\n  if (options.audio) {\n    if (typeof options.audio === \"object\") {\n      constraints.audio = options.audio;\n    } else {\n      constraints.audio = true;\n    }\n  } else {\n    constraints.audio = false;\n  }\n  return constraints;\n}\nfunction detectSilence(track) {\n  let timeOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;\n  return __awaiter(this, void 0, void 0, function* () {\n    const ctx = getNewAudioContext();\n    if (ctx) {\n      const analyser = ctx.createAnalyser();\n      analyser.fftSize = 2048;\n      const bufferLength = analyser.frequencyBinCount;\n      const dataArray = new Uint8Array(bufferLength);\n      const source = ctx.createMediaStreamSource(new MediaStream([track.mediaStreamTrack]));\n      source.connect(analyser);\n      yield sleep(timeOffset);\n      analyser.getByteTimeDomainData(dataArray);\n      const someNoise = dataArray.some((sample) => sample !== 128 && sample !== 0);\n      ctx.close();\n      return !someNoise;\n    }\n    return false;\n  });\n}\nfunction getNewAudioContext() {\n  const AudioContext2 = (\n    // @ts-ignore\n    typeof window !== \"undefined\" && (window.AudioContext || window.webkitAudioContext)\n  );\n  if (AudioContext2) {\n    return new AudioContext2({\n      latencyHint: \"interactive\"\n    });\n  }\n}\nvar separator = \"|\";\nvar ddExtensionURI = \"https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension\";\nfunction unpackStreamId(packed) {\n  const parts = packed.split(separator);\n  if (parts.length > 1) {\n    return [parts[0], packed.substr(parts[0].length + 1)];\n  }\n  return [packed, \"\"];\n}\nfunction sleep(duration) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return new Promise((resolve) => setTimeout(resolve, duration));\n  });\n}\nfunction supportsTransceiver() {\n  return \"addTransceiver\" in RTCPeerConnection.prototype;\n}\nfunction supportsAddTrack() {\n  return \"addTrack\" in RTCPeerConnection.prototype;\n}\nfunction supportsAdaptiveStream() {\n  return typeof ResizeObserver !== void 0 && typeof IntersectionObserver !== void 0;\n}\nfunction supportsDynacast() {\n  return supportsTransceiver();\n}\nfunction supportsAV1() {\n  if (!(\"getCapabilities\" in RTCRtpSender)) {\n    return false;\n  }\n  const capabilities = RTCRtpSender.getCapabilities(\"video\");\n  let hasAV1 = false;\n  if (capabilities) {\n    for (const codec of capabilities.codecs) {\n      if (codec.mimeType === \"video/AV1\") {\n        hasAV1 = true;\n        break;\n      }\n    }\n  }\n  return hasAV1;\n}\nfunction supportsVP9() {\n  if (!(\"getCapabilities\" in RTCRtpSender)) {\n    return false;\n  }\n  const capabilities = RTCRtpSender.getCapabilities(\"video\");\n  let hasVP9 = false;\n  if (capabilities) {\n    for (const codec of capabilities.codecs) {\n      if (codec.mimeType === \"video/VP9\") {\n        hasVP9 = true;\n        break;\n      }\n    }\n  }\n  return hasVP9;\n}\nfunction isSVCCodec(codec) {\n  return codec === \"av1\" || codec === \"vp9\";\n}\nfunction supportsSetSinkId(elm) {\n  if (!document) {\n    return false;\n  }\n  if (!elm) {\n    elm = document.createElement(\"audio\");\n  }\n  return \"setSinkId\" in elm;\n}\nvar setCodecPreferencesVersions = {\n  Chrome: \"100\",\n  Chromium: \"100\",\n  Safari: \"15\",\n  Firefox: \"100\",\n  Edge: \"100\",\n  Brave: \"1.40\"\n};\nfunction supportsSetCodecPreferences(transceiver) {\n  if (!isWeb()) {\n    return false;\n  }\n  if (!(\"setCodecPreferences\" in transceiver)) {\n    return false;\n  }\n  const uap = UAParser();\n  if (!uap.browser.name || !uap.browser.version) {\n    return false;\n  }\n  const v = setCodecPreferencesVersions[uap.browser.name];\n  if (v) {\n    return compareVersions(uap.browser.version, v) >= 0;\n  }\n  return false;\n}\nfunction isBrowserSupported() {\n  return supportsTransceiver() || supportsAddTrack();\n}\nfunction isFireFox() {\n  if (!isWeb())\n    return false;\n  return navigator.userAgent.indexOf(\"Firefox\") !== -1;\n}\nfunction isChromiumBased() {\n  if (!isWeb())\n    return false;\n  return navigator.userAgent.indexOf(\"Chrom\") !== -1;\n}\nfunction isSafari() {\n  if (!isWeb())\n    return false;\n  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n}\nfunction isMobile() {\n  if (!isWeb())\n    return false;\n  return /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent);\n}\nfunction isWeb() {\n  return typeof document !== \"undefined\";\n}\nfunction isReactNative() {\n  return navigator.product == \"ReactNative\";\n}\nfunction isCloud(serverUrl) {\n  return serverUrl.hostname.endsWith(\".livekit.cloud\");\n}\nfunction getLKReactNativeInfo() {\n  if (global && global.LiveKitReactNativeGlobal) {\n    return global.LiveKitReactNativeGlobal;\n  }\n  return void 0;\n}\nfunction getReactNativeOs() {\n  if (!isReactNative()) {\n    return void 0;\n  }\n  let info = getLKReactNativeInfo();\n  if (info) {\n    return info.platform;\n  }\n  return void 0;\n}\nfunction getDevicePixelRatio() {\n  if (isWeb()) {\n    return window.devicePixelRatio;\n  }\n  if (isReactNative()) {\n    let info = getLKReactNativeInfo();\n    if (info) {\n      return info.devicePixelRatio;\n    }\n  }\n  return 1;\n}\nfunction compareVersions(v1, v2) {\n  const parts1 = v1.split(\".\");\n  const parts2 = v2.split(\".\");\n  const k = Math.min(v1.length, v2.length);\n  for (let i = 0; i < k; ++i) {\n    const p1 = parseInt(parts1[i], 10);\n    const p2 = parseInt(parts2[i], 10);\n    if (p1 > p2)\n      return 1;\n    if (p1 < p2)\n      return -1;\n  }\n  return parts1.length == parts2.length ? 0 : parts1.length < parts2.length ? -1 : 1;\n}\nfunction roDispatchCallback(entries) {\n  for (const entry of entries) {\n    entry.target.handleResize(entry);\n  }\n}\nfunction ioDispatchCallback(entries) {\n  for (const entry of entries) {\n    entry.target.handleVisibilityChanged(entry);\n  }\n}\nvar resizeObserver = null;\nvar getResizeObserver = () => {\n  if (!resizeObserver)\n    resizeObserver = new ResizeObserver(roDispatchCallback);\n  return resizeObserver;\n};\nvar intersectionObserver = null;\nvar getIntersectionObserver = () => {\n  if (!intersectionObserver)\n    intersectionObserver = new IntersectionObserver(ioDispatchCallback, {\n      root: document,\n      rootMargin: \"0px\"\n    });\n  return intersectionObserver;\n};\nfunction getClientInfo() {\n  var _a;\n  const info = ClientInfo.fromPartial({\n    sdk: ClientInfo_SDK.JS,\n    protocol: protocolVersion,\n    version\n  });\n  if (isReactNative()) {\n    info.os = (_a = getReactNativeOs()) !== null && _a !== void 0 ? _a : \"\";\n  }\n  return info;\n}\nvar emptyVideoStreamTrack;\nfunction getEmptyVideoStreamTrack() {\n  if (!emptyVideoStreamTrack) {\n    emptyVideoStreamTrack = createDummyVideoStreamTrack();\n  }\n  return emptyVideoStreamTrack;\n}\nfunction createDummyVideoStreamTrack() {\n  let width = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16;\n  let height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 16;\n  let enabled = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n  let paintContent = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = width;\n  canvas.height = height;\n  const ctx = canvas.getContext(\"2d\");\n  ctx === null || ctx === void 0 ? void 0 : ctx.fillRect(0, 0, canvas.width, canvas.height);\n  if (paintContent && ctx) {\n    ctx.beginPath();\n    ctx.arc(width / 2, height / 2, 50, 0, Math.PI * 2, true);\n    ctx.closePath();\n    ctx.fillStyle = \"grey\";\n    ctx.fill();\n  }\n  const dummyStream = canvas.captureStream();\n  const [dummyTrack] = dummyStream.getTracks();\n  if (!dummyTrack) {\n    throw Error(\"Could not get empty media stream video track\");\n  }\n  dummyTrack.enabled = enabled;\n  return dummyTrack;\n}\nvar emptyAudioStreamTrack;\nfunction getEmptyAudioStreamTrack() {\n  if (!emptyAudioStreamTrack) {\n    const ctx = new AudioContext();\n    const oscillator = ctx.createOscillator();\n    const dst = ctx.createMediaStreamDestination();\n    oscillator.connect(dst);\n    oscillator.start();\n    [emptyAudioStreamTrack] = dst.stream.getAudioTracks();\n    if (!emptyAudioStreamTrack) {\n      throw Error(\"Could not get empty media stream audio track\");\n    }\n    emptyAudioStreamTrack.enabled = false;\n  }\n  return emptyAudioStreamTrack;\n}\nvar Future = class {\n  constructor(futureBase, onFinally) {\n    this.onFinally = onFinally;\n    this.promise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n      this.resolve = resolve;\n      this.reject = reject;\n      if (futureBase) {\n        yield futureBase(resolve, reject);\n      }\n    })).finally(() => {\n      var _a;\n      return (_a = this.onFinally) === null || _a === void 0 ? void 0 : _a.call(this);\n    });\n  }\n};\nfunction createAudioAnalyser(track, options) {\n  const opts = Object.assign({\n    cloneTrack: false,\n    fftSize: 2048,\n    smoothingTimeConstant: 0.8,\n    minDecibels: -100,\n    maxDecibels: -80\n  }, options);\n  const audioContext = getNewAudioContext();\n  if (!audioContext) {\n    throw new Error(\"Audio Context not supported on this browser\");\n  }\n  const streamTrack = opts.cloneTrack ? track.mediaStreamTrack.clone() : track.mediaStreamTrack;\n  const mediaStreamSource = audioContext.createMediaStreamSource(new MediaStream([streamTrack]));\n  const analyser = audioContext.createAnalyser();\n  analyser.minDecibels = opts.minDecibels;\n  analyser.maxDecibels = opts.maxDecibels;\n  analyser.fftSize = opts.fftSize;\n  analyser.smoothingTimeConstant = opts.smoothingTimeConstant;\n  mediaStreamSource.connect(analyser);\n  const dataArray = new Uint8Array(analyser.frequencyBinCount);\n  const calculateVolume = () => {\n    analyser.getByteFrequencyData(dataArray);\n    let sum = 0;\n    for (const amplitude of dataArray) {\n      sum += Math.pow(amplitude / 255, 2);\n    }\n    const volume = Math.sqrt(sum / dataArray.length);\n    return volume;\n  };\n  const cleanup = () => {\n    audioContext.close();\n    if (opts.cloneTrack) {\n      streamTrack.stop();\n    }\n  };\n  return {\n    calculateVolume,\n    analyser,\n    cleanup\n  };\n}\nvar Mutex = class {\n  constructor() {\n    this._locking = Promise.resolve();\n    this._locks = 0;\n  }\n  isLocked() {\n    return this._locks > 0;\n  }\n  lock() {\n    this._locks += 1;\n    let unlockNext;\n    const willLock = new Promise((resolve) => unlockNext = () => {\n      this._locks -= 1;\n      resolve();\n    });\n    const willUnlock = this._locking.then(() => unlockNext);\n    this._locking = this._locking.then(() => willLock);\n    return willUnlock;\n  }\n};\nvar QueueTaskStatus;\n(function(QueueTaskStatus2) {\n  QueueTaskStatus2[QueueTaskStatus2[\"WAITING\"] = 0] = \"WAITING\";\n  QueueTaskStatus2[QueueTaskStatus2[\"RUNNING\"] = 1] = \"RUNNING\";\n  QueueTaskStatus2[QueueTaskStatus2[\"COMPLETED\"] = 2] = \"COMPLETED\";\n})(QueueTaskStatus || (QueueTaskStatus = {}));\nvar AsyncQueue = class {\n  constructor() {\n    this.pendingTasks = /* @__PURE__ */ new Map();\n    this.taskMutex = new Mutex();\n    this.nextTaskIndex = 0;\n  }\n  run(task) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const taskInfo = {\n        id: this.nextTaskIndex++,\n        enqueuedAt: Date.now(),\n        status: QueueTaskStatus.WAITING\n      };\n      this.pendingTasks.set(taskInfo.id, taskInfo);\n      const unlock = yield this.taskMutex.lock();\n      try {\n        taskInfo.executedAt = Date.now();\n        taskInfo.status = QueueTaskStatus.RUNNING;\n        return yield task();\n      } finally {\n        taskInfo.status = QueueTaskStatus.COMPLETED;\n        this.pendingTasks.delete(taskInfo.id);\n        unlock();\n      }\n    });\n  }\n  flush() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.run(() => __awaiter(this, void 0, void 0, function* () {\n      }));\n    });\n  }\n  snapshot() {\n    return Array.from(this.pendingTasks.values());\n  }\n};\nvar SignalTarget;\n(function(SignalTarget2) {\n  SignalTarget2[SignalTarget2[\"PUBLISHER\"] = 0] = \"PUBLISHER\";\n  SignalTarget2[SignalTarget2[\"SUBSCRIBER\"] = 1] = \"SUBSCRIBER\";\n  SignalTarget2[SignalTarget2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(SignalTarget || (SignalTarget = {}));\nfunction signalTargetFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"PUBLISHER\":\n      return SignalTarget.PUBLISHER;\n    case 1:\n    case \"SUBSCRIBER\":\n      return SignalTarget.SUBSCRIBER;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return SignalTarget.UNRECOGNIZED;\n  }\n}\nfunction signalTargetToJSON(object) {\n  switch (object) {\n    case SignalTarget.PUBLISHER:\n      return \"PUBLISHER\";\n    case SignalTarget.SUBSCRIBER:\n      return \"SUBSCRIBER\";\n    case SignalTarget.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar StreamState;\n(function(StreamState2) {\n  StreamState2[StreamState2[\"ACTIVE\"] = 0] = \"ACTIVE\";\n  StreamState2[StreamState2[\"PAUSED\"] = 1] = \"PAUSED\";\n  StreamState2[StreamState2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(StreamState || (StreamState = {}));\nfunction streamStateFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"ACTIVE\":\n      return StreamState.ACTIVE;\n    case 1:\n    case \"PAUSED\":\n      return StreamState.PAUSED;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return StreamState.UNRECOGNIZED;\n  }\n}\nfunction streamStateToJSON(object) {\n  switch (object) {\n    case StreamState.ACTIVE:\n      return \"ACTIVE\";\n    case StreamState.PAUSED:\n      return \"PAUSED\";\n    case StreamState.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar CandidateProtocol;\n(function(CandidateProtocol2) {\n  CandidateProtocol2[CandidateProtocol2[\"UDP\"] = 0] = \"UDP\";\n  CandidateProtocol2[CandidateProtocol2[\"TCP\"] = 1] = \"TCP\";\n  CandidateProtocol2[CandidateProtocol2[\"TLS\"] = 2] = \"TLS\";\n  CandidateProtocol2[CandidateProtocol2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(CandidateProtocol || (CandidateProtocol = {}));\nfunction candidateProtocolFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"UDP\":\n      return CandidateProtocol.UDP;\n    case 1:\n    case \"TCP\":\n      return CandidateProtocol.TCP;\n    case 2:\n    case \"TLS\":\n      return CandidateProtocol.TLS;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return CandidateProtocol.UNRECOGNIZED;\n  }\n}\nfunction candidateProtocolToJSON(object) {\n  switch (object) {\n    case CandidateProtocol.UDP:\n      return \"UDP\";\n    case CandidateProtocol.TCP:\n      return \"TCP\";\n    case CandidateProtocol.TLS:\n      return \"TLS\";\n    case CandidateProtocol.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nfunction createBaseSignalRequest() {\n  return {\n    message: void 0\n  };\n}\nvar SignalRequest = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    var _a;\n    switch ((_a = message.message) === null || _a === void 0 ? void 0 : _a.$case) {\n      case \"offer\":\n        SessionDescription.encode(message.message.offer, writer2.uint32(10).fork()).ldelim();\n        break;\n      case \"answer\":\n        SessionDescription.encode(message.message.answer, writer2.uint32(18).fork()).ldelim();\n        break;\n      case \"trickle\":\n        TrickleRequest.encode(message.message.trickle, writer2.uint32(26).fork()).ldelim();\n        break;\n      case \"addTrack\":\n        AddTrackRequest.encode(message.message.addTrack, writer2.uint32(34).fork()).ldelim();\n        break;\n      case \"mute\":\n        MuteTrackRequest.encode(message.message.mute, writer2.uint32(42).fork()).ldelim();\n        break;\n      case \"subscription\":\n        UpdateSubscription.encode(message.message.subscription, writer2.uint32(50).fork()).ldelim();\n        break;\n      case \"trackSetting\":\n        UpdateTrackSettings.encode(message.message.trackSetting, writer2.uint32(58).fork()).ldelim();\n        break;\n      case \"leave\":\n        LeaveRequest.encode(message.message.leave, writer2.uint32(66).fork()).ldelim();\n        break;\n      case \"updateLayers\":\n        UpdateVideoLayers.encode(message.message.updateLayers, writer2.uint32(82).fork()).ldelim();\n        break;\n      case \"subscriptionPermission\":\n        SubscriptionPermission.encode(message.message.subscriptionPermission, writer2.uint32(90).fork()).ldelim();\n        break;\n      case \"syncState\":\n        SyncState.encode(message.message.syncState, writer2.uint32(98).fork()).ldelim();\n        break;\n      case \"simulate\":\n        SimulateScenario.encode(message.message.simulate, writer2.uint32(106).fork()).ldelim();\n        break;\n      case \"ping\":\n        writer2.uint32(112).int64(message.message.ping);\n        break;\n      case \"updateMetadata\":\n        UpdateParticipantMetadata.encode(message.message.updateMetadata, writer2.uint32(122).fork()).ldelim();\n        break;\n      case \"pingReq\":\n        Ping.encode(message.message.pingReq, writer2.uint32(130).fork()).ldelim();\n        break;\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseSignalRequest();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.message = {\n            $case: \"offer\",\n            offer: SessionDescription.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.message = {\n            $case: \"answer\",\n            answer: SessionDescription.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 3:\n          if (tag != 26) {\n            break;\n          }\n          message.message = {\n            $case: \"trickle\",\n            trickle: TrickleRequest.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 4:\n          if (tag != 34) {\n            break;\n          }\n          message.message = {\n            $case: \"addTrack\",\n            addTrack: AddTrackRequest.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 5:\n          if (tag != 42) {\n            break;\n          }\n          message.message = {\n            $case: \"mute\",\n            mute: MuteTrackRequest.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 6:\n          if (tag != 50) {\n            break;\n          }\n          message.message = {\n            $case: \"subscription\",\n            subscription: UpdateSubscription.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 7:\n          if (tag != 58) {\n            break;\n          }\n          message.message = {\n            $case: \"trackSetting\",\n            trackSetting: UpdateTrackSettings.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 8:\n          if (tag != 66) {\n            break;\n          }\n          message.message = {\n            $case: \"leave\",\n            leave: LeaveRequest.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 10:\n          if (tag != 82) {\n            break;\n          }\n          message.message = {\n            $case: \"updateLayers\",\n            updateLayers: UpdateVideoLayers.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 11:\n          if (tag != 90) {\n            break;\n          }\n          message.message = {\n            $case: \"subscriptionPermission\",\n            subscriptionPermission: SubscriptionPermission.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 12:\n          if (tag != 98) {\n            break;\n          }\n          message.message = {\n            $case: \"syncState\",\n            syncState: SyncState.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 13:\n          if (tag != 106) {\n            break;\n          }\n          message.message = {\n            $case: \"simulate\",\n            simulate: SimulateScenario.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 14:\n          if (tag != 112) {\n            break;\n          }\n          message.message = {\n            $case: \"ping\",\n            ping: longToNumber(reader2.int64())\n          };\n          continue;\n        case 15:\n          if (tag != 122) {\n            break;\n          }\n          message.message = {\n            $case: \"updateMetadata\",\n            updateMetadata: UpdateParticipantMetadata.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 16:\n          if (tag != 130) {\n            break;\n          }\n          message.message = {\n            $case: \"pingReq\",\n            pingReq: Ping.decode(reader2, reader2.uint32())\n          };\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      message: isSet(object.offer) ? {\n        $case: \"offer\",\n        offer: SessionDescription.fromJSON(object.offer)\n      } : isSet(object.answer) ? {\n        $case: \"answer\",\n        answer: SessionDescription.fromJSON(object.answer)\n      } : isSet(object.trickle) ? {\n        $case: \"trickle\",\n        trickle: TrickleRequest.fromJSON(object.trickle)\n      } : isSet(object.addTrack) ? {\n        $case: \"addTrack\",\n        addTrack: AddTrackRequest.fromJSON(object.addTrack)\n      } : isSet(object.mute) ? {\n        $case: \"mute\",\n        mute: MuteTrackRequest.fromJSON(object.mute)\n      } : isSet(object.subscription) ? {\n        $case: \"subscription\",\n        subscription: UpdateSubscription.fromJSON(object.subscription)\n      } : isSet(object.trackSetting) ? {\n        $case: \"trackSetting\",\n        trackSetting: UpdateTrackSettings.fromJSON(object.trackSetting)\n      } : isSet(object.leave) ? {\n        $case: \"leave\",\n        leave: LeaveRequest.fromJSON(object.leave)\n      } : isSet(object.updateLayers) ? {\n        $case: \"updateLayers\",\n        updateLayers: UpdateVideoLayers.fromJSON(object.updateLayers)\n      } : isSet(object.subscriptionPermission) ? {\n        $case: \"subscriptionPermission\",\n        subscriptionPermission: SubscriptionPermission.fromJSON(object.subscriptionPermission)\n      } : isSet(object.syncState) ? {\n        $case: \"syncState\",\n        syncState: SyncState.fromJSON(object.syncState)\n      } : isSet(object.simulate) ? {\n        $case: \"simulate\",\n        simulate: SimulateScenario.fromJSON(object.simulate)\n      } : isSet(object.ping) ? {\n        $case: \"ping\",\n        ping: Number(object.ping)\n      } : isSet(object.updateMetadata) ? {\n        $case: \"updateMetadata\",\n        updateMetadata: UpdateParticipantMetadata.fromJSON(object.updateMetadata)\n      } : isSet(object.pingReq) ? {\n        $case: \"pingReq\",\n        pingReq: Ping.fromJSON(object.pingReq)\n      } : void 0\n    };\n  },\n  toJSON(message) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19;\n    const obj = {};\n    ((_a = message.message) === null || _a === void 0 ? void 0 : _a.$case) === \"offer\" && (obj.offer = ((_b = message.message) === null || _b === void 0 ? void 0 : _b.offer) ? SessionDescription.toJSON((_c = message.message) === null || _c === void 0 ? void 0 : _c.offer) : void 0);\n    ((_d = message.message) === null || _d === void 0 ? void 0 : _d.$case) === \"answer\" && (obj.answer = ((_e = message.message) === null || _e === void 0 ? void 0 : _e.answer) ? SessionDescription.toJSON((_f = message.message) === null || _f === void 0 ? void 0 : _f.answer) : void 0);\n    ((_g = message.message) === null || _g === void 0 ? void 0 : _g.$case) === \"trickle\" && (obj.trickle = ((_h = message.message) === null || _h === void 0 ? void 0 : _h.trickle) ? TrickleRequest.toJSON((_j = message.message) === null || _j === void 0 ? void 0 : _j.trickle) : void 0);\n    ((_k = message.message) === null || _k === void 0 ? void 0 : _k.$case) === \"addTrack\" && (obj.addTrack = ((_l = message.message) === null || _l === void 0 ? void 0 : _l.addTrack) ? AddTrackRequest.toJSON((_m = message.message) === null || _m === void 0 ? void 0 : _m.addTrack) : void 0);\n    ((_o = message.message) === null || _o === void 0 ? void 0 : _o.$case) === \"mute\" && (obj.mute = ((_p = message.message) === null || _p === void 0 ? void 0 : _p.mute) ? MuteTrackRequest.toJSON((_q = message.message) === null || _q === void 0 ? void 0 : _q.mute) : void 0);\n    ((_r = message.message) === null || _r === void 0 ? void 0 : _r.$case) === \"subscription\" && (obj.subscription = ((_s = message.message) === null || _s === void 0 ? void 0 : _s.subscription) ? UpdateSubscription.toJSON((_t = message.message) === null || _t === void 0 ? void 0 : _t.subscription) : void 0);\n    ((_u = message.message) === null || _u === void 0 ? void 0 : _u.$case) === \"trackSetting\" && (obj.trackSetting = ((_v = message.message) === null || _v === void 0 ? void 0 : _v.trackSetting) ? UpdateTrackSettings.toJSON((_w = message.message) === null || _w === void 0 ? void 0 : _w.trackSetting) : void 0);\n    ((_x = message.message) === null || _x === void 0 ? void 0 : _x.$case) === \"leave\" && (obj.leave = ((_y = message.message) === null || _y === void 0 ? void 0 : _y.leave) ? LeaveRequest.toJSON((_z = message.message) === null || _z === void 0 ? void 0 : _z.leave) : void 0);\n    ((_0 = message.message) === null || _0 === void 0 ? void 0 : _0.$case) === \"updateLayers\" && (obj.updateLayers = ((_1 = message.message) === null || _1 === void 0 ? void 0 : _1.updateLayers) ? UpdateVideoLayers.toJSON((_2 = message.message) === null || _2 === void 0 ? void 0 : _2.updateLayers) : void 0);\n    ((_3 = message.message) === null || _3 === void 0 ? void 0 : _3.$case) === \"subscriptionPermission\" && (obj.subscriptionPermission = ((_4 = message.message) === null || _4 === void 0 ? void 0 : _4.subscriptionPermission) ? SubscriptionPermission.toJSON((_5 = message.message) === null || _5 === void 0 ? void 0 : _5.subscriptionPermission) : void 0);\n    ((_6 = message.message) === null || _6 === void 0 ? void 0 : _6.$case) === \"syncState\" && (obj.syncState = ((_7 = message.message) === null || _7 === void 0 ? void 0 : _7.syncState) ? SyncState.toJSON((_8 = message.message) === null || _8 === void 0 ? void 0 : _8.syncState) : void 0);\n    ((_9 = message.message) === null || _9 === void 0 ? void 0 : _9.$case) === \"simulate\" && (obj.simulate = ((_10 = message.message) === null || _10 === void 0 ? void 0 : _10.simulate) ? SimulateScenario.toJSON((_11 = message.message) === null || _11 === void 0 ? void 0 : _11.simulate) : void 0);\n    ((_12 = message.message) === null || _12 === void 0 ? void 0 : _12.$case) === \"ping\" && (obj.ping = Math.round((_13 = message.message) === null || _13 === void 0 ? void 0 : _13.ping));\n    ((_14 = message.message) === null || _14 === void 0 ? void 0 : _14.$case) === \"updateMetadata\" && (obj.updateMetadata = ((_15 = message.message) === null || _15 === void 0 ? void 0 : _15.updateMetadata) ? UpdateParticipantMetadata.toJSON((_16 = message.message) === null || _16 === void 0 ? void 0 : _16.updateMetadata) : void 0);\n    ((_17 = message.message) === null || _17 === void 0 ? void 0 : _17.$case) === \"pingReq\" && (obj.pingReq = ((_18 = message.message) === null || _18 === void 0 ? void 0 : _18.pingReq) ? Ping.toJSON((_19 = message.message) === null || _19 === void 0 ? void 0 : _19.pingReq) : void 0);\n    return obj;\n  },\n  create(base) {\n    return SignalRequest.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20;\n    const message = createBaseSignalRequest();\n    if (((_a = object.message) === null || _a === void 0 ? void 0 : _a.$case) === \"offer\" && ((_b = object.message) === null || _b === void 0 ? void 0 : _b.offer) !== void 0 && ((_c = object.message) === null || _c === void 0 ? void 0 : _c.offer) !== null) {\n      message.message = {\n        $case: \"offer\",\n        offer: SessionDescription.fromPartial(object.message.offer)\n      };\n    }\n    if (((_d = object.message) === null || _d === void 0 ? void 0 : _d.$case) === \"answer\" && ((_e = object.message) === null || _e === void 0 ? void 0 : _e.answer) !== void 0 && ((_f = object.message) === null || _f === void 0 ? void 0 : _f.answer) !== null) {\n      message.message = {\n        $case: \"answer\",\n        answer: SessionDescription.fromPartial(object.message.answer)\n      };\n    }\n    if (((_g = object.message) === null || _g === void 0 ? void 0 : _g.$case) === \"trickle\" && ((_h = object.message) === null || _h === void 0 ? void 0 : _h.trickle) !== void 0 && ((_j = object.message) === null || _j === void 0 ? void 0 : _j.trickle) !== null) {\n      message.message = {\n        $case: \"trickle\",\n        trickle: TrickleRequest.fromPartial(object.message.trickle)\n      };\n    }\n    if (((_k = object.message) === null || _k === void 0 ? void 0 : _k.$case) === \"addTrack\" && ((_l = object.message) === null || _l === void 0 ? void 0 : _l.addTrack) !== void 0 && ((_m = object.message) === null || _m === void 0 ? void 0 : _m.addTrack) !== null) {\n      message.message = {\n        $case: \"addTrack\",\n        addTrack: AddTrackRequest.fromPartial(object.message.addTrack)\n      };\n    }\n    if (((_o = object.message) === null || _o === void 0 ? void 0 : _o.$case) === \"mute\" && ((_p = object.message) === null || _p === void 0 ? void 0 : _p.mute) !== void 0 && ((_q = object.message) === null || _q === void 0 ? void 0 : _q.mute) !== null) {\n      message.message = {\n        $case: \"mute\",\n        mute: MuteTrackRequest.fromPartial(object.message.mute)\n      };\n    }\n    if (((_r = object.message) === null || _r === void 0 ? void 0 : _r.$case) === \"subscription\" && ((_s = object.message) === null || _s === void 0 ? void 0 : _s.subscription) !== void 0 && ((_t = object.message) === null || _t === void 0 ? void 0 : _t.subscription) !== null) {\n      message.message = {\n        $case: \"subscription\",\n        subscription: UpdateSubscription.fromPartial(object.message.subscription)\n      };\n    }\n    if (((_u = object.message) === null || _u === void 0 ? void 0 : _u.$case) === \"trackSetting\" && ((_v = object.message) === null || _v === void 0 ? void 0 : _v.trackSetting) !== void 0 && ((_w = object.message) === null || _w === void 0 ? void 0 : _w.trackSetting) !== null) {\n      message.message = {\n        $case: \"trackSetting\",\n        trackSetting: UpdateTrackSettings.fromPartial(object.message.trackSetting)\n      };\n    }\n    if (((_x = object.message) === null || _x === void 0 ? void 0 : _x.$case) === \"leave\" && ((_y = object.message) === null || _y === void 0 ? void 0 : _y.leave) !== void 0 && ((_z = object.message) === null || _z === void 0 ? void 0 : _z.leave) !== null) {\n      message.message = {\n        $case: \"leave\",\n        leave: LeaveRequest.fromPartial(object.message.leave)\n      };\n    }\n    if (((_0 = object.message) === null || _0 === void 0 ? void 0 : _0.$case) === \"updateLayers\" && ((_1 = object.message) === null || _1 === void 0 ? void 0 : _1.updateLayers) !== void 0 && ((_2 = object.message) === null || _2 === void 0 ? void 0 : _2.updateLayers) !== null) {\n      message.message = {\n        $case: \"updateLayers\",\n        updateLayers: UpdateVideoLayers.fromPartial(object.message.updateLayers)\n      };\n    }\n    if (((_3 = object.message) === null || _3 === void 0 ? void 0 : _3.$case) === \"subscriptionPermission\" && ((_4 = object.message) === null || _4 === void 0 ? void 0 : _4.subscriptionPermission) !== void 0 && ((_5 = object.message) === null || _5 === void 0 ? void 0 : _5.subscriptionPermission) !== null) {\n      message.message = {\n        $case: \"subscriptionPermission\",\n        subscriptionPermission: SubscriptionPermission.fromPartial(object.message.subscriptionPermission)\n      };\n    }\n    if (((_6 = object.message) === null || _6 === void 0 ? void 0 : _6.$case) === \"syncState\" && ((_7 = object.message) === null || _7 === void 0 ? void 0 : _7.syncState) !== void 0 && ((_8 = object.message) === null || _8 === void 0 ? void 0 : _8.syncState) !== null) {\n      message.message = {\n        $case: \"syncState\",\n        syncState: SyncState.fromPartial(object.message.syncState)\n      };\n    }\n    if (((_9 = object.message) === null || _9 === void 0 ? void 0 : _9.$case) === \"simulate\" && ((_10 = object.message) === null || _10 === void 0 ? void 0 : _10.simulate) !== void 0 && ((_11 = object.message) === null || _11 === void 0 ? void 0 : _11.simulate) !== null) {\n      message.message = {\n        $case: \"simulate\",\n        simulate: SimulateScenario.fromPartial(object.message.simulate)\n      };\n    }\n    if (((_12 = object.message) === null || _12 === void 0 ? void 0 : _12.$case) === \"ping\" && ((_13 = object.message) === null || _13 === void 0 ? void 0 : _13.ping) !== void 0 && ((_14 = object.message) === null || _14 === void 0 ? void 0 : _14.ping) !== null) {\n      message.message = {\n        $case: \"ping\",\n        ping: object.message.ping\n      };\n    }\n    if (((_15 = object.message) === null || _15 === void 0 ? void 0 : _15.$case) === \"updateMetadata\" && ((_16 = object.message) === null || _16 === void 0 ? void 0 : _16.updateMetadata) !== void 0 && ((_17 = object.message) === null || _17 === void 0 ? void 0 : _17.updateMetadata) !== null) {\n      message.message = {\n        $case: \"updateMetadata\",\n        updateMetadata: UpdateParticipantMetadata.fromPartial(object.message.updateMetadata)\n      };\n    }\n    if (((_18 = object.message) === null || _18 === void 0 ? void 0 : _18.$case) === \"pingReq\" && ((_19 = object.message) === null || _19 === void 0 ? void 0 : _19.pingReq) !== void 0 && ((_20 = object.message) === null || _20 === void 0 ? void 0 : _20.pingReq) !== null) {\n      message.message = {\n        $case: \"pingReq\",\n        pingReq: Ping.fromPartial(object.message.pingReq)\n      };\n    }\n    return message;\n  }\n};\nfunction createBaseSignalResponse() {\n  return {\n    message: void 0\n  };\n}\nvar SignalResponse = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    var _a;\n    switch ((_a = message.message) === null || _a === void 0 ? void 0 : _a.$case) {\n      case \"join\":\n        JoinResponse.encode(message.message.join, writer2.uint32(10).fork()).ldelim();\n        break;\n      case \"answer\":\n        SessionDescription.encode(message.message.answer, writer2.uint32(18).fork()).ldelim();\n        break;\n      case \"offer\":\n        SessionDescription.encode(message.message.offer, writer2.uint32(26).fork()).ldelim();\n        break;\n      case \"trickle\":\n        TrickleRequest.encode(message.message.trickle, writer2.uint32(34).fork()).ldelim();\n        break;\n      case \"update\":\n        ParticipantUpdate.encode(message.message.update, writer2.uint32(42).fork()).ldelim();\n        break;\n      case \"trackPublished\":\n        TrackPublishedResponse.encode(message.message.trackPublished, writer2.uint32(50).fork()).ldelim();\n        break;\n      case \"leave\":\n        LeaveRequest.encode(message.message.leave, writer2.uint32(66).fork()).ldelim();\n        break;\n      case \"mute\":\n        MuteTrackRequest.encode(message.message.mute, writer2.uint32(74).fork()).ldelim();\n        break;\n      case \"speakersChanged\":\n        SpeakersChanged.encode(message.message.speakersChanged, writer2.uint32(82).fork()).ldelim();\n        break;\n      case \"roomUpdate\":\n        RoomUpdate.encode(message.message.roomUpdate, writer2.uint32(90).fork()).ldelim();\n        break;\n      case \"connectionQuality\":\n        ConnectionQualityUpdate.encode(message.message.connectionQuality, writer2.uint32(98).fork()).ldelim();\n        break;\n      case \"streamStateUpdate\":\n        StreamStateUpdate.encode(message.message.streamStateUpdate, writer2.uint32(106).fork()).ldelim();\n        break;\n      case \"subscribedQualityUpdate\":\n        SubscribedQualityUpdate.encode(message.message.subscribedQualityUpdate, writer2.uint32(114).fork()).ldelim();\n        break;\n      case \"subscriptionPermissionUpdate\":\n        SubscriptionPermissionUpdate.encode(message.message.subscriptionPermissionUpdate, writer2.uint32(122).fork()).ldelim();\n        break;\n      case \"refreshToken\":\n        writer2.uint32(130).string(message.message.refreshToken);\n        break;\n      case \"trackUnpublished\":\n        TrackUnpublishedResponse.encode(message.message.trackUnpublished, writer2.uint32(138).fork()).ldelim();\n        break;\n      case \"pong\":\n        writer2.uint32(144).int64(message.message.pong);\n        break;\n      case \"reconnect\":\n        ReconnectResponse.encode(message.message.reconnect, writer2.uint32(154).fork()).ldelim();\n        break;\n      case \"pongResp\":\n        Pong.encode(message.message.pongResp, writer2.uint32(162).fork()).ldelim();\n        break;\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseSignalResponse();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.message = {\n            $case: \"join\",\n            join: JoinResponse.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.message = {\n            $case: \"answer\",\n            answer: SessionDescription.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 3:\n          if (tag != 26) {\n            break;\n          }\n          message.message = {\n            $case: \"offer\",\n            offer: SessionDescription.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 4:\n          if (tag != 34) {\n            break;\n          }\n          message.message = {\n            $case: \"trickle\",\n            trickle: TrickleRequest.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 5:\n          if (tag != 42) {\n            break;\n          }\n          message.message = {\n            $case: \"update\",\n            update: ParticipantUpdate.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 6:\n          if (tag != 50) {\n            break;\n          }\n          message.message = {\n            $case: \"trackPublished\",\n            trackPublished: TrackPublishedResponse.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 8:\n          if (tag != 66) {\n            break;\n          }\n          message.message = {\n            $case: \"leave\",\n            leave: LeaveRequest.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 9:\n          if (tag != 74) {\n            break;\n          }\n          message.message = {\n            $case: \"mute\",\n            mute: MuteTrackRequest.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 10:\n          if (tag != 82) {\n            break;\n          }\n          message.message = {\n            $case: \"speakersChanged\",\n            speakersChanged: SpeakersChanged.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 11:\n          if (tag != 90) {\n            break;\n          }\n          message.message = {\n            $case: \"roomUpdate\",\n            roomUpdate: RoomUpdate.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 12:\n          if (tag != 98) {\n            break;\n          }\n          message.message = {\n            $case: \"connectionQuality\",\n            connectionQuality: ConnectionQualityUpdate.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 13:\n          if (tag != 106) {\n            break;\n          }\n          message.message = {\n            $case: \"streamStateUpdate\",\n            streamStateUpdate: StreamStateUpdate.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 14:\n          if (tag != 114) {\n            break;\n          }\n          message.message = {\n            $case: \"subscribedQualityUpdate\",\n            subscribedQualityUpdate: SubscribedQualityUpdate.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 15:\n          if (tag != 122) {\n            break;\n          }\n          message.message = {\n            $case: \"subscriptionPermissionUpdate\",\n            subscriptionPermissionUpdate: SubscriptionPermissionUpdate.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 16:\n          if (tag != 130) {\n            break;\n          }\n          message.message = {\n            $case: \"refreshToken\",\n            refreshToken: reader2.string()\n          };\n          continue;\n        case 17:\n          if (tag != 138) {\n            break;\n          }\n          message.message = {\n            $case: \"trackUnpublished\",\n            trackUnpublished: TrackUnpublishedResponse.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 18:\n          if (tag != 144) {\n            break;\n          }\n          message.message = {\n            $case: \"pong\",\n            pong: longToNumber(reader2.int64())\n          };\n          continue;\n        case 19:\n          if (tag != 154) {\n            break;\n          }\n          message.message = {\n            $case: \"reconnect\",\n            reconnect: ReconnectResponse.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 20:\n          if (tag != 162) {\n            break;\n          }\n          message.message = {\n            $case: \"pongResp\",\n            pongResp: Pong.decode(reader2, reader2.uint32())\n          };\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      message: isSet(object.join) ? {\n        $case: \"join\",\n        join: JoinResponse.fromJSON(object.join)\n      } : isSet(object.answer) ? {\n        $case: \"answer\",\n        answer: SessionDescription.fromJSON(object.answer)\n      } : isSet(object.offer) ? {\n        $case: \"offer\",\n        offer: SessionDescription.fromJSON(object.offer)\n      } : isSet(object.trickle) ? {\n        $case: \"trickle\",\n        trickle: TrickleRequest.fromJSON(object.trickle)\n      } : isSet(object.update) ? {\n        $case: \"update\",\n        update: ParticipantUpdate.fromJSON(object.update)\n      } : isSet(object.trackPublished) ? {\n        $case: \"trackPublished\",\n        trackPublished: TrackPublishedResponse.fromJSON(object.trackPublished)\n      } : isSet(object.leave) ? {\n        $case: \"leave\",\n        leave: LeaveRequest.fromJSON(object.leave)\n      } : isSet(object.mute) ? {\n        $case: \"mute\",\n        mute: MuteTrackRequest.fromJSON(object.mute)\n      } : isSet(object.speakersChanged) ? {\n        $case: \"speakersChanged\",\n        speakersChanged: SpeakersChanged.fromJSON(object.speakersChanged)\n      } : isSet(object.roomUpdate) ? {\n        $case: \"roomUpdate\",\n        roomUpdate: RoomUpdate.fromJSON(object.roomUpdate)\n      } : isSet(object.connectionQuality) ? {\n        $case: \"connectionQuality\",\n        connectionQuality: ConnectionQualityUpdate.fromJSON(object.connectionQuality)\n      } : isSet(object.streamStateUpdate) ? {\n        $case: \"streamStateUpdate\",\n        streamStateUpdate: StreamStateUpdate.fromJSON(object.streamStateUpdate)\n      } : isSet(object.subscribedQualityUpdate) ? {\n        $case: \"subscribedQualityUpdate\",\n        subscribedQualityUpdate: SubscribedQualityUpdate.fromJSON(object.subscribedQualityUpdate)\n      } : isSet(object.subscriptionPermissionUpdate) ? {\n        $case: \"subscriptionPermissionUpdate\",\n        subscriptionPermissionUpdate: SubscriptionPermissionUpdate.fromJSON(object.subscriptionPermissionUpdate)\n      } : isSet(object.refreshToken) ? {\n        $case: \"refreshToken\",\n        refreshToken: String(object.refreshToken)\n      } : isSet(object.trackUnpublished) ? {\n        $case: \"trackUnpublished\",\n        trackUnpublished: TrackUnpublishedResponse.fromJSON(object.trackUnpublished)\n      } : isSet(object.pong) ? {\n        $case: \"pong\",\n        pong: Number(object.pong)\n      } : isSet(object.reconnect) ? {\n        $case: \"reconnect\",\n        reconnect: ReconnectResponse.fromJSON(object.reconnect)\n      } : isSet(object.pongResp) ? {\n        $case: \"pongResp\",\n        pongResp: Pong.fromJSON(object.pongResp)\n      } : void 0\n    };\n  },\n  toJSON(message) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30;\n    const obj = {};\n    ((_a = message.message) === null || _a === void 0 ? void 0 : _a.$case) === \"join\" && (obj.join = ((_b = message.message) === null || _b === void 0 ? void 0 : _b.join) ? JoinResponse.toJSON((_c = message.message) === null || _c === void 0 ? void 0 : _c.join) : void 0);\n    ((_d = message.message) === null || _d === void 0 ? void 0 : _d.$case) === \"answer\" && (obj.answer = ((_e = message.message) === null || _e === void 0 ? void 0 : _e.answer) ? SessionDescription.toJSON((_f = message.message) === null || _f === void 0 ? void 0 : _f.answer) : void 0);\n    ((_g = message.message) === null || _g === void 0 ? void 0 : _g.$case) === \"offer\" && (obj.offer = ((_h = message.message) === null || _h === void 0 ? void 0 : _h.offer) ? SessionDescription.toJSON((_j = message.message) === null || _j === void 0 ? void 0 : _j.offer) : void 0);\n    ((_k = message.message) === null || _k === void 0 ? void 0 : _k.$case) === \"trickle\" && (obj.trickle = ((_l = message.message) === null || _l === void 0 ? void 0 : _l.trickle) ? TrickleRequest.toJSON((_m = message.message) === null || _m === void 0 ? void 0 : _m.trickle) : void 0);\n    ((_o = message.message) === null || _o === void 0 ? void 0 : _o.$case) === \"update\" && (obj.update = ((_p = message.message) === null || _p === void 0 ? void 0 : _p.update) ? ParticipantUpdate.toJSON((_q = message.message) === null || _q === void 0 ? void 0 : _q.update) : void 0);\n    ((_r = message.message) === null || _r === void 0 ? void 0 : _r.$case) === \"trackPublished\" && (obj.trackPublished = ((_s = message.message) === null || _s === void 0 ? void 0 : _s.trackPublished) ? TrackPublishedResponse.toJSON((_t = message.message) === null || _t === void 0 ? void 0 : _t.trackPublished) : void 0);\n    ((_u = message.message) === null || _u === void 0 ? void 0 : _u.$case) === \"leave\" && (obj.leave = ((_v = message.message) === null || _v === void 0 ? void 0 : _v.leave) ? LeaveRequest.toJSON((_w = message.message) === null || _w === void 0 ? void 0 : _w.leave) : void 0);\n    ((_x = message.message) === null || _x === void 0 ? void 0 : _x.$case) === \"mute\" && (obj.mute = ((_y = message.message) === null || _y === void 0 ? void 0 : _y.mute) ? MuteTrackRequest.toJSON((_z = message.message) === null || _z === void 0 ? void 0 : _z.mute) : void 0);\n    ((_0 = message.message) === null || _0 === void 0 ? void 0 : _0.$case) === \"speakersChanged\" && (obj.speakersChanged = ((_1 = message.message) === null || _1 === void 0 ? void 0 : _1.speakersChanged) ? SpeakersChanged.toJSON((_2 = message.message) === null || _2 === void 0 ? void 0 : _2.speakersChanged) : void 0);\n    ((_3 = message.message) === null || _3 === void 0 ? void 0 : _3.$case) === \"roomUpdate\" && (obj.roomUpdate = ((_4 = message.message) === null || _4 === void 0 ? void 0 : _4.roomUpdate) ? RoomUpdate.toJSON((_5 = message.message) === null || _5 === void 0 ? void 0 : _5.roomUpdate) : void 0);\n    ((_6 = message.message) === null || _6 === void 0 ? void 0 : _6.$case) === \"connectionQuality\" && (obj.connectionQuality = ((_7 = message.message) === null || _7 === void 0 ? void 0 : _7.connectionQuality) ? ConnectionQualityUpdate.toJSON((_8 = message.message) === null || _8 === void 0 ? void 0 : _8.connectionQuality) : void 0);\n    ((_9 = message.message) === null || _9 === void 0 ? void 0 : _9.$case) === \"streamStateUpdate\" && (obj.streamStateUpdate = ((_10 = message.message) === null || _10 === void 0 ? void 0 : _10.streamStateUpdate) ? StreamStateUpdate.toJSON((_11 = message.message) === null || _11 === void 0 ? void 0 : _11.streamStateUpdate) : void 0);\n    ((_12 = message.message) === null || _12 === void 0 ? void 0 : _12.$case) === \"subscribedQualityUpdate\" && (obj.subscribedQualityUpdate = ((_13 = message.message) === null || _13 === void 0 ? void 0 : _13.subscribedQualityUpdate) ? SubscribedQualityUpdate.toJSON((_14 = message.message) === null || _14 === void 0 ? void 0 : _14.subscribedQualityUpdate) : void 0);\n    ((_15 = message.message) === null || _15 === void 0 ? void 0 : _15.$case) === \"subscriptionPermissionUpdate\" && (obj.subscriptionPermissionUpdate = ((_16 = message.message) === null || _16 === void 0 ? void 0 : _16.subscriptionPermissionUpdate) ? SubscriptionPermissionUpdate.toJSON((_17 = message.message) === null || _17 === void 0 ? void 0 : _17.subscriptionPermissionUpdate) : void 0);\n    ((_18 = message.message) === null || _18 === void 0 ? void 0 : _18.$case) === \"refreshToken\" && (obj.refreshToken = (_19 = message.message) === null || _19 === void 0 ? void 0 : _19.refreshToken);\n    ((_20 = message.message) === null || _20 === void 0 ? void 0 : _20.$case) === \"trackUnpublished\" && (obj.trackUnpublished = ((_21 = message.message) === null || _21 === void 0 ? void 0 : _21.trackUnpublished) ? TrackUnpublishedResponse.toJSON((_22 = message.message) === null || _22 === void 0 ? void 0 : _22.trackUnpublished) : void 0);\n    ((_23 = message.message) === null || _23 === void 0 ? void 0 : _23.$case) === \"pong\" && (obj.pong = Math.round((_24 = message.message) === null || _24 === void 0 ? void 0 : _24.pong));\n    ((_25 = message.message) === null || _25 === void 0 ? void 0 : _25.$case) === \"reconnect\" && (obj.reconnect = ((_26 = message.message) === null || _26 === void 0 ? void 0 : _26.reconnect) ? ReconnectResponse.toJSON((_27 = message.message) === null || _27 === void 0 ? void 0 : _27.reconnect) : void 0);\n    ((_28 = message.message) === null || _28 === void 0 ? void 0 : _28.$case) === \"pongResp\" && (obj.pongResp = ((_29 = message.message) === null || _29 === void 0 ? void 0 : _29.pongResp) ? Pong.toJSON((_30 = message.message) === null || _30 === void 0 ? void 0 : _30.pongResp) : void 0);\n    return obj;\n  },\n  create(base) {\n    return SignalResponse.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32;\n    const message = createBaseSignalResponse();\n    if (((_a = object.message) === null || _a === void 0 ? void 0 : _a.$case) === \"join\" && ((_b = object.message) === null || _b === void 0 ? void 0 : _b.join) !== void 0 && ((_c = object.message) === null || _c === void 0 ? void 0 : _c.join) !== null) {\n      message.message = {\n        $case: \"join\",\n        join: JoinResponse.fromPartial(object.message.join)\n      };\n    }\n    if (((_d = object.message) === null || _d === void 0 ? void 0 : _d.$case) === \"answer\" && ((_e = object.message) === null || _e === void 0 ? void 0 : _e.answer) !== void 0 && ((_f = object.message) === null || _f === void 0 ? void 0 : _f.answer) !== null) {\n      message.message = {\n        $case: \"answer\",\n        answer: SessionDescription.fromPartial(object.message.answer)\n      };\n    }\n    if (((_g = object.message) === null || _g === void 0 ? void 0 : _g.$case) === \"offer\" && ((_h = object.message) === null || _h === void 0 ? void 0 : _h.offer) !== void 0 && ((_j = object.message) === null || _j === void 0 ? void 0 : _j.offer) !== null) {\n      message.message = {\n        $case: \"offer\",\n        offer: SessionDescription.fromPartial(object.message.offer)\n      };\n    }\n    if (((_k = object.message) === null || _k === void 0 ? void 0 : _k.$case) === \"trickle\" && ((_l = object.message) === null || _l === void 0 ? void 0 : _l.trickle) !== void 0 && ((_m = object.message) === null || _m === void 0 ? void 0 : _m.trickle) !== null) {\n      message.message = {\n        $case: \"trickle\",\n        trickle: TrickleRequest.fromPartial(object.message.trickle)\n      };\n    }\n    if (((_o = object.message) === null || _o === void 0 ? void 0 : _o.$case) === \"update\" && ((_p = object.message) === null || _p === void 0 ? void 0 : _p.update) !== void 0 && ((_q = object.message) === null || _q === void 0 ? void 0 : _q.update) !== null) {\n      message.message = {\n        $case: \"update\",\n        update: ParticipantUpdate.fromPartial(object.message.update)\n      };\n    }\n    if (((_r = object.message) === null || _r === void 0 ? void 0 : _r.$case) === \"trackPublished\" && ((_s = object.message) === null || _s === void 0 ? void 0 : _s.trackPublished) !== void 0 && ((_t = object.message) === null || _t === void 0 ? void 0 : _t.trackPublished) !== null) {\n      message.message = {\n        $case: \"trackPublished\",\n        trackPublished: TrackPublishedResponse.fromPartial(object.message.trackPublished)\n      };\n    }\n    if (((_u = object.message) === null || _u === void 0 ? void 0 : _u.$case) === \"leave\" && ((_v = object.message) === null || _v === void 0 ? void 0 : _v.leave) !== void 0 && ((_w = object.message) === null || _w === void 0 ? void 0 : _w.leave) !== null) {\n      message.message = {\n        $case: \"leave\",\n        leave: LeaveRequest.fromPartial(object.message.leave)\n      };\n    }\n    if (((_x = object.message) === null || _x === void 0 ? void 0 : _x.$case) === \"mute\" && ((_y = object.message) === null || _y === void 0 ? void 0 : _y.mute) !== void 0 && ((_z = object.message) === null || _z === void 0 ? void 0 : _z.mute) !== null) {\n      message.message = {\n        $case: \"mute\",\n        mute: MuteTrackRequest.fromPartial(object.message.mute)\n      };\n    }\n    if (((_0 = object.message) === null || _0 === void 0 ? void 0 : _0.$case) === \"speakersChanged\" && ((_1 = object.message) === null || _1 === void 0 ? void 0 : _1.speakersChanged) !== void 0 && ((_2 = object.message) === null || _2 === void 0 ? void 0 : _2.speakersChanged) !== null) {\n      message.message = {\n        $case: \"speakersChanged\",\n        speakersChanged: SpeakersChanged.fromPartial(object.message.speakersChanged)\n      };\n    }\n    if (((_3 = object.message) === null || _3 === void 0 ? void 0 : _3.$case) === \"roomUpdate\" && ((_4 = object.message) === null || _4 === void 0 ? void 0 : _4.roomUpdate) !== void 0 && ((_5 = object.message) === null || _5 === void 0 ? void 0 : _5.roomUpdate) !== null) {\n      message.message = {\n        $case: \"roomUpdate\",\n        roomUpdate: RoomUpdate.fromPartial(object.message.roomUpdate)\n      };\n    }\n    if (((_6 = object.message) === null || _6 === void 0 ? void 0 : _6.$case) === \"connectionQuality\" && ((_7 = object.message) === null || _7 === void 0 ? void 0 : _7.connectionQuality) !== void 0 && ((_8 = object.message) === null || _8 === void 0 ? void 0 : _8.connectionQuality) !== null) {\n      message.message = {\n        $case: \"connectionQuality\",\n        connectionQuality: ConnectionQualityUpdate.fromPartial(object.message.connectionQuality)\n      };\n    }\n    if (((_9 = object.message) === null || _9 === void 0 ? void 0 : _9.$case) === \"streamStateUpdate\" && ((_10 = object.message) === null || _10 === void 0 ? void 0 : _10.streamStateUpdate) !== void 0 && ((_11 = object.message) === null || _11 === void 0 ? void 0 : _11.streamStateUpdate) !== null) {\n      message.message = {\n        $case: \"streamStateUpdate\",\n        streamStateUpdate: StreamStateUpdate.fromPartial(object.message.streamStateUpdate)\n      };\n    }\n    if (((_12 = object.message) === null || _12 === void 0 ? void 0 : _12.$case) === \"subscribedQualityUpdate\" && ((_13 = object.message) === null || _13 === void 0 ? void 0 : _13.subscribedQualityUpdate) !== void 0 && ((_14 = object.message) === null || _14 === void 0 ? void 0 : _14.subscribedQualityUpdate) !== null) {\n      message.message = {\n        $case: \"subscribedQualityUpdate\",\n        subscribedQualityUpdate: SubscribedQualityUpdate.fromPartial(object.message.subscribedQualityUpdate)\n      };\n    }\n    if (((_15 = object.message) === null || _15 === void 0 ? void 0 : _15.$case) === \"subscriptionPermissionUpdate\" && ((_16 = object.message) === null || _16 === void 0 ? void 0 : _16.subscriptionPermissionUpdate) !== void 0 && ((_17 = object.message) === null || _17 === void 0 ? void 0 : _17.subscriptionPermissionUpdate) !== null) {\n      message.message = {\n        $case: \"subscriptionPermissionUpdate\",\n        subscriptionPermissionUpdate: SubscriptionPermissionUpdate.fromPartial(object.message.subscriptionPermissionUpdate)\n      };\n    }\n    if (((_18 = object.message) === null || _18 === void 0 ? void 0 : _18.$case) === \"refreshToken\" && ((_19 = object.message) === null || _19 === void 0 ? void 0 : _19.refreshToken) !== void 0 && ((_20 = object.message) === null || _20 === void 0 ? void 0 : _20.refreshToken) !== null) {\n      message.message = {\n        $case: \"refreshToken\",\n        refreshToken: object.message.refreshToken\n      };\n    }\n    if (((_21 = object.message) === null || _21 === void 0 ? void 0 : _21.$case) === \"trackUnpublished\" && ((_22 = object.message) === null || _22 === void 0 ? void 0 : _22.trackUnpublished) !== void 0 && ((_23 = object.message) === null || _23 === void 0 ? void 0 : _23.trackUnpublished) !== null) {\n      message.message = {\n        $case: \"trackUnpublished\",\n        trackUnpublished: TrackUnpublishedResponse.fromPartial(object.message.trackUnpublished)\n      };\n    }\n    if (((_24 = object.message) === null || _24 === void 0 ? void 0 : _24.$case) === \"pong\" && ((_25 = object.message) === null || _25 === void 0 ? void 0 : _25.pong) !== void 0 && ((_26 = object.message) === null || _26 === void 0 ? void 0 : _26.pong) !== null) {\n      message.message = {\n        $case: \"pong\",\n        pong: object.message.pong\n      };\n    }\n    if (((_27 = object.message) === null || _27 === void 0 ? void 0 : _27.$case) === \"reconnect\" && ((_28 = object.message) === null || _28 === void 0 ? void 0 : _28.reconnect) !== void 0 && ((_29 = object.message) === null || _29 === void 0 ? void 0 : _29.reconnect) !== null) {\n      message.message = {\n        $case: \"reconnect\",\n        reconnect: ReconnectResponse.fromPartial(object.message.reconnect)\n      };\n    }\n    if (((_30 = object.message) === null || _30 === void 0 ? void 0 : _30.$case) === \"pongResp\" && ((_31 = object.message) === null || _31 === void 0 ? void 0 : _31.pongResp) !== void 0 && ((_32 = object.message) === null || _32 === void 0 ? void 0 : _32.pongResp) !== null) {\n      message.message = {\n        $case: \"pongResp\",\n        pongResp: Pong.fromPartial(object.message.pongResp)\n      };\n    }\n    return message;\n  }\n};\nfunction createBaseSimulcastCodec() {\n  return {\n    codec: \"\",\n    cid: \"\",\n    enableSimulcastLayers: false\n  };\n}\nvar SimulcastCodec = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.codec !== \"\") {\n      writer2.uint32(10).string(message.codec);\n    }\n    if (message.cid !== \"\") {\n      writer2.uint32(18).string(message.cid);\n    }\n    if (message.enableSimulcastLayers === true) {\n      writer2.uint32(24).bool(message.enableSimulcastLayers);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseSimulcastCodec();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.codec = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.cid = reader2.string();\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.enableSimulcastLayers = reader2.bool();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      codec: isSet(object.codec) ? String(object.codec) : \"\",\n      cid: isSet(object.cid) ? String(object.cid) : \"\",\n      enableSimulcastLayers: isSet(object.enableSimulcastLayers) ? Boolean(object.enableSimulcastLayers) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.codec !== void 0 && (obj.codec = message.codec);\n    message.cid !== void 0 && (obj.cid = message.cid);\n    message.enableSimulcastLayers !== void 0 && (obj.enableSimulcastLayers = message.enableSimulcastLayers);\n    return obj;\n  },\n  create(base) {\n    return SimulcastCodec.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseSimulcastCodec();\n    message.codec = (_a = object.codec) !== null && _a !== void 0 ? _a : \"\";\n    message.cid = (_b = object.cid) !== null && _b !== void 0 ? _b : \"\";\n    message.enableSimulcastLayers = (_c = object.enableSimulcastLayers) !== null && _c !== void 0 ? _c : false;\n    return message;\n  }\n};\nfunction createBaseAddTrackRequest() {\n  return {\n    cid: \"\",\n    name: \"\",\n    type: 0,\n    width: 0,\n    height: 0,\n    muted: false,\n    disableDtx: false,\n    source: 0,\n    layers: [],\n    simulcastCodecs: [],\n    sid: \"\",\n    stereo: false,\n    disableRed: false,\n    encryption: 0\n  };\n}\nvar AddTrackRequest = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.cid !== \"\") {\n      writer2.uint32(10).string(message.cid);\n    }\n    if (message.name !== \"\") {\n      writer2.uint32(18).string(message.name);\n    }\n    if (message.type !== 0) {\n      writer2.uint32(24).int32(message.type);\n    }\n    if (message.width !== 0) {\n      writer2.uint32(32).uint32(message.width);\n    }\n    if (message.height !== 0) {\n      writer2.uint32(40).uint32(message.height);\n    }\n    if (message.muted === true) {\n      writer2.uint32(48).bool(message.muted);\n    }\n    if (message.disableDtx === true) {\n      writer2.uint32(56).bool(message.disableDtx);\n    }\n    if (message.source !== 0) {\n      writer2.uint32(64).int32(message.source);\n    }\n    for (const v of message.layers) {\n      VideoLayer.encode(v, writer2.uint32(74).fork()).ldelim();\n    }\n    for (const v of message.simulcastCodecs) {\n      SimulcastCodec.encode(v, writer2.uint32(82).fork()).ldelim();\n    }\n    if (message.sid !== \"\") {\n      writer2.uint32(90).string(message.sid);\n    }\n    if (message.stereo === true) {\n      writer2.uint32(96).bool(message.stereo);\n    }\n    if (message.disableRed === true) {\n      writer2.uint32(104).bool(message.disableRed);\n    }\n    if (message.encryption !== 0) {\n      writer2.uint32(112).int32(message.encryption);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseAddTrackRequest();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.cid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.name = reader2.string();\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.type = reader2.int32();\n          continue;\n        case 4:\n          if (tag != 32) {\n            break;\n          }\n          message.width = reader2.uint32();\n          continue;\n        case 5:\n          if (tag != 40) {\n            break;\n          }\n          message.height = reader2.uint32();\n          continue;\n        case 6:\n          if (tag != 48) {\n            break;\n          }\n          message.muted = reader2.bool();\n          continue;\n        case 7:\n          if (tag != 56) {\n            break;\n          }\n          message.disableDtx = reader2.bool();\n          continue;\n        case 8:\n          if (tag != 64) {\n            break;\n          }\n          message.source = reader2.int32();\n          continue;\n        case 9:\n          if (tag != 74) {\n            break;\n          }\n          message.layers.push(VideoLayer.decode(reader2, reader2.uint32()));\n          continue;\n        case 10:\n          if (tag != 82) {\n            break;\n          }\n          message.simulcastCodecs.push(SimulcastCodec.decode(reader2, reader2.uint32()));\n          continue;\n        case 11:\n          if (tag != 90) {\n            break;\n          }\n          message.sid = reader2.string();\n          continue;\n        case 12:\n          if (tag != 96) {\n            break;\n          }\n          message.stereo = reader2.bool();\n          continue;\n        case 13:\n          if (tag != 104) {\n            break;\n          }\n          message.disableRed = reader2.bool();\n          continue;\n        case 14:\n          if (tag != 112) {\n            break;\n          }\n          message.encryption = reader2.int32();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      cid: isSet(object.cid) ? String(object.cid) : \"\",\n      name: isSet(object.name) ? String(object.name) : \"\",\n      type: isSet(object.type) ? trackTypeFromJSON(object.type) : 0,\n      width: isSet(object.width) ? Number(object.width) : 0,\n      height: isSet(object.height) ? Number(object.height) : 0,\n      muted: isSet(object.muted) ? Boolean(object.muted) : false,\n      disableDtx: isSet(object.disableDtx) ? Boolean(object.disableDtx) : false,\n      source: isSet(object.source) ? trackSourceFromJSON(object.source) : 0,\n      layers: Array.isArray(object === null || object === void 0 ? void 0 : object.layers) ? object.layers.map((e) => VideoLayer.fromJSON(e)) : [],\n      simulcastCodecs: Array.isArray(object === null || object === void 0 ? void 0 : object.simulcastCodecs) ? object.simulcastCodecs.map((e) => SimulcastCodec.fromJSON(e)) : [],\n      sid: isSet(object.sid) ? String(object.sid) : \"\",\n      stereo: isSet(object.stereo) ? Boolean(object.stereo) : false,\n      disableRed: isSet(object.disableRed) ? Boolean(object.disableRed) : false,\n      encryption: isSet(object.encryption) ? encryption_TypeFromJSON(object.encryption) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.cid !== void 0 && (obj.cid = message.cid);\n    message.name !== void 0 && (obj.name = message.name);\n    message.type !== void 0 && (obj.type = trackTypeToJSON(message.type));\n    message.width !== void 0 && (obj.width = Math.round(message.width));\n    message.height !== void 0 && (obj.height = Math.round(message.height));\n    message.muted !== void 0 && (obj.muted = message.muted);\n    message.disableDtx !== void 0 && (obj.disableDtx = message.disableDtx);\n    message.source !== void 0 && (obj.source = trackSourceToJSON(message.source));\n    if (message.layers) {\n      obj.layers = message.layers.map((e) => e ? VideoLayer.toJSON(e) : void 0);\n    } else {\n      obj.layers = [];\n    }\n    if (message.simulcastCodecs) {\n      obj.simulcastCodecs = message.simulcastCodecs.map((e) => e ? SimulcastCodec.toJSON(e) : void 0);\n    } else {\n      obj.simulcastCodecs = [];\n    }\n    message.sid !== void 0 && (obj.sid = message.sid);\n    message.stereo !== void 0 && (obj.stereo = message.stereo);\n    message.disableRed !== void 0 && (obj.disableRed = message.disableRed);\n    message.encryption !== void 0 && (obj.encryption = encryption_TypeToJSON(message.encryption));\n    return obj;\n  },\n  create(base) {\n    return AddTrackRequest.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;\n    const message = createBaseAddTrackRequest();\n    message.cid = (_a = object.cid) !== null && _a !== void 0 ? _a : \"\";\n    message.name = (_b = object.name) !== null && _b !== void 0 ? _b : \"\";\n    message.type = (_c = object.type) !== null && _c !== void 0 ? _c : 0;\n    message.width = (_d = object.width) !== null && _d !== void 0 ? _d : 0;\n    message.height = (_e = object.height) !== null && _e !== void 0 ? _e : 0;\n    message.muted = (_f = object.muted) !== null && _f !== void 0 ? _f : false;\n    message.disableDtx = (_g = object.disableDtx) !== null && _g !== void 0 ? _g : false;\n    message.source = (_h = object.source) !== null && _h !== void 0 ? _h : 0;\n    message.layers = ((_j = object.layers) === null || _j === void 0 ? void 0 : _j.map((e) => VideoLayer.fromPartial(e))) || [];\n    message.simulcastCodecs = ((_k = object.simulcastCodecs) === null || _k === void 0 ? void 0 : _k.map((e) => SimulcastCodec.fromPartial(e))) || [];\n    message.sid = (_l = object.sid) !== null && _l !== void 0 ? _l : \"\";\n    message.stereo = (_m = object.stereo) !== null && _m !== void 0 ? _m : false;\n    message.disableRed = (_o = object.disableRed) !== null && _o !== void 0 ? _o : false;\n    message.encryption = (_p = object.encryption) !== null && _p !== void 0 ? _p : 0;\n    return message;\n  }\n};\nfunction createBaseTrickleRequest() {\n  return {\n    candidateInit: \"\",\n    target: 0\n  };\n}\nvar TrickleRequest = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.candidateInit !== \"\") {\n      writer2.uint32(10).string(message.candidateInit);\n    }\n    if (message.target !== 0) {\n      writer2.uint32(16).int32(message.target);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseTrickleRequest();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.candidateInit = reader2.string();\n          continue;\n        case 2:\n          if (tag != 16) {\n            break;\n          }\n          message.target = reader2.int32();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      candidateInit: isSet(object.candidateInit) ? String(object.candidateInit) : \"\",\n      target: isSet(object.target) ? signalTargetFromJSON(object.target) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.candidateInit !== void 0 && (obj.candidateInit = message.candidateInit);\n    message.target !== void 0 && (obj.target = signalTargetToJSON(message.target));\n    return obj;\n  },\n  create(base) {\n    return TrickleRequest.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseTrickleRequest();\n    message.candidateInit = (_a = object.candidateInit) !== null && _a !== void 0 ? _a : \"\";\n    message.target = (_b = object.target) !== null && _b !== void 0 ? _b : 0;\n    return message;\n  }\n};\nfunction createBaseMuteTrackRequest() {\n  return {\n    sid: \"\",\n    muted: false\n  };\n}\nvar MuteTrackRequest = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.sid !== \"\") {\n      writer2.uint32(10).string(message.sid);\n    }\n    if (message.muted === true) {\n      writer2.uint32(16).bool(message.muted);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseMuteTrackRequest();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.sid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 16) {\n            break;\n          }\n          message.muted = reader2.bool();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      sid: isSet(object.sid) ? String(object.sid) : \"\",\n      muted: isSet(object.muted) ? Boolean(object.muted) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.sid !== void 0 && (obj.sid = message.sid);\n    message.muted !== void 0 && (obj.muted = message.muted);\n    return obj;\n  },\n  create(base) {\n    return MuteTrackRequest.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseMuteTrackRequest();\n    message.sid = (_a = object.sid) !== null && _a !== void 0 ? _a : \"\";\n    message.muted = (_b = object.muted) !== null && _b !== void 0 ? _b : false;\n    return message;\n  }\n};\nfunction createBaseJoinResponse() {\n  return {\n    room: void 0,\n    participant: void 0,\n    otherParticipants: [],\n    serverVersion: \"\",\n    iceServers: [],\n    subscriberPrimary: false,\n    alternativeUrl: \"\",\n    clientConfiguration: void 0,\n    serverRegion: \"\",\n    pingTimeout: 0,\n    pingInterval: 0,\n    serverInfo: void 0\n  };\n}\nvar JoinResponse = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.room !== void 0) {\n      Room$1.encode(message.room, writer2.uint32(10).fork()).ldelim();\n    }\n    if (message.participant !== void 0) {\n      ParticipantInfo.encode(message.participant, writer2.uint32(18).fork()).ldelim();\n    }\n    for (const v of message.otherParticipants) {\n      ParticipantInfo.encode(v, writer2.uint32(26).fork()).ldelim();\n    }\n    if (message.serverVersion !== \"\") {\n      writer2.uint32(34).string(message.serverVersion);\n    }\n    for (const v of message.iceServers) {\n      ICEServer.encode(v, writer2.uint32(42).fork()).ldelim();\n    }\n    if (message.subscriberPrimary === true) {\n      writer2.uint32(48).bool(message.subscriberPrimary);\n    }\n    if (message.alternativeUrl !== \"\") {\n      writer2.uint32(58).string(message.alternativeUrl);\n    }\n    if (message.clientConfiguration !== void 0) {\n      ClientConfiguration.encode(message.clientConfiguration, writer2.uint32(66).fork()).ldelim();\n    }\n    if (message.serverRegion !== \"\") {\n      writer2.uint32(74).string(message.serverRegion);\n    }\n    if (message.pingTimeout !== 0) {\n      writer2.uint32(80).int32(message.pingTimeout);\n    }\n    if (message.pingInterval !== 0) {\n      writer2.uint32(88).int32(message.pingInterval);\n    }\n    if (message.serverInfo !== void 0) {\n      ServerInfo.encode(message.serverInfo, writer2.uint32(98).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseJoinResponse();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.room = Room$1.decode(reader2, reader2.uint32());\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.participant = ParticipantInfo.decode(reader2, reader2.uint32());\n          continue;\n        case 3:\n          if (tag != 26) {\n            break;\n          }\n          message.otherParticipants.push(ParticipantInfo.decode(reader2, reader2.uint32()));\n          continue;\n        case 4:\n          if (tag != 34) {\n            break;\n          }\n          message.serverVersion = reader2.string();\n          continue;\n        case 5:\n          if (tag != 42) {\n            break;\n          }\n          message.iceServers.push(ICEServer.decode(reader2, reader2.uint32()));\n          continue;\n        case 6:\n          if (tag != 48) {\n            break;\n          }\n          message.subscriberPrimary = reader2.bool();\n          continue;\n        case 7:\n          if (tag != 58) {\n            break;\n          }\n          message.alternativeUrl = reader2.string();\n          continue;\n        case 8:\n          if (tag != 66) {\n            break;\n          }\n          message.clientConfiguration = ClientConfiguration.decode(reader2, reader2.uint32());\n          continue;\n        case 9:\n          if (tag != 74) {\n            break;\n          }\n          message.serverRegion = reader2.string();\n          continue;\n        case 10:\n          if (tag != 80) {\n            break;\n          }\n          message.pingTimeout = reader2.int32();\n          continue;\n        case 11:\n          if (tag != 88) {\n            break;\n          }\n          message.pingInterval = reader2.int32();\n          continue;\n        case 12:\n          if (tag != 98) {\n            break;\n          }\n          message.serverInfo = ServerInfo.decode(reader2, reader2.uint32());\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      room: isSet(object.room) ? Room$1.fromJSON(object.room) : void 0,\n      participant: isSet(object.participant) ? ParticipantInfo.fromJSON(object.participant) : void 0,\n      otherParticipants: Array.isArray(object === null || object === void 0 ? void 0 : object.otherParticipants) ? object.otherParticipants.map((e) => ParticipantInfo.fromJSON(e)) : [],\n      serverVersion: isSet(object.serverVersion) ? String(object.serverVersion) : \"\",\n      iceServers: Array.isArray(object === null || object === void 0 ? void 0 : object.iceServers) ? object.iceServers.map((e) => ICEServer.fromJSON(e)) : [],\n      subscriberPrimary: isSet(object.subscriberPrimary) ? Boolean(object.subscriberPrimary) : false,\n      alternativeUrl: isSet(object.alternativeUrl) ? String(object.alternativeUrl) : \"\",\n      clientConfiguration: isSet(object.clientConfiguration) ? ClientConfiguration.fromJSON(object.clientConfiguration) : void 0,\n      serverRegion: isSet(object.serverRegion) ? String(object.serverRegion) : \"\",\n      pingTimeout: isSet(object.pingTimeout) ? Number(object.pingTimeout) : 0,\n      pingInterval: isSet(object.pingInterval) ? Number(object.pingInterval) : 0,\n      serverInfo: isSet(object.serverInfo) ? ServerInfo.fromJSON(object.serverInfo) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.room !== void 0 && (obj.room = message.room ? Room$1.toJSON(message.room) : void 0);\n    message.participant !== void 0 && (obj.participant = message.participant ? ParticipantInfo.toJSON(message.participant) : void 0);\n    if (message.otherParticipants) {\n      obj.otherParticipants = message.otherParticipants.map((e) => e ? ParticipantInfo.toJSON(e) : void 0);\n    } else {\n      obj.otherParticipants = [];\n    }\n    message.serverVersion !== void 0 && (obj.serverVersion = message.serverVersion);\n    if (message.iceServers) {\n      obj.iceServers = message.iceServers.map((e) => e ? ICEServer.toJSON(e) : void 0);\n    } else {\n      obj.iceServers = [];\n    }\n    message.subscriberPrimary !== void 0 && (obj.subscriberPrimary = message.subscriberPrimary);\n    message.alternativeUrl !== void 0 && (obj.alternativeUrl = message.alternativeUrl);\n    message.clientConfiguration !== void 0 && (obj.clientConfiguration = message.clientConfiguration ? ClientConfiguration.toJSON(message.clientConfiguration) : void 0);\n    message.serverRegion !== void 0 && (obj.serverRegion = message.serverRegion);\n    message.pingTimeout !== void 0 && (obj.pingTimeout = Math.round(message.pingTimeout));\n    message.pingInterval !== void 0 && (obj.pingInterval = Math.round(message.pingInterval));\n    message.serverInfo !== void 0 && (obj.serverInfo = message.serverInfo ? ServerInfo.toJSON(message.serverInfo) : void 0);\n    return obj;\n  },\n  create(base) {\n    return JoinResponse.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const message = createBaseJoinResponse();\n    message.room = object.room !== void 0 && object.room !== null ? Room$1.fromPartial(object.room) : void 0;\n    message.participant = object.participant !== void 0 && object.participant !== null ? ParticipantInfo.fromPartial(object.participant) : void 0;\n    message.otherParticipants = ((_a = object.otherParticipants) === null || _a === void 0 ? void 0 : _a.map((e) => ParticipantInfo.fromPartial(e))) || [];\n    message.serverVersion = (_b = object.serverVersion) !== null && _b !== void 0 ? _b : \"\";\n    message.iceServers = ((_c = object.iceServers) === null || _c === void 0 ? void 0 : _c.map((e) => ICEServer.fromPartial(e))) || [];\n    message.subscriberPrimary = (_d = object.subscriberPrimary) !== null && _d !== void 0 ? _d : false;\n    message.alternativeUrl = (_e = object.alternativeUrl) !== null && _e !== void 0 ? _e : \"\";\n    message.clientConfiguration = object.clientConfiguration !== void 0 && object.clientConfiguration !== null ? ClientConfiguration.fromPartial(object.clientConfiguration) : void 0;\n    message.serverRegion = (_f = object.serverRegion) !== null && _f !== void 0 ? _f : \"\";\n    message.pingTimeout = (_g = object.pingTimeout) !== null && _g !== void 0 ? _g : 0;\n    message.pingInterval = (_h = object.pingInterval) !== null && _h !== void 0 ? _h : 0;\n    message.serverInfo = object.serverInfo !== void 0 && object.serverInfo !== null ? ServerInfo.fromPartial(object.serverInfo) : void 0;\n    return message;\n  }\n};\nfunction createBaseReconnectResponse() {\n  return {\n    iceServers: [],\n    clientConfiguration: void 0\n  };\n}\nvar ReconnectResponse = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    for (const v of message.iceServers) {\n      ICEServer.encode(v, writer2.uint32(10).fork()).ldelim();\n    }\n    if (message.clientConfiguration !== void 0) {\n      ClientConfiguration.encode(message.clientConfiguration, writer2.uint32(18).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseReconnectResponse();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.iceServers.push(ICEServer.decode(reader2, reader2.uint32()));\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.clientConfiguration = ClientConfiguration.decode(reader2, reader2.uint32());\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      iceServers: Array.isArray(object === null || object === void 0 ? void 0 : object.iceServers) ? object.iceServers.map((e) => ICEServer.fromJSON(e)) : [],\n      clientConfiguration: isSet(object.clientConfiguration) ? ClientConfiguration.fromJSON(object.clientConfiguration) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.iceServers) {\n      obj.iceServers = message.iceServers.map((e) => e ? ICEServer.toJSON(e) : void 0);\n    } else {\n      obj.iceServers = [];\n    }\n    message.clientConfiguration !== void 0 && (obj.clientConfiguration = message.clientConfiguration ? ClientConfiguration.toJSON(message.clientConfiguration) : void 0);\n    return obj;\n  },\n  create(base) {\n    return ReconnectResponse.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseReconnectResponse();\n    message.iceServers = ((_a = object.iceServers) === null || _a === void 0 ? void 0 : _a.map((e) => ICEServer.fromPartial(e))) || [];\n    message.clientConfiguration = object.clientConfiguration !== void 0 && object.clientConfiguration !== null ? ClientConfiguration.fromPartial(object.clientConfiguration) : void 0;\n    return message;\n  }\n};\nfunction createBaseTrackPublishedResponse() {\n  return {\n    cid: \"\",\n    track: void 0\n  };\n}\nvar TrackPublishedResponse = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.cid !== \"\") {\n      writer2.uint32(10).string(message.cid);\n    }\n    if (message.track !== void 0) {\n      TrackInfo.encode(message.track, writer2.uint32(18).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseTrackPublishedResponse();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.cid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.track = TrackInfo.decode(reader2, reader2.uint32());\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      cid: isSet(object.cid) ? String(object.cid) : \"\",\n      track: isSet(object.track) ? TrackInfo.fromJSON(object.track) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.cid !== void 0 && (obj.cid = message.cid);\n    message.track !== void 0 && (obj.track = message.track ? TrackInfo.toJSON(message.track) : void 0);\n    return obj;\n  },\n  create(base) {\n    return TrackPublishedResponse.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseTrackPublishedResponse();\n    message.cid = (_a = object.cid) !== null && _a !== void 0 ? _a : \"\";\n    message.track = object.track !== void 0 && object.track !== null ? TrackInfo.fromPartial(object.track) : void 0;\n    return message;\n  }\n};\nfunction createBaseTrackUnpublishedResponse() {\n  return {\n    trackSid: \"\"\n  };\n}\nvar TrackUnpublishedResponse = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.trackSid !== \"\") {\n      writer2.uint32(10).string(message.trackSid);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseTrackUnpublishedResponse();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.trackSid = reader2.string();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      trackSid: isSet(object.trackSid) ? String(object.trackSid) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.trackSid !== void 0 && (obj.trackSid = message.trackSid);\n    return obj;\n  },\n  create(base) {\n    return TrackUnpublishedResponse.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseTrackUnpublishedResponse();\n    message.trackSid = (_a = object.trackSid) !== null && _a !== void 0 ? _a : \"\";\n    return message;\n  }\n};\nfunction createBaseSessionDescription() {\n  return {\n    type: \"\",\n    sdp: \"\"\n  };\n}\nvar SessionDescription = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.type !== \"\") {\n      writer2.uint32(10).string(message.type);\n    }\n    if (message.sdp !== \"\") {\n      writer2.uint32(18).string(message.sdp);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseSessionDescription();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.type = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.sdp = reader2.string();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      type: isSet(object.type) ? String(object.type) : \"\",\n      sdp: isSet(object.sdp) ? String(object.sdp) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.type !== void 0 && (obj.type = message.type);\n    message.sdp !== void 0 && (obj.sdp = message.sdp);\n    return obj;\n  },\n  create(base) {\n    return SessionDescription.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseSessionDescription();\n    message.type = (_a = object.type) !== null && _a !== void 0 ? _a : \"\";\n    message.sdp = (_b = object.sdp) !== null && _b !== void 0 ? _b : \"\";\n    return message;\n  }\n};\nfunction createBaseParticipantUpdate() {\n  return {\n    participants: []\n  };\n}\nvar ParticipantUpdate = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    for (const v of message.participants) {\n      ParticipantInfo.encode(v, writer2.uint32(10).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseParticipantUpdate();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.participants.push(ParticipantInfo.decode(reader2, reader2.uint32()));\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      participants: Array.isArray(object === null || object === void 0 ? void 0 : object.participants) ? object.participants.map((e) => ParticipantInfo.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.participants) {\n      obj.participants = message.participants.map((e) => e ? ParticipantInfo.toJSON(e) : void 0);\n    } else {\n      obj.participants = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return ParticipantUpdate.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseParticipantUpdate();\n    message.participants = ((_a = object.participants) === null || _a === void 0 ? void 0 : _a.map((e) => ParticipantInfo.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseUpdateSubscription() {\n  return {\n    trackSids: [],\n    subscribe: false,\n    participantTracks: []\n  };\n}\nvar UpdateSubscription = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    for (const v of message.trackSids) {\n      writer2.uint32(10).string(v);\n    }\n    if (message.subscribe === true) {\n      writer2.uint32(16).bool(message.subscribe);\n    }\n    for (const v of message.participantTracks) {\n      ParticipantTracks.encode(v, writer2.uint32(26).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseUpdateSubscription();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.trackSids.push(reader2.string());\n          continue;\n        case 2:\n          if (tag != 16) {\n            break;\n          }\n          message.subscribe = reader2.bool();\n          continue;\n        case 3:\n          if (tag != 26) {\n            break;\n          }\n          message.participantTracks.push(ParticipantTracks.decode(reader2, reader2.uint32()));\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      trackSids: Array.isArray(object === null || object === void 0 ? void 0 : object.trackSids) ? object.trackSids.map((e) => String(e)) : [],\n      subscribe: isSet(object.subscribe) ? Boolean(object.subscribe) : false,\n      participantTracks: Array.isArray(object === null || object === void 0 ? void 0 : object.participantTracks) ? object.participantTracks.map((e) => ParticipantTracks.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.trackSids) {\n      obj.trackSids = message.trackSids.map((e) => e);\n    } else {\n      obj.trackSids = [];\n    }\n    message.subscribe !== void 0 && (obj.subscribe = message.subscribe);\n    if (message.participantTracks) {\n      obj.participantTracks = message.participantTracks.map((e) => e ? ParticipantTracks.toJSON(e) : void 0);\n    } else {\n      obj.participantTracks = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return UpdateSubscription.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseUpdateSubscription();\n    message.trackSids = ((_a = object.trackSids) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n    message.subscribe = (_b = object.subscribe) !== null && _b !== void 0 ? _b : false;\n    message.participantTracks = ((_c = object.participantTracks) === null || _c === void 0 ? void 0 : _c.map((e) => ParticipantTracks.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseUpdateTrackSettings() {\n  return {\n    trackSids: [],\n    disabled: false,\n    quality: 0,\n    width: 0,\n    height: 0,\n    fps: 0,\n    priority: 0\n  };\n}\nvar UpdateTrackSettings = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    for (const v of message.trackSids) {\n      writer2.uint32(10).string(v);\n    }\n    if (message.disabled === true) {\n      writer2.uint32(24).bool(message.disabled);\n    }\n    if (message.quality !== 0) {\n      writer2.uint32(32).int32(message.quality);\n    }\n    if (message.width !== 0) {\n      writer2.uint32(40).uint32(message.width);\n    }\n    if (message.height !== 0) {\n      writer2.uint32(48).uint32(message.height);\n    }\n    if (message.fps !== 0) {\n      writer2.uint32(56).uint32(message.fps);\n    }\n    if (message.priority !== 0) {\n      writer2.uint32(64).uint32(message.priority);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseUpdateTrackSettings();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.trackSids.push(reader2.string());\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.disabled = reader2.bool();\n          continue;\n        case 4:\n          if (tag != 32) {\n            break;\n          }\n          message.quality = reader2.int32();\n          continue;\n        case 5:\n          if (tag != 40) {\n            break;\n          }\n          message.width = reader2.uint32();\n          continue;\n        case 6:\n          if (tag != 48) {\n            break;\n          }\n          message.height = reader2.uint32();\n          continue;\n        case 7:\n          if (tag != 56) {\n            break;\n          }\n          message.fps = reader2.uint32();\n          continue;\n        case 8:\n          if (tag != 64) {\n            break;\n          }\n          message.priority = reader2.uint32();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      trackSids: Array.isArray(object === null || object === void 0 ? void 0 : object.trackSids) ? object.trackSids.map((e) => String(e)) : [],\n      disabled: isSet(object.disabled) ? Boolean(object.disabled) : false,\n      quality: isSet(object.quality) ? videoQualityFromJSON(object.quality) : 0,\n      width: isSet(object.width) ? Number(object.width) : 0,\n      height: isSet(object.height) ? Number(object.height) : 0,\n      fps: isSet(object.fps) ? Number(object.fps) : 0,\n      priority: isSet(object.priority) ? Number(object.priority) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.trackSids) {\n      obj.trackSids = message.trackSids.map((e) => e);\n    } else {\n      obj.trackSids = [];\n    }\n    message.disabled !== void 0 && (obj.disabled = message.disabled);\n    message.quality !== void 0 && (obj.quality = videoQualityToJSON(message.quality));\n    message.width !== void 0 && (obj.width = Math.round(message.width));\n    message.height !== void 0 && (obj.height = Math.round(message.height));\n    message.fps !== void 0 && (obj.fps = Math.round(message.fps));\n    message.priority !== void 0 && (obj.priority = Math.round(message.priority));\n    return obj;\n  },\n  create(base) {\n    return UpdateTrackSettings.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const message = createBaseUpdateTrackSettings();\n    message.trackSids = ((_a = object.trackSids) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n    message.disabled = (_b = object.disabled) !== null && _b !== void 0 ? _b : false;\n    message.quality = (_c = object.quality) !== null && _c !== void 0 ? _c : 0;\n    message.width = (_d = object.width) !== null && _d !== void 0 ? _d : 0;\n    message.height = (_e = object.height) !== null && _e !== void 0 ? _e : 0;\n    message.fps = (_f = object.fps) !== null && _f !== void 0 ? _f : 0;\n    message.priority = (_g = object.priority) !== null && _g !== void 0 ? _g : 0;\n    return message;\n  }\n};\nfunction createBaseLeaveRequest() {\n  return {\n    canReconnect: false,\n    reason: 0\n  };\n}\nvar LeaveRequest = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.canReconnect === true) {\n      writer2.uint32(8).bool(message.canReconnect);\n    }\n    if (message.reason !== 0) {\n      writer2.uint32(16).int32(message.reason);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseLeaveRequest();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 8) {\n            break;\n          }\n          message.canReconnect = reader2.bool();\n          continue;\n        case 2:\n          if (tag != 16) {\n            break;\n          }\n          message.reason = reader2.int32();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      canReconnect: isSet(object.canReconnect) ? Boolean(object.canReconnect) : false,\n      reason: isSet(object.reason) ? disconnectReasonFromJSON(object.reason) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.canReconnect !== void 0 && (obj.canReconnect = message.canReconnect);\n    message.reason !== void 0 && (obj.reason = disconnectReasonToJSON(message.reason));\n    return obj;\n  },\n  create(base) {\n    return LeaveRequest.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseLeaveRequest();\n    message.canReconnect = (_a = object.canReconnect) !== null && _a !== void 0 ? _a : false;\n    message.reason = (_b = object.reason) !== null && _b !== void 0 ? _b : 0;\n    return message;\n  }\n};\nfunction createBaseUpdateVideoLayers() {\n  return {\n    trackSid: \"\",\n    layers: []\n  };\n}\nvar UpdateVideoLayers = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.trackSid !== \"\") {\n      writer2.uint32(10).string(message.trackSid);\n    }\n    for (const v of message.layers) {\n      VideoLayer.encode(v, writer2.uint32(18).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseUpdateVideoLayers();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.trackSid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.layers.push(VideoLayer.decode(reader2, reader2.uint32()));\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      trackSid: isSet(object.trackSid) ? String(object.trackSid) : \"\",\n      layers: Array.isArray(object === null || object === void 0 ? void 0 : object.layers) ? object.layers.map((e) => VideoLayer.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.trackSid !== void 0 && (obj.trackSid = message.trackSid);\n    if (message.layers) {\n      obj.layers = message.layers.map((e) => e ? VideoLayer.toJSON(e) : void 0);\n    } else {\n      obj.layers = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return UpdateVideoLayers.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseUpdateVideoLayers();\n    message.trackSid = (_a = object.trackSid) !== null && _a !== void 0 ? _a : \"\";\n    message.layers = ((_b = object.layers) === null || _b === void 0 ? void 0 : _b.map((e) => VideoLayer.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseUpdateParticipantMetadata() {\n  return {\n    metadata: \"\",\n    name: \"\"\n  };\n}\nvar UpdateParticipantMetadata = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.metadata !== \"\") {\n      writer2.uint32(10).string(message.metadata);\n    }\n    if (message.name !== \"\") {\n      writer2.uint32(18).string(message.name);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseUpdateParticipantMetadata();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.metadata = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.name = reader2.string();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      metadata: isSet(object.metadata) ? String(object.metadata) : \"\",\n      name: isSet(object.name) ? String(object.name) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.metadata !== void 0 && (obj.metadata = message.metadata);\n    message.name !== void 0 && (obj.name = message.name);\n    return obj;\n  },\n  create(base) {\n    return UpdateParticipantMetadata.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseUpdateParticipantMetadata();\n    message.metadata = (_a = object.metadata) !== null && _a !== void 0 ? _a : \"\";\n    message.name = (_b = object.name) !== null && _b !== void 0 ? _b : \"\";\n    return message;\n  }\n};\nfunction createBaseICEServer() {\n  return {\n    urls: [],\n    username: \"\",\n    credential: \"\"\n  };\n}\nvar ICEServer = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    for (const v of message.urls) {\n      writer2.uint32(10).string(v);\n    }\n    if (message.username !== \"\") {\n      writer2.uint32(18).string(message.username);\n    }\n    if (message.credential !== \"\") {\n      writer2.uint32(26).string(message.credential);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseICEServer();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.urls.push(reader2.string());\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.username = reader2.string();\n          continue;\n        case 3:\n          if (tag != 26) {\n            break;\n          }\n          message.credential = reader2.string();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      urls: Array.isArray(object === null || object === void 0 ? void 0 : object.urls) ? object.urls.map((e) => String(e)) : [],\n      username: isSet(object.username) ? String(object.username) : \"\",\n      credential: isSet(object.credential) ? String(object.credential) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.urls) {\n      obj.urls = message.urls.map((e) => e);\n    } else {\n      obj.urls = [];\n    }\n    message.username !== void 0 && (obj.username = message.username);\n    message.credential !== void 0 && (obj.credential = message.credential);\n    return obj;\n  },\n  create(base) {\n    return ICEServer.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseICEServer();\n    message.urls = ((_a = object.urls) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n    message.username = (_b = object.username) !== null && _b !== void 0 ? _b : \"\";\n    message.credential = (_c = object.credential) !== null && _c !== void 0 ? _c : \"\";\n    return message;\n  }\n};\nfunction createBaseSpeakersChanged() {\n  return {\n    speakers: []\n  };\n}\nvar SpeakersChanged = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    for (const v of message.speakers) {\n      SpeakerInfo.encode(v, writer2.uint32(10).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseSpeakersChanged();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.speakers.push(SpeakerInfo.decode(reader2, reader2.uint32()));\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      speakers: Array.isArray(object === null || object === void 0 ? void 0 : object.speakers) ? object.speakers.map((e) => SpeakerInfo.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.speakers) {\n      obj.speakers = message.speakers.map((e) => e ? SpeakerInfo.toJSON(e) : void 0);\n    } else {\n      obj.speakers = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return SpeakersChanged.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseSpeakersChanged();\n    message.speakers = ((_a = object.speakers) === null || _a === void 0 ? void 0 : _a.map((e) => SpeakerInfo.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseRoomUpdate() {\n  return {\n    room: void 0\n  };\n}\nvar RoomUpdate = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.room !== void 0) {\n      Room$1.encode(message.room, writer2.uint32(10).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseRoomUpdate();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.room = Room$1.decode(reader2, reader2.uint32());\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      room: isSet(object.room) ? Room$1.fromJSON(object.room) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.room !== void 0 && (obj.room = message.room ? Room$1.toJSON(message.room) : void 0);\n    return obj;\n  },\n  create(base) {\n    return RoomUpdate.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    const message = createBaseRoomUpdate();\n    message.room = object.room !== void 0 && object.room !== null ? Room$1.fromPartial(object.room) : void 0;\n    return message;\n  }\n};\nfunction createBaseConnectionQualityInfo() {\n  return {\n    participantSid: \"\",\n    quality: 0,\n    score: 0\n  };\n}\nvar ConnectionQualityInfo = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.participantSid !== \"\") {\n      writer2.uint32(10).string(message.participantSid);\n    }\n    if (message.quality !== 0) {\n      writer2.uint32(16).int32(message.quality);\n    }\n    if (message.score !== 0) {\n      writer2.uint32(29).float(message.score);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseConnectionQualityInfo();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.participantSid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 16) {\n            break;\n          }\n          message.quality = reader2.int32();\n          continue;\n        case 3:\n          if (tag != 29) {\n            break;\n          }\n          message.score = reader2.float();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      participantSid: isSet(object.participantSid) ? String(object.participantSid) : \"\",\n      quality: isSet(object.quality) ? connectionQualityFromJSON(object.quality) : 0,\n      score: isSet(object.score) ? Number(object.score) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.participantSid !== void 0 && (obj.participantSid = message.participantSid);\n    message.quality !== void 0 && (obj.quality = connectionQualityToJSON(message.quality));\n    message.score !== void 0 && (obj.score = message.score);\n    return obj;\n  },\n  create(base) {\n    return ConnectionQualityInfo.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseConnectionQualityInfo();\n    message.participantSid = (_a = object.participantSid) !== null && _a !== void 0 ? _a : \"\";\n    message.quality = (_b = object.quality) !== null && _b !== void 0 ? _b : 0;\n    message.score = (_c = object.score) !== null && _c !== void 0 ? _c : 0;\n    return message;\n  }\n};\nfunction createBaseConnectionQualityUpdate() {\n  return {\n    updates: []\n  };\n}\nvar ConnectionQualityUpdate = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    for (const v of message.updates) {\n      ConnectionQualityInfo.encode(v, writer2.uint32(10).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseConnectionQualityUpdate();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.updates.push(ConnectionQualityInfo.decode(reader2, reader2.uint32()));\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      updates: Array.isArray(object === null || object === void 0 ? void 0 : object.updates) ? object.updates.map((e) => ConnectionQualityInfo.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.updates) {\n      obj.updates = message.updates.map((e) => e ? ConnectionQualityInfo.toJSON(e) : void 0);\n    } else {\n      obj.updates = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return ConnectionQualityUpdate.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseConnectionQualityUpdate();\n    message.updates = ((_a = object.updates) === null || _a === void 0 ? void 0 : _a.map((e) => ConnectionQualityInfo.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseStreamStateInfo() {\n  return {\n    participantSid: \"\",\n    trackSid: \"\",\n    state: 0\n  };\n}\nvar StreamStateInfo = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.participantSid !== \"\") {\n      writer2.uint32(10).string(message.participantSid);\n    }\n    if (message.trackSid !== \"\") {\n      writer2.uint32(18).string(message.trackSid);\n    }\n    if (message.state !== 0) {\n      writer2.uint32(24).int32(message.state);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseStreamStateInfo();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.participantSid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.trackSid = reader2.string();\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.state = reader2.int32();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      participantSid: isSet(object.participantSid) ? String(object.participantSid) : \"\",\n      trackSid: isSet(object.trackSid) ? String(object.trackSid) : \"\",\n      state: isSet(object.state) ? streamStateFromJSON(object.state) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.participantSid !== void 0 && (obj.participantSid = message.participantSid);\n    message.trackSid !== void 0 && (obj.trackSid = message.trackSid);\n    message.state !== void 0 && (obj.state = streamStateToJSON(message.state));\n    return obj;\n  },\n  create(base) {\n    return StreamStateInfo.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseStreamStateInfo();\n    message.participantSid = (_a = object.participantSid) !== null && _a !== void 0 ? _a : \"\";\n    message.trackSid = (_b = object.trackSid) !== null && _b !== void 0 ? _b : \"\";\n    message.state = (_c = object.state) !== null && _c !== void 0 ? _c : 0;\n    return message;\n  }\n};\nfunction createBaseStreamStateUpdate() {\n  return {\n    streamStates: []\n  };\n}\nvar StreamStateUpdate = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    for (const v of message.streamStates) {\n      StreamStateInfo.encode(v, writer2.uint32(10).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseStreamStateUpdate();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.streamStates.push(StreamStateInfo.decode(reader2, reader2.uint32()));\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      streamStates: Array.isArray(object === null || object === void 0 ? void 0 : object.streamStates) ? object.streamStates.map((e) => StreamStateInfo.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.streamStates) {\n      obj.streamStates = message.streamStates.map((e) => e ? StreamStateInfo.toJSON(e) : void 0);\n    } else {\n      obj.streamStates = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return StreamStateUpdate.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseStreamStateUpdate();\n    message.streamStates = ((_a = object.streamStates) === null || _a === void 0 ? void 0 : _a.map((e) => StreamStateInfo.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseSubscribedQuality() {\n  return {\n    quality: 0,\n    enabled: false\n  };\n}\nvar SubscribedQuality = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.quality !== 0) {\n      writer2.uint32(8).int32(message.quality);\n    }\n    if (message.enabled === true) {\n      writer2.uint32(16).bool(message.enabled);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseSubscribedQuality();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 8) {\n            break;\n          }\n          message.quality = reader2.int32();\n          continue;\n        case 2:\n          if (tag != 16) {\n            break;\n          }\n          message.enabled = reader2.bool();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      quality: isSet(object.quality) ? videoQualityFromJSON(object.quality) : 0,\n      enabled: isSet(object.enabled) ? Boolean(object.enabled) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.quality !== void 0 && (obj.quality = videoQualityToJSON(message.quality));\n    message.enabled !== void 0 && (obj.enabled = message.enabled);\n    return obj;\n  },\n  create(base) {\n    return SubscribedQuality.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseSubscribedQuality();\n    message.quality = (_a = object.quality) !== null && _a !== void 0 ? _a : 0;\n    message.enabled = (_b = object.enabled) !== null && _b !== void 0 ? _b : false;\n    return message;\n  }\n};\nfunction createBaseSubscribedCodec() {\n  return {\n    codec: \"\",\n    qualities: []\n  };\n}\nvar SubscribedCodec = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.codec !== \"\") {\n      writer2.uint32(10).string(message.codec);\n    }\n    for (const v of message.qualities) {\n      SubscribedQuality.encode(v, writer2.uint32(18).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseSubscribedCodec();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.codec = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.qualities.push(SubscribedQuality.decode(reader2, reader2.uint32()));\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      codec: isSet(object.codec) ? String(object.codec) : \"\",\n      qualities: Array.isArray(object === null || object === void 0 ? void 0 : object.qualities) ? object.qualities.map((e) => SubscribedQuality.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.codec !== void 0 && (obj.codec = message.codec);\n    if (message.qualities) {\n      obj.qualities = message.qualities.map((e) => e ? SubscribedQuality.toJSON(e) : void 0);\n    } else {\n      obj.qualities = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return SubscribedCodec.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseSubscribedCodec();\n    message.codec = (_a = object.codec) !== null && _a !== void 0 ? _a : \"\";\n    message.qualities = ((_b = object.qualities) === null || _b === void 0 ? void 0 : _b.map((e) => SubscribedQuality.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseSubscribedQualityUpdate() {\n  return {\n    trackSid: \"\",\n    subscribedQualities: [],\n    subscribedCodecs: []\n  };\n}\nvar SubscribedQualityUpdate = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.trackSid !== \"\") {\n      writer2.uint32(10).string(message.trackSid);\n    }\n    for (const v of message.subscribedQualities) {\n      SubscribedQuality.encode(v, writer2.uint32(18).fork()).ldelim();\n    }\n    for (const v of message.subscribedCodecs) {\n      SubscribedCodec.encode(v, writer2.uint32(26).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseSubscribedQualityUpdate();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.trackSid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.subscribedQualities.push(SubscribedQuality.decode(reader2, reader2.uint32()));\n          continue;\n        case 3:\n          if (tag != 26) {\n            break;\n          }\n          message.subscribedCodecs.push(SubscribedCodec.decode(reader2, reader2.uint32()));\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      trackSid: isSet(object.trackSid) ? String(object.trackSid) : \"\",\n      subscribedQualities: Array.isArray(object === null || object === void 0 ? void 0 : object.subscribedQualities) ? object.subscribedQualities.map((e) => SubscribedQuality.fromJSON(e)) : [],\n      subscribedCodecs: Array.isArray(object === null || object === void 0 ? void 0 : object.subscribedCodecs) ? object.subscribedCodecs.map((e) => SubscribedCodec.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.trackSid !== void 0 && (obj.trackSid = message.trackSid);\n    if (message.subscribedQualities) {\n      obj.subscribedQualities = message.subscribedQualities.map((e) => e ? SubscribedQuality.toJSON(e) : void 0);\n    } else {\n      obj.subscribedQualities = [];\n    }\n    if (message.subscribedCodecs) {\n      obj.subscribedCodecs = message.subscribedCodecs.map((e) => e ? SubscribedCodec.toJSON(e) : void 0);\n    } else {\n      obj.subscribedCodecs = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return SubscribedQualityUpdate.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseSubscribedQualityUpdate();\n    message.trackSid = (_a = object.trackSid) !== null && _a !== void 0 ? _a : \"\";\n    message.subscribedQualities = ((_b = object.subscribedQualities) === null || _b === void 0 ? void 0 : _b.map((e) => SubscribedQuality.fromPartial(e))) || [];\n    message.subscribedCodecs = ((_c = object.subscribedCodecs) === null || _c === void 0 ? void 0 : _c.map((e) => SubscribedCodec.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseTrackPermission() {\n  return {\n    participantSid: \"\",\n    allTracks: false,\n    trackSids: [],\n    participantIdentity: \"\"\n  };\n}\nvar TrackPermission = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.participantSid !== \"\") {\n      writer2.uint32(10).string(message.participantSid);\n    }\n    if (message.allTracks === true) {\n      writer2.uint32(16).bool(message.allTracks);\n    }\n    for (const v of message.trackSids) {\n      writer2.uint32(26).string(v);\n    }\n    if (message.participantIdentity !== \"\") {\n      writer2.uint32(34).string(message.participantIdentity);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseTrackPermission();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.participantSid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 16) {\n            break;\n          }\n          message.allTracks = reader2.bool();\n          continue;\n        case 3:\n          if (tag != 26) {\n            break;\n          }\n          message.trackSids.push(reader2.string());\n          continue;\n        case 4:\n          if (tag != 34) {\n            break;\n          }\n          message.participantIdentity = reader2.string();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      participantSid: isSet(object.participantSid) ? String(object.participantSid) : \"\",\n      allTracks: isSet(object.allTracks) ? Boolean(object.allTracks) : false,\n      trackSids: Array.isArray(object === null || object === void 0 ? void 0 : object.trackSids) ? object.trackSids.map((e) => String(e)) : [],\n      participantIdentity: isSet(object.participantIdentity) ? String(object.participantIdentity) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.participantSid !== void 0 && (obj.participantSid = message.participantSid);\n    message.allTracks !== void 0 && (obj.allTracks = message.allTracks);\n    if (message.trackSids) {\n      obj.trackSids = message.trackSids.map((e) => e);\n    } else {\n      obj.trackSids = [];\n    }\n    message.participantIdentity !== void 0 && (obj.participantIdentity = message.participantIdentity);\n    return obj;\n  },\n  create(base) {\n    return TrackPermission.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseTrackPermission();\n    message.participantSid = (_a = object.participantSid) !== null && _a !== void 0 ? _a : \"\";\n    message.allTracks = (_b = object.allTracks) !== null && _b !== void 0 ? _b : false;\n    message.trackSids = ((_c = object.trackSids) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];\n    message.participantIdentity = (_d = object.participantIdentity) !== null && _d !== void 0 ? _d : \"\";\n    return message;\n  }\n};\nfunction createBaseSubscriptionPermission() {\n  return {\n    allParticipants: false,\n    trackPermissions: []\n  };\n}\nvar SubscriptionPermission = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.allParticipants === true) {\n      writer2.uint32(8).bool(message.allParticipants);\n    }\n    for (const v of message.trackPermissions) {\n      TrackPermission.encode(v, writer2.uint32(18).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseSubscriptionPermission();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 8) {\n            break;\n          }\n          message.allParticipants = reader2.bool();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.trackPermissions.push(TrackPermission.decode(reader2, reader2.uint32()));\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      allParticipants: isSet(object.allParticipants) ? Boolean(object.allParticipants) : false,\n      trackPermissions: Array.isArray(object === null || object === void 0 ? void 0 : object.trackPermissions) ? object.trackPermissions.map((e) => TrackPermission.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.allParticipants !== void 0 && (obj.allParticipants = message.allParticipants);\n    if (message.trackPermissions) {\n      obj.trackPermissions = message.trackPermissions.map((e) => e ? TrackPermission.toJSON(e) : void 0);\n    } else {\n      obj.trackPermissions = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return SubscriptionPermission.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseSubscriptionPermission();\n    message.allParticipants = (_a = object.allParticipants) !== null && _a !== void 0 ? _a : false;\n    message.trackPermissions = ((_b = object.trackPermissions) === null || _b === void 0 ? void 0 : _b.map((e) => TrackPermission.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseSubscriptionPermissionUpdate() {\n  return {\n    participantSid: \"\",\n    trackSid: \"\",\n    allowed: false\n  };\n}\nvar SubscriptionPermissionUpdate = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.participantSid !== \"\") {\n      writer2.uint32(10).string(message.participantSid);\n    }\n    if (message.trackSid !== \"\") {\n      writer2.uint32(18).string(message.trackSid);\n    }\n    if (message.allowed === true) {\n      writer2.uint32(24).bool(message.allowed);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseSubscriptionPermissionUpdate();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.participantSid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.trackSid = reader2.string();\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.allowed = reader2.bool();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      participantSid: isSet(object.participantSid) ? String(object.participantSid) : \"\",\n      trackSid: isSet(object.trackSid) ? String(object.trackSid) : \"\",\n      allowed: isSet(object.allowed) ? Boolean(object.allowed) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.participantSid !== void 0 && (obj.participantSid = message.participantSid);\n    message.trackSid !== void 0 && (obj.trackSid = message.trackSid);\n    message.allowed !== void 0 && (obj.allowed = message.allowed);\n    return obj;\n  },\n  create(base) {\n    return SubscriptionPermissionUpdate.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseSubscriptionPermissionUpdate();\n    message.participantSid = (_a = object.participantSid) !== null && _a !== void 0 ? _a : \"\";\n    message.trackSid = (_b = object.trackSid) !== null && _b !== void 0 ? _b : \"\";\n    message.allowed = (_c = object.allowed) !== null && _c !== void 0 ? _c : false;\n    return message;\n  }\n};\nfunction createBaseSyncState() {\n  return {\n    answer: void 0,\n    subscription: void 0,\n    publishTracks: [],\n    dataChannels: [],\n    offer: void 0\n  };\n}\nvar SyncState = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.answer !== void 0) {\n      SessionDescription.encode(message.answer, writer2.uint32(10).fork()).ldelim();\n    }\n    if (message.subscription !== void 0) {\n      UpdateSubscription.encode(message.subscription, writer2.uint32(18).fork()).ldelim();\n    }\n    for (const v of message.publishTracks) {\n      TrackPublishedResponse.encode(v, writer2.uint32(26).fork()).ldelim();\n    }\n    for (const v of message.dataChannels) {\n      DataChannelInfo.encode(v, writer2.uint32(34).fork()).ldelim();\n    }\n    if (message.offer !== void 0) {\n      SessionDescription.encode(message.offer, writer2.uint32(42).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseSyncState();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.answer = SessionDescription.decode(reader2, reader2.uint32());\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.subscription = UpdateSubscription.decode(reader2, reader2.uint32());\n          continue;\n        case 3:\n          if (tag != 26) {\n            break;\n          }\n          message.publishTracks.push(TrackPublishedResponse.decode(reader2, reader2.uint32()));\n          continue;\n        case 4:\n          if (tag != 34) {\n            break;\n          }\n          message.dataChannels.push(DataChannelInfo.decode(reader2, reader2.uint32()));\n          continue;\n        case 5:\n          if (tag != 42) {\n            break;\n          }\n          message.offer = SessionDescription.decode(reader2, reader2.uint32());\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      answer: isSet(object.answer) ? SessionDescription.fromJSON(object.answer) : void 0,\n      subscription: isSet(object.subscription) ? UpdateSubscription.fromJSON(object.subscription) : void 0,\n      publishTracks: Array.isArray(object === null || object === void 0 ? void 0 : object.publishTracks) ? object.publishTracks.map((e) => TrackPublishedResponse.fromJSON(e)) : [],\n      dataChannels: Array.isArray(object === null || object === void 0 ? void 0 : object.dataChannels) ? object.dataChannels.map((e) => DataChannelInfo.fromJSON(e)) : [],\n      offer: isSet(object.offer) ? SessionDescription.fromJSON(object.offer) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.answer !== void 0 && (obj.answer = message.answer ? SessionDescription.toJSON(message.answer) : void 0);\n    message.subscription !== void 0 && (obj.subscription = message.subscription ? UpdateSubscription.toJSON(message.subscription) : void 0);\n    if (message.publishTracks) {\n      obj.publishTracks = message.publishTracks.map((e) => e ? TrackPublishedResponse.toJSON(e) : void 0);\n    } else {\n      obj.publishTracks = [];\n    }\n    if (message.dataChannels) {\n      obj.dataChannels = message.dataChannels.map((e) => e ? DataChannelInfo.toJSON(e) : void 0);\n    } else {\n      obj.dataChannels = [];\n    }\n    message.offer !== void 0 && (obj.offer = message.offer ? SessionDescription.toJSON(message.offer) : void 0);\n    return obj;\n  },\n  create(base) {\n    return SyncState.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseSyncState();\n    message.answer = object.answer !== void 0 && object.answer !== null ? SessionDescription.fromPartial(object.answer) : void 0;\n    message.subscription = object.subscription !== void 0 && object.subscription !== null ? UpdateSubscription.fromPartial(object.subscription) : void 0;\n    message.publishTracks = ((_a = object.publishTracks) === null || _a === void 0 ? void 0 : _a.map((e) => TrackPublishedResponse.fromPartial(e))) || [];\n    message.dataChannels = ((_b = object.dataChannels) === null || _b === void 0 ? void 0 : _b.map((e) => DataChannelInfo.fromPartial(e))) || [];\n    message.offer = object.offer !== void 0 && object.offer !== null ? SessionDescription.fromPartial(object.offer) : void 0;\n    return message;\n  }\n};\nfunction createBaseDataChannelInfo() {\n  return {\n    label: \"\",\n    id: 0,\n    target: 0\n  };\n}\nvar DataChannelInfo = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.label !== \"\") {\n      writer2.uint32(10).string(message.label);\n    }\n    if (message.id !== 0) {\n      writer2.uint32(16).uint32(message.id);\n    }\n    if (message.target !== 0) {\n      writer2.uint32(24).int32(message.target);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseDataChannelInfo();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.label = reader2.string();\n          continue;\n        case 2:\n          if (tag != 16) {\n            break;\n          }\n          message.id = reader2.uint32();\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.target = reader2.int32();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      label: isSet(object.label) ? String(object.label) : \"\",\n      id: isSet(object.id) ? Number(object.id) : 0,\n      target: isSet(object.target) ? signalTargetFromJSON(object.target) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.label !== void 0 && (obj.label = message.label);\n    message.id !== void 0 && (obj.id = Math.round(message.id));\n    message.target !== void 0 && (obj.target = signalTargetToJSON(message.target));\n    return obj;\n  },\n  create(base) {\n    return DataChannelInfo.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseDataChannelInfo();\n    message.label = (_a = object.label) !== null && _a !== void 0 ? _a : \"\";\n    message.id = (_b = object.id) !== null && _b !== void 0 ? _b : 0;\n    message.target = (_c = object.target) !== null && _c !== void 0 ? _c : 0;\n    return message;\n  }\n};\nfunction createBaseSimulateScenario() {\n  return {\n    scenario: void 0\n  };\n}\nvar SimulateScenario = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    var _a;\n    switch ((_a = message.scenario) === null || _a === void 0 ? void 0 : _a.$case) {\n      case \"speakerUpdate\":\n        writer2.uint32(8).int32(message.scenario.speakerUpdate);\n        break;\n      case \"nodeFailure\":\n        writer2.uint32(16).bool(message.scenario.nodeFailure);\n        break;\n      case \"migration\":\n        writer2.uint32(24).bool(message.scenario.migration);\n        break;\n      case \"serverLeave\":\n        writer2.uint32(32).bool(message.scenario.serverLeave);\n        break;\n      case \"switchCandidateProtocol\":\n        writer2.uint32(40).int32(message.scenario.switchCandidateProtocol);\n        break;\n      case \"subscriberBandwidth\":\n        writer2.uint32(48).int64(message.scenario.subscriberBandwidth);\n        break;\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseSimulateScenario();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 8) {\n            break;\n          }\n          message.scenario = {\n            $case: \"speakerUpdate\",\n            speakerUpdate: reader2.int32()\n          };\n          continue;\n        case 2:\n          if (tag != 16) {\n            break;\n          }\n          message.scenario = {\n            $case: \"nodeFailure\",\n            nodeFailure: reader2.bool()\n          };\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.scenario = {\n            $case: \"migration\",\n            migration: reader2.bool()\n          };\n          continue;\n        case 4:\n          if (tag != 32) {\n            break;\n          }\n          message.scenario = {\n            $case: \"serverLeave\",\n            serverLeave: reader2.bool()\n          };\n          continue;\n        case 5:\n          if (tag != 40) {\n            break;\n          }\n          message.scenario = {\n            $case: \"switchCandidateProtocol\",\n            switchCandidateProtocol: reader2.int32()\n          };\n          continue;\n        case 6:\n          if (tag != 48) {\n            break;\n          }\n          message.scenario = {\n            $case: \"subscriberBandwidth\",\n            subscriberBandwidth: longToNumber(reader2.int64())\n          };\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      scenario: isSet(object.speakerUpdate) ? {\n        $case: \"speakerUpdate\",\n        speakerUpdate: Number(object.speakerUpdate)\n      } : isSet(object.nodeFailure) ? {\n        $case: \"nodeFailure\",\n        nodeFailure: Boolean(object.nodeFailure)\n      } : isSet(object.migration) ? {\n        $case: \"migration\",\n        migration: Boolean(object.migration)\n      } : isSet(object.serverLeave) ? {\n        $case: \"serverLeave\",\n        serverLeave: Boolean(object.serverLeave)\n      } : isSet(object.switchCandidateProtocol) ? {\n        $case: \"switchCandidateProtocol\",\n        switchCandidateProtocol: candidateProtocolFromJSON(object.switchCandidateProtocol)\n      } : isSet(object.subscriberBandwidth) ? {\n        $case: \"subscriberBandwidth\",\n        subscriberBandwidth: Number(object.subscriberBandwidth)\n      } : void 0\n    };\n  },\n  toJSON(message) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;\n    const obj = {};\n    ((_a = message.scenario) === null || _a === void 0 ? void 0 : _a.$case) === \"speakerUpdate\" && (obj.speakerUpdate = Math.round((_b = message.scenario) === null || _b === void 0 ? void 0 : _b.speakerUpdate));\n    ((_c = message.scenario) === null || _c === void 0 ? void 0 : _c.$case) === \"nodeFailure\" && (obj.nodeFailure = (_d = message.scenario) === null || _d === void 0 ? void 0 : _d.nodeFailure);\n    ((_e = message.scenario) === null || _e === void 0 ? void 0 : _e.$case) === \"migration\" && (obj.migration = (_f = message.scenario) === null || _f === void 0 ? void 0 : _f.migration);\n    ((_g = message.scenario) === null || _g === void 0 ? void 0 : _g.$case) === \"serverLeave\" && (obj.serverLeave = (_h = message.scenario) === null || _h === void 0 ? void 0 : _h.serverLeave);\n    ((_j = message.scenario) === null || _j === void 0 ? void 0 : _j.$case) === \"switchCandidateProtocol\" && (obj.switchCandidateProtocol = ((_k = message.scenario) === null || _k === void 0 ? void 0 : _k.switchCandidateProtocol) !== void 0 ? candidateProtocolToJSON((_l = message.scenario) === null || _l === void 0 ? void 0 : _l.switchCandidateProtocol) : void 0);\n    ((_m = message.scenario) === null || _m === void 0 ? void 0 : _m.$case) === \"subscriberBandwidth\" && (obj.subscriberBandwidth = Math.round((_o = message.scenario) === null || _o === void 0 ? void 0 : _o.subscriberBandwidth));\n    return obj;\n  },\n  create(base) {\n    return SimulateScenario.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;\n    const message = createBaseSimulateScenario();\n    if (((_a = object.scenario) === null || _a === void 0 ? void 0 : _a.$case) === \"speakerUpdate\" && ((_b = object.scenario) === null || _b === void 0 ? void 0 : _b.speakerUpdate) !== void 0 && ((_c = object.scenario) === null || _c === void 0 ? void 0 : _c.speakerUpdate) !== null) {\n      message.scenario = {\n        $case: \"speakerUpdate\",\n        speakerUpdate: object.scenario.speakerUpdate\n      };\n    }\n    if (((_d = object.scenario) === null || _d === void 0 ? void 0 : _d.$case) === \"nodeFailure\" && ((_e = object.scenario) === null || _e === void 0 ? void 0 : _e.nodeFailure) !== void 0 && ((_f = object.scenario) === null || _f === void 0 ? void 0 : _f.nodeFailure) !== null) {\n      message.scenario = {\n        $case: \"nodeFailure\",\n        nodeFailure: object.scenario.nodeFailure\n      };\n    }\n    if (((_g = object.scenario) === null || _g === void 0 ? void 0 : _g.$case) === \"migration\" && ((_h = object.scenario) === null || _h === void 0 ? void 0 : _h.migration) !== void 0 && ((_j = object.scenario) === null || _j === void 0 ? void 0 : _j.migration) !== null) {\n      message.scenario = {\n        $case: \"migration\",\n        migration: object.scenario.migration\n      };\n    }\n    if (((_k = object.scenario) === null || _k === void 0 ? void 0 : _k.$case) === \"serverLeave\" && ((_l = object.scenario) === null || _l === void 0 ? void 0 : _l.serverLeave) !== void 0 && ((_m = object.scenario) === null || _m === void 0 ? void 0 : _m.serverLeave) !== null) {\n      message.scenario = {\n        $case: \"serverLeave\",\n        serverLeave: object.scenario.serverLeave\n      };\n    }\n    if (((_o = object.scenario) === null || _o === void 0 ? void 0 : _o.$case) === \"switchCandidateProtocol\" && ((_p = object.scenario) === null || _p === void 0 ? void 0 : _p.switchCandidateProtocol) !== void 0 && ((_q = object.scenario) === null || _q === void 0 ? void 0 : _q.switchCandidateProtocol) !== null) {\n      message.scenario = {\n        $case: \"switchCandidateProtocol\",\n        switchCandidateProtocol: object.scenario.switchCandidateProtocol\n      };\n    }\n    if (((_r = object.scenario) === null || _r === void 0 ? void 0 : _r.$case) === \"subscriberBandwidth\" && ((_s = object.scenario) === null || _s === void 0 ? void 0 : _s.subscriberBandwidth) !== void 0 && ((_t = object.scenario) === null || _t === void 0 ? void 0 : _t.subscriberBandwidth) !== null) {\n      message.scenario = {\n        $case: \"subscriberBandwidth\",\n        subscriberBandwidth: object.scenario.subscriberBandwidth\n      };\n    }\n    return message;\n  }\n};\nfunction createBasePing() {\n  return {\n    timestamp: 0,\n    rtt: 0\n  };\n}\nvar Ping = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.timestamp !== 0) {\n      writer2.uint32(8).int64(message.timestamp);\n    }\n    if (message.rtt !== 0) {\n      writer2.uint32(16).int64(message.rtt);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBasePing();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 8) {\n            break;\n          }\n          message.timestamp = longToNumber(reader2.int64());\n          continue;\n        case 2:\n          if (tag != 16) {\n            break;\n          }\n          message.rtt = longToNumber(reader2.int64());\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      timestamp: isSet(object.timestamp) ? Number(object.timestamp) : 0,\n      rtt: isSet(object.rtt) ? Number(object.rtt) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.timestamp !== void 0 && (obj.timestamp = Math.round(message.timestamp));\n    message.rtt !== void 0 && (obj.rtt = Math.round(message.rtt));\n    return obj;\n  },\n  create(base) {\n    return Ping.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBasePing();\n    message.timestamp = (_a = object.timestamp) !== null && _a !== void 0 ? _a : 0;\n    message.rtt = (_b = object.rtt) !== null && _b !== void 0 ? _b : 0;\n    return message;\n  }\n};\nfunction createBasePong() {\n  return {\n    lastPingTimestamp: 0,\n    timestamp: 0\n  };\n}\nvar Pong = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.lastPingTimestamp !== 0) {\n      writer2.uint32(8).int64(message.lastPingTimestamp);\n    }\n    if (message.timestamp !== 0) {\n      writer2.uint32(16).int64(message.timestamp);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBasePong();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 8) {\n            break;\n          }\n          message.lastPingTimestamp = longToNumber(reader2.int64());\n          continue;\n        case 2:\n          if (tag != 16) {\n            break;\n          }\n          message.timestamp = longToNumber(reader2.int64());\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      lastPingTimestamp: isSet(object.lastPingTimestamp) ? Number(object.lastPingTimestamp) : 0,\n      timestamp: isSet(object.timestamp) ? Number(object.timestamp) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.lastPingTimestamp !== void 0 && (obj.lastPingTimestamp = Math.round(message.lastPingTimestamp));\n    message.timestamp !== void 0 && (obj.timestamp = Math.round(message.timestamp));\n    return obj;\n  },\n  create(base) {\n    return Pong.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBasePong();\n    message.lastPingTimestamp = (_a = object.lastPingTimestamp) !== null && _a !== void 0 ? _a : 0;\n    message.timestamp = (_b = object.timestamp) !== null && _b !== void 0 ? _b : 0;\n    return message;\n  }\n};\nvar tsProtoGlobalThis = (() => {\n  if (typeof globalThis !== \"undefined\") {\n    return globalThis;\n  }\n  if (typeof self !== \"undefined\") {\n    return self;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n  throw \"Unable to locate global object\";\n})();\nfunction longToNumber(long2) {\n  if (long2.gt(Number.MAX_SAFE_INTEGER)) {\n    throw new tsProtoGlobalThis.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\n  }\n  return long2.toNumber();\n}\nif (_m0.util.Long !== Long$1) {\n  _m0.util.Long = Long$1;\n  _m0.configure();\n}\nfunction isSet(value) {\n  return value !== null && value !== void 0;\n}\nvar LivekitError = class extends Error {\n  constructor(code, message) {\n    super(message || \"an error has occured\");\n    this.code = code;\n  }\n};\nvar ConnectionError = class extends LivekitError {\n  constructor(message, reason, status) {\n    super(1, message);\n    this.status = status;\n    this.reason = reason;\n  }\n};\nvar DeviceUnsupportedError = class extends LivekitError {\n  constructor(message) {\n    super(21, message !== null && message !== void 0 ? message : \"device is unsupported\");\n  }\n};\nvar TrackInvalidError = class extends LivekitError {\n  constructor(message) {\n    super(20, message !== null && message !== void 0 ? message : \"track is invalid\");\n  }\n};\nvar UnsupportedServer = class extends LivekitError {\n  constructor(message) {\n    super(10, message !== null && message !== void 0 ? message : \"unsupported server\");\n  }\n};\nvar UnexpectedConnectionState = class extends LivekitError {\n  constructor(message) {\n    super(12, message !== null && message !== void 0 ? message : \"unexpected connection state\");\n  }\n};\nvar NegotiationError = class extends LivekitError {\n  constructor(message) {\n    super(13, message !== null && message !== void 0 ? message : \"unable to negotiate\");\n  }\n};\nvar PublishDataError = class extends LivekitError {\n  constructor(message) {\n    super(13, message !== null && message !== void 0 ? message : \"unable to publish data\");\n  }\n};\nvar MediaDeviceFailure;\n(function(MediaDeviceFailure2) {\n  MediaDeviceFailure2[\"PermissionDenied\"] = \"PermissionDenied\";\n  MediaDeviceFailure2[\"NotFound\"] = \"NotFound\";\n  MediaDeviceFailure2[\"DeviceInUse\"] = \"DeviceInUse\";\n  MediaDeviceFailure2[\"Other\"] = \"Other\";\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\n(function(MediaDeviceFailure2) {\n  function getFailure(error) {\n    if (error && \"name\" in error) {\n      if (error.name === \"NotFoundError\" || error.name === \"DevicesNotFoundError\") {\n        return MediaDeviceFailure2.NotFound;\n      }\n      if (error.name === \"NotAllowedError\" || error.name === \"PermissionDeniedError\") {\n        return MediaDeviceFailure2.PermissionDenied;\n      }\n      if (error.name === \"NotReadableError\" || error.name === \"TrackStartError\") {\n        return MediaDeviceFailure2.DeviceInUse;\n      }\n      return MediaDeviceFailure2.Other;\n    }\n  }\n  MediaDeviceFailure2.getFailure = getFailure;\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\nvar CriticalTimers = class {\n};\nCriticalTimers.setTimeout = function() {\n  return setTimeout(...arguments);\n};\nCriticalTimers.setInterval = function() {\n  return setInterval(...arguments);\n};\nCriticalTimers.clearTimeout = function() {\n  return clearTimeout(...arguments);\n};\nCriticalTimers.clearInterval = function() {\n  return clearInterval(...arguments);\n};\nvar passThroughQueueSignals = [\"syncState\", \"trickle\", \"offer\", \"answer\", \"simulate\", \"leave\"];\nfunction canPassThroughQueue(req) {\n  const canPass = passThroughQueueSignals.indexOf(req.$case) >= 0;\n  livekitLogger.trace(\"request allowed to bypass queue:\", {\n    canPass,\n    req\n  });\n  return canPass;\n}\nvar SignalClient = class {\n  constructor() {\n    let useJSON = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n    this.rtt = 0;\n    this.isConnected = false;\n    this.isReconnecting = false;\n    this.useJSON = useJSON;\n    this.requestQueue = new AsyncQueue();\n    this.queuedRequests = [];\n    this.closingLock = new Mutex();\n  }\n  join(url, token, opts, abortSignal) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.isConnected = false;\n      this.options = opts;\n      const res = yield this.connect(url, token, opts, abortSignal);\n      return res;\n    });\n  }\n  reconnect(url, token, sid, reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.options) {\n        livekitLogger.warn(\"attempted to reconnect without signal options being set, ignoring\");\n        return;\n      }\n      this.isReconnecting = true;\n      this.clearPingInterval();\n      const res = yield this.connect(url, token, Object.assign(Object.assign({}, this.options), {\n        reconnect: true,\n        sid,\n        reconnectReason: reason\n      }));\n      return res;\n    });\n  }\n  connect(url, token, opts, abortSignal) {\n    this.connectOptions = opts;\n    if (url.startsWith(\"http\")) {\n      url = url.replace(\"http\", \"ws\");\n    }\n    url = url.replace(/\\/$/, \"\");\n    url += \"/rtc\";\n    const clientInfo = getClientInfo();\n    const params = createConnectionParams(token, clientInfo, opts);\n    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n      const abortHandler = () => __awaiter(this, void 0, void 0, function* () {\n        yield this.close();\n        reject(new ConnectionError(\"room connection has been cancelled (signal)\"));\n      });\n      if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {\n        abortHandler();\n      }\n      abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.addEventListener(\"abort\", abortHandler);\n      livekitLogger.debug(\"connecting to \".concat(url + params));\n      if (this.ws) {\n        yield this.close();\n      }\n      this.ws = new WebSocket(url + params);\n      this.ws.binaryType = \"arraybuffer\";\n      this.ws.onerror = (ev) => __awaiter(this, void 0, void 0, function* () {\n        if (!this.isConnected) {\n          try {\n            const resp = yield fetch(\"http\".concat(url.substring(2), \"/validate\").concat(params));\n            if (resp.status.toFixed(0).startsWith(\"4\")) {\n              const msg = yield resp.text();\n              reject(new ConnectionError(msg, 0, resp.status));\n            } else {\n              reject(new ConnectionError(\"Internal error\", 2, resp.status));\n            }\n          } catch (e) {\n            reject(new ConnectionError(\n              \"server was not reachable\",\n              1\n              /* ConnectionErrorReason.ServerUnreachable */\n            ));\n          }\n          return;\n        }\n        this.handleWSError(ev);\n      });\n      this.ws.onmessage = (ev) => __awaiter(this, void 0, void 0, function* () {\n        var _a, _b, _c, _d;\n        let resp;\n        if (typeof ev.data === \"string\") {\n          const json = JSON.parse(ev.data);\n          resp = SignalResponse.fromJSON(json);\n        } else if (ev.data instanceof ArrayBuffer) {\n          resp = SignalResponse.decode(new Uint8Array(ev.data));\n        } else {\n          livekitLogger.error(\"could not decode websocket message: \".concat(typeof ev.data));\n          return;\n        }\n        if (!this.isConnected) {\n          let shouldProcessMessage = false;\n          if (((_a = resp.message) === null || _a === void 0 ? void 0 : _a.$case) === \"join\") {\n            this.isConnected = true;\n            abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener(\"abort\", abortHandler);\n            this.pingTimeoutDuration = resp.message.join.pingTimeout;\n            this.pingIntervalDuration = resp.message.join.pingInterval;\n            if (this.pingTimeoutDuration && this.pingTimeoutDuration > 0) {\n              livekitLogger.debug(\"ping config\", {\n                timeout: this.pingTimeoutDuration,\n                interval: this.pingIntervalDuration\n              });\n              this.startPingInterval();\n            }\n            resolve(resp.message.join);\n          } else if (opts.reconnect) {\n            this.isConnected = true;\n            abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener(\"abort\", abortHandler);\n            this.startPingInterval();\n            if (((_b = resp.message) === null || _b === void 0 ? void 0 : _b.$case) === \"reconnect\") {\n              resolve((_c = resp.message) === null || _c === void 0 ? void 0 : _c.reconnect);\n            } else {\n              resolve();\n              shouldProcessMessage = true;\n            }\n          } else if (!opts.reconnect) {\n            reject(new ConnectionError(\"did not receive join response, got \".concat((_d = resp.message) === null || _d === void 0 ? void 0 : _d.$case, \" instead\")));\n          }\n          if (!shouldProcessMessage) {\n            return;\n          }\n        }\n        if (this.signalLatency) {\n          yield sleep(this.signalLatency);\n        }\n        this.handleSignalResponse(resp);\n      });\n      this.ws.onclose = (ev) => {\n        livekitLogger.warn(\"websocket closed\", {\n          ev\n        });\n        this.handleOnClose(ev.reason);\n      };\n    }));\n  }\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.closingLock.lock();\n      try {\n        this.isConnected = false;\n        if (this.ws) {\n          this.ws.onclose = null;\n          this.ws.onmessage = null;\n          this.ws.onopen = null;\n          const closePromise = new Promise((resolve) => {\n            if (this.ws) {\n              this.ws.onclose = resolve;\n            } else {\n              resolve(true);\n            }\n          });\n          if (this.ws.readyState < this.ws.CLOSING) {\n            this.ws.close();\n            yield Promise.race([closePromise, sleep(250)]);\n          }\n          this.ws = void 0;\n          this.clearPingInterval();\n        }\n      } finally {\n        unlock();\n      }\n    });\n  }\n  // initial offer after joining\n  sendOffer(offer) {\n    livekitLogger.debug(\"sending offer\", offer);\n    this.sendRequest({\n      $case: \"offer\",\n      offer: toProtoSessionDescription(offer)\n    });\n  }\n  // answer a server-initiated offer\n  sendAnswer(answer) {\n    livekitLogger.debug(\"sending answer\");\n    return this.sendRequest({\n      $case: \"answer\",\n      answer: toProtoSessionDescription(answer)\n    });\n  }\n  sendIceCandidate(candidate, target) {\n    livekitLogger.trace(\"sending ice candidate\", candidate);\n    return this.sendRequest({\n      $case: \"trickle\",\n      trickle: {\n        candidateInit: JSON.stringify(candidate),\n        target\n      }\n    });\n  }\n  sendMuteTrack(trackSid, muted) {\n    return this.sendRequest({\n      $case: \"mute\",\n      mute: {\n        sid: trackSid,\n        muted\n      }\n    });\n  }\n  sendAddTrack(req) {\n    return this.sendRequest({\n      $case: \"addTrack\",\n      addTrack: AddTrackRequest.fromPartial(req)\n    });\n  }\n  sendUpdateLocalMetadata(metadata, name) {\n    return this.sendRequest({\n      $case: \"updateMetadata\",\n      updateMetadata: {\n        metadata,\n        name\n      }\n    });\n  }\n  sendUpdateTrackSettings(settings) {\n    this.sendRequest({\n      $case: \"trackSetting\",\n      trackSetting: settings\n    });\n  }\n  sendUpdateSubscription(sub) {\n    return this.sendRequest({\n      $case: \"subscription\",\n      subscription: sub\n    });\n  }\n  sendSyncState(sync) {\n    return this.sendRequest({\n      $case: \"syncState\",\n      syncState: sync\n    });\n  }\n  sendUpdateVideoLayers(trackSid, layers) {\n    return this.sendRequest({\n      $case: \"updateLayers\",\n      updateLayers: {\n        trackSid,\n        layers\n      }\n    });\n  }\n  sendUpdateSubscriptionPermissions(allParticipants, trackPermissions) {\n    return this.sendRequest({\n      $case: \"subscriptionPermission\",\n      subscriptionPermission: {\n        allParticipants,\n        trackPermissions\n      }\n    });\n  }\n  sendSimulateScenario(scenario) {\n    return this.sendRequest({\n      $case: \"simulate\",\n      simulate: scenario\n    });\n  }\n  sendPing() {\n    return Promise.all([this.sendRequest({\n      $case: \"ping\",\n      ping: Date.now()\n    }), this.sendRequest({\n      $case: \"pingReq\",\n      pingReq: {\n        timestamp: Date.now(),\n        rtt: this.rtt\n      }\n    })]);\n  }\n  sendLeave() {\n    return this.sendRequest({\n      $case: \"leave\",\n      leave: {\n        canReconnect: false,\n        reason: DisconnectReason.CLIENT_INITIATED\n      }\n    });\n  }\n  sendRequest(message) {\n    let fromQueue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    return __awaiter(this, void 0, void 0, function* () {\n      const canQueue = !fromQueue && !canPassThroughQueue(message);\n      if (canQueue && this.isReconnecting) {\n        this.queuedRequests.push(() => __awaiter(this, void 0, void 0, function* () {\n          yield this.sendRequest(message, true);\n        }));\n        return;\n      }\n      if (!fromQueue) {\n        yield this.requestQueue.flush();\n      }\n      if (this.signalLatency) {\n        yield sleep(this.signalLatency);\n      }\n      if (!this.ws || this.ws.readyState !== this.ws.OPEN) {\n        livekitLogger.error(\"cannot send signal request before connected, type: \".concat(message === null || message === void 0 ? void 0 : message.$case));\n        return;\n      }\n      const req = {\n        message\n      };\n      try {\n        if (this.useJSON) {\n          this.ws.send(JSON.stringify(SignalRequest.toJSON(req)));\n        } else {\n          this.ws.send(SignalRequest.encode(req).finish());\n        }\n      } catch (e) {\n        livekitLogger.error(\"error sending signal message\", {\n          error: e\n        });\n      }\n    });\n  }\n  handleSignalResponse(res) {\n    var _a, _b;\n    const msg = res.message;\n    if (msg == void 0) {\n      livekitLogger.debug(\"received unsupported message\");\n      return;\n    }\n    if (msg.$case === \"answer\") {\n      const sd = fromProtoSessionDescription(msg.answer);\n      if (this.onAnswer) {\n        this.onAnswer(sd);\n      }\n    } else if (msg.$case === \"offer\") {\n      const sd = fromProtoSessionDescription(msg.offer);\n      if (this.onOffer) {\n        this.onOffer(sd);\n      }\n    } else if (msg.$case === \"trickle\") {\n      const candidate = JSON.parse(msg.trickle.candidateInit);\n      if (this.onTrickle) {\n        this.onTrickle(candidate, msg.trickle.target);\n      }\n    } else if (msg.$case === \"update\") {\n      if (this.onParticipantUpdate) {\n        this.onParticipantUpdate((_a = msg.update.participants) !== null && _a !== void 0 ? _a : []);\n      }\n    } else if (msg.$case === \"trackPublished\") {\n      if (this.onLocalTrackPublished) {\n        this.onLocalTrackPublished(msg.trackPublished);\n      }\n    } else if (msg.$case === \"speakersChanged\") {\n      if (this.onSpeakersChanged) {\n        this.onSpeakersChanged((_b = msg.speakersChanged.speakers) !== null && _b !== void 0 ? _b : []);\n      }\n    } else if (msg.$case === \"leave\") {\n      if (this.onLeave) {\n        this.onLeave(msg.leave);\n      }\n    } else if (msg.$case === \"mute\") {\n      if (this.onRemoteMuteChanged) {\n        this.onRemoteMuteChanged(msg.mute.sid, msg.mute.muted);\n      }\n    } else if (msg.$case === \"roomUpdate\") {\n      if (this.onRoomUpdate && msg.roomUpdate.room) {\n        this.onRoomUpdate(msg.roomUpdate.room);\n      }\n    } else if (msg.$case === \"connectionQuality\") {\n      if (this.onConnectionQuality) {\n        this.onConnectionQuality(msg.connectionQuality);\n      }\n    } else if (msg.$case === \"streamStateUpdate\") {\n      if (this.onStreamStateUpdate) {\n        this.onStreamStateUpdate(msg.streamStateUpdate);\n      }\n    } else if (msg.$case === \"subscribedQualityUpdate\") {\n      if (this.onSubscribedQualityUpdate) {\n        this.onSubscribedQualityUpdate(msg.subscribedQualityUpdate);\n      }\n    } else if (msg.$case === \"subscriptionPermissionUpdate\") {\n      if (this.onSubscriptionPermissionUpdate) {\n        this.onSubscriptionPermissionUpdate(msg.subscriptionPermissionUpdate);\n      }\n    } else if (msg.$case === \"refreshToken\") {\n      if (this.onTokenRefresh) {\n        this.onTokenRefresh(msg.refreshToken);\n      }\n    } else if (msg.$case === \"trackUnpublished\") {\n      if (this.onLocalTrackUnpublished) {\n        this.onLocalTrackUnpublished(msg.trackUnpublished);\n      }\n    } else if (msg.$case === \"pong\") {\n      this.resetPingTimeout();\n    } else if (msg.$case === \"pongResp\") {\n      this.rtt = Date.now() - msg.pongResp.lastPingTimestamp;\n      this.resetPingTimeout();\n    } else {\n      livekitLogger.debug(\"unsupported message\", msg);\n    }\n  }\n  setReconnected() {\n    while (this.queuedRequests.length > 0) {\n      const req = this.queuedRequests.shift();\n      if (req) {\n        this.requestQueue.run(req);\n      }\n    }\n    this.isReconnecting = false;\n  }\n  handleOnClose(reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.isConnected)\n        return;\n      yield this.close();\n      livekitLogger.debug(\"websocket connection closed: \".concat(reason));\n      if (this.onClose) {\n        this.onClose(reason);\n      }\n    });\n  }\n  handleWSError(ev) {\n    livekitLogger.error(\"websocket error\", ev);\n  }\n  /**\n   * Resets the ping timeout and starts a new timeout.\n   * Call this after receiving a pong message\n   */\n  resetPingTimeout() {\n    this.clearPingTimeout();\n    if (!this.pingTimeoutDuration) {\n      livekitLogger.warn(\"ping timeout duration not set\");\n      return;\n    }\n    this.pingTimeout = CriticalTimers.setTimeout(() => {\n      livekitLogger.warn(\"ping timeout triggered. last pong received at: \".concat(new Date(Date.now() - this.pingTimeoutDuration * 1e3).toUTCString()));\n      this.handleOnClose(\"ping timeout\");\n    }, this.pingTimeoutDuration * 1e3);\n  }\n  /**\n   * Clears ping timeout (does not start a new timeout)\n   */\n  clearPingTimeout() {\n    if (this.pingTimeout) {\n      CriticalTimers.clearTimeout(this.pingTimeout);\n    }\n  }\n  startPingInterval() {\n    this.clearPingInterval();\n    this.resetPingTimeout();\n    if (!this.pingIntervalDuration) {\n      livekitLogger.warn(\"ping interval duration not set\");\n      return;\n    }\n    livekitLogger.debug(\"start ping interval\");\n    this.pingInterval = CriticalTimers.setInterval(() => {\n      this.sendPing();\n    }, this.pingIntervalDuration * 1e3);\n  }\n  clearPingInterval() {\n    livekitLogger.debug(\"clearing ping interval\");\n    this.clearPingTimeout();\n    if (this.pingInterval) {\n      CriticalTimers.clearInterval(this.pingInterval);\n    }\n  }\n};\nfunction fromProtoSessionDescription(sd) {\n  const rsd = {\n    type: \"offer\",\n    sdp: sd.sdp\n  };\n  switch (sd.type) {\n    case \"answer\":\n    case \"offer\":\n    case \"pranswer\":\n    case \"rollback\":\n      rsd.type = sd.type;\n      break;\n  }\n  return rsd;\n}\nfunction toProtoSessionDescription(rsd) {\n  const sd = {\n    sdp: rsd.sdp,\n    type: rsd.type\n  };\n  return sd;\n}\nfunction createConnectionParams(token, info, opts) {\n  var _a;\n  const params = new URLSearchParams();\n  params.set(\"access_token\", token);\n  if (opts.reconnect) {\n    params.set(\"reconnect\", \"1\");\n    if (opts.sid) {\n      params.set(\"sid\", opts.sid);\n    }\n  }\n  params.set(\"auto_subscribe\", opts.autoSubscribe ? \"1\" : \"0\");\n  params.set(\"sdk\", isReactNative() ? \"reactnative\" : \"js\");\n  params.set(\"version\", info.version);\n  params.set(\"protocol\", info.protocol.toString());\n  if (info.deviceModel) {\n    params.set(\"device_model\", info.deviceModel);\n  }\n  if (info.os) {\n    params.set(\"os\", info.os);\n  }\n  if (info.osVersion) {\n    params.set(\"os_version\", info.osVersion);\n  }\n  if (info.browser) {\n    params.set(\"browser\", info.browser);\n  }\n  if (info.browserVersion) {\n    params.set(\"browser_version\", info.browserVersion);\n  }\n  if (opts.publishOnly !== void 0) {\n    params.set(\"publish\", opts.publishOnly);\n  }\n  if (opts.adaptiveStream) {\n    params.set(\"adaptive_stream\", \"1\");\n  }\n  if (opts.reconnectReason) {\n    params.set(\"reconnect_reason\", opts.reconnectReason.toString());\n  }\n  if ((_a = navigator.connection) === null || _a === void 0 ? void 0 : _a.type) {\n    params.set(\"network\", navigator.connection.type);\n  }\n  return \"?\".concat(params.toString());\n}\nvar defaultId = \"default\";\nvar DeviceManager = class {\n  static getInstance() {\n    if (this.instance === void 0) {\n      this.instance = new DeviceManager();\n    }\n    return this.instance;\n  }\n  getDevices(kind) {\n    let requestPermissions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (((_a = DeviceManager.userMediaPromiseMap) === null || _a === void 0 ? void 0 : _a.size) > 0) {\n        livekitLogger.debug(\"awaiting getUserMedia promise\");\n        try {\n          if (kind) {\n            yield DeviceManager.userMediaPromiseMap.get(kind);\n          } else {\n            yield Promise.all(DeviceManager.userMediaPromiseMap.values());\n          }\n        } catch (e) {\n          livekitLogger.warn(\"error waiting for media permissons\");\n        }\n      }\n      let devices = yield navigator.mediaDevices.enumerateDevices();\n      if (requestPermissions && kind && // for safari we need to skip this check, as otherwise it will re-acquire user media and fail on iOS https://bugs.webkit.org/show_bug.cgi?id=179363\n      (!DeviceManager.userMediaPromiseMap.get(kind) || !isSafari())) {\n        const isDummyDeviceOrEmpty = devices.length === 0 || devices.some((device) => {\n          const noLabel = device.label === \"\";\n          const isRelevant = kind ? device.kind === kind : true;\n          return noLabel && isRelevant;\n        });\n        if (isDummyDeviceOrEmpty) {\n          const permissionsToAcquire = {\n            video: kind !== \"audioinput\" && kind !== \"audiooutput\",\n            audio: kind !== \"videoinput\"\n          };\n          const stream = yield navigator.mediaDevices.getUserMedia(permissionsToAcquire);\n          devices = yield navigator.mediaDevices.enumerateDevices();\n          stream.getTracks().forEach((track) => {\n            track.stop();\n          });\n        }\n      }\n      if (kind) {\n        devices = devices.filter((device) => device.kind === kind);\n      }\n      return devices;\n    });\n  }\n  normalizeDeviceId(kind, deviceId, groupId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (deviceId !== defaultId) {\n        return deviceId;\n      }\n      const devices = yield this.getDevices(kind);\n      const device = devices.find((d) => d.groupId === groupId && d.deviceId !== defaultId);\n      return device === null || device === void 0 ? void 0 : device.deviceId;\n    });\n  }\n};\nDeviceManager.mediaDeviceKinds = [\"audioinput\", \"audiooutput\", \"videoinput\"];\nDeviceManager.userMediaPromiseMap = /* @__PURE__ */ new Map();\nvar parser$1 = {};\nvar grammar$2 = { exports: {} };\nvar grammar$1 = grammar$2.exports = {\n  v: [{\n    name: \"version\",\n    reg: /^(\\d*)$/\n  }],\n  o: [{\n    // o=- 20518 0 IN IP4 203.0.113.1\n    // NB: sessionId will be a String in most cases because it is huge\n    name: \"origin\",\n    reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n    names: [\"username\", \"sessionId\", \"sessionVersion\", \"netType\", \"ipVer\", \"address\"],\n    format: \"%s %s %d %s IP%d %s\"\n  }],\n  // default parsing of these only (though some of these feel outdated)\n  s: [{\n    name: \"name\"\n  }],\n  i: [{\n    name: \"description\"\n  }],\n  u: [{\n    name: \"uri\"\n  }],\n  e: [{\n    name: \"email\"\n  }],\n  p: [{\n    name: \"phone\"\n  }],\n  z: [{\n    name: \"timezones\"\n  }],\n  // TODO: this one can actually be parsed properly...\n  r: [{\n    name: \"repeats\"\n  }],\n  // TODO: this one can also be parsed properly\n  // k: [{}], // outdated thing ignored\n  t: [{\n    // t=0 0\n    name: \"timing\",\n    reg: /^(\\d*) (\\d*)/,\n    names: [\"start\", \"stop\"],\n    format: \"%d %d\"\n  }],\n  c: [{\n    // c=IN IP4 10.47.197.26\n    name: \"connection\",\n    reg: /^IN IP(\\d) (\\S*)/,\n    names: [\"version\", \"ip\"],\n    format: \"IN IP%d %s\"\n  }],\n  b: [{\n    // b=AS:4000\n    push: \"bandwidth\",\n    reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n    names: [\"type\", \"limit\"],\n    format: \"%s:%s\"\n  }],\n  m: [{\n    // m=video 51744 RTP/AVP 126 97 98 34 31\n    // NB: special - pushes to session\n    // TODO: rtp/fmtp should be filtered by the payloads found here?\n    reg: /^(\\w*) (\\d*) ([\\w/]*)(?: (.*))?/,\n    names: [\"type\", \"port\", \"protocol\", \"payloads\"],\n    format: \"%s %d %s %s\"\n  }],\n  a: [\n    {\n      // a=rtpmap:110 opus/48000/2\n      push: \"rtp\",\n      reg: /^rtpmap:(\\d*) ([\\w\\-.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n      names: [\"payload\", \"codec\", \"rate\", \"encoding\"],\n      format: function(o) {\n        return o.encoding ? \"rtpmap:%d %s/%s/%s\" : o.rate ? \"rtpmap:%d %s/%s\" : \"rtpmap:%d %s\";\n      }\n    },\n    {\n      // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n      // a=fmtp:111 minptime=10; useinbandfec=1\n      push: \"fmtp\",\n      reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n      names: [\"payload\", \"config\"],\n      format: \"fmtp:%d %s\"\n    },\n    {\n      // a=control:streamid=0\n      name: \"control\",\n      reg: /^control:(.*)/,\n      format: \"control:%s\"\n    },\n    {\n      // a=rtcp:65179 IN IP4 193.84.77.194\n      name: \"rtcp\",\n      reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n      names: [\"port\", \"netType\", \"ipVer\", \"address\"],\n      format: function(o) {\n        return o.address != null ? \"rtcp:%d %s IP%d %s\" : \"rtcp:%d\";\n      }\n    },\n    {\n      // a=rtcp-fb:98 trr-int 100\n      push: \"rtcpFbTrrInt\",\n      reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n      names: [\"payload\", \"value\"],\n      format: \"rtcp-fb:%s trr-int %d\"\n    },\n    {\n      // a=rtcp-fb:98 nack rpsi\n      push: \"rtcpFb\",\n      reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n      names: [\"payload\", \"type\", \"subtype\"],\n      format: function(o) {\n        return o.subtype != null ? \"rtcp-fb:%s %s %s\" : \"rtcp-fb:%s %s\";\n      }\n    },\n    {\n      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n      // a=extmap:1/recvonly URI-gps-string\n      // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24\n      push: \"ext\",\n      reg: /^extmap:(\\d+)(?:\\/(\\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\\S*)(?: (\\S*))?/,\n      names: [\"value\", \"direction\", \"encrypt-uri\", \"uri\", \"config\"],\n      format: function(o) {\n        return \"extmap:%d\" + (o.direction ? \"/%s\" : \"%v\") + (o[\"encrypt-uri\"] ? \" %s\" : \"%v\") + \" %s\" + (o.config ? \" %s\" : \"\");\n      }\n    },\n    {\n      // a=extmap-allow-mixed\n      name: \"extmapAllowMixed\",\n      reg: /^(extmap-allow-mixed)/\n    },\n    {\n      // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n      push: \"crypto\",\n      reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n      names: [\"id\", \"suite\", \"config\", \"sessionConfig\"],\n      format: function(o) {\n        return o.sessionConfig != null ? \"crypto:%d %s %s %s\" : \"crypto:%d %s %s\";\n      }\n    },\n    {\n      // a=setup:actpass\n      name: \"setup\",\n      reg: /^setup:(\\w*)/,\n      format: \"setup:%s\"\n    },\n    {\n      // a=connection:new\n      name: \"connectionType\",\n      reg: /^connection:(new|existing)/,\n      format: \"connection:%s\"\n    },\n    {\n      // a=mid:1\n      name: \"mid\",\n      reg: /^mid:([^\\s]*)/,\n      format: \"mid:%s\"\n    },\n    {\n      // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n      name: \"msid\",\n      reg: /^msid:(.*)/,\n      format: \"msid:%s\"\n    },\n    {\n      // a=ptime:20\n      name: \"ptime\",\n      reg: /^ptime:(\\d*(?:\\.\\d*)*)/,\n      format: \"ptime:%d\"\n    },\n    {\n      // a=maxptime:60\n      name: \"maxptime\",\n      reg: /^maxptime:(\\d*(?:\\.\\d*)*)/,\n      format: \"maxptime:%d\"\n    },\n    {\n      // a=sendrecv\n      name: \"direction\",\n      reg: /^(sendrecv|recvonly|sendonly|inactive)/\n    },\n    {\n      // a=ice-lite\n      name: \"icelite\",\n      reg: /^(ice-lite)/\n    },\n    {\n      // a=ice-ufrag:F7gI\n      name: \"iceUfrag\",\n      reg: /^ice-ufrag:(\\S*)/,\n      format: \"ice-ufrag:%s\"\n    },\n    {\n      // a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n      name: \"icePwd\",\n      reg: /^ice-pwd:(\\S*)/,\n      format: \"ice-pwd:%s\"\n    },\n    {\n      // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n      name: \"fingerprint\",\n      reg: /^fingerprint:(\\S*) (\\S*)/,\n      names: [\"type\", \"hash\"],\n      format: \"fingerprint:%s %s\"\n    },\n    {\n      // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n      // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\n      // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\n      // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\n      // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\n      push: \"candidates\",\n      reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\n      names: [\"foundation\", \"component\", \"transport\", \"priority\", \"ip\", \"port\", \"type\", \"raddr\", \"rport\", \"tcptype\", \"generation\", \"network-id\", \"network-cost\"],\n      format: function(o) {\n        var str = \"candidate:%s %d %s %d %s %d typ %s\";\n        str += o.raddr != null ? \" raddr %s rport %d\" : \"%v%v\";\n        str += o.tcptype != null ? \" tcptype %s\" : \"%v\";\n        if (o.generation != null) {\n          str += \" generation %d\";\n        }\n        str += o[\"network-id\"] != null ? \" network-id %d\" : \"%v\";\n        str += o[\"network-cost\"] != null ? \" network-cost %d\" : \"%v\";\n        return str;\n      }\n    },\n    {\n      // a=end-of-candidates (keep after the candidates line for readability)\n      name: \"endOfCandidates\",\n      reg: /^(end-of-candidates)/\n    },\n    {\n      // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n      name: \"remoteCandidates\",\n      reg: /^remote-candidates:(.*)/,\n      format: \"remote-candidates:%s\"\n    },\n    {\n      // a=ice-options:google-ice\n      name: \"iceOptions\",\n      reg: /^ice-options:(\\S*)/,\n      format: \"ice-options:%s\"\n    },\n    {\n      // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n      push: \"ssrcs\",\n      reg: /^ssrc:(\\d*) ([\\w_-]*)(?::(.*))?/,\n      names: [\"id\", \"attribute\", \"value\"],\n      format: function(o) {\n        var str = \"ssrc:%d\";\n        if (o.attribute != null) {\n          str += \" %s\";\n          if (o.value != null) {\n            str += \":%s\";\n          }\n        }\n        return str;\n      }\n    },\n    {\n      // a=ssrc-group:FEC 1 2\n      // a=ssrc-group:FEC-FR 3004364195 1080772241\n      push: \"ssrcGroups\",\n      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\n      reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\n      names: [\"semantics\", \"ssrcs\"],\n      format: \"ssrc-group:%s %s\"\n    },\n    {\n      // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n      name: \"msidSemantic\",\n      reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n      names: [\"semantic\", \"token\"],\n      format: \"msid-semantic: %s %s\"\n      // space after ':' is not accidental\n    },\n    {\n      // a=group:BUNDLE audio video\n      push: \"groups\",\n      reg: /^group:(\\w*) (.*)/,\n      names: [\"type\", \"mids\"],\n      format: \"group:%s %s\"\n    },\n    {\n      // a=rtcp-mux\n      name: \"rtcpMux\",\n      reg: /^(rtcp-mux)/\n    },\n    {\n      // a=rtcp-rsize\n      name: \"rtcpRsize\",\n      reg: /^(rtcp-rsize)/\n    },\n    {\n      // a=sctpmap:5000 webrtc-datachannel 1024\n      name: \"sctpmap\",\n      reg: /^sctpmap:([\\w_/]*) (\\S*)(?: (\\S*))?/,\n      names: [\"sctpmapNumber\", \"app\", \"maxMessageSize\"],\n      format: function(o) {\n        return o.maxMessageSize != null ? \"sctpmap:%s %s %s\" : \"sctpmap:%s %s\";\n      }\n    },\n    {\n      // a=x-google-flag:conference\n      name: \"xGoogleFlag\",\n      reg: /^x-google-flag:([^\\s]*)/,\n      format: \"x-google-flag:%s\"\n    },\n    {\n      // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\n      push: \"rids\",\n      reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\n      names: [\"id\", \"direction\", \"params\"],\n      format: function(o) {\n        return o.params ? \"rid:%s %s %s\" : \"rid:%s %s\";\n      }\n    },\n    {\n      // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\n      // a=imageattr:* send [x=800,y=640] recv *\n      // a=imageattr:100 recv [x=320,y=240]\n      push: \"imageattrs\",\n      reg: new RegExp(\n        // a=imageattr:97\n        \"^imageattr:(\\\\d+|\\\\*)[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?\"\n      ),\n      names: [\"pt\", \"dir1\", \"attrs1\", \"dir2\", \"attrs2\"],\n      format: function(o) {\n        return \"imageattr:%s %s %s\" + (o.dir2 ? \" %s %s\" : \"\");\n      }\n    },\n    {\n      // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\n      // a=simulcast:recv 1;4,5 send 6;7\n      name: \"simulcast\",\n      reg: new RegExp(\n        // a=simulcast:\n        \"^simulcast:(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?$\"\n      ),\n      names: [\"dir1\", \"list1\", \"dir2\", \"list2\"],\n      format: function(o) {\n        return \"simulcast:%s %s\" + (o.dir2 ? \" %s %s\" : \"\");\n      }\n    },\n    {\n      // old simulcast draft 03 (implemented by Firefox)\n      //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\n      // a=simulcast: recv pt=97;98 send pt=97\n      // a=simulcast: send rid=5;6;7 paused=6,7\n      name: \"simulcast_03\",\n      reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\n      names: [\"value\"],\n      format: \"simulcast: %s\"\n    },\n    {\n      // a=framerate:25\n      // a=framerate:29.97\n      name: \"framerate\",\n      reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\n      format: \"framerate:%s\"\n    },\n    {\n      // RFC4570\n      // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5\n      name: \"sourceFilter\",\n      reg: /^source-filter: *(excl|incl) (\\S*) (IP4|IP6|\\*) (\\S*) (.*)/,\n      names: [\"filterMode\", \"netType\", \"addressTypes\", \"destAddress\", \"srcList\"],\n      format: \"source-filter: %s %s %s %s %s\"\n    },\n    {\n      // a=bundle-only\n      name: \"bundleOnly\",\n      reg: /^(bundle-only)/\n    },\n    {\n      // a=label:1\n      name: \"label\",\n      reg: /^label:(.+)/,\n      format: \"label:%s\"\n    },\n    {\n      // RFC version 26 for SCTP over DTLS\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5\n      name: \"sctpPort\",\n      reg: /^sctp-port:(\\d+)$/,\n      format: \"sctp-port:%s\"\n    },\n    {\n      // RFC version 26 for SCTP over DTLS\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6\n      name: \"maxMessageSize\",\n      reg: /^max-message-size:(\\d+)$/,\n      format: \"max-message-size:%s\"\n    },\n    {\n      // RFC7273\n      // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37\n      push: \"tsRefClocks\",\n      reg: /^ts-refclk:([^\\s=]*)(?:=(\\S*))?/,\n      names: [\"clksrc\", \"clksrcExt\"],\n      format: function(o) {\n        return \"ts-refclk:%s\" + (o.clksrcExt != null ? \"=%s\" : \"\");\n      }\n    },\n    {\n      // RFC7273\n      // a=mediaclk:direct=963214424\n      name: \"mediaClk\",\n      reg: /^mediaclk:(?:id=(\\S*))? *([^\\s=]*)(?:=(\\S*))?(?: *rate=(\\d+)\\/(\\d+))?/,\n      names: [\"id\", \"mediaClockName\", \"mediaClockValue\", \"rateNumerator\", \"rateDenominator\"],\n      format: function(o) {\n        var str = \"mediaclk:\";\n        str += o.id != null ? \"id=%s %s\" : \"%v%s\";\n        str += o.mediaClockValue != null ? \"=%s\" : \"\";\n        str += o.rateNumerator != null ? \" rate=%s\" : \"\";\n        str += o.rateDenominator != null ? \"/%s\" : \"\";\n        return str;\n      }\n    },\n    {\n      // a=keywds:keywords\n      name: \"keywords\",\n      reg: /^keywds:(.+)$/,\n      format: \"keywds:%s\"\n    },\n    {\n      // a=content:main\n      name: \"content\",\n      reg: /^content:(.+)/,\n      format: \"content:%s\"\n    },\n    // BFCP https://tools.ietf.org/html/rfc4583\n    {\n      // a=floorctrl:c-s\n      name: \"bfcpFloorCtrl\",\n      reg: /^floorctrl:(c-only|s-only|c-s)/,\n      format: \"floorctrl:%s\"\n    },\n    {\n      // a=confid:1\n      name: \"bfcpConfId\",\n      reg: /^confid:(\\d+)/,\n      format: \"confid:%s\"\n    },\n    {\n      // a=userid:1\n      name: \"bfcpUserId\",\n      reg: /^userid:(\\d+)/,\n      format: \"userid:%s\"\n    },\n    {\n      // a=floorid:1\n      name: \"bfcpFloorId\",\n      reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,\n      names: [\"id\", \"mStream\"],\n      format: \"floorid:%s mstrm:%s\"\n    },\n    {\n      // any a= that we don't understand is kept verbatim on media.invalid\n      push: \"invalid\",\n      names: [\"value\"]\n    }\n  ]\n};\nObject.keys(grammar$1).forEach(function(key) {\n  var objs = grammar$1[key];\n  objs.forEach(function(obj) {\n    if (!obj.reg) {\n      obj.reg = /(.*)/;\n    }\n    if (!obj.format) {\n      obj.format = \"%s\";\n    }\n  });\n});\nvar grammarExports = grammar$2.exports;\n(function(exports) {\n  var toIntIfInt = function(v) {\n    return String(Number(v)) === v ? Number(v) : v;\n  };\n  var attachProperties = function(match, location, names, rawName) {\n    if (rawName && !names) {\n      location[rawName] = toIntIfInt(match[1]);\n    } else {\n      for (var i = 0; i < names.length; i += 1) {\n        if (match[i + 1] != null) {\n          location[names[i]] = toIntIfInt(match[i + 1]);\n        }\n      }\n    }\n  };\n  var parseReg = function(obj, location, content) {\n    var needsBlank = obj.name && obj.names;\n    if (obj.push && !location[obj.push]) {\n      location[obj.push] = [];\n    } else if (needsBlank && !location[obj.name]) {\n      location[obj.name] = {};\n    }\n    var keyLocation = obj.push ? {} : (\n      // blank object that will be pushed\n      needsBlank ? location[obj.name] : location\n    );\n    attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n    if (obj.push) {\n      location[obj.push].push(keyLocation);\n    }\n  };\n  var grammar2 = grammarExports;\n  var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n  exports.parse = function(sdp2) {\n    var session = {}, media = [], location = session;\n    sdp2.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function(l) {\n      var type = l[0];\n      var content = l.slice(2);\n      if (type === \"m\") {\n        media.push({\n          rtp: [],\n          fmtp: []\n        });\n        location = media[media.length - 1];\n      }\n      for (var j = 0; j < (grammar2[type] || []).length; j += 1) {\n        var obj = grammar2[type][j];\n        if (obj.reg.test(content)) {\n          return parseReg(obj, location, content);\n        }\n      }\n    });\n    session.media = media;\n    return session;\n  };\n  var paramReducer = function(acc, expr) {\n    var s = expr.split(/=(.+)/, 2);\n    if (s.length === 2) {\n      acc[s[0]] = toIntIfInt(s[1]);\n    } else if (s.length === 1 && expr.length > 1) {\n      acc[s[0]] = void 0;\n    }\n    return acc;\n  };\n  exports.parseParams = function(str) {\n    return str.split(/;\\s?/).reduce(paramReducer, {});\n  };\n  exports.parseFmtpConfig = exports.parseParams;\n  exports.parsePayloads = function(str) {\n    return str.toString().split(\" \").map(Number);\n  };\n  exports.parseRemoteCandidates = function(str) {\n    var candidates = [];\n    var parts = str.split(\" \").map(toIntIfInt);\n    for (var i = 0; i < parts.length; i += 3) {\n      candidates.push({\n        component: parts[i],\n        ip: parts[i + 1],\n        port: parts[i + 2]\n      });\n    }\n    return candidates;\n  };\n  exports.parseImageAttributes = function(str) {\n    return str.split(\" \").map(function(item) {\n      return item.substring(1, item.length - 1).split(\",\").reduce(paramReducer, {});\n    });\n  };\n  exports.parseSimulcastStreamList = function(str) {\n    return str.split(\";\").map(function(stream) {\n      return stream.split(\",\").map(function(format2) {\n        var scid, paused = false;\n        if (format2[0] !== \"~\") {\n          scid = toIntIfInt(format2);\n        } else {\n          scid = toIntIfInt(format2.substring(1, format2.length));\n          paused = true;\n        }\n        return {\n          scid,\n          paused\n        };\n      });\n    });\n  };\n})(parser$1);\nvar grammar = grammarExports;\nvar formatRegExp = /%[sdv%]/g;\nvar format = function(formatStr) {\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  return formatStr.replace(formatRegExp, function(x) {\n    if (i >= len) {\n      return x;\n    }\n    var arg = args[i];\n    i += 1;\n    switch (x) {\n      case \"%%\":\n        return \"%\";\n      case \"%s\":\n        return String(arg);\n      case \"%d\":\n        return Number(arg);\n      case \"%v\":\n        return \"\";\n    }\n  });\n};\nvar makeLine = function(type, obj, location) {\n  var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;\n  var args = [type + \"=\" + str];\n  if (obj.names) {\n    for (var i = 0; i < obj.names.length; i += 1) {\n      var n = obj.names[i];\n      if (obj.name) {\n        args.push(location[obj.name][n]);\n      } else {\n        args.push(location[obj.names[i]]);\n      }\n    }\n  } else {\n    args.push(location[obj.name]);\n  }\n  return format.apply(null, args);\n};\nvar defaultOuterOrder = [\"v\", \"o\", \"s\", \"i\", \"u\", \"e\", \"p\", \"c\", \"b\", \"t\", \"r\", \"z\", \"a\"];\nvar defaultInnerOrder = [\"i\", \"c\", \"b\", \"a\"];\nvar writer$1 = function(session, opts) {\n  opts = opts || {};\n  if (session.version == null) {\n    session.version = 0;\n  }\n  if (session.name == null) {\n    session.name = \" \";\n  }\n  session.media.forEach(function(mLine) {\n    if (mLine.payloads == null) {\n      mLine.payloads = \"\";\n    }\n  });\n  var outerOrder = opts.outerOrder || defaultOuterOrder;\n  var innerOrder = opts.innerOrder || defaultInnerOrder;\n  var sdp2 = [];\n  outerOrder.forEach(function(type) {\n    grammar[type].forEach(function(obj) {\n      if (obj.name in session && session[obj.name] != null) {\n        sdp2.push(makeLine(type, obj, session));\n      } else if (obj.push in session && session[obj.push] != null) {\n        session[obj.push].forEach(function(el) {\n          sdp2.push(makeLine(type, obj, el));\n        });\n      }\n    });\n  });\n  session.media.forEach(function(mLine) {\n    sdp2.push(makeLine(\"m\", grammar.m[0], mLine));\n    innerOrder.forEach(function(type) {\n      grammar[type].forEach(function(obj) {\n        if (obj.name in mLine && mLine[obj.name] != null) {\n          sdp2.push(makeLine(type, obj, mLine));\n        } else if (obj.push in mLine && mLine[obj.push] != null) {\n          mLine[obj.push].forEach(function(el) {\n            sdp2.push(makeLine(type, obj, el));\n          });\n        }\n      });\n    });\n  });\n  return sdp2.join(\"\\r\\n\") + \"\\r\\n\";\n};\nvar parser = parser$1;\nvar writer = writer$1;\nvar write = writer;\nvar parse = parser.parse;\nparser.parseParams;\nparser.parseFmtpConfig;\nparser.parsePayloads;\nparser.parseRemoteCandidates;\nparser.parseImageAttributes;\nparser.parseSimulcastStreamList;\nfunction r(r2, e, n) {\n  var i, t, o;\n  void 0 === e && (e = 50), void 0 === n && (n = {});\n  var a = null != (i = n.isImmediate) && i, u = null != (t = n.callback) && t, c = n.maxWait, v = Date.now(), l = [];\n  function f() {\n    if (void 0 !== c) {\n      var r3 = Date.now() - v;\n      if (r3 + e >= c)\n        return c - r3;\n    }\n    return e;\n  }\n  var d = function() {\n    var e2 = [].slice.call(arguments), n2 = this;\n    return new Promise(function(i2, t2) {\n      var c2 = a && void 0 === o;\n      if (void 0 !== o && clearTimeout(o), o = setTimeout(function() {\n        if (o = void 0, v = Date.now(), !a) {\n          var i3 = r2.apply(n2, e2);\n          u && u(i3), l.forEach(function(r3) {\n            return (0, r3.resolve)(i3);\n          }), l = [];\n        }\n      }, f()), c2) {\n        var d2 = r2.apply(n2, e2);\n        return u && u(d2), i2(d2);\n      }\n      l.push({\n        resolve: i2,\n        reject: t2\n      });\n    });\n  };\n  return d.cancel = function(r3) {\n    void 0 !== o && clearTimeout(o), l.forEach(function(e2) {\n      return (0, e2.reject)(r3);\n    }), l = [];\n  }, d;\n}\nvar PCEvents = {\n  NegotiationStarted: \"negotiationStarted\",\n  NegotiationComplete: \"negotiationComplete\"\n};\nvar PCTransport = class extends eventsExports.EventEmitter {\n  constructor(config) {\n    let mediaConstraints = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    super();\n    this.pendingCandidates = [];\n    this.restartingIce = false;\n    this.renegotiate = false;\n    this.trackBitrates = [];\n    this.remoteStereoMids = [];\n    this.remoteNackMids = [];\n    this.negotiate = r((onError) => {\n      this.emit(PCEvents.NegotiationStarted);\n      try {\n        this.createAndSendOffer();\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          throw e;\n        }\n      }\n    }, 100);\n    this.pc = isChromiumBased() ? (\n      // @ts-expect-error chrome allows additional media constraints to be passed into the RTCPeerConnection constructor\n      new RTCPeerConnection(config, mediaConstraints)\n    ) : new RTCPeerConnection(config);\n  }\n  get isICEConnected() {\n    return this.pc.iceConnectionState === \"connected\" || this.pc.iceConnectionState === \"completed\";\n  }\n  addIceCandidate(candidate) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.pc.remoteDescription && !this.restartingIce) {\n        return this.pc.addIceCandidate(candidate);\n      }\n      this.pendingCandidates.push(candidate);\n    });\n  }\n  setRemoteDescription(sd) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (sd.type === \"offer\") {\n        let {\n          stereoMids,\n          nackMids\n        } = extractStereoAndNackAudioFromOffer(sd);\n        this.remoteStereoMids = stereoMids;\n        this.remoteNackMids = nackMids;\n      }\n      yield this.pc.setRemoteDescription(sd);\n      this.pendingCandidates.forEach((candidate) => {\n        this.pc.addIceCandidate(candidate);\n      });\n      this.pendingCandidates = [];\n      this.restartingIce = false;\n      if (this.renegotiate) {\n        this.renegotiate = false;\n        this.createAndSendOffer();\n      } else if (sd.type === \"answer\") {\n        this.emit(PCEvents.NegotiationComplete);\n      }\n    });\n  }\n  createAndSendOffer(options) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.onOffer === void 0) {\n        return;\n      }\n      if (options === null || options === void 0 ? void 0 : options.iceRestart) {\n        livekitLogger.debug(\"restarting ICE\");\n        this.restartingIce = true;\n      }\n      if (this.pc.signalingState === \"have-local-offer\") {\n        const currentSD = this.pc.remoteDescription;\n        if ((options === null || options === void 0 ? void 0 : options.iceRestart) && currentSD) {\n          yield this.pc.setRemoteDescription(currentSD);\n        } else {\n          this.renegotiate = true;\n          return;\n        }\n      } else if (this.pc.signalingState === \"closed\") {\n        livekitLogger.warn(\"could not createOffer with closed peer connection\");\n        return;\n      }\n      livekitLogger.debug(\"starting to negotiate\");\n      const offer = yield this.pc.createOffer(options);\n      const sdpParsed = parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : \"\");\n      sdpParsed.media.forEach((media) => {\n        if (media.type === \"audio\") {\n          ensureAudioNackAndStereo(media, [], []);\n        } else if (media.type === \"video\") {\n          ensureVideoDDExtensionForSVC(media);\n          this.trackBitrates.some((trackbr) => {\n            if (!media.msid || !media.msid.includes(trackbr.sid)) {\n              return false;\n            }\n            let codecPayload = 0;\n            media.rtp.some((rtp) => {\n              if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {\n                codecPayload = rtp.payload;\n                return true;\n              }\n              return false;\n            });\n            if (codecPayload > 0) {\n              if (!media.fmtp.some((fmtp) => {\n                if (fmtp.payload === codecPayload) {\n                  if (!fmtp.config.includes(\"x-google-start-bitrate\")) {\n                    fmtp.config += \";x-google-start-bitrate=\".concat(trackbr.maxbr * 0.7);\n                  }\n                  if (!fmtp.config.includes(\"x-google-max-bitrate\")) {\n                    fmtp.config += \";x-google-max-bitrate=\".concat(trackbr.maxbr);\n                  }\n                  return true;\n                }\n                return false;\n              })) {\n                media.fmtp.push({\n                  payload: codecPayload,\n                  config: \"x-google-start-bitrate=\".concat(trackbr.maxbr * 0.7, \";x-google-max-bitrate=\").concat(trackbr.maxbr)\n                });\n              }\n            }\n            return true;\n          });\n        }\n      });\n      this.trackBitrates = [];\n      yield this.setMungedLocalDescription(offer, write(sdpParsed));\n      this.onOffer(offer);\n    });\n  }\n  createAndSetAnswer() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const answer = yield this.pc.createAnswer();\n      const sdpParsed = parse((_a = answer.sdp) !== null && _a !== void 0 ? _a : \"\");\n      sdpParsed.media.forEach((media) => {\n        if (media.type === \"audio\") {\n          ensureAudioNackAndStereo(media, this.remoteStereoMids, this.remoteNackMids);\n        }\n      });\n      yield this.setMungedLocalDescription(answer, write(sdpParsed));\n      return answer;\n    });\n  }\n  setTrackCodecBitrate(sid, codec, maxbr) {\n    this.trackBitrates.push({\n      sid,\n      codec,\n      maxbr\n    });\n  }\n  close() {\n    this.pc.onconnectionstatechange = null;\n    this.pc.oniceconnectionstatechange = null;\n    this.pc.close();\n  }\n  setMungedLocalDescription(sd, munged) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const originalSdp = sd.sdp;\n      sd.sdp = munged;\n      try {\n        livekitLogger.debug(\"setting munged local description\");\n        yield this.pc.setLocalDescription(sd);\n        return;\n      } catch (e) {\n        livekitLogger.warn(\"not able to set \".concat(sd.type, \", falling back to unmodified sdp\"), {\n          error: e\n        });\n        sd.sdp = originalSdp;\n      }\n      try {\n        yield this.pc.setLocalDescription(sd);\n      } catch (e) {\n        let msg = \"unknown error\";\n        if (e instanceof Error) {\n          msg = e.message;\n        } else if (typeof e === \"string\") {\n          msg = e;\n        }\n        throw new NegotiationError(msg);\n      }\n    });\n  }\n};\nfunction ensureAudioNackAndStereo(media, stereoMids, nackMids) {\n  let opusPayload = 0;\n  media.rtp.some((rtp) => {\n    if (rtp.codec === \"opus\") {\n      opusPayload = rtp.payload;\n      return true;\n    }\n    return false;\n  });\n  if (opusPayload > 0) {\n    if (!media.rtcpFb) {\n      media.rtcpFb = [];\n    }\n    if (nackMids.includes(media.mid) && !media.rtcpFb.some((fb) => fb.payload === opusPayload && fb.type === \"nack\")) {\n      media.rtcpFb.push({\n        payload: opusPayload,\n        type: \"nack\"\n      });\n    }\n    if (stereoMids.includes(media.mid)) {\n      media.fmtp.some((fmtp) => {\n        if (fmtp.payload === opusPayload) {\n          if (!fmtp.config.includes(\"stereo=1\")) {\n            fmtp.config += \";stereo=1\";\n          }\n          return true;\n        }\n        return false;\n      });\n    }\n  }\n}\nfunction ensureVideoDDExtensionForSVC(media) {\n  var _a, _b, _c, _d;\n  const codec = (_b = (_a = media.rtp[0]) === null || _a === void 0 ? void 0 : _a.codec) === null || _b === void 0 ? void 0 : _b.toLowerCase();\n  if (!isSVCCodec(codec)) {\n    return;\n  }\n  let maxID = 0;\n  const ddFound = (_c = media.ext) === null || _c === void 0 ? void 0 : _c.some((ext) => {\n    if (ext.uri === ddExtensionURI) {\n      return true;\n    }\n    if (ext.value > maxID) {\n      maxID = ext.value;\n    }\n    return false;\n  });\n  if (!ddFound) {\n    (_d = media.ext) === null || _d === void 0 ? void 0 : _d.push({\n      value: maxID + 1,\n      uri: ddExtensionURI\n    });\n  }\n}\nfunction extractStereoAndNackAudioFromOffer(offer) {\n  var _a;\n  const stereoMids = [];\n  const nackMids = [];\n  const sdpParsed = parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : \"\");\n  let opusPayload = 0;\n  sdpParsed.media.forEach((media) => {\n    var _a2;\n    if (media.type === \"audio\") {\n      media.rtp.some((rtp) => {\n        if (rtp.codec === \"opus\") {\n          opusPayload = rtp.payload;\n          return true;\n        }\n        return false;\n      });\n      if ((_a2 = media.rtcpFb) === null || _a2 === void 0 ? void 0 : _a2.some((fb) => fb.payload === opusPayload && fb.type === \"nack\")) {\n        nackMids.push(media.mid);\n      }\n      media.fmtp.some((fmtp) => {\n        if (fmtp.payload === opusPayload) {\n          if (fmtp.config.includes(\"sprop-stereo=1\")) {\n            stereoMids.push(media.mid);\n          }\n          return true;\n        }\n        return false;\n      });\n    }\n  });\n  return {\n    stereoMids,\n    nackMids\n  };\n}\nvar RegionUrlProvider = class {\n  constructor(url, token) {\n    this.lastUpdateAt = 0;\n    this.settingsCacheTime = 3e3;\n    this.attemptedRegions = [];\n    this.serverUrl = new URL(url);\n    this.token = token;\n  }\n  isCloud() {\n    return isCloud(this.serverUrl);\n  }\n  getNextBestRegionUrl(abortSignal) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.isCloud()) {\n        throw Error(\"region availability is only supported for LiveKit Cloud domains\");\n      }\n      if (!this.regionSettings || Date.now() - this.lastUpdateAt > this.settingsCacheTime) {\n        this.regionSettings = yield this.fetchRegionSettings(abortSignal);\n      }\n      const regionsLeft = this.regionSettings.regions.filter((region) => !this.attemptedRegions.find((attempted) => attempted.url === region.url));\n      if (regionsLeft.length > 0) {\n        const nextRegion = regionsLeft[0];\n        this.attemptedRegions.push(nextRegion);\n        livekitLogger.debug(\"next region: \".concat(nextRegion.region));\n        return nextRegion.url;\n      } else {\n        return null;\n      }\n    });\n  }\n  resetAttempts() {\n    this.attemptedRegions = [];\n  }\n  fetchRegionSettings(signal) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const regionSettingsResponse = yield fetch(\"\".concat(getCloudConfigUrl(this.serverUrl), \"/regions\"), {\n        headers: {\n          authorization: \"Bearer \".concat(this.token)\n        },\n        signal\n      });\n      if (regionSettingsResponse.ok) {\n        const regionSettings = yield regionSettingsResponse.json();\n        this.lastUpdateAt = Date.now();\n        return regionSettings;\n      } else {\n        throw new ConnectionError(\"Could not fetch region settings: \".concat(regionSettingsResponse.statusText), regionSettingsResponse.status === 401 ? 0 : void 0, regionSettingsResponse.status);\n      }\n    });\n  }\n};\nfunction getCloudConfigUrl(serverUrl) {\n  return \"\".concat(serverUrl.protocol.replace(\"ws\", \"http\"), \"//\").concat(serverUrl.host, \"/settings\");\n}\nvar VideoPreset = class {\n  constructor(width, height, maxBitrate, maxFramerate, priority) {\n    this.width = width;\n    this.height = height;\n    this.encoding = {\n      maxBitrate,\n      maxFramerate,\n      priority\n    };\n  }\n  get resolution() {\n    return {\n      width: this.width,\n      height: this.height,\n      frameRate: this.encoding.maxFramerate,\n      aspectRatio: this.width / this.height\n    };\n  }\n};\nvar backupCodecs = [\"vp8\", \"h264\"];\nfunction isBackupCodec(codec) {\n  return !!backupCodecs.find((backup) => backup === codec);\n}\nfunction isCodecEqual(c1, c2) {\n  return (c1 === null || c1 === void 0 ? void 0 : c1.toLowerCase().replace(/audio\\/|video\\//y, \"\")) === (c2 === null || c2 === void 0 ? void 0 : c2.toLowerCase().replace(/audio\\/|video\\//y, \"\"));\n}\nvar AudioPresets;\n(function(AudioPresets2) {\n  AudioPresets2.telephone = {\n    maxBitrate: 12e3\n  };\n  AudioPresets2.speech = {\n    maxBitrate: 2e4\n  };\n  AudioPresets2.music = {\n    maxBitrate: 32e3\n  };\n  AudioPresets2.musicStereo = {\n    maxBitrate: 48e3\n  };\n  AudioPresets2.musicHighQuality = {\n    maxBitrate: 64e3\n  };\n  AudioPresets2.musicHighQualityStereo = {\n    maxBitrate: 96e3\n  };\n})(AudioPresets || (AudioPresets = {}));\nvar VideoPresets = {\n  h90: new VideoPreset(160, 90, 6e4, 15),\n  h180: new VideoPreset(320, 180, 12e4, 15),\n  h216: new VideoPreset(384, 216, 18e4, 15),\n  h360: new VideoPreset(640, 360, 3e5, 20),\n  h540: new VideoPreset(960, 540, 6e5, 25),\n  h720: new VideoPreset(1280, 720, 17e5, 30),\n  h1080: new VideoPreset(1920, 1080, 3e6, 30),\n  h1440: new VideoPreset(2560, 1440, 5e6, 30),\n  h2160: new VideoPreset(3840, 2160, 8e6, 30)\n};\nvar VideoPresets43 = {\n  h120: new VideoPreset(160, 120, 8e4, 15),\n  h180: new VideoPreset(240, 180, 1e5, 15),\n  h240: new VideoPreset(320, 240, 15e4, 15),\n  h360: new VideoPreset(480, 360, 225e3, 20),\n  h480: new VideoPreset(640, 480, 3e5, 20),\n  h540: new VideoPreset(720, 540, 45e4, 25),\n  h720: new VideoPreset(960, 720, 15e5, 30),\n  h1080: new VideoPreset(1440, 1080, 25e5, 30),\n  h1440: new VideoPreset(1920, 1440, 35e5, 30)\n};\nvar ScreenSharePresets = {\n  h360fps3: new VideoPreset(640, 360, 2e5, 3, \"medium\"),\n  h720fps5: new VideoPreset(1280, 720, 4e5, 5, \"medium\"),\n  h720fps15: new VideoPreset(1280, 720, 1e6, 15, \"medium\"),\n  h1080fps15: new VideoPreset(1920, 1080, 15e5, 15, \"medium\"),\n  h1080fps30: new VideoPreset(1920, 1080, 3e6, 30, \"medium\")\n};\nvar publishDefaults = {\n  /**\n   * @deprecated\n   */\n  audioBitrate: AudioPresets.music.maxBitrate,\n  audioPreset: AudioPresets.music,\n  dtx: true,\n  red: true,\n  forceStereo: false,\n  simulcast: true,\n  screenShareEncoding: ScreenSharePresets.h1080fps15.encoding,\n  stopMicTrackOnMute: false,\n  videoCodec: \"vp8\",\n  backupCodec: {\n    codec: \"vp8\",\n    encoding: VideoPresets.h540.encoding\n  }\n};\nvar audioDefaults = {\n  autoGainControl: true,\n  echoCancellation: true,\n  noiseSuppression: true\n};\nvar videoDefaults = {\n  resolution: VideoPresets.h720.resolution\n};\nvar roomOptionDefaults = {\n  adaptiveStream: false,\n  dynacast: false,\n  stopLocalTrackOnUnpublish: true,\n  reconnectPolicy: new DefaultReconnectPolicy(),\n  disconnectOnPageLeave: true,\n  expWebAudioMix: false\n};\nvar roomConnectOptionDefaults = {\n  autoSubscribe: true,\n  maxRetries: 1,\n  peerConnectionTimeout: 15e3\n};\nvar RoomEvent;\n(function(RoomEvent2) {\n  RoomEvent2[\"Connected\"] = \"connected\";\n  RoomEvent2[\"Reconnecting\"] = \"reconnecting\";\n  RoomEvent2[\"Reconnected\"] = \"reconnected\";\n  RoomEvent2[\"Disconnected\"] = \"disconnected\";\n  RoomEvent2[\"ConnectionStateChanged\"] = \"connectionStateChanged\";\n  RoomEvent2[\"StateChanged\"] = \"connectionStateChanged\";\n  RoomEvent2[\"MediaDevicesChanged\"] = \"mediaDevicesChanged\";\n  RoomEvent2[\"ParticipantConnected\"] = \"participantConnected\";\n  RoomEvent2[\"ParticipantDisconnected\"] = \"participantDisconnected\";\n  RoomEvent2[\"TrackPublished\"] = \"trackPublished\";\n  RoomEvent2[\"TrackSubscribed\"] = \"trackSubscribed\";\n  RoomEvent2[\"TrackSubscriptionFailed\"] = \"trackSubscriptionFailed\";\n  RoomEvent2[\"TrackUnpublished\"] = \"trackUnpublished\";\n  RoomEvent2[\"TrackUnsubscribed\"] = \"trackUnsubscribed\";\n  RoomEvent2[\"TrackMuted\"] = \"trackMuted\";\n  RoomEvent2[\"TrackUnmuted\"] = \"trackUnmuted\";\n  RoomEvent2[\"LocalTrackPublished\"] = \"localTrackPublished\";\n  RoomEvent2[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n  RoomEvent2[\"LocalAudioSilenceDetected\"] = \"localAudioSilenceDetected\";\n  RoomEvent2[\"ActiveSpeakersChanged\"] = \"activeSpeakersChanged\";\n  RoomEvent2[\"ParticipantMetadataChanged\"] = \"participantMetadataChanged\";\n  RoomEvent2[\"ParticipantNameChanged\"] = \"participantNameChanged\";\n  RoomEvent2[\"RoomMetadataChanged\"] = \"roomMetadataChanged\";\n  RoomEvent2[\"DataReceived\"] = \"dataReceived\";\n  RoomEvent2[\"ConnectionQualityChanged\"] = \"connectionQualityChanged\";\n  RoomEvent2[\"TrackStreamStateChanged\"] = \"trackStreamStateChanged\";\n  RoomEvent2[\"TrackSubscriptionPermissionChanged\"] = \"trackSubscriptionPermissionChanged\";\n  RoomEvent2[\"TrackSubscriptionStatusChanged\"] = \"trackSubscriptionStatusChanged\";\n  RoomEvent2[\"AudioPlaybackStatusChanged\"] = \"audioPlaybackChanged\";\n  RoomEvent2[\"MediaDevicesError\"] = \"mediaDevicesError\";\n  RoomEvent2[\"ParticipantPermissionsChanged\"] = \"participantPermissionsChanged\";\n  RoomEvent2[\"SignalConnected\"] = \"signalConnected\";\n  RoomEvent2[\"RecordingStatusChanged\"] = \"recordingStatusChanged\";\n  RoomEvent2[\"DCBufferStatusChanged\"] = \"dcBufferStatusChanged\";\n})(RoomEvent || (RoomEvent = {}));\nvar ParticipantEvent;\n(function(ParticipantEvent2) {\n  ParticipantEvent2[\"TrackPublished\"] = \"trackPublished\";\n  ParticipantEvent2[\"TrackSubscribed\"] = \"trackSubscribed\";\n  ParticipantEvent2[\"TrackSubscriptionFailed\"] = \"trackSubscriptionFailed\";\n  ParticipantEvent2[\"TrackUnpublished\"] = \"trackUnpublished\";\n  ParticipantEvent2[\"TrackUnsubscribed\"] = \"trackUnsubscribed\";\n  ParticipantEvent2[\"TrackMuted\"] = \"trackMuted\";\n  ParticipantEvent2[\"TrackUnmuted\"] = \"trackUnmuted\";\n  ParticipantEvent2[\"LocalTrackPublished\"] = \"localTrackPublished\";\n  ParticipantEvent2[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n  ParticipantEvent2[\"ParticipantMetadataChanged\"] = \"participantMetadataChanged\";\n  ParticipantEvent2[\"ParticipantNameChanged\"] = \"participantNameChanged\";\n  ParticipantEvent2[\"DataReceived\"] = \"dataReceived\";\n  ParticipantEvent2[\"IsSpeakingChanged\"] = \"isSpeakingChanged\";\n  ParticipantEvent2[\"ConnectionQualityChanged\"] = \"connectionQualityChanged\";\n  ParticipantEvent2[\"TrackStreamStateChanged\"] = \"trackStreamStateChanged\";\n  ParticipantEvent2[\"TrackSubscriptionPermissionChanged\"] = \"trackSubscriptionPermissionChanged\";\n  ParticipantEvent2[\"TrackSubscriptionStatusChanged\"] = \"trackSubscriptionStatusChanged\";\n  ParticipantEvent2[\"MediaDevicesError\"] = \"mediaDevicesError\";\n  ParticipantEvent2[\"ParticipantPermissionsChanged\"] = \"participantPermissionsChanged\";\n})(ParticipantEvent || (ParticipantEvent = {}));\nvar EngineEvent;\n(function(EngineEvent2) {\n  EngineEvent2[\"TransportsCreated\"] = \"transportsCreated\";\n  EngineEvent2[\"Connected\"] = \"connected\";\n  EngineEvent2[\"Disconnected\"] = \"disconnected\";\n  EngineEvent2[\"Resuming\"] = \"resuming\";\n  EngineEvent2[\"Resumed\"] = \"resumed\";\n  EngineEvent2[\"Restarting\"] = \"restarting\";\n  EngineEvent2[\"Restarted\"] = \"restarted\";\n  EngineEvent2[\"SignalResumed\"] = \"signalResumed\";\n  EngineEvent2[\"SignalRestarted\"] = \"signalRestarted\";\n  EngineEvent2[\"Closing\"] = \"closing\";\n  EngineEvent2[\"MediaTrackAdded\"] = \"mediaTrackAdded\";\n  EngineEvent2[\"ActiveSpeakersUpdate\"] = \"activeSpeakersUpdate\";\n  EngineEvent2[\"DataPacketReceived\"] = \"dataPacketReceived\";\n  EngineEvent2[\"DCBufferStatusChanged\"] = \"dcBufferStatusChanged\";\n})(EngineEvent || (EngineEvent = {}));\nvar TrackEvent;\n(function(TrackEvent2) {\n  TrackEvent2[\"Message\"] = \"message\";\n  TrackEvent2[\"Muted\"] = \"muted\";\n  TrackEvent2[\"Unmuted\"] = \"unmuted\";\n  TrackEvent2[\"Restarted\"] = \"restarted\";\n  TrackEvent2[\"Ended\"] = \"ended\";\n  TrackEvent2[\"Subscribed\"] = \"subscribed\";\n  TrackEvent2[\"Unsubscribed\"] = \"unsubscribed\";\n  TrackEvent2[\"UpdateSettings\"] = \"updateSettings\";\n  TrackEvent2[\"UpdateSubscription\"] = \"updateSubscription\";\n  TrackEvent2[\"AudioPlaybackStarted\"] = \"audioPlaybackStarted\";\n  TrackEvent2[\"AudioPlaybackFailed\"] = \"audioPlaybackFailed\";\n  TrackEvent2[\"AudioSilenceDetected\"] = \"audioSilenceDetected\";\n  TrackEvent2[\"VisibilityChanged\"] = \"visibilityChanged\";\n  TrackEvent2[\"VideoDimensionsChanged\"] = \"videoDimensionsChanged\";\n  TrackEvent2[\"ElementAttached\"] = \"elementAttached\";\n  TrackEvent2[\"ElementDetached\"] = \"elementDetached\";\n  TrackEvent2[\"UpstreamPaused\"] = \"upstreamPaused\";\n  TrackEvent2[\"UpstreamResumed\"] = \"upstreamResumed\";\n  TrackEvent2[\"SubscriptionPermissionChanged\"] = \"subscriptionPermissionChanged\";\n  TrackEvent2[\"SubscriptionStatusChanged\"] = \"subscriptionStatusChanged\";\n})(TrackEvent || (TrackEvent = {}));\nvar BACKGROUND_REACTION_DELAY = 5e3;\nvar recycledElements = [];\nvar Track = class extends eventsExports.EventEmitter {\n  constructor(mediaTrack, kind) {\n    super();\n    this.attachedElements = [];\n    this.isMuted = false;\n    this.streamState = Track.StreamState.Active;\n    this.isInBackground = false;\n    this._currentBitrate = 0;\n    this.appVisibilityChangedListener = () => {\n      if (this.backgroundTimeout) {\n        clearTimeout(this.backgroundTimeout);\n      }\n      if (document.visibilityState === \"hidden\") {\n        this.backgroundTimeout = setTimeout(() => this.handleAppVisibilityChanged(), BACKGROUND_REACTION_DELAY);\n      } else {\n        this.handleAppVisibilityChanged();\n      }\n    };\n    this.setMaxListeners(100);\n    this.kind = kind;\n    this._mediaStreamTrack = mediaTrack;\n    this._mediaStreamID = mediaTrack.id;\n    this.source = Track.Source.Unknown;\n  }\n  /** current receive bits per second */\n  get currentBitrate() {\n    return this._currentBitrate;\n  }\n  get mediaStreamTrack() {\n    return this._mediaStreamTrack;\n  }\n  /**\n   * @internal\n   * used for keep mediaStream's first id, since it's id might change\n   * if we disable/enable a track\n   */\n  get mediaStreamID() {\n    return this._mediaStreamID;\n  }\n  attach(element) {\n    let elementType = \"audio\";\n    if (this.kind === Track.Kind.Video) {\n      elementType = \"video\";\n    }\n    if (this.attachedElements.length === 0 && Track.Kind.Video) {\n      this.addAppVisibilityListener();\n    }\n    if (!element) {\n      if (elementType === \"audio\") {\n        recycledElements.forEach((e) => {\n          if (e.parentElement === null && !element) {\n            element = e;\n          }\n        });\n        if (element) {\n          recycledElements.splice(recycledElements.indexOf(element), 1);\n        }\n      }\n      if (!element) {\n        element = document.createElement(elementType);\n      }\n    }\n    if (!this.attachedElements.includes(element)) {\n      this.attachedElements.push(element);\n    }\n    attachToElement(this._mediaStreamTrack, element);\n    const allMediaStreamTracks = element.srcObject.getTracks();\n    if (allMediaStreamTracks.some((tr) => tr.kind === \"audio\")) {\n      element.play().then(() => {\n        this.emit(TrackEvent.AudioPlaybackStarted);\n      }).catch((e) => {\n        if (e.name === \"NotAllowedError\") {\n          this.emit(TrackEvent.AudioPlaybackFailed, e);\n        } else {\n          livekitLogger.warn(\"could not playback audio\", e);\n        }\n        if (element && allMediaStreamTracks.some((tr) => tr.kind === \"video\") && e.name === \"NotAllowedError\") {\n          element.muted = true;\n          element.play().catch(() => {\n          });\n        }\n      });\n    }\n    this.emit(TrackEvent.ElementAttached, element);\n    return element;\n  }\n  detach(element) {\n    try {\n      if (element) {\n        detachTrack(this._mediaStreamTrack, element);\n        const idx = this.attachedElements.indexOf(element);\n        if (idx >= 0) {\n          this.attachedElements.splice(idx, 1);\n          this.recycleElement(element);\n          this.emit(TrackEvent.ElementDetached, element);\n        }\n        return element;\n      }\n      const detached = [];\n      this.attachedElements.forEach((elm) => {\n        detachTrack(this._mediaStreamTrack, elm);\n        detached.push(elm);\n        this.recycleElement(elm);\n        this.emit(TrackEvent.ElementDetached, elm);\n      });\n      this.attachedElements = [];\n      return detached;\n    } finally {\n      if (this.attachedElements.length === 0) {\n        this.removeAppVisibilityListener();\n      }\n    }\n  }\n  stop() {\n    this.stopMonitor();\n    this._mediaStreamTrack.stop();\n  }\n  enable() {\n    this._mediaStreamTrack.enabled = true;\n  }\n  disable() {\n    this._mediaStreamTrack.enabled = false;\n  }\n  /* @internal */\n  stopMonitor() {\n    if (this.monitorInterval) {\n      clearInterval(this.monitorInterval);\n    }\n  }\n  recycleElement(element) {\n    if (element instanceof HTMLAudioElement) {\n      let shouldCache = true;\n      element.pause();\n      recycledElements.forEach((e) => {\n        if (!e.parentElement) {\n          shouldCache = false;\n        }\n      });\n      if (shouldCache) {\n        recycledElements.push(element);\n      }\n    }\n  }\n  handleAppVisibilityChanged() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.isInBackground = document.visibilityState === \"hidden\";\n    });\n  }\n  addAppVisibilityListener() {\n    if (isWeb()) {\n      this.isInBackground = document.visibilityState === \"hidden\";\n      document.addEventListener(\"visibilitychange\", this.appVisibilityChangedListener);\n    } else {\n      this.isInBackground = false;\n    }\n  }\n  removeAppVisibilityListener() {\n    if (isWeb()) {\n      document.removeEventListener(\"visibilitychange\", this.appVisibilityChangedListener);\n    }\n  }\n};\nfunction attachToElement(track, element) {\n  let mediaStream;\n  if (element.srcObject instanceof MediaStream) {\n    mediaStream = element.srcObject;\n  } else {\n    mediaStream = new MediaStream();\n  }\n  let existingTracks;\n  if (track.kind === \"audio\") {\n    existingTracks = mediaStream.getAudioTracks();\n  } else {\n    existingTracks = mediaStream.getVideoTracks();\n  }\n  if (!existingTracks.includes(track)) {\n    existingTracks.forEach((et) => {\n      mediaStream.removeTrack(et);\n    });\n    mediaStream.addTrack(track);\n  }\n  element.autoplay = true;\n  element.muted = mediaStream.getAudioTracks().length === 0;\n  if (element instanceof HTMLVideoElement) {\n    element.playsInline = true;\n  }\n  if (element.srcObject !== mediaStream) {\n    element.srcObject = mediaStream;\n    if ((isSafari() || isFireFox()) && element instanceof HTMLVideoElement) {\n      setTimeout(() => {\n        element.srcObject = mediaStream;\n        element.play().catch(() => {\n        });\n      }, 0);\n    }\n  }\n}\nfunction detachTrack(track, element) {\n  if (element.srcObject instanceof MediaStream) {\n    const mediaStream = element.srcObject;\n    mediaStream.removeTrack(track);\n    if (mediaStream.getTracks().length > 0) {\n      element.srcObject = mediaStream;\n    } else {\n      element.srcObject = null;\n    }\n  }\n}\n(function(Track2) {\n  let Kind;\n  (function(Kind2) {\n    Kind2[\"Audio\"] = \"audio\";\n    Kind2[\"Video\"] = \"video\";\n    Kind2[\"Unknown\"] = \"unknown\";\n  })(Kind = Track2.Kind || (Track2.Kind = {}));\n  let Source;\n  (function(Source2) {\n    Source2[\"Camera\"] = \"camera\";\n    Source2[\"Microphone\"] = \"microphone\";\n    Source2[\"ScreenShare\"] = \"screen_share\";\n    Source2[\"ScreenShareAudio\"] = \"screen_share_audio\";\n    Source2[\"Unknown\"] = \"unknown\";\n  })(Source = Track2.Source || (Track2.Source = {}));\n  let StreamState$1;\n  (function(StreamState2) {\n    StreamState2[\"Active\"] = \"active\";\n    StreamState2[\"Paused\"] = \"paused\";\n    StreamState2[\"Unknown\"] = \"unknown\";\n  })(StreamState$1 = Track2.StreamState || (Track2.StreamState = {}));\n  function kindToProto(k) {\n    switch (k) {\n      case Kind.Audio:\n        return TrackType.AUDIO;\n      case Kind.Video:\n        return TrackType.VIDEO;\n      default:\n        return TrackType.UNRECOGNIZED;\n    }\n  }\n  Track2.kindToProto = kindToProto;\n  function kindFromProto(t) {\n    switch (t) {\n      case TrackType.AUDIO:\n        return Kind.Audio;\n      case TrackType.VIDEO:\n        return Kind.Video;\n      default:\n        return Kind.Unknown;\n    }\n  }\n  Track2.kindFromProto = kindFromProto;\n  function sourceToProto(s) {\n    switch (s) {\n      case Source.Camera:\n        return TrackSource.CAMERA;\n      case Source.Microphone:\n        return TrackSource.MICROPHONE;\n      case Source.ScreenShare:\n        return TrackSource.SCREEN_SHARE;\n      case Source.ScreenShareAudio:\n        return TrackSource.SCREEN_SHARE_AUDIO;\n      default:\n        return TrackSource.UNRECOGNIZED;\n    }\n  }\n  Track2.sourceToProto = sourceToProto;\n  function sourceFromProto(s) {\n    switch (s) {\n      case TrackSource.CAMERA:\n        return Source.Camera;\n      case TrackSource.MICROPHONE:\n        return Source.Microphone;\n      case TrackSource.SCREEN_SHARE:\n        return Source.ScreenShare;\n      case TrackSource.SCREEN_SHARE_AUDIO:\n        return Source.ScreenShareAudio;\n      default:\n        return Source.Unknown;\n    }\n  }\n  Track2.sourceFromProto = sourceFromProto;\n  function streamStateFromProto(s) {\n    switch (s) {\n      case StreamState.ACTIVE:\n        return StreamState$1.Active;\n      case StreamState.PAUSED:\n        return StreamState$1.Paused;\n      default:\n        return StreamState$1.Unknown;\n    }\n  }\n  Track2.streamStateFromProto = streamStateFromProto;\n})(Track || (Track = {}));\nvar lossyDataChannel = \"_lossy\";\nvar reliableDataChannel = \"_reliable\";\nvar minReconnectWait = 2 * 1e3;\nvar leaveReconnect = \"leave-reconnect\";\nvar PCState;\n(function(PCState2) {\n  PCState2[PCState2[\"New\"] = 0] = \"New\";\n  PCState2[PCState2[\"Connected\"] = 1] = \"Connected\";\n  PCState2[PCState2[\"Disconnected\"] = 2] = \"Disconnected\";\n  PCState2[PCState2[\"Reconnecting\"] = 3] = \"Reconnecting\";\n  PCState2[PCState2[\"Closed\"] = 4] = \"Closed\";\n})(PCState || (PCState = {}));\nvar RTCEngine = class extends eventsExports.EventEmitter {\n  get isClosed() {\n    return this._isClosed;\n  }\n  constructor(options) {\n    super();\n    this.options = options;\n    this.rtcConfig = {};\n    this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;\n    this.fullReconnectOnNext = false;\n    this.subscriberPrimary = false;\n    this.pcState = PCState.New;\n    this._isClosed = true;\n    this.pendingTrackResolvers = {};\n    this.hasPublished = false;\n    this.reconnectAttempts = 0;\n    this.reconnectStart = 0;\n    this.attemptingReconnect = false;\n    this.joinAttempts = 0;\n    this.maxJoinAttempts = 1;\n    this.shouldFailNext = false;\n    this.handleDataChannel = (_ref) => {\n      let {\n        channel\n      } = _ref;\n      return __awaiter(this, void 0, void 0, function* () {\n        if (!channel) {\n          return;\n        }\n        if (channel.label === reliableDataChannel) {\n          this.reliableDCSub = channel;\n        } else if (channel.label === lossyDataChannel) {\n          this.lossyDCSub = channel;\n        } else {\n          return;\n        }\n        livekitLogger.debug(\"on data channel \".concat(channel.id, \", \").concat(channel.label));\n        channel.onmessage = this.handleDataMessage;\n      });\n    };\n    this.handleDataMessage = (message) => __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      const unlock = yield this.dataProcessLock.lock();\n      try {\n        let buffer;\n        if (message.data instanceof ArrayBuffer) {\n          buffer = message.data;\n        } else if (message.data instanceof Blob) {\n          buffer = yield message.data.arrayBuffer();\n        } else {\n          livekitLogger.error(\"unsupported data type\", message.data);\n          return;\n        }\n        const dp = DataPacket.decode(new Uint8Array(buffer));\n        if (((_a = dp.value) === null || _a === void 0 ? void 0 : _a.$case) === \"speaker\") {\n          this.emit(EngineEvent.ActiveSpeakersUpdate, dp.value.speaker.speakers);\n        } else if (((_b = dp.value) === null || _b === void 0 ? void 0 : _b.$case) === \"user\") {\n          this.emit(EngineEvent.DataPacketReceived, dp.value.user, dp.kind);\n        }\n      } finally {\n        unlock();\n      }\n    });\n    this.handleDataError = (event) => {\n      const channel = event.currentTarget;\n      const channelKind = channel.maxRetransmits === 0 ? \"lossy\" : \"reliable\";\n      if (event instanceof ErrorEvent) {\n        const {\n          error\n        } = event.error;\n        livekitLogger.error(\"DataChannel error on \".concat(channelKind, \": \").concat(event.message), error);\n      } else {\n        livekitLogger.error(\"Unknown DataChannel Error on \".concat(channelKind), event);\n      }\n    };\n    this.handleBufferedAmountLow = (event) => {\n      const channel = event.currentTarget;\n      const channelKind = channel.maxRetransmits === 0 ? DataPacket_Kind.LOSSY : DataPacket_Kind.RELIABLE;\n      this.updateAndEmitDCBufferStatus(channelKind);\n    };\n    this.handleDisconnect = (connection, disconnectReason) => {\n      if (this._isClosed) {\n        return;\n      }\n      livekitLogger.warn(\"\".concat(connection, \" disconnected\"));\n      if (this.reconnectAttempts === 0) {\n        this.reconnectStart = Date.now();\n      }\n      const disconnect = (duration2) => {\n        livekitLogger.warn(\"could not recover connection after \".concat(this.reconnectAttempts, \" attempts, \").concat(duration2, \"ms. giving up\"));\n        this.emit(EngineEvent.Disconnected);\n        this.close();\n      };\n      const duration = Date.now() - this.reconnectStart;\n      let delay = this.getNextRetryDelay({\n        elapsedMs: duration,\n        retryCount: this.reconnectAttempts\n      });\n      if (delay === null) {\n        disconnect(duration);\n        return;\n      }\n      if (connection === leaveReconnect) {\n        delay = 0;\n      }\n      livekitLogger.debug(\"reconnecting in \".concat(delay, \"ms\"));\n      this.clearReconnectTimeout();\n      if (this.url && this.token && isCloud(new URL(this.url))) {\n        this.regionUrlProvider = new RegionUrlProvider(this.url, this.token);\n      }\n      this.reconnectTimeout = CriticalTimers.setTimeout(() => this.attemptReconnect(disconnectReason), delay);\n    };\n    this.waitForRestarted = () => {\n      return new Promise((resolve, reject) => {\n        if (this.pcState === PCState.Connected) {\n          resolve();\n        }\n        const onRestarted = () => {\n          this.off(EngineEvent.Disconnected, onDisconnected);\n          resolve();\n        };\n        const onDisconnected = () => {\n          this.off(EngineEvent.Restarted, onRestarted);\n          reject();\n        };\n        this.once(EngineEvent.Restarted, onRestarted);\n        this.once(EngineEvent.Disconnected, onDisconnected);\n      });\n    };\n    this.updateAndEmitDCBufferStatus = (kind) => {\n      const status = this.isBufferStatusLow(kind);\n      if (typeof status !== \"undefined\" && status !== this.dcBufferStatus.get(kind)) {\n        this.dcBufferStatus.set(kind, status);\n        this.emit(EngineEvent.DCBufferStatusChanged, status, kind);\n      }\n    };\n    this.isBufferStatusLow = (kind) => {\n      const dc = this.dataChannelForKind(kind);\n      if (dc) {\n        return dc.bufferedAmount <= dc.bufferedAmountLowThreshold;\n      }\n    };\n    this.handleBrowserOnLine = () => {\n      if (this.client.isReconnecting) {\n        this.clearReconnectTimeout();\n        this.attemptReconnect(ReconnectReason.RR_SIGNAL_DISCONNECTED);\n      }\n    };\n    this.client = new SignalClient();\n    this.client.signalLatency = this.options.expSignalLatency;\n    this.reconnectPolicy = this.options.reconnectPolicy;\n    this.registerOnLineListener();\n    this.closingLock = new Mutex();\n    this.dataProcessLock = new Mutex();\n    this.dcBufferStatus = /* @__PURE__ */ new Map([[DataPacket_Kind.LOSSY, true], [DataPacket_Kind.RELIABLE, true]]);\n  }\n  join(url, token, opts, abortSignal) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.url = url;\n      this.token = token;\n      this.signalOpts = opts;\n      try {\n        this.joinAttempts += 1;\n        const joinResponse = yield this.client.join(url, token, opts, abortSignal);\n        this._isClosed = false;\n        this.latestJoinResponse = joinResponse;\n        this.subscriberPrimary = joinResponse.subscriberPrimary;\n        if (!this.publisher) {\n          this.configure(joinResponse);\n        }\n        if (!this.subscriberPrimary) {\n          this.negotiate();\n        }\n        this.clientConfiguration = joinResponse.clientConfiguration;\n        return joinResponse;\n      } catch (e) {\n        if (e instanceof ConnectionError) {\n          if (e.reason === 1) {\n            livekitLogger.warn(\"Couldn't connect to server, attempt \".concat(this.joinAttempts, \" of \").concat(this.maxJoinAttempts));\n            if (this.joinAttempts < this.maxJoinAttempts) {\n              return this.join(url, token, opts, abortSignal);\n            }\n          }\n        }\n        throw e;\n      }\n    });\n  }\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.closingLock.lock();\n      if (this.isClosed) {\n        unlock();\n        return;\n      }\n      try {\n        this._isClosed = true;\n        this.emit(EngineEvent.Closing);\n        this.removeAllListeners();\n        this.deregisterOnLineListener();\n        this.clearPendingReconnect();\n        if (this.publisher && this.publisher.pc.signalingState !== \"closed\") {\n          this.publisher.pc.getSenders().forEach((sender) => {\n            var _a, _b;\n            try {\n              if ((_a = this.publisher) === null || _a === void 0 ? void 0 : _a.pc.removeTrack) {\n                (_b = this.publisher) === null || _b === void 0 ? void 0 : _b.pc.removeTrack(sender);\n              }\n            } catch (e) {\n              livekitLogger.warn(\"could not removeTrack\", {\n                error: e\n              });\n            }\n          });\n          this.publisher.close();\n          this.publisher = void 0;\n        }\n        if (this.subscriber) {\n          this.subscriber.close();\n          this.subscriber = void 0;\n        }\n        yield this.client.close();\n      } finally {\n        unlock();\n      }\n    });\n  }\n  addTrack(req) {\n    if (this.pendingTrackResolvers[req.cid]) {\n      throw new TrackInvalidError(\"a track with the same ID has already been published\");\n    }\n    return new Promise((resolve, reject) => {\n      const publicationTimeout = setTimeout(() => {\n        delete this.pendingTrackResolvers[req.cid];\n        reject(new ConnectionError(\"publication of local track timed out, no response from server\"));\n      }, 1e4);\n      this.pendingTrackResolvers[req.cid] = {\n        resolve: (info) => {\n          clearTimeout(publicationTimeout);\n          resolve(info);\n        },\n        reject: () => {\n          clearTimeout(publicationTimeout);\n          reject(new Error(\"Cancelled publication by calling unpublish\"));\n        }\n      };\n      this.client.sendAddTrack(req);\n    });\n  }\n  /**\n   * Removes sender from PeerConnection, returning true if it was removed successfully\n   * and a negotiation is necessary\n   * @param sender\n   * @returns\n   */\n  removeTrack(sender) {\n    var _a;\n    if (sender.track && this.pendingTrackResolvers[sender.track.id]) {\n      const {\n        reject\n      } = this.pendingTrackResolvers[sender.track.id];\n      if (reject) {\n        reject();\n      }\n      delete this.pendingTrackResolvers[sender.track.id];\n    }\n    try {\n      (_a = this.publisher) === null || _a === void 0 ? void 0 : _a.pc.removeTrack(sender);\n      return true;\n    } catch (e) {\n      livekitLogger.warn(\"failed to remove track\", {\n        error: e,\n        method: \"removeTrack\"\n      });\n    }\n    return false;\n  }\n  updateMuteStatus(trackSid, muted) {\n    this.client.sendMuteTrack(trackSid, muted);\n  }\n  get dataSubscriberReadyState() {\n    var _a;\n    return (_a = this.reliableDCSub) === null || _a === void 0 ? void 0 : _a.readyState;\n  }\n  getConnectedServerAddress() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.primaryPC === void 0) {\n        return void 0;\n      }\n      return getConnectedAddress(this.primaryPC);\n    });\n  }\n  configure(joinResponse) {\n    var _a;\n    if (this.publisher || this.subscriber) {\n      return;\n    }\n    this.participantSid = (_a = joinResponse.participant) === null || _a === void 0 ? void 0 : _a.sid;\n    const rtcConfig = this.makeRTCConfiguration(joinResponse);\n    const googConstraints = {\n      optional: [{\n        googDscp: true\n      }]\n    };\n    this.publisher = new PCTransport(rtcConfig, googConstraints);\n    this.subscriber = new PCTransport(rtcConfig);\n    this.emit(EngineEvent.TransportsCreated, this.publisher, this.subscriber);\n    this.publisher.pc.onicecandidate = (ev) => {\n      if (!ev.candidate)\n        return;\n      livekitLogger.trace(\"adding ICE candidate for peer\", ev.candidate);\n      this.client.sendIceCandidate(ev.candidate, SignalTarget.PUBLISHER);\n    };\n    this.subscriber.pc.onicecandidate = (ev) => {\n      if (!ev.candidate)\n        return;\n      this.client.sendIceCandidate(ev.candidate, SignalTarget.SUBSCRIBER);\n    };\n    this.publisher.onOffer = (offer) => {\n      this.client.sendOffer(offer);\n    };\n    let primaryPC = this.publisher.pc;\n    let secondaryPC = this.subscriber.pc;\n    let subscriberPrimary = joinResponse.subscriberPrimary;\n    if (subscriberPrimary) {\n      primaryPC = this.subscriber.pc;\n      secondaryPC = this.publisher.pc;\n      this.subscriber.pc.ondatachannel = this.handleDataChannel;\n    }\n    this.primaryPC = primaryPC;\n    primaryPC.onconnectionstatechange = () => __awaiter(this, void 0, void 0, function* () {\n      livekitLogger.debug(\"primary PC state changed \".concat(primaryPC.connectionState));\n      if (primaryPC.connectionState === \"connected\") {\n        const shouldEmit = this.pcState === PCState.New;\n        this.pcState = PCState.Connected;\n        if (shouldEmit) {\n          this.emit(EngineEvent.Connected, joinResponse);\n        }\n      } else if (primaryPC.connectionState === \"failed\") {\n        if (this.pcState === PCState.Connected) {\n          this.pcState = PCState.Disconnected;\n          this.handleDisconnect(\"primary peerconnection\", subscriberPrimary ? ReconnectReason.RR_SUBSCRIBER_FAILED : ReconnectReason.RR_PUBLISHER_FAILED);\n        }\n      }\n    });\n    secondaryPC.onconnectionstatechange = () => __awaiter(this, void 0, void 0, function* () {\n      livekitLogger.debug(\"secondary PC state changed \".concat(secondaryPC.connectionState));\n      if (secondaryPC.connectionState === \"failed\") {\n        this.handleDisconnect(\"secondary peerconnection\", subscriberPrimary ? ReconnectReason.RR_PUBLISHER_FAILED : ReconnectReason.RR_SUBSCRIBER_FAILED);\n      }\n    });\n    this.subscriber.pc.ontrack = (ev) => {\n      this.emit(EngineEvent.MediaTrackAdded, ev.track, ev.streams[0], ev.receiver);\n    };\n    this.createDataChannels();\n    this.client.onAnswer = (sd) => __awaiter(this, void 0, void 0, function* () {\n      if (!this.publisher) {\n        return;\n      }\n      livekitLogger.debug(\"received server answer\", {\n        RTCSdpType: sd.type,\n        signalingState: this.publisher.pc.signalingState\n      });\n      yield this.publisher.setRemoteDescription(sd);\n    });\n    this.client.onTrickle = (candidate, target) => {\n      if (!this.publisher || !this.subscriber) {\n        return;\n      }\n      livekitLogger.trace(\"got ICE candidate from peer\", {\n        candidate,\n        target\n      });\n      if (target === SignalTarget.PUBLISHER) {\n        this.publisher.addIceCandidate(candidate);\n      } else {\n        this.subscriber.addIceCandidate(candidate);\n      }\n    };\n    this.client.onOffer = (sd) => __awaiter(this, void 0, void 0, function* () {\n      if (!this.subscriber) {\n        return;\n      }\n      livekitLogger.debug(\"received server offer\", {\n        RTCSdpType: sd.type,\n        signalingState: this.subscriber.pc.signalingState\n      });\n      yield this.subscriber.setRemoteDescription(sd);\n      const answer = yield this.subscriber.createAndSetAnswer();\n      this.client.sendAnswer(answer);\n    });\n    this.client.onLocalTrackPublished = (res) => {\n      livekitLogger.debug(\"received trackPublishedResponse\", res);\n      const {\n        resolve\n      } = this.pendingTrackResolvers[res.cid];\n      if (!resolve) {\n        livekitLogger.error(\"missing track resolver for \".concat(res.cid));\n        return;\n      }\n      delete this.pendingTrackResolvers[res.cid];\n      resolve(res.track);\n    };\n    this.client.onTokenRefresh = (token) => {\n      this.token = token;\n    };\n    this.client.onClose = () => {\n      this.handleDisconnect(\"signal\", ReconnectReason.RR_SIGNAL_DISCONNECTED);\n    };\n    this.client.onLeave = (leave) => {\n      if (leave === null || leave === void 0 ? void 0 : leave.canReconnect) {\n        this.fullReconnectOnNext = true;\n        this.primaryPC = void 0;\n        this.handleDisconnect(leaveReconnect);\n      } else {\n        this.emit(EngineEvent.Disconnected, leave === null || leave === void 0 ? void 0 : leave.reason);\n        this.close();\n      }\n      livekitLogger.trace(\"leave request\", {\n        leave\n      });\n    };\n  }\n  makeRTCConfiguration(serverResponse) {\n    const rtcConfig = Object.assign({}, this.rtcConfig);\n    if (serverResponse.iceServers && !rtcConfig.iceServers) {\n      const rtcIceServers = [];\n      serverResponse.iceServers.forEach((iceServer) => {\n        const rtcIceServer = {\n          urls: iceServer.urls\n        };\n        if (iceServer.username)\n          rtcIceServer.username = iceServer.username;\n        if (iceServer.credential) {\n          rtcIceServer.credential = iceServer.credential;\n        }\n        rtcIceServers.push(rtcIceServer);\n      });\n      rtcConfig.iceServers = rtcIceServers;\n    }\n    if (serverResponse.clientConfiguration && serverResponse.clientConfiguration.forceRelay === ClientConfigSetting.ENABLED) {\n      rtcConfig.iceTransportPolicy = \"relay\";\n    }\n    rtcConfig.sdpSemantics = \"unified-plan\";\n    rtcConfig.continualGatheringPolicy = \"gather_continually\";\n    return rtcConfig;\n  }\n  createDataChannels() {\n    if (!this.publisher) {\n      return;\n    }\n    if (this.lossyDC) {\n      this.lossyDC.onmessage = null;\n      this.lossyDC.onerror = null;\n    }\n    if (this.reliableDC) {\n      this.reliableDC.onmessage = null;\n      this.reliableDC.onerror = null;\n    }\n    this.lossyDC = this.publisher.pc.createDataChannel(lossyDataChannel, {\n      // will drop older packets that arrive\n      ordered: true,\n      maxRetransmits: 0\n    });\n    this.reliableDC = this.publisher.pc.createDataChannel(reliableDataChannel, {\n      ordered: true\n    });\n    this.lossyDC.onmessage = this.handleDataMessage;\n    this.reliableDC.onmessage = this.handleDataMessage;\n    this.lossyDC.onerror = this.handleDataError;\n    this.reliableDC.onerror = this.handleDataError;\n    this.lossyDC.bufferedAmountLowThreshold = 65535;\n    this.reliableDC.bufferedAmountLowThreshold = 65535;\n    this.lossyDC.onbufferedamountlow = this.handleBufferedAmountLow;\n    this.reliableDC.onbufferedamountlow = this.handleBufferedAmountLow;\n  }\n  setPreferredCodec(transceiver, kind, videoCodec) {\n    if (!(\"getCapabilities\" in RTCRtpSender)) {\n      return;\n    }\n    const cap = RTCRtpSender.getCapabilities(kind);\n    if (!cap)\n      return;\n    livekitLogger.debug(\"get capabilities\", cap);\n    const matched = [];\n    const partialMatched = [];\n    const unmatched = [];\n    cap.codecs.forEach((c) => {\n      const codec = c.mimeType.toLowerCase();\n      if (codec === \"audio/opus\") {\n        matched.push(c);\n        return;\n      }\n      const matchesVideoCodec = codec === \"video/\".concat(videoCodec);\n      if (!matchesVideoCodec) {\n        unmatched.push(c);\n        return;\n      }\n      if (videoCodec === \"h264\") {\n        if (c.sdpFmtpLine && c.sdpFmtpLine.includes(\"profile-level-id=42e01f\")) {\n          matched.push(c);\n        } else {\n          partialMatched.push(c);\n        }\n        return;\n      }\n      matched.push(c);\n    });\n    if (supportsSetCodecPreferences(transceiver)) {\n      transceiver.setCodecPreferences(matched.concat(partialMatched, unmatched));\n    }\n  }\n  createSender(track, opts, encodings) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (supportsTransceiver()) {\n        return this.createTransceiverRTCRtpSender(track, opts, encodings);\n      }\n      if (supportsAddTrack()) {\n        livekitLogger.debug(\"using add-track fallback\");\n        return this.createRTCRtpSender(track.mediaStreamTrack);\n      }\n      throw new UnexpectedConnectionState(\"Required webRTC APIs not supported on this device\");\n    });\n  }\n  createSimulcastSender(track, simulcastTrack, opts, encodings) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (supportsTransceiver()) {\n        return this.createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings);\n      }\n      if (supportsAddTrack()) {\n        livekitLogger.debug(\"using add-track fallback\");\n        return this.createRTCRtpSender(track.mediaStreamTrack);\n      }\n      throw new UnexpectedConnectionState(\"Cannot stream on this device\");\n    });\n  }\n  createTransceiverRTCRtpSender(track, opts, encodings) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.publisher) {\n        throw new UnexpectedConnectionState(\"publisher is closed\");\n      }\n      const transceiverInit = {\n        direction: \"sendonly\"\n      };\n      if (encodings) {\n        transceiverInit.sendEncodings = encodings;\n      }\n      const transceiver = yield this.publisher.pc.addTransceiver(track.mediaStreamTrack, transceiverInit);\n      if (track.kind === Track.Kind.Video && opts.videoCodec) {\n        this.setPreferredCodec(transceiver, track.kind, opts.videoCodec);\n        track.codec = opts.videoCodec;\n      }\n      return transceiver.sender;\n    });\n  }\n  createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.publisher) {\n        throw new UnexpectedConnectionState(\"publisher is closed\");\n      }\n      const transceiverInit = {\n        direction: \"sendonly\"\n      };\n      if (encodings) {\n        transceiverInit.sendEncodings = encodings;\n      }\n      const transceiver = yield this.publisher.pc.addTransceiver(simulcastTrack.mediaStreamTrack, transceiverInit);\n      if (!opts.videoCodec) {\n        return;\n      }\n      this.setPreferredCodec(transceiver, track.kind, opts.videoCodec);\n      track.setSimulcastTrackSender(opts.videoCodec, transceiver.sender);\n      return transceiver.sender;\n    });\n  }\n  createRTCRtpSender(track) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.publisher) {\n        throw new UnexpectedConnectionState(\"publisher is closed\");\n      }\n      return this.publisher.pc.addTrack(track);\n    });\n  }\n  attemptReconnect(reason) {\n    var _a, _b, _c;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._isClosed) {\n        return;\n      }\n      if (this.attemptingReconnect) {\n        return;\n      }\n      if (((_a = this.clientConfiguration) === null || _a === void 0 ? void 0 : _a.resumeConnection) === ClientConfigSetting.DISABLED || // signaling state could change to closed due to hardware sleep\n      // those connections cannot be resumed\n      ((_c = (_b = this.primaryPC) === null || _b === void 0 ? void 0 : _b.signalingState) !== null && _c !== void 0 ? _c : \"closed\") === \"closed\") {\n        this.fullReconnectOnNext = true;\n      }\n      try {\n        this.attemptingReconnect = true;\n        if (this.fullReconnectOnNext) {\n          yield this.restartConnection();\n        } else {\n          yield this.resumeConnection(reason);\n        }\n        this.clearPendingReconnect();\n        this.fullReconnectOnNext = false;\n      } catch (e) {\n        this.reconnectAttempts += 1;\n        let recoverable = true;\n        if (e instanceof UnexpectedConnectionState) {\n          livekitLogger.debug(\"received unrecoverable error\", {\n            error: e\n          });\n          recoverable = false;\n        } else if (!(e instanceof SignalReconnectError)) {\n          this.fullReconnectOnNext = true;\n        }\n        if (recoverable) {\n          this.handleDisconnect(\"reconnect\", ReconnectReason.RR_UNKOWN);\n        } else {\n          livekitLogger.info(\"could not recover connection after \".concat(this.reconnectAttempts, \" attempts, \").concat(Date.now() - this.reconnectStart, \"ms. giving up\"));\n          this.emit(EngineEvent.Disconnected);\n          yield this.close();\n        }\n      } finally {\n        this.attemptingReconnect = false;\n      }\n    });\n  }\n  getNextRetryDelay(context) {\n    try {\n      return this.reconnectPolicy.nextRetryDelayInMs(context);\n    } catch (e) {\n      livekitLogger.warn(\"encountered error in reconnect policy\", {\n        error: e\n      });\n    }\n    return null;\n  }\n  restartConnection(regionUrl) {\n    var _a, _b, _c, _d, _e;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!this.url || !this.token) {\n          throw new UnexpectedConnectionState(\"could not reconnect, url or token not saved\");\n        }\n        livekitLogger.info(\"reconnecting, attempt: \".concat(this.reconnectAttempts));\n        this.emit(EngineEvent.Restarting);\n        if (this.client.isConnected) {\n          yield this.client.sendLeave();\n        }\n        yield this.client.close();\n        this.primaryPC = void 0;\n        (_a = this.publisher) === null || _a === void 0 ? void 0 : _a.close();\n        this.publisher = void 0;\n        (_b = this.subscriber) === null || _b === void 0 ? void 0 : _b.close();\n        this.subscriber = void 0;\n        let joinResponse;\n        try {\n          if (!this.signalOpts) {\n            livekitLogger.warn(\"attempted connection restart, without signal options present\");\n            throw new SignalReconnectError();\n          }\n          joinResponse = yield this.join(regionUrl !== null && regionUrl !== void 0 ? regionUrl : this.url, this.token, this.signalOpts);\n        } catch (e) {\n          if (e instanceof ConnectionError && e.reason === 0) {\n            throw new UnexpectedConnectionState(\"could not reconnect, token might be expired\");\n          }\n          throw new SignalReconnectError();\n        }\n        if (this.shouldFailNext) {\n          this.shouldFailNext = false;\n          throw new Error(\"simulated failure\");\n        }\n        this.client.setReconnected();\n        this.emit(EngineEvent.SignalRestarted, joinResponse);\n        yield this.waitForPCReconnected();\n        (_c = this.regionUrlProvider) === null || _c === void 0 ? void 0 : _c.resetAttempts();\n        this.emit(EngineEvent.Restarted);\n      } catch (error) {\n        const nextRegionUrl = yield (_d = this.regionUrlProvider) === null || _d === void 0 ? void 0 : _d.getNextBestRegionUrl();\n        if (nextRegionUrl) {\n          yield this.restartConnection(nextRegionUrl);\n          return;\n        } else {\n          (_e = this.regionUrlProvider) === null || _e === void 0 ? void 0 : _e.resetAttempts();\n          throw error;\n        }\n      }\n    });\n  }\n  resumeConnection(reason) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.url || !this.token) {\n        throw new UnexpectedConnectionState(\"could not reconnect, url or token not saved\");\n      }\n      if (!this.publisher || !this.subscriber) {\n        throw new UnexpectedConnectionState(\"publisher and subscriber connections unset\");\n      }\n      livekitLogger.info(\"resuming signal connection, attempt \".concat(this.reconnectAttempts));\n      this.emit(EngineEvent.Resuming);\n      try {\n        const res = yield this.client.reconnect(this.url, this.token, this.participantSid, reason);\n        if (res) {\n          const rtcConfig = this.makeRTCConfiguration(res);\n          this.publisher.pc.setConfiguration(rtcConfig);\n          this.subscriber.pc.setConfiguration(rtcConfig);\n        }\n      } catch (e) {\n        let message = \"\";\n        if (e instanceof Error) {\n          message = e.message;\n        }\n        if (e instanceof ConnectionError && e.reason === 0) {\n          throw new UnexpectedConnectionState(\"could not reconnect, token might be expired\");\n        }\n        throw new SignalReconnectError(message);\n      }\n      this.emit(EngineEvent.SignalResumed);\n      if (this.shouldFailNext) {\n        this.shouldFailNext = false;\n        throw new Error(\"simulated failure\");\n      }\n      this.subscriber.restartingIce = true;\n      if (this.hasPublished) {\n        yield this.publisher.createAndSendOffer({\n          iceRestart: true\n        });\n      }\n      yield this.waitForPCReconnected();\n      this.client.setReconnected();\n      if (((_a = this.reliableDC) === null || _a === void 0 ? void 0 : _a.readyState) === \"open\" && this.reliableDC.id === null) {\n        this.createDataChannels();\n      }\n      this.emit(EngineEvent.Resumed);\n    });\n  }\n  waitForPCInitialConnection(timeout, abortController) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.pcState === PCState.Connected) {\n        return;\n      }\n      if (this.pcState !== PCState.New) {\n        throw new UnexpectedConnectionState(\"Expected peer connection to be new on initial connection\");\n      }\n      return new Promise((resolve, reject) => {\n        const abortHandler = () => {\n          livekitLogger.warn(\"closing engine\");\n          CriticalTimers.clearTimeout(connectTimeout);\n          reject(new ConnectionError(\n            \"room connection has been cancelled\",\n            3\n            /* ConnectionErrorReason.Cancelled */\n          ));\n        };\n        if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {\n          abortHandler();\n        }\n        abortController === null || abortController === void 0 ? void 0 : abortController.signal.addEventListener(\"abort\", abortHandler);\n        const onConnected = () => {\n          CriticalTimers.clearTimeout(connectTimeout);\n          abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener(\"abort\", abortHandler);\n          resolve();\n        };\n        const connectTimeout = CriticalTimers.setTimeout(() => {\n          this.off(EngineEvent.Connected, onConnected);\n          reject(new ConnectionError(\"could not establish pc connection\"));\n        }, timeout !== null && timeout !== void 0 ? timeout : this.peerConnectionTimeout);\n        this.once(EngineEvent.Connected, onConnected);\n      });\n    });\n  }\n  waitForPCReconnected() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const startTime = Date.now();\n      let now = startTime;\n      this.pcState = PCState.Reconnecting;\n      livekitLogger.debug(\"waiting for peer connection to reconnect\");\n      while (now - startTime < this.peerConnectionTimeout) {\n        if (this.primaryPC === void 0) {\n          break;\n        } else if (\n          // on Safari, we don't get a connectionstatechanged event during ICE restart\n          // this means we'd have to check its status manually and update address\n          // manually\n          now - startTime > minReconnectWait && ((_a = this.primaryPC) === null || _a === void 0 ? void 0 : _a.connectionState) === \"connected\"\n        ) {\n          this.pcState = PCState.Connected;\n        }\n        if (this.pcState === PCState.Connected) {\n          return;\n        }\n        yield sleep(100);\n        now = Date.now();\n      }\n      throw new ConnectionError(\"could not establish PC connection\");\n    });\n  }\n  /* @internal */\n  sendDataPacket(packet, kind) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const msg = DataPacket.encode(packet).finish();\n      yield this.ensurePublisherConnected(kind);\n      const dc = this.dataChannelForKind(kind);\n      if (dc) {\n        dc.send(msg);\n      }\n      this.updateAndEmitDCBufferStatus(kind);\n    });\n  }\n  /**\n   * @internal\n   */\n  ensureDataTransportConnected(kind) {\n    let subscriber = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.subscriberPrimary;\n    var _a, _b, _c;\n    return __awaiter(this, void 0, void 0, function* () {\n      const transport = subscriber ? this.subscriber : this.publisher;\n      const transportName = subscriber ? \"Subscriber\" : \"Publisher\";\n      if (!transport) {\n        throw new ConnectionError(\"\".concat(transportName, \" connection not set\"));\n      }\n      if (!subscriber && !((_a = this.publisher) === null || _a === void 0 ? void 0 : _a.isICEConnected) && ((_b = this.publisher) === null || _b === void 0 ? void 0 : _b.pc.iceConnectionState) !== \"checking\") {\n        this.negotiate();\n      }\n      const targetChannel = this.dataChannelForKind(kind, subscriber);\n      if ((targetChannel === null || targetChannel === void 0 ? void 0 : targetChannel.readyState) === \"open\") {\n        return;\n      }\n      const endTime = (/* @__PURE__ */ new Date()).getTime() + this.peerConnectionTimeout;\n      while ((/* @__PURE__ */ new Date()).getTime() < endTime) {\n        if (transport.isICEConnected && ((_c = this.dataChannelForKind(kind, subscriber)) === null || _c === void 0 ? void 0 : _c.readyState) === \"open\") {\n          return;\n        }\n        yield sleep(50);\n      }\n      throw new ConnectionError(\"could not establish \".concat(transportName, \" connection, state: \").concat(transport.pc.iceConnectionState));\n    });\n  }\n  ensurePublisherConnected(kind) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.ensureDataTransportConnected(kind, false);\n    });\n  }\n  /* @internal */\n  verifyTransport() {\n    if (!this.primaryPC) {\n      return false;\n    }\n    if (this.primaryPC.connectionState === \"closed\" || this.primaryPC.connectionState === \"failed\") {\n      return false;\n    }\n    if (this.hasPublished && this.subscriberPrimary) {\n      if (!this.publisher) {\n        return false;\n      }\n      if (this.publisher.pc.connectionState === \"closed\" || this.publisher.pc.connectionState === \"failed\") {\n        return false;\n      }\n    }\n    if (!this.client.ws || this.client.ws.readyState === WebSocket.CLOSED) {\n      return false;\n    }\n    return true;\n  }\n  /** @internal */\n  negotiate() {\n    return new Promise((resolve, reject) => {\n      if (!this.publisher) {\n        reject(new NegotiationError(\"publisher is not defined\"));\n        return;\n      }\n      this.hasPublished = true;\n      const handleClosed = () => {\n        livekitLogger.debug(\"engine disconnected while negotiation was ongoing\");\n        cleanup();\n        resolve();\n        return;\n      };\n      this.on(EngineEvent.Closing, handleClosed);\n      const negotiationTimeout = setTimeout(() => {\n        reject(\"negotiation timed out\");\n        this.handleDisconnect(\"negotiation\", ReconnectReason.RR_SIGNAL_DISCONNECTED);\n      }, this.peerConnectionTimeout);\n      const cleanup = () => {\n        clearTimeout(negotiationTimeout);\n        this.off(EngineEvent.Closing, handleClosed);\n      };\n      this.publisher.once(PCEvents.NegotiationStarted, () => {\n        var _a;\n        (_a = this.publisher) === null || _a === void 0 ? void 0 : _a.once(PCEvents.NegotiationComplete, () => {\n          cleanup();\n          resolve();\n        });\n      });\n      this.publisher.negotiate((e) => {\n        cleanup();\n        reject(e);\n        if (e instanceof NegotiationError) {\n          this.fullReconnectOnNext = true;\n        }\n        this.handleDisconnect(\"negotiation\", ReconnectReason.RR_UNKOWN);\n      });\n    });\n  }\n  dataChannelForKind(kind, sub) {\n    if (!sub) {\n      if (kind === DataPacket_Kind.LOSSY) {\n        return this.lossyDC;\n      }\n      if (kind === DataPacket_Kind.RELIABLE) {\n        return this.reliableDC;\n      }\n    } else {\n      if (kind === DataPacket_Kind.LOSSY) {\n        return this.lossyDCSub;\n      }\n      if (kind === DataPacket_Kind.RELIABLE) {\n        return this.reliableDCSub;\n      }\n    }\n  }\n  /* @internal */\n  failNext() {\n    this.shouldFailNext = true;\n  }\n  clearReconnectTimeout() {\n    if (this.reconnectTimeout) {\n      CriticalTimers.clearTimeout(this.reconnectTimeout);\n    }\n  }\n  clearPendingReconnect() {\n    this.clearReconnectTimeout();\n    this.reconnectAttempts = 0;\n  }\n  registerOnLineListener() {\n    if (isWeb()) {\n      window.addEventListener(\"online\", this.handleBrowserOnLine);\n    }\n  }\n  deregisterOnLineListener() {\n    if (isWeb()) {\n      window.removeEventListener(\"online\", this.handleBrowserOnLine);\n    }\n  }\n};\nfunction getConnectedAddress(pc) {\n  var _a;\n  return __awaiter(this, void 0, void 0, function* () {\n    let selectedCandidatePairId = \"\";\n    const candidatePairs = /* @__PURE__ */ new Map();\n    const candidates = /* @__PURE__ */ new Map();\n    const stats = yield pc.getStats();\n    stats.forEach((v) => {\n      switch (v.type) {\n        case \"transport\":\n          selectedCandidatePairId = v.selectedCandidatePairId;\n          break;\n        case \"candidate-pair\":\n          if (selectedCandidatePairId === \"\" && v.selected) {\n            selectedCandidatePairId = v.id;\n          }\n          candidatePairs.set(v.id, v);\n          break;\n        case \"remote-candidate\":\n          candidates.set(v.id, \"\".concat(v.address, \":\").concat(v.port));\n          break;\n      }\n    });\n    if (selectedCandidatePairId === \"\") {\n      return void 0;\n    }\n    const selectedID = (_a = candidatePairs.get(selectedCandidatePairId)) === null || _a === void 0 ? void 0 : _a.remoteCandidateId;\n    if (selectedID === void 0) {\n      return void 0;\n    }\n    return candidates.get(selectedID);\n  });\n}\nvar SignalReconnectError = class extends Error {\n};\nvar monitorFrequency = 2e3;\nfunction computeBitrate(currentStats, prevStats) {\n  if (!prevStats) {\n    return 0;\n  }\n  let bytesNow;\n  let bytesPrev;\n  if (\"bytesReceived\" in currentStats) {\n    bytesNow = currentStats.bytesReceived;\n    bytesPrev = prevStats.bytesReceived;\n  } else if (\"bytesSent\" in currentStats) {\n    bytesNow = currentStats.bytesSent;\n    bytesPrev = prevStats.bytesSent;\n  }\n  if (bytesNow === void 0 || bytesPrev === void 0 || currentStats.timestamp === void 0 || prevStats.timestamp === void 0) {\n    return 0;\n  }\n  return (bytesNow - bytesPrev) * 8 * 1e3 / (currentStats.timestamp - prevStats.timestamp);\n}\nvar defaultDimensionsTimeout = 2 * 1e3;\nvar LocalTrack = class extends Track {\n  /**\n   *\n   * @param mediaTrack\n   * @param kind\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */\n  constructor(mediaTrack, kind, constraints) {\n    let userProvidedTrack = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n    super(mediaTrack, kind);\n    this._isUpstreamPaused = false;\n    this.handleEnded = () => {\n      if (this.isInBackground) {\n        this.reacquireTrack = true;\n      }\n      this.emit(TrackEvent.Ended, this);\n    };\n    this._mediaStreamTrack.addEventListener(\"ended\", this.handleEnded);\n    this.constraints = constraints !== null && constraints !== void 0 ? constraints : mediaTrack.getConstraints();\n    this.reacquireTrack = false;\n    this.providedByUser = userProvidedTrack;\n    this.muteLock = new Mutex();\n    this.pauseUpstreamLock = new Mutex();\n  }\n  get id() {\n    return this._mediaStreamTrack.id;\n  }\n  get dimensions() {\n    if (this.kind !== Track.Kind.Video) {\n      return void 0;\n    }\n    const {\n      width,\n      height\n    } = this._mediaStreamTrack.getSettings();\n    if (width && height) {\n      return {\n        width,\n        height\n      };\n    }\n    return void 0;\n  }\n  get isUpstreamPaused() {\n    return this._isUpstreamPaused;\n  }\n  get isUserProvided() {\n    return this.providedByUser;\n  }\n  waitForDimensions() {\n    let timeout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultDimensionsTimeout;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.kind === Track.Kind.Audio) {\n        throw new Error(\"cannot get dimensions for audio tracks\");\n      }\n      const started = Date.now();\n      while (Date.now() - started < timeout) {\n        const dims = this.dimensions;\n        if (dims) {\n          return dims;\n        }\n        yield sleep(50);\n      }\n      throw new TrackInvalidError(\"unable to get track dimensions after timeout\");\n    });\n  }\n  /**\n   * @returns DeviceID of the device that is currently being used for this track\n   */\n  getDeviceId() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.source === Track.Source.ScreenShare) {\n        return;\n      }\n      const {\n        deviceId,\n        groupId\n      } = this._mediaStreamTrack.getSettings();\n      const kind = this.kind === Track.Kind.Audio ? \"audioinput\" : \"videoinput\";\n      return DeviceManager.getInstance().normalizeDeviceId(kind, deviceId, groupId);\n    });\n  }\n  mute() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.setTrackMuted(true);\n      return this;\n    });\n  }\n  unmute() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.setTrackMuted(false);\n      return this;\n    });\n  }\n  replaceTrack(track) {\n    let userProvidedTrack = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.sender) {\n        throw new TrackInvalidError(\"unable to replace an unpublished track\");\n      }\n      this.attachedElements.forEach((el) => {\n        detachTrack(this._mediaStreamTrack, el);\n      });\n      this._mediaStreamTrack.removeEventListener(\"ended\", this.handleEnded);\n      if (!this.providedByUser) {\n        this._mediaStreamTrack.stop();\n      }\n      track.addEventListener(\"ended\", this.handleEnded);\n      livekitLogger.debug(\"replace MediaStreamTrack\");\n      if (this.sender) {\n        yield this.sender.replaceTrack(track);\n      }\n      this._mediaStreamTrack = track;\n      this._mediaStreamTrack.enabled = !this.isMuted;\n      yield this.resumeUpstream();\n      this.attachedElements.forEach((el) => {\n        attachToElement(track, el);\n      });\n      this.mediaStream = new MediaStream([track]);\n      this.providedByUser = userProvidedTrack;\n      return this;\n    });\n  }\n  restart(constraints) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!constraints) {\n        constraints = this.constraints;\n      }\n      livekitLogger.debug(\"restarting track with constraints\", constraints);\n      const streamConstraints = {\n        audio: false,\n        video: false\n      };\n      if (this.kind === Track.Kind.Video) {\n        streamConstraints.video = constraints;\n      } else {\n        streamConstraints.audio = constraints;\n      }\n      this.attachedElements.forEach((el) => {\n        detachTrack(this._mediaStreamTrack, el);\n      });\n      this._mediaStreamTrack.removeEventListener(\"ended\", this.handleEnded);\n      this._mediaStreamTrack.stop();\n      const mediaStream = yield navigator.mediaDevices.getUserMedia(streamConstraints);\n      const newTrack = mediaStream.getTracks()[0];\n      newTrack.addEventListener(\"ended\", this.handleEnded);\n      livekitLogger.debug(\"re-acquired MediaStreamTrack\");\n      if (this.sender) {\n        yield this.sender.replaceTrack(newTrack);\n      }\n      this._mediaStreamTrack = newTrack;\n      yield this.resumeUpstream();\n      this.attachedElements.forEach((el) => {\n        attachToElement(newTrack, el);\n      });\n      this.mediaStream = mediaStream;\n      this.constraints = constraints;\n      this.emit(TrackEvent.Restarted, this);\n      return this;\n    });\n  }\n  setTrackMuted(muted) {\n    livekitLogger.debug(\"setting \".concat(this.kind, \" track \").concat(muted ? \"muted\" : \"unmuted\"));\n    if (this.isMuted === muted && this._mediaStreamTrack.enabled !== muted) {\n      return;\n    }\n    this.isMuted = muted;\n    this._mediaStreamTrack.enabled = !muted;\n    this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);\n  }\n  get needsReAcquisition() {\n    return this._mediaStreamTrack.readyState !== \"live\" || this._mediaStreamTrack.muted || !this._mediaStreamTrack.enabled || this.reacquireTrack;\n  }\n  handleAppVisibilityChanged() {\n    const _super = Object.create(null, {\n      handleAppVisibilityChanged: {\n        get: () => super.handleAppVisibilityChanged\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      yield _super.handleAppVisibilityChanged.call(this);\n      if (!isMobile())\n        return;\n      livekitLogger.debug(\"visibility changed, is in Background: \".concat(this.isInBackground));\n      if (!this.isInBackground && this.needsReAcquisition && !this.isUserProvided && !this.isMuted) {\n        livekitLogger.debug(\"track needs to be reaquired, restarting \".concat(this.source));\n        yield this.restart();\n        this.reacquireTrack = false;\n      }\n    });\n  }\n  pauseUpstream() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.pauseUpstreamLock.lock();\n      try {\n        if (this._isUpstreamPaused === true) {\n          return;\n        }\n        if (!this.sender) {\n          livekitLogger.warn(\"unable to pause upstream for an unpublished track\");\n          return;\n        }\n        this._isUpstreamPaused = true;\n        this.emit(TrackEvent.UpstreamPaused, this);\n        const emptyTrack = this.kind === Track.Kind.Audio ? getEmptyAudioStreamTrack() : getEmptyVideoStreamTrack();\n        yield this.sender.replaceTrack(emptyTrack);\n      } finally {\n        unlock();\n      }\n    });\n  }\n  resumeUpstream() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.pauseUpstreamLock.lock();\n      try {\n        if (this._isUpstreamPaused === false) {\n          return;\n        }\n        if (!this.sender) {\n          livekitLogger.warn(\"unable to resume upstream for an unpublished track\");\n          return;\n        }\n        this._isUpstreamPaused = false;\n        this.emit(TrackEvent.UpstreamResumed, this);\n        yield this.sender.replaceTrack(this._mediaStreamTrack);\n      } finally {\n        unlock();\n      }\n    });\n  }\n};\nvar LocalAudioTrack = class extends LocalTrack {\n  /**\n   *\n   * @param mediaTrack\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */\n  constructor(mediaTrack, constraints) {\n    let userProvidedTrack = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n    super(mediaTrack, Track.Kind.Audio, constraints, userProvidedTrack);\n    this.stopOnMute = false;\n    this.monitorSender = () => __awaiter(this, void 0, void 0, function* () {\n      if (!this.sender) {\n        this._currentBitrate = 0;\n        return;\n      }\n      let stats;\n      try {\n        stats = yield this.getSenderStats();\n      } catch (e) {\n        livekitLogger.error(\"could not get audio sender stats\", {\n          error: e\n        });\n        return;\n      }\n      if (stats && this.prevStats) {\n        this._currentBitrate = computeBitrate(stats, this.prevStats);\n      }\n      this.prevStats = stats;\n    });\n    this.checkForSilence();\n  }\n  setDeviceId(deviceId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.constraints.deviceId === deviceId) {\n        return;\n      }\n      this.constraints.deviceId = deviceId;\n      if (!this.isMuted) {\n        yield this.restartTrack();\n      }\n    });\n  }\n  mute() {\n    const _super = Object.create(null, {\n      mute: {\n        get: () => super.mute\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.muteLock.lock();\n      try {\n        if (this.source === Track.Source.Microphone && this.stopOnMute && !this.isUserProvided) {\n          livekitLogger.debug(\"stopping mic track\");\n          this._mediaStreamTrack.stop();\n        }\n        yield _super.mute.call(this);\n        return this;\n      } finally {\n        unlock();\n      }\n    });\n  }\n  unmute() {\n    const _super = Object.create(null, {\n      unmute: {\n        get: () => super.unmute\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.muteLock.lock();\n      try {\n        if (this.source === Track.Source.Microphone && (this.stopOnMute || this._mediaStreamTrack.readyState === \"ended\") && !this.isUserProvided) {\n          livekitLogger.debug(\"reacquiring mic track\");\n          yield this.restartTrack();\n        }\n        yield _super.unmute.call(this);\n        return this;\n      } finally {\n        unlock();\n      }\n    });\n  }\n  restartTrack(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let constraints;\n      if (options) {\n        const streamConstraints = constraintsForOptions({\n          audio: options\n        });\n        if (typeof streamConstraints.audio !== \"boolean\") {\n          constraints = streamConstraints.audio;\n        }\n      }\n      yield this.restart(constraints);\n    });\n  }\n  restart(constraints) {\n    const _super = Object.create(null, {\n      restart: {\n        get: () => super.restart\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const track = yield _super.restart.call(this, constraints);\n      this.checkForSilence();\n      return track;\n    });\n  }\n  /* @internal */\n  startMonitor() {\n    if (!isWeb()) {\n      return;\n    }\n    if (this.monitorInterval) {\n      return;\n    }\n    this.monitorInterval = setInterval(() => {\n      this.monitorSender();\n    }, monitorFrequency);\n  }\n  getSenderStats() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n        return void 0;\n      }\n      const stats = yield this.sender.getStats();\n      let audioStats;\n      stats.forEach((v) => {\n        if (v.type === \"outbound-rtp\") {\n          audioStats = {\n            type: \"audio\",\n            streamId: v.id,\n            packetsSent: v.packetsSent,\n            packetsLost: v.packetsLost,\n            bytesSent: v.bytesSent,\n            timestamp: v.timestamp,\n            roundTripTime: v.roundTripTime,\n            jitter: v.jitter\n          };\n        }\n      });\n      return audioStats;\n    });\n  }\n  checkForSilence() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const trackIsSilent = yield detectSilence(this);\n      if (trackIsSilent) {\n        if (!this.isMuted) {\n          livekitLogger.warn(\"silence detected on local audio track\");\n        }\n        this.emit(TrackEvent.AudioSilenceDetected);\n      }\n      return trackIsSilent;\n    });\n  }\n};\nvar refreshSubscribedCodecAfterNewCodec = 5e3;\nvar LocalVideoTrack = class extends LocalTrack {\n  /**\n   *\n   * @param mediaTrack\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */\n  constructor(mediaTrack, constraints) {\n    let userProvidedTrack = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n    super(mediaTrack, Track.Kind.Video, constraints, userProvidedTrack);\n    this.simulcastCodecs = /* @__PURE__ */ new Map();\n    this.monitorSender = () => __awaiter(this, void 0, void 0, function* () {\n      if (!this.sender) {\n        this._currentBitrate = 0;\n        return;\n      }\n      let stats;\n      try {\n        stats = yield this.getSenderStats();\n      } catch (e) {\n        livekitLogger.error(\"could not get audio sender stats\", {\n          error: e\n        });\n        return;\n      }\n      const statsMap = new Map(stats.map((s) => [s.rid, s]));\n      if (this.prevStats) {\n        let totalBitrate = 0;\n        statsMap.forEach((s, key) => {\n          var _a;\n          const prev = (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.get(key);\n          totalBitrate += computeBitrate(s, prev);\n        });\n        this._currentBitrate = totalBitrate;\n      }\n      this.prevStats = statsMap;\n    });\n    this.senderLock = new Mutex();\n  }\n  get isSimulcast() {\n    if (this.sender && this.sender.getParameters().encodings.length > 1) {\n      return true;\n    }\n    return false;\n  }\n  /* @internal */\n  startMonitor(signalClient) {\n    var _a;\n    this.signalClient = signalClient;\n    if (!isWeb()) {\n      return;\n    }\n    const params = (_a = this.sender) === null || _a === void 0 ? void 0 : _a.getParameters();\n    if (params) {\n      this.encodings = params.encodings;\n    }\n    if (this.monitorInterval) {\n      return;\n    }\n    this.monitorInterval = setInterval(() => {\n      this.monitorSender();\n    }, monitorFrequency);\n  }\n  stop() {\n    this._mediaStreamTrack.getConstraints();\n    this.simulcastCodecs.forEach((trackInfo) => {\n      trackInfo.mediaStreamTrack.stop();\n    });\n    super.stop();\n  }\n  mute() {\n    const _super = Object.create(null, {\n      mute: {\n        get: () => super.mute\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.muteLock.lock();\n      try {\n        if (this.source === Track.Source.Camera && !this.isUserProvided) {\n          livekitLogger.debug(\"stopping camera track\");\n          this._mediaStreamTrack.stop();\n        }\n        yield _super.mute.call(this);\n        return this;\n      } finally {\n        unlock();\n      }\n    });\n  }\n  unmute() {\n    const _super = Object.create(null, {\n      unmute: {\n        get: () => super.unmute\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.muteLock.lock();\n      try {\n        if (this.source === Track.Source.Camera && !this.isUserProvided) {\n          livekitLogger.debug(\"reacquiring camera track\");\n          yield this.restartTrack();\n        }\n        yield _super.unmute.call(this);\n        return this;\n      } finally {\n        unlock();\n      }\n    });\n  }\n  getSenderStats() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n        return [];\n      }\n      const items = [];\n      const stats = yield this.sender.getStats();\n      stats.forEach((v) => {\n        var _a2;\n        if (v.type === \"outbound-rtp\") {\n          const vs = {\n            type: \"video\",\n            streamId: v.id,\n            frameHeight: v.frameHeight,\n            frameWidth: v.frameWidth,\n            firCount: v.firCount,\n            pliCount: v.pliCount,\n            nackCount: v.nackCount,\n            packetsSent: v.packetsSent,\n            bytesSent: v.bytesSent,\n            framesSent: v.framesSent,\n            timestamp: v.timestamp,\n            rid: (_a2 = v.rid) !== null && _a2 !== void 0 ? _a2 : v.id,\n            retransmittedPacketsSent: v.retransmittedPacketsSent,\n            qualityLimitationReason: v.qualityLimitationReason,\n            qualityLimitationResolutionChanges: v.qualityLimitationResolutionChanges\n          };\n          const r2 = stats.get(v.remoteId);\n          if (r2) {\n            vs.jitter = r2.jitter;\n            vs.packetsLost = r2.packetsLost;\n            vs.roundTripTime = r2.roundTripTime;\n          }\n          items.push(vs);\n        }\n      });\n      return items;\n    });\n  }\n  setPublishingQuality(maxQuality) {\n    const qualities = [];\n    for (let q = VideoQuality.LOW; q <= VideoQuality.HIGH; q += 1) {\n      qualities.push({\n        quality: q,\n        enabled: q <= maxQuality\n      });\n    }\n    livekitLogger.debug(\"setting publishing quality. max quality \".concat(maxQuality));\n    this.setPublishingLayers(qualities);\n  }\n  setDeviceId(deviceId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.constraints.deviceId === deviceId) {\n        return;\n      }\n      this.constraints.deviceId = deviceId;\n      if (!this.isMuted) {\n        yield this.restartTrack();\n      }\n    });\n  }\n  restartTrack(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let constraints;\n      if (options) {\n        const streamConstraints = constraintsForOptions({\n          video: options\n        });\n        if (typeof streamConstraints.video !== \"boolean\") {\n          constraints = streamConstraints.video;\n        }\n      }\n      yield this.restart(constraints);\n    });\n  }\n  addSimulcastTrack(codec, encodings) {\n    if (this.simulcastCodecs.has(codec)) {\n      throw new Error(\"\".concat(codec, \" already added\"));\n    }\n    const simulcastCodecInfo = {\n      codec,\n      mediaStreamTrack: this.mediaStreamTrack.clone(),\n      sender: void 0,\n      encodings\n    };\n    this.simulcastCodecs.set(codec, simulcastCodecInfo);\n    return simulcastCodecInfo;\n  }\n  setSimulcastTrackSender(codec, sender) {\n    const simulcastCodecInfo = this.simulcastCodecs.get(codec);\n    if (!simulcastCodecInfo) {\n      return;\n    }\n    simulcastCodecInfo.sender = sender;\n    setTimeout(() => {\n      if (this.subscribedCodecs) {\n        this.setPublishingCodecs(this.subscribedCodecs);\n      }\n    }, refreshSubscribedCodecAfterNewCodec);\n  }\n  /**\n   * @internal\n   * Sets codecs that should be publishing\n   */\n  setPublishingCodecs(codecs) {\n    var _a, codecs_1, codecs_1_1;\n    var _b, e_1, _c, _d;\n    return __awaiter(this, void 0, void 0, function* () {\n      livekitLogger.debug(\"setting publishing codecs\", {\n        codecs,\n        currentCodec: this.codec\n      });\n      if (!this.codec && codecs.length > 0) {\n        yield this.setPublishingLayers(codecs[0].qualities);\n        return [];\n      }\n      this.subscribedCodecs = codecs;\n      const newCodecs = [];\n      try {\n        for (_a = true, codecs_1 = __asyncValues(codecs); codecs_1_1 = yield codecs_1.next(), _b = codecs_1_1.done, !_b; ) {\n          _d = codecs_1_1.value;\n          _a = false;\n          try {\n            const codec = _d;\n            if (!this.codec || this.codec === codec.codec) {\n              yield this.setPublishingLayers(codec.qualities);\n            } else {\n              const simulcastCodecInfo = this.simulcastCodecs.get(codec.codec);\n              livekitLogger.debug(\"try setPublishingCodec for \".concat(codec.codec), simulcastCodecInfo);\n              if (!simulcastCodecInfo || !simulcastCodecInfo.sender) {\n                for (const q of codec.qualities) {\n                  if (q.enabled) {\n                    newCodecs.push(codec.codec);\n                    break;\n                  }\n                }\n              } else if (simulcastCodecInfo.encodings) {\n                livekitLogger.debug(\"try setPublishingLayersForSender \".concat(codec.codec));\n                yield setPublishingLayersForSender(simulcastCodecInfo.sender, simulcastCodecInfo.encodings, codec.qualities, this.senderLock);\n              }\n            }\n          } finally {\n            _a = true;\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (!_a && !_b && (_c = codecs_1.return))\n            yield _c.call(codecs_1);\n        } finally {\n          if (e_1)\n            throw e_1.error;\n        }\n      }\n      return newCodecs;\n    });\n  }\n  /**\n   * @internal\n   * Sets layers that should be publishing\n   */\n  setPublishingLayers(qualities) {\n    return __awaiter(this, void 0, void 0, function* () {\n      livekitLogger.debug(\"setting publishing layers\", qualities);\n      if (!this.sender || !this.encodings) {\n        return;\n      }\n      yield setPublishingLayersForSender(this.sender, this.encodings, qualities, this.senderLock);\n    });\n  }\n  handleAppVisibilityChanged() {\n    const _super = Object.create(null, {\n      handleAppVisibilityChanged: {\n        get: () => super.handleAppVisibilityChanged\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      yield _super.handleAppVisibilityChanged.call(this);\n      if (!isMobile())\n        return;\n      if (this.isInBackground && this.source === Track.Source.Camera) {\n        this._mediaStreamTrack.enabled = false;\n      }\n    });\n  }\n};\nfunction setPublishingLayersForSender(sender, senderEncodings, qualities, senderLock) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const unlock = yield senderLock.lock();\n    livekitLogger.debug(\"setPublishingLayersForSender\", {\n      sender,\n      qualities,\n      senderEncodings\n    });\n    try {\n      const params = sender.getParameters();\n      const {\n        encodings\n      } = params;\n      if (!encodings) {\n        return;\n      }\n      if (encodings.length !== senderEncodings.length) {\n        livekitLogger.warn(\"cannot set publishing layers, encodings mismatch\");\n        return;\n      }\n      let hasChanged = false;\n      encodings.forEach((encoding, idx) => {\n        var _a;\n        let rid = (_a = encoding.rid) !== null && _a !== void 0 ? _a : \"\";\n        if (rid === \"\") {\n          rid = \"q\";\n        }\n        const quality = videoQualityForRid(rid);\n        const subscribedQuality = qualities.find((q) => q.quality === quality);\n        if (!subscribedQuality) {\n          return;\n        }\n        if (encoding.active !== subscribedQuality.enabled) {\n          hasChanged = true;\n          encoding.active = subscribedQuality.enabled;\n          livekitLogger.debug(\"setting layer \".concat(subscribedQuality.quality, \" to \").concat(encoding.active ? \"enabled\" : \"disabled\"));\n          if (isFireFox()) {\n            if (subscribedQuality.enabled) {\n              encoding.scaleResolutionDownBy = senderEncodings[idx].scaleResolutionDownBy;\n              encoding.maxBitrate = senderEncodings[idx].maxBitrate;\n              encoding.maxFrameRate = senderEncodings[idx].maxFrameRate;\n            } else {\n              encoding.scaleResolutionDownBy = 4;\n              encoding.maxBitrate = 10;\n              encoding.maxFrameRate = 2;\n            }\n          }\n        }\n      });\n      if (hasChanged) {\n        params.encodings = encodings;\n        yield sender.setParameters(params);\n      }\n    } finally {\n      unlock();\n    }\n  });\n}\nfunction videoQualityForRid(rid) {\n  switch (rid) {\n    case \"f\":\n      return VideoQuality.HIGH;\n    case \"h\":\n      return VideoQuality.MEDIUM;\n    case \"q\":\n      return VideoQuality.LOW;\n    default:\n      return VideoQuality.UNRECOGNIZED;\n  }\n}\nfunction videoLayersFromEncodings(width, height, encodings) {\n  if (!encodings) {\n    return [{\n      quality: VideoQuality.HIGH,\n      width,\n      height,\n      bitrate: 0,\n      ssrc: 0\n    }];\n  }\n  return encodings.map((encoding) => {\n    var _a, _b, _c;\n    const scale = (_a = encoding.scaleResolutionDownBy) !== null && _a !== void 0 ? _a : 1;\n    let quality = videoQualityForRid((_b = encoding.rid) !== null && _b !== void 0 ? _b : \"\");\n    if (quality === VideoQuality.UNRECOGNIZED && encodings.length === 1) {\n      quality = VideoQuality.HIGH;\n    }\n    return {\n      quality,\n      width: width / scale,\n      height: height / scale,\n      bitrate: (_c = encoding.maxBitrate) !== null && _c !== void 0 ? _c : 0,\n      ssrc: 0\n    };\n  });\n}\nvar RemoteTrack = class extends Track {\n  constructor(mediaTrack, sid, kind, receiver) {\n    super(mediaTrack, kind);\n    this.sid = sid;\n    this.receiver = receiver;\n  }\n  /** @internal */\n  setMuted(muted) {\n    if (this.isMuted !== muted) {\n      this.isMuted = muted;\n      this._mediaStreamTrack.enabled = !muted;\n      this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);\n    }\n  }\n  /** @internal */\n  setMediaStream(stream) {\n    this.mediaStream = stream;\n    stream.onremovetrack = () => {\n      this.receiver = void 0;\n      this._currentBitrate = 0;\n      this.emit(TrackEvent.Ended, this);\n    };\n  }\n  start() {\n    this.startMonitor();\n    super.enable();\n  }\n  stop() {\n    this.stopMonitor();\n    super.disable();\n  }\n  /* @internal */\n  startMonitor() {\n    if (!this.monitorInterval) {\n      this.monitorInterval = setInterval(() => this.monitorReceiver(), monitorFrequency);\n    }\n  }\n};\nvar RemoteAudioTrack = class extends RemoteTrack {\n  constructor(mediaTrack, sid, receiver, audioContext, audioOutput) {\n    super(mediaTrack, sid, Track.Kind.Audio, receiver);\n    this.monitorReceiver = () => __awaiter(this, void 0, void 0, function* () {\n      if (!this.receiver) {\n        this._currentBitrate = 0;\n        return;\n      }\n      const stats = yield this.getReceiverStats();\n      if (stats && this.prevStats && this.receiver) {\n        this._currentBitrate = computeBitrate(stats, this.prevStats);\n      }\n      this.prevStats = stats;\n    });\n    this.audioContext = audioContext;\n    this.webAudioPluginNodes = [];\n    if (audioOutput) {\n      this.sinkId = audioOutput.deviceId;\n    }\n  }\n  /**\n   * sets the volume for all attached audio elements\n   */\n  setVolume(volume) {\n    var _a;\n    for (const el of this.attachedElements) {\n      if (this.audioContext) {\n        (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.gain.setTargetAtTime(volume, 0, 0.1);\n      } else {\n        el.volume = volume;\n      }\n    }\n    this.elementVolume = volume;\n  }\n  /**\n   * gets the volume of attached audio elements (loudest)\n   */\n  getVolume() {\n    if (this.elementVolume) {\n      return this.elementVolume;\n    }\n    let highestVolume = 0;\n    this.attachedElements.forEach((element) => {\n      if (element.volume > highestVolume) {\n        highestVolume = element.volume;\n      }\n    });\n    return highestVolume;\n  }\n  /**\n   * calls setSinkId on all attached elements, if supported\n   * @param deviceId audio output device\n   */\n  setSinkId(deviceId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.sinkId = deviceId;\n      yield Promise.all(this.attachedElements.map((elm) => {\n        if (!supportsSetSinkId(elm)) {\n          return;\n        }\n        return elm.setSinkId(deviceId);\n      }));\n    });\n  }\n  attach(element) {\n    const needsNewWebAudioConnection = this.attachedElements.length === 0;\n    if (!element) {\n      element = super.attach();\n    } else {\n      super.attach(element);\n    }\n    if (this.elementVolume) {\n      element.volume = this.elementVolume;\n    }\n    if (this.sinkId && supportsSetSinkId(element)) {\n      element.setSinkId(this.sinkId);\n    }\n    if (this.audioContext && needsNewWebAudioConnection) {\n      livekitLogger.debug(\"using audio context mapping\");\n      this.connectWebAudio(this.audioContext, element);\n      element.volume = 0;\n      element.muted = true;\n    }\n    return element;\n  }\n  detach(element) {\n    let detached;\n    if (!element) {\n      detached = super.detach();\n      this.disconnectWebAudio();\n    } else {\n      detached = super.detach(element);\n      if (this.audioContext) {\n        if (this.attachedElements.length > 0) {\n          this.connectWebAudio(this.audioContext, this.attachedElements[0]);\n        } else {\n          this.disconnectWebAudio();\n        }\n      }\n    }\n    return detached;\n  }\n  /**\n   * @internal\n   * @experimental\n   */\n  setAudioContext(audioContext) {\n    this.audioContext = audioContext;\n    if (audioContext && this.attachedElements.length > 0) {\n      this.connectWebAudio(audioContext, this.attachedElements[0]);\n    } else if (!audioContext) {\n      this.disconnectWebAudio();\n    }\n  }\n  /**\n   * @internal\n   * @experimental\n   * @param {AudioNode[]} nodes - An array of WebAudio nodes. These nodes should not be connected to each other when passed, as the sdk will take care of connecting them in the order of the array.\n   */\n  setWebAudioPlugins(nodes) {\n    this.webAudioPluginNodes = nodes;\n    if (this.attachedElements.length > 0 && this.audioContext) {\n      this.connectWebAudio(this.audioContext, this.attachedElements[0]);\n    }\n  }\n  connectWebAudio(context, element) {\n    this.disconnectWebAudio();\n    this.sourceNode = context.createMediaStreamSource(element.srcObject);\n    let lastNode = this.sourceNode;\n    this.webAudioPluginNodes.forEach((node) => {\n      lastNode.connect(node);\n      lastNode = node;\n    });\n    this.gainNode = context.createGain();\n    lastNode.connect(this.gainNode);\n    this.gainNode.connect(context.destination);\n    if (this.elementVolume) {\n      this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1);\n    }\n    if (context.state !== \"running\") {\n      context.resume().then(() => {\n        if (context.state !== \"running\") {\n          this.emit(TrackEvent.AudioPlaybackFailed, new Error(\"Audio Context couldn't be started automatically\"));\n        }\n      }).catch((e) => {\n        this.emit(TrackEvent.AudioPlaybackFailed, e);\n      });\n    }\n  }\n  disconnectWebAudio() {\n    var _a, _b;\n    (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.disconnect();\n    (_b = this.sourceNode) === null || _b === void 0 ? void 0 : _b.disconnect();\n    this.gainNode = void 0;\n    this.sourceNode = void 0;\n  }\n  getReceiverStats() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.receiver || !this.receiver.getStats) {\n        return;\n      }\n      const stats = yield this.receiver.getStats();\n      let receiverStats;\n      stats.forEach((v) => {\n        if (v.type === \"inbound-rtp\") {\n          receiverStats = {\n            type: \"audio\",\n            timestamp: v.timestamp,\n            jitter: v.jitter,\n            bytesReceived: v.bytesReceived,\n            concealedSamples: v.concealedSamples,\n            concealmentEvents: v.concealmentEvents,\n            silentConcealedSamples: v.silentConcealedSamples,\n            silentConcealmentEvents: v.silentConcealmentEvents,\n            totalAudioEnergy: v.totalAudioEnergy,\n            totalSamplesDuration: v.totalSamplesDuration\n          };\n        }\n      });\n      return receiverStats;\n    });\n  }\n};\nvar REACTION_DELAY = 100;\nvar RemoteVideoTrack = class extends RemoteTrack {\n  constructor(mediaTrack, sid, receiver, adaptiveStreamSettings) {\n    super(mediaTrack, sid, Track.Kind.Video, receiver);\n    this.elementInfos = [];\n    this.isObserved = false;\n    this.monitorReceiver = () => __awaiter(this, void 0, void 0, function* () {\n      if (!this.receiver) {\n        this._currentBitrate = 0;\n        return;\n      }\n      const stats = yield this.getReceiverStats();\n      if (stats && this.prevStats && this.receiver) {\n        this._currentBitrate = computeBitrate(stats, this.prevStats);\n      }\n      this.prevStats = stats;\n    });\n    this.debouncedHandleResize = r(() => {\n      this.updateDimensions();\n    }, REACTION_DELAY);\n    this.adaptiveStreamSettings = adaptiveStreamSettings;\n  }\n  get isAdaptiveStream() {\n    return this.adaptiveStreamSettings !== void 0;\n  }\n  get mediaStreamTrack() {\n    if (this.isAdaptiveStream && !this.isObserved) {\n      livekitLogger.warn(\"When using adaptiveStream, you need to use remoteVideoTrack.attach() to add the track to a HTMLVideoElement, otherwise your video tracks might never start\");\n    }\n    return this._mediaStreamTrack;\n  }\n  /** @internal */\n  setMuted(muted) {\n    super.setMuted(muted);\n    this.attachedElements.forEach((element) => {\n      if (muted) {\n        detachTrack(this._mediaStreamTrack, element);\n      } else {\n        attachToElement(this._mediaStreamTrack, element);\n      }\n    });\n  }\n  attach(element) {\n    if (!element) {\n      element = super.attach();\n    } else {\n      super.attach(element);\n    }\n    if (this.adaptiveStreamSettings && this.elementInfos.find((info) => info.element === element) === void 0) {\n      const elementInfo = new HTMLElementInfo(element);\n      this.observeElementInfo(elementInfo);\n    }\n    return element;\n  }\n  /**\n   * Observe an ElementInfo for changes when adaptive streaming.\n   * @param elementInfo\n   * @internal\n   */\n  observeElementInfo(elementInfo) {\n    if (this.adaptiveStreamSettings && this.elementInfos.find((info) => info === elementInfo) === void 0) {\n      elementInfo.handleResize = () => {\n        this.debouncedHandleResize();\n      };\n      elementInfo.handleVisibilityChanged = () => {\n        this.updateVisibility();\n      };\n      this.elementInfos.push(elementInfo);\n      elementInfo.observe();\n      this.debouncedHandleResize();\n      this.updateVisibility();\n      this.isObserved = true;\n    } else {\n      livekitLogger.warn(\"visibility resize observer not triggered\");\n    }\n  }\n  /**\n   * Stop observing an ElementInfo for changes.\n   * @param elementInfo\n   * @internal\n   */\n  stopObservingElementInfo(elementInfo) {\n    if (!this.isAdaptiveStream) {\n      livekitLogger.warn(\"stopObservingElementInfo ignored\");\n      return;\n    }\n    const stopElementInfos = this.elementInfos.filter((info) => info === elementInfo);\n    for (const info of stopElementInfos) {\n      info.stopObserving();\n    }\n    this.elementInfos = this.elementInfos.filter((info) => info !== elementInfo);\n    this.updateVisibility();\n  }\n  detach(element) {\n    let detachedElements = [];\n    if (element) {\n      this.stopObservingElement(element);\n      return super.detach(element);\n    }\n    detachedElements = super.detach();\n    for (const e of detachedElements) {\n      this.stopObservingElement(e);\n    }\n    return detachedElements;\n  }\n  /** @internal */\n  getDecoderImplementation() {\n    var _a;\n    return (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.decoderImplementation;\n  }\n  getReceiverStats() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.receiver || !this.receiver.getStats) {\n        return;\n      }\n      const stats = yield this.receiver.getStats();\n      let receiverStats;\n      stats.forEach((v) => {\n        if (v.type === \"inbound-rtp\") {\n          receiverStats = {\n            type: \"video\",\n            framesDecoded: v.framesDecoded,\n            framesDropped: v.framesDropped,\n            framesReceived: v.framesReceived,\n            packetsReceived: v.packetsReceived,\n            packetsLost: v.packetsLost,\n            frameWidth: v.frameWidth,\n            frameHeight: v.frameHeight,\n            pliCount: v.pliCount,\n            firCount: v.firCount,\n            nackCount: v.nackCount,\n            jitter: v.jitter,\n            timestamp: v.timestamp,\n            bytesReceived: v.bytesReceived,\n            decoderImplementation: v.decoderImplementation\n          };\n        }\n      });\n      return receiverStats;\n    });\n  }\n  stopObservingElement(element) {\n    const stopElementInfos = this.elementInfos.filter((info) => info.element === element);\n    for (const info of stopElementInfos) {\n      info.stopObserving();\n    }\n    this.elementInfos = this.elementInfos.filter((info) => info.element !== element);\n  }\n  handleAppVisibilityChanged() {\n    const _super = Object.create(null, {\n      handleAppVisibilityChanged: {\n        get: () => super.handleAppVisibilityChanged\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      yield _super.handleAppVisibilityChanged.call(this);\n      if (!this.isAdaptiveStream)\n        return;\n      this.updateVisibility();\n    });\n  }\n  updateVisibility() {\n    var _a, _b;\n    const lastVisibilityChange = this.elementInfos.reduce((prev, info) => Math.max(prev, info.visibilityChangedAt || 0), 0);\n    const backgroundPause = ((_b = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pauseVideoInBackground) !== null && _b !== void 0 ? _b : true) ? this.isInBackground : false;\n    const isPiPMode = this.elementInfos.some((info) => info.pictureInPicture);\n    const isVisible = this.elementInfos.some((info) => info.visible) && !backgroundPause || isPiPMode;\n    if (this.lastVisible === isVisible) {\n      return;\n    }\n    if (!isVisible && Date.now() - lastVisibilityChange < REACTION_DELAY) {\n      CriticalTimers.setTimeout(() => {\n        this.updateVisibility();\n      }, REACTION_DELAY);\n      return;\n    }\n    this.lastVisible = isVisible;\n    this.emit(TrackEvent.VisibilityChanged, isVisible, this);\n  }\n  updateDimensions() {\n    var _a, _b, _c, _d;\n    let maxWidth = 0;\n    let maxHeight = 0;\n    for (const info of this.elementInfos) {\n      const pixelDensity = (_b = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pixelDensity) !== null && _b !== void 0 ? _b : 1;\n      const pixelDensityValue = pixelDensity === \"screen\" ? getDevicePixelRatio() : pixelDensity;\n      const currentElementWidth = info.width() * pixelDensityValue;\n      const currentElementHeight = info.height() * pixelDensityValue;\n      if (currentElementWidth + currentElementHeight > maxWidth + maxHeight) {\n        maxWidth = currentElementWidth;\n        maxHeight = currentElementHeight;\n      }\n    }\n    if (((_c = this.lastDimensions) === null || _c === void 0 ? void 0 : _c.width) === maxWidth && ((_d = this.lastDimensions) === null || _d === void 0 ? void 0 : _d.height) === maxHeight) {\n      return;\n    }\n    this.lastDimensions = {\n      width: maxWidth,\n      height: maxHeight\n    };\n    this.emit(TrackEvent.VideoDimensionsChanged, this.lastDimensions, this);\n  }\n};\nvar HTMLElementInfo = class {\n  get visible() {\n    return this.isPiP || this.isIntersecting;\n  }\n  get pictureInPicture() {\n    return this.isPiP;\n  }\n  constructor(element, visible) {\n    this.onVisibilityChanged = (entry) => {\n      var _a;\n      const {\n        target,\n        isIntersecting\n      } = entry;\n      if (target === this.element) {\n        this.isIntersecting = isIntersecting;\n        this.visibilityChangedAt = Date.now();\n        (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n      }\n    };\n    this.onEnterPiP = () => {\n      var _a;\n      this.isPiP = true;\n      (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n    };\n    this.onLeavePiP = () => {\n      var _a;\n      this.isPiP = false;\n      (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n    };\n    this.element = element;\n    this.isIntersecting = visible !== null && visible !== void 0 ? visible : isElementInViewport(element);\n    this.isPiP = isWeb() && document.pictureInPictureElement === element;\n    this.visibilityChangedAt = 0;\n  }\n  width() {\n    return this.element.clientWidth;\n  }\n  height() {\n    return this.element.clientHeight;\n  }\n  observe() {\n    this.isIntersecting = isElementInViewport(this.element);\n    this.isPiP = document.pictureInPictureElement === this.element;\n    this.element.handleResize = () => {\n      var _a;\n      (_a = this.handleResize) === null || _a === void 0 ? void 0 : _a.call(this);\n    };\n    this.element.handleVisibilityChanged = this.onVisibilityChanged;\n    getIntersectionObserver().observe(this.element);\n    getResizeObserver().observe(this.element);\n    this.element.addEventListener(\"enterpictureinpicture\", this.onEnterPiP);\n    this.element.addEventListener(\"leavepictureinpicture\", this.onLeavePiP);\n  }\n  stopObserving() {\n    var _a, _b;\n    (_a = getIntersectionObserver()) === null || _a === void 0 ? void 0 : _a.unobserve(this.element);\n    (_b = getResizeObserver()) === null || _b === void 0 ? void 0 : _b.unobserve(this.element);\n    this.element.removeEventListener(\"enterpictureinpicture\", this.onEnterPiP);\n    this.element.removeEventListener(\"leavepictureinpicture\", this.onLeavePiP);\n  }\n};\nfunction isElementInViewport(el) {\n  let top = el.offsetTop;\n  let left = el.offsetLeft;\n  const width = el.offsetWidth;\n  const height = el.offsetHeight;\n  const {\n    hidden\n  } = el;\n  const {\n    opacity,\n    display\n  } = getComputedStyle(el);\n  while (el.offsetParent) {\n    el = el.offsetParent;\n    top += el.offsetTop;\n    left += el.offsetLeft;\n  }\n  return top < window.pageYOffset + window.innerHeight && left < window.pageXOffset + window.innerWidth && top + height > window.pageYOffset && left + width > window.pageXOffset && !hidden && (opacity !== \"\" ? parseFloat(opacity) > 0 : true) && display !== \"none\";\n}\nvar TrackPublication = class extends eventsExports.EventEmitter {\n  constructor(kind, id, name) {\n    super();\n    this.metadataMuted = false;\n    this.handleMuted = () => {\n      this.emit(TrackEvent.Muted);\n    };\n    this.handleUnmuted = () => {\n      this.emit(TrackEvent.Unmuted);\n    };\n    this.setMaxListeners(100);\n    this.kind = kind;\n    this.trackSid = id;\n    this.trackName = name;\n    this.source = Track.Source.Unknown;\n  }\n  /** @internal */\n  setTrack(track) {\n    if (this.track) {\n      this.track.off(TrackEvent.Muted, this.handleMuted);\n      this.track.off(TrackEvent.Unmuted, this.handleUnmuted);\n    }\n    this.track = track;\n    if (track) {\n      track.on(TrackEvent.Muted, this.handleMuted);\n      track.on(TrackEvent.Unmuted, this.handleUnmuted);\n    }\n  }\n  get isMuted() {\n    return this.metadataMuted;\n  }\n  get isEnabled() {\n    return true;\n  }\n  get isSubscribed() {\n    return this.track !== void 0;\n  }\n  /**\n   * an [AudioTrack] if this publication holds an audio track\n   */\n  get audioTrack() {\n    if (this.track instanceof LocalAudioTrack || this.track instanceof RemoteAudioTrack) {\n      return this.track;\n    }\n  }\n  /**\n   * an [VideoTrack] if this publication holds a video track\n   */\n  get videoTrack() {\n    if (this.track instanceof LocalVideoTrack || this.track instanceof RemoteVideoTrack) {\n      return this.track;\n    }\n  }\n  /** @internal */\n  updateInfo(info) {\n    this.trackSid = info.sid;\n    this.trackName = info.name;\n    this.source = Track.sourceFromProto(info.source);\n    this.mimeType = info.mimeType;\n    if (this.kind === Track.Kind.Video && info.width > 0) {\n      this.dimensions = {\n        width: info.width,\n        height: info.height\n      };\n      this.simulcasted = info.simulcast;\n    }\n    this.trackInfo = info;\n    livekitLogger.trace(\"update publication info\", {\n      info\n    });\n  }\n};\n(function(TrackPublication2) {\n  (function(SubscriptionStatus) {\n    SubscriptionStatus[\"Desired\"] = \"desired\";\n    SubscriptionStatus[\"Subscribed\"] = \"subscribed\";\n    SubscriptionStatus[\"Unsubscribed\"] = \"unsubscribed\";\n  })(TrackPublication2.SubscriptionStatus || (TrackPublication2.SubscriptionStatus = {}));\n  (function(PermissionStatus) {\n    PermissionStatus[\"Allowed\"] = \"allowed\";\n    PermissionStatus[\"NotAllowed\"] = \"not_allowed\";\n  })(TrackPublication2.PermissionStatus || (TrackPublication2.PermissionStatus = {}));\n})(TrackPublication || (TrackPublication = {}));\nvar LocalTrackPublication = class extends TrackPublication {\n  get isUpstreamPaused() {\n    var _a;\n    return (_a = this.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused;\n  }\n  constructor(kind, ti, track) {\n    super(kind, ti.sid, ti.name);\n    this.track = void 0;\n    this.handleTrackEnded = () => {\n      this.emit(TrackEvent.Ended);\n    };\n    this.updateInfo(ti);\n    this.setTrack(track);\n  }\n  setTrack(track) {\n    if (this.track) {\n      this.track.off(TrackEvent.Ended, this.handleTrackEnded);\n    }\n    super.setTrack(track);\n    if (track) {\n      track.on(TrackEvent.Ended, this.handleTrackEnded);\n    }\n  }\n  get isMuted() {\n    if (this.track) {\n      return this.track.isMuted;\n    }\n    return super.isMuted;\n  }\n  get audioTrack() {\n    return super.audioTrack;\n  }\n  get videoTrack() {\n    return super.videoTrack;\n  }\n  /**\n   * Mute the track associated with this publication\n   */\n  mute() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      return (_a = this.track) === null || _a === void 0 ? void 0 : _a.mute();\n    });\n  }\n  /**\n   * Unmute track associated with this publication\n   */\n  unmute() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      return (_a = this.track) === null || _a === void 0 ? void 0 : _a.unmute();\n    });\n  }\n  /**\n   * Pauses the media stream track associated with this publication from being sent to the server\n   * and signals \"muted\" event to other participants\n   * Useful if you want to pause the stream without pausing the local media stream track\n   */\n  pauseUpstream() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.pauseUpstream();\n    });\n  }\n  /**\n   * Resumes sending the media stream track associated with this publication to the server after a call to [[pauseUpstream()]]\n   * and signals \"unmuted\" event to other participants (unless the track is explicitly muted)\n   */\n  resumeUpstream() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.resumeUpstream();\n    });\n  }\n};\nvar ConnectionQuality;\n(function(ConnectionQuality2) {\n  ConnectionQuality2[\"Excellent\"] = \"excellent\";\n  ConnectionQuality2[\"Good\"] = \"good\";\n  ConnectionQuality2[\"Poor\"] = \"poor\";\n  ConnectionQuality2[\"Unknown\"] = \"unknown\";\n})(ConnectionQuality || (ConnectionQuality = {}));\nfunction qualityFromProto(q) {\n  switch (q) {\n    case ConnectionQuality$1.EXCELLENT:\n      return ConnectionQuality.Excellent;\n    case ConnectionQuality$1.GOOD:\n      return ConnectionQuality.Good;\n    case ConnectionQuality$1.POOR:\n      return ConnectionQuality.Poor;\n    default:\n      return ConnectionQuality.Unknown;\n  }\n}\nvar Participant = class extends eventsExports.EventEmitter {\n  /** @internal */\n  constructor(sid, identity, name, metadata) {\n    super();\n    this.audioLevel = 0;\n    this.isSpeaking = false;\n    this._connectionQuality = ConnectionQuality.Unknown;\n    this.setMaxListeners(100);\n    this.sid = sid;\n    this.identity = identity;\n    this.name = name;\n    this.metadata = metadata;\n    this.audioTracks = /* @__PURE__ */ new Map();\n    this.videoTracks = /* @__PURE__ */ new Map();\n    this.tracks = /* @__PURE__ */ new Map();\n  }\n  getTracks() {\n    return Array.from(this.tracks.values());\n  }\n  /**\n   * Finds the first track that matches the source filter, for example, getting\n   * the user's camera track with getTrackBySource(Track.Source.Camera).\n   * @param source\n   * @returns\n   */\n  getTrack(source) {\n    for (const [, pub] of this.tracks) {\n      if (pub.source === source) {\n        return pub;\n      }\n    }\n  }\n  /**\n   * Finds the first track that matches the track's name.\n   * @param name\n   * @returns\n   */\n  getTrackByName(name) {\n    for (const [, pub] of this.tracks) {\n      if (pub.trackName === name) {\n        return pub;\n      }\n    }\n  }\n  get connectionQuality() {\n    return this._connectionQuality;\n  }\n  get isCameraEnabled() {\n    var _a;\n    const track = this.getTrack(Track.Source.Camera);\n    return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);\n  }\n  get isMicrophoneEnabled() {\n    var _a;\n    const track = this.getTrack(Track.Source.Microphone);\n    return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);\n  }\n  get isScreenShareEnabled() {\n    const track = this.getTrack(Track.Source.ScreenShare);\n    return !!track;\n  }\n  get isLocal() {\n    return false;\n  }\n  /** when participant joined the room */\n  get joinedAt() {\n    if (this.participantInfo) {\n      return new Date(this.participantInfo.joinedAt * 1e3);\n    }\n    return /* @__PURE__ */ new Date();\n  }\n  /** @internal */\n  updateInfo(info) {\n    if (this.participantInfo && this.participantInfo.sid === info.sid && this.participantInfo.version > info.version) {\n      return false;\n    }\n    this.identity = info.identity;\n    this.sid = info.sid;\n    this.setName(info.name);\n    this.setMetadata(info.metadata);\n    if (info.permission) {\n      this.setPermissions(info.permission);\n    }\n    this.participantInfo = info;\n    livekitLogger.trace(\"update participant info\", {\n      info\n    });\n    return true;\n  }\n  /** @internal */\n  setMetadata(md) {\n    const changed = this.metadata !== md;\n    const prevMetadata = this.metadata;\n    this.metadata = md;\n    if (changed) {\n      this.emit(ParticipantEvent.ParticipantMetadataChanged, prevMetadata);\n    }\n  }\n  setName(name) {\n    const changed = this.name !== name;\n    this.name = name;\n    if (changed) {\n      this.emit(ParticipantEvent.ParticipantNameChanged, name);\n    }\n  }\n  /** @internal */\n  setPermissions(permissions) {\n    var _a, _b, _c, _d, _e;\n    const prevPermissions = this.permissions;\n    const changed = permissions.canPublish !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublish) || permissions.canSubscribe !== ((_b = this.permissions) === null || _b === void 0 ? void 0 : _b.canSubscribe) || permissions.canPublishData !== ((_c = this.permissions) === null || _c === void 0 ? void 0 : _c.canPublishData) || permissions.hidden !== ((_d = this.permissions) === null || _d === void 0 ? void 0 : _d.hidden) || permissions.recorder !== ((_e = this.permissions) === null || _e === void 0 ? void 0 : _e.recorder) || permissions.canPublishSources.length !== this.permissions.canPublishSources.length || permissions.canPublishSources.some((value, index) => {\n      var _a2;\n      return value !== ((_a2 = this.permissions) === null || _a2 === void 0 ? void 0 : _a2.canPublishSources[index]);\n    });\n    this.permissions = permissions;\n    if (changed) {\n      this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);\n    }\n    return changed;\n  }\n  /** @internal */\n  setIsSpeaking(speaking) {\n    if (speaking === this.isSpeaking) {\n      return;\n    }\n    this.isSpeaking = speaking;\n    if (speaking) {\n      this.lastSpokeAt = /* @__PURE__ */ new Date();\n    }\n    this.emit(ParticipantEvent.IsSpeakingChanged, speaking);\n  }\n  /** @internal */\n  setConnectionQuality(q) {\n    const prevQuality = this._connectionQuality;\n    this._connectionQuality = qualityFromProto(q);\n    if (prevQuality !== this._connectionQuality) {\n      this.emit(ParticipantEvent.ConnectionQualityChanged, this._connectionQuality);\n    }\n  }\n  addTrackPublication(publication) {\n    publication.on(TrackEvent.Muted, () => {\n      this.emit(ParticipantEvent.TrackMuted, publication);\n    });\n    publication.on(TrackEvent.Unmuted, () => {\n      this.emit(ParticipantEvent.TrackUnmuted, publication);\n    });\n    const pub = publication;\n    if (pub.track) {\n      pub.track.sid = publication.trackSid;\n    }\n    this.tracks.set(publication.trackSid, publication);\n    switch (publication.kind) {\n      case Track.Kind.Audio:\n        this.audioTracks.set(publication.trackSid, publication);\n        break;\n      case Track.Kind.Video:\n        this.videoTracks.set(publication.trackSid, publication);\n        break;\n    }\n  }\n};\nfunction trackPermissionToProto(perms) {\n  var _a, _b, _c;\n  if (!perms.participantSid && !perms.participantIdentity) {\n    throw new Error(\"Invalid track permission, must provide at least one of participantIdentity and participantSid\");\n  }\n  return {\n    participantIdentity: (_a = perms.participantIdentity) !== null && _a !== void 0 ? _a : \"\",\n    participantSid: (_b = perms.participantSid) !== null && _b !== void 0 ? _b : \"\",\n    allTracks: (_c = perms.allowAll) !== null && _c !== void 0 ? _c : false,\n    trackSids: perms.allowedTrackSids || []\n  };\n}\nvar RemoteTrackPublication = class extends TrackPublication {\n  constructor(kind, ti, autoSubscribe) {\n    super(kind, ti.sid, ti.name);\n    this.track = void 0;\n    this.allowed = true;\n    this.disabled = false;\n    this.currentVideoQuality = VideoQuality.HIGH;\n    this.handleEnded = (track) => {\n      this.setTrack(void 0);\n      this.emit(TrackEvent.Ended, track);\n    };\n    this.handleVisibilityChange = (visible) => {\n      livekitLogger.debug(\"adaptivestream video visibility \".concat(this.trackSid, \", visible=\").concat(visible), {\n        trackSid: this.trackSid\n      });\n      this.disabled = !visible;\n      this.emitTrackUpdate();\n    };\n    this.handleVideoDimensionsChange = (dimensions) => {\n      livekitLogger.debug(\"adaptivestream video dimensions \".concat(dimensions.width, \"x\").concat(dimensions.height), {\n        trackSid: this.trackSid\n      });\n      this.videoDimensions = dimensions;\n      this.emitTrackUpdate();\n    };\n    this.subscribed = autoSubscribe;\n    this.updateInfo(ti);\n  }\n  /**\n   * Subscribe or unsubscribe to this remote track\n   * @param subscribed true to subscribe to a track, false to unsubscribe\n   */\n  setSubscribed(subscribed) {\n    const prevStatus = this.subscriptionStatus;\n    const prevPermission = this.permissionStatus;\n    this.subscribed = subscribed;\n    if (subscribed) {\n      this.allowed = true;\n    }\n    const sub = {\n      trackSids: [this.trackSid],\n      subscribe: this.subscribed,\n      participantTracks: [{\n        // sending an empty participant id since TrackPublication doesn't keep it\n        // this is filled in by the participant that receives this message\n        participantSid: \"\",\n        trackSids: [this.trackSid]\n      }]\n    };\n    this.emit(TrackEvent.UpdateSubscription, sub);\n    this.emitSubscriptionUpdateIfChanged(prevStatus);\n    this.emitPermissionUpdateIfChanged(prevPermission);\n  }\n  get subscriptionStatus() {\n    if (this.subscribed === false) {\n      return TrackPublication.SubscriptionStatus.Unsubscribed;\n    }\n    if (!super.isSubscribed) {\n      return TrackPublication.SubscriptionStatus.Desired;\n    }\n    return TrackPublication.SubscriptionStatus.Subscribed;\n  }\n  get permissionStatus() {\n    return this.allowed ? TrackPublication.PermissionStatus.Allowed : TrackPublication.PermissionStatus.NotAllowed;\n  }\n  /**\n   * Returns true if track is subscribed, and ready for playback\n   */\n  get isSubscribed() {\n    if (this.subscribed === false) {\n      return false;\n    }\n    return super.isSubscribed;\n  }\n  // returns client's desire to subscribe to a track, also true if autoSubscribe is enabled\n  get isDesired() {\n    return this.subscribed !== false;\n  }\n  get isEnabled() {\n    return !this.disabled;\n  }\n  /**\n   * disable server from sending down data for this track. this is useful when\n   * the participant is off screen, you may disable streaming down their video\n   * to reduce bandwidth requirements\n   * @param enabled\n   */\n  setEnabled(enabled) {\n    if (!this.isManualOperationAllowed() || this.disabled === !enabled) {\n      return;\n    }\n    this.disabled = !enabled;\n    this.emitTrackUpdate();\n  }\n  /**\n   * for tracks that support simulcasting, adjust subscribed quality\n   *\n   * This indicates the highest quality the client can accept. if network\n   * bandwidth does not allow, server will automatically reduce quality to\n   * optimize for uninterrupted video\n   */\n  setVideoQuality(quality) {\n    if (!this.isManualOperationAllowed() || this.currentVideoQuality === quality) {\n      return;\n    }\n    this.currentVideoQuality = quality;\n    this.videoDimensions = void 0;\n    this.emitTrackUpdate();\n  }\n  setVideoDimensions(dimensions) {\n    var _a, _b;\n    if (!this.isManualOperationAllowed()) {\n      return;\n    }\n    if (((_a = this.videoDimensions) === null || _a === void 0 ? void 0 : _a.width) === dimensions.width && ((_b = this.videoDimensions) === null || _b === void 0 ? void 0 : _b.height) === dimensions.height) {\n      return;\n    }\n    if (this.track instanceof RemoteVideoTrack) {\n      this.videoDimensions = dimensions;\n    }\n    this.currentVideoQuality = void 0;\n    this.emitTrackUpdate();\n  }\n  setVideoFPS(fps) {\n    if (!this.isManualOperationAllowed()) {\n      return;\n    }\n    if (!(this.track instanceof RemoteVideoTrack)) {\n      return;\n    }\n    if (this.fps === fps) {\n      return;\n    }\n    this.fps = fps;\n    this.emitTrackUpdate();\n  }\n  get videoQuality() {\n    return this.currentVideoQuality;\n  }\n  /** @internal */\n  setTrack(track) {\n    const prevStatus = this.subscriptionStatus;\n    const prevPermission = this.permissionStatus;\n    const prevTrack = this.track;\n    if (prevTrack === track) {\n      return;\n    }\n    if (prevTrack) {\n      prevTrack.off(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);\n      prevTrack.off(TrackEvent.VisibilityChanged, this.handleVisibilityChange);\n      prevTrack.off(TrackEvent.Ended, this.handleEnded);\n      prevTrack.detach();\n      prevTrack.stopMonitor();\n      this.emit(TrackEvent.Unsubscribed, prevTrack);\n    }\n    super.setTrack(track);\n    if (track) {\n      track.sid = this.trackSid;\n      track.on(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);\n      track.on(TrackEvent.VisibilityChanged, this.handleVisibilityChange);\n      track.on(TrackEvent.Ended, this.handleEnded);\n      this.emit(TrackEvent.Subscribed, track);\n    }\n    this.emitPermissionUpdateIfChanged(prevPermission);\n    this.emitSubscriptionUpdateIfChanged(prevStatus);\n  }\n  /** @internal */\n  setAllowed(allowed) {\n    const prevStatus = this.subscriptionStatus;\n    const prevPermission = this.permissionStatus;\n    this.allowed = allowed;\n    this.emitPermissionUpdateIfChanged(prevPermission);\n    this.emitSubscriptionUpdateIfChanged(prevStatus);\n  }\n  /** @internal */\n  updateInfo(info) {\n    super.updateInfo(info);\n    const prevMetadataMuted = this.metadataMuted;\n    this.metadataMuted = info.muted;\n    if (this.track) {\n      this.track.setMuted(info.muted);\n    } else if (prevMetadataMuted !== info.muted) {\n      this.emit(info.muted ? TrackEvent.Muted : TrackEvent.Unmuted);\n    }\n  }\n  emitSubscriptionUpdateIfChanged(previousStatus) {\n    const currentStatus = this.subscriptionStatus;\n    if (previousStatus === currentStatus) {\n      return;\n    }\n    this.emit(TrackEvent.SubscriptionStatusChanged, currentStatus, previousStatus);\n  }\n  emitPermissionUpdateIfChanged(previousPermissionStatus) {\n    const currentPermissionStatus = this.permissionStatus;\n    if (currentPermissionStatus !== previousPermissionStatus) {\n      this.emit(TrackEvent.SubscriptionPermissionChanged, this.permissionStatus, previousPermissionStatus);\n    }\n  }\n  isManualOperationAllowed() {\n    if (this.kind === Track.Kind.Video && this.isAdaptiveStream) {\n      livekitLogger.warn(\"adaptive stream is enabled, cannot change video track settings\", {\n        trackSid: this.trackSid\n      });\n      return false;\n    }\n    if (!this.isDesired) {\n      livekitLogger.warn(\"cannot update track settings when not subscribed\", {\n        trackSid: this.trackSid\n      });\n      return false;\n    }\n    return true;\n  }\n  get isAdaptiveStream() {\n    return this.track instanceof RemoteVideoTrack && this.track.isAdaptiveStream;\n  }\n  /* @internal */\n  emitTrackUpdate() {\n    const settings = UpdateTrackSettings.fromPartial({\n      trackSids: [this.trackSid],\n      disabled: this.disabled,\n      fps: this.fps\n    });\n    if (this.videoDimensions) {\n      settings.width = this.videoDimensions.width;\n      settings.height = this.videoDimensions.height;\n    } else if (this.currentVideoQuality !== void 0) {\n      settings.quality = this.currentVideoQuality;\n    } else {\n      settings.quality = VideoQuality.HIGH;\n    }\n    this.emit(TrackEvent.UpdateSettings, settings);\n  }\n};\nvar RemoteParticipant = class extends Participant {\n  /** @internal */\n  static fromParticipantInfo(signalClient, pi) {\n    return new RemoteParticipant(signalClient, pi.sid, pi.identity, pi.name, pi.metadata);\n  }\n  /** @internal */\n  constructor(signalClient, sid, identity, name, metadata) {\n    super(sid, identity || \"\", name, metadata);\n    this.signalClient = signalClient;\n    this.tracks = /* @__PURE__ */ new Map();\n    this.audioTracks = /* @__PURE__ */ new Map();\n    this.videoTracks = /* @__PURE__ */ new Map();\n  }\n  addTrackPublication(publication) {\n    super.addTrackPublication(publication);\n    publication.on(TrackEvent.UpdateSettings, (settings) => {\n      livekitLogger.debug(\"send update settings\", settings);\n      this.signalClient.sendUpdateTrackSettings(settings);\n    });\n    publication.on(TrackEvent.UpdateSubscription, (sub) => {\n      sub.participantTracks.forEach((pt) => {\n        pt.participantSid = this.sid;\n      });\n      this.signalClient.sendUpdateSubscription(sub);\n    });\n    publication.on(TrackEvent.SubscriptionPermissionChanged, (status) => {\n      this.emit(ParticipantEvent.TrackSubscriptionPermissionChanged, publication, status);\n    });\n    publication.on(TrackEvent.SubscriptionStatusChanged, (status) => {\n      this.emit(ParticipantEvent.TrackSubscriptionStatusChanged, publication, status);\n    });\n    publication.on(TrackEvent.Subscribed, (track) => {\n      this.emit(ParticipantEvent.TrackSubscribed, track, publication);\n    });\n    publication.on(TrackEvent.Unsubscribed, (previousTrack) => {\n      this.emit(ParticipantEvent.TrackUnsubscribed, previousTrack, publication);\n    });\n  }\n  getTrack(source) {\n    const track = super.getTrack(source);\n    if (track) {\n      return track;\n    }\n  }\n  getTrackByName(name) {\n    const track = super.getTrackByName(name);\n    if (track) {\n      return track;\n    }\n  }\n  /**\n   * sets the volume on the participant's microphone track\n   * if no track exists the volume will be applied when the microphone track is added\n   */\n  setVolume(volume) {\n    this.volume = volume;\n    const audioPublication = this.getTrack(Track.Source.Microphone);\n    if (audioPublication && audioPublication.track) {\n      audioPublication.track.setVolume(volume);\n    }\n  }\n  /**\n   * gets the volume on the participant's microphone track\n   */\n  getVolume() {\n    const audioPublication = this.getTrack(Track.Source.Microphone);\n    if (audioPublication && audioPublication.track) {\n      return audioPublication.track.getVolume();\n    }\n    return this.volume;\n  }\n  /** @internal */\n  addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft) {\n    let publication = this.getTrackPublication(sid);\n    if (!publication) {\n      if (!sid.startsWith(\"TR\")) {\n        this.tracks.forEach((p) => {\n          if (!publication && mediaTrack.kind === p.kind.toString()) {\n            publication = p;\n          }\n        });\n      }\n    }\n    if (!publication) {\n      if (triesLeft === 0) {\n        livekitLogger.error(\"could not find published track\", {\n          participant: this.sid,\n          trackSid: sid\n        });\n        this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);\n        return;\n      }\n      if (triesLeft === void 0)\n        triesLeft = 20;\n      setTimeout(() => {\n        this.addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft - 1);\n      }, 150);\n      return;\n    }\n    if (mediaTrack.readyState === \"ended\") {\n      livekitLogger.error(\"unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()\", {\n        participant: this.sid,\n        trackSid: sid\n      });\n      this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);\n      return;\n    }\n    const isVideo = mediaTrack.kind === \"video\";\n    let track;\n    if (isVideo) {\n      track = new RemoteVideoTrack(mediaTrack, sid, receiver, adaptiveStreamSettings);\n    } else {\n      track = new RemoteAudioTrack(mediaTrack, sid, receiver, this.audioContext, this.audioOutput);\n    }\n    track.source = publication.source;\n    track.isMuted = publication.isMuted;\n    track.setMediaStream(mediaStream);\n    track.start();\n    publication.setTrack(track);\n    if (this.volume !== void 0 && track instanceof RemoteAudioTrack && track.source === Track.Source.Microphone) {\n      track.setVolume(this.volume);\n    }\n    return publication;\n  }\n  /** @internal */\n  get hasMetadata() {\n    return !!this.participantInfo;\n  }\n  getTrackPublication(sid) {\n    return this.tracks.get(sid);\n  }\n  /** @internal */\n  updateInfo(info) {\n    if (!super.updateInfo(info)) {\n      return false;\n    }\n    const validTracks = /* @__PURE__ */ new Map();\n    const newTracks = /* @__PURE__ */ new Map();\n    info.tracks.forEach((ti) => {\n      var _a;\n      let publication = this.getTrackPublication(ti.sid);\n      if (!publication) {\n        const kind = Track.kindFromProto(ti.type);\n        if (!kind) {\n          return;\n        }\n        publication = new RemoteTrackPublication(kind, ti, (_a = this.signalClient.connectOptions) === null || _a === void 0 ? void 0 : _a.autoSubscribe);\n        publication.updateInfo(ti);\n        newTracks.set(ti.sid, publication);\n        const existingTrackOfSource = Array.from(this.tracks.values()).find((publishedTrack) => publishedTrack.source === (publication === null || publication === void 0 ? void 0 : publication.source));\n        if (existingTrackOfSource && publication.source !== Track.Source.Unknown) {\n          livekitLogger.debug(\"received a second track publication for \".concat(this.identity, \" with the same source: \").concat(publication.source), {\n            oldTrack: existingTrackOfSource,\n            newTrack: publication,\n            participant: this,\n            participantInfo: info\n          });\n        }\n        this.addTrackPublication(publication);\n      } else {\n        publication.updateInfo(ti);\n      }\n      validTracks.set(ti.sid, publication);\n    });\n    this.tracks.forEach((publication) => {\n      if (!validTracks.has(publication.trackSid)) {\n        livekitLogger.trace(\"detected removed track on remote participant, unpublishing\", {\n          publication,\n          participantSid: this.sid\n        });\n        this.unpublishTrack(publication.trackSid, true);\n      }\n    });\n    newTracks.forEach((publication) => {\n      this.emit(ParticipantEvent.TrackPublished, publication);\n    });\n    return true;\n  }\n  /** @internal */\n  unpublishTrack(sid, sendUnpublish) {\n    const publication = this.tracks.get(sid);\n    if (!publication) {\n      return;\n    }\n    this.tracks.delete(sid);\n    switch (publication.kind) {\n      case Track.Kind.Audio:\n        this.audioTracks.delete(sid);\n        break;\n      case Track.Kind.Video:\n        this.videoTracks.delete(sid);\n        break;\n    }\n    const {\n      track\n    } = publication;\n    if (track) {\n      track.stop();\n      publication.setTrack(void 0);\n    }\n    if (sendUnpublish) {\n      this.emit(ParticipantEvent.TrackUnpublished, publication);\n    }\n  }\n  /**\n   * @internal\n   */\n  setAudioContext(ctx) {\n    this.audioContext = ctx;\n    this.audioTracks.forEach((track) => track.track instanceof RemoteAudioTrack && track.track.setAudioContext(ctx));\n  }\n  /**\n   * @internal\n   */\n  setAudioOutput(output) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.audioOutput = output;\n      const promises = [];\n      this.audioTracks.forEach((pub) => {\n        var _a;\n        if (pub.track instanceof RemoteAudioTrack) {\n          promises.push(pub.track.setSinkId((_a = output.deviceId) !== null && _a !== void 0 ? _a : \"default\"));\n        }\n      });\n      yield Promise.all(promises);\n    });\n  }\n  /** @internal */\n  emit(event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    livekitLogger.trace(\"participant event\", {\n      participant: this.sid,\n      event,\n      args\n    });\n    return super.emit(event, ...args);\n  }\n};\nfunction mediaTrackToLocalTrack(mediaStreamTrack, constraints) {\n  switch (mediaStreamTrack.kind) {\n    case \"audio\":\n      return new LocalAudioTrack(mediaStreamTrack, constraints, false);\n    case \"video\":\n      return new LocalVideoTrack(mediaStreamTrack, constraints, false);\n    default:\n      throw new TrackInvalidError(\"unsupported track type: \".concat(mediaStreamTrack.kind));\n  }\n}\nvar presets169 = Object.values(VideoPresets);\nvar presets43 = Object.values(VideoPresets43);\nvar presetsScreenShare = Object.values(ScreenSharePresets);\nvar defaultSimulcastPresets169 = [VideoPresets.h180, VideoPresets.h360];\nvar defaultSimulcastPresets43 = [VideoPresets43.h180, VideoPresets43.h360];\nvar computeDefaultScreenShareSimulcastPresets = (fromPreset) => {\n  const layers = [{\n    scaleResolutionDownBy: 2,\n    fps: 3\n  }];\n  return layers.map((t) => {\n    var _a;\n    return new VideoPreset(Math.floor(fromPreset.width / t.scaleResolutionDownBy), Math.floor(fromPreset.height / t.scaleResolutionDownBy), Math.max(15e4, Math.floor(fromPreset.encoding.maxBitrate / (Math.pow(t.scaleResolutionDownBy, 2) * (((_a = fromPreset.encoding.maxFramerate) !== null && _a !== void 0 ? _a : 30) / t.fps)))), t.fps, fromPreset.encoding.priority);\n  });\n};\nvar videoRids = [\"q\", \"h\", \"f\"];\nfunction computeVideoEncodings(isScreenShare, width, height, options) {\n  var _a, _b;\n  let videoEncoding = options === null || options === void 0 ? void 0 : options.videoEncoding;\n  if (isScreenShare) {\n    videoEncoding = options === null || options === void 0 ? void 0 : options.screenShareEncoding;\n  }\n  const useSimulcast = options === null || options === void 0 ? void 0 : options.simulcast;\n  const scalabilityMode = options === null || options === void 0 ? void 0 : options.scalabilityMode;\n  const videoCodec = options === null || options === void 0 ? void 0 : options.videoCodec;\n  if (!videoEncoding && !useSimulcast && !scalabilityMode || !width || !height) {\n    return [{}];\n  }\n  if (!videoEncoding) {\n    videoEncoding = determineAppropriateEncoding(isScreenShare, width, height, videoCodec);\n    livekitLogger.debug(\"using video encoding\", videoEncoding);\n  }\n  const original = new VideoPreset(width, height, videoEncoding.maxBitrate, videoEncoding.maxFramerate);\n  if (scalabilityMode && isSVCCodec(videoCodec)) {\n    livekitLogger.debug(\"using svc with scalabilityMode \".concat(scalabilityMode));\n    const encodings = [];\n    switch (scalabilityMode) {\n      case \"L3T3\":\n        for (let i = 0; i < 3; i += 1) {\n          encodings.push({\n            rid: videoRids[2 - i],\n            scaleResolutionDownBy: Math.pow(2, i),\n            maxBitrate: videoEncoding.maxBitrate / Math.pow(3, i),\n            /* @ts-ignore */\n            maxFramerate: original.encoding.maxFramerate,\n            /* @ts-ignore */\n            scalabilityMode: \"L3T3\"\n          });\n        }\n        livekitLogger.debug(\"encodings\", encodings);\n        return encodings;\n      default:\n        throw new Error(\"unsupported scalabilityMode: \".concat(scalabilityMode));\n    }\n  }\n  if (!useSimulcast) {\n    return [videoEncoding];\n  }\n  let presets = [];\n  if (isScreenShare) {\n    presets = (_a = sortPresets(options === null || options === void 0 ? void 0 : options.screenShareSimulcastLayers)) !== null && _a !== void 0 ? _a : defaultSimulcastLayers(isScreenShare, original);\n  } else {\n    presets = (_b = sortPresets(options === null || options === void 0 ? void 0 : options.videoSimulcastLayers)) !== null && _b !== void 0 ? _b : defaultSimulcastLayers(isScreenShare, original);\n  }\n  let midPreset;\n  if (presets.length > 0) {\n    const lowPreset = presets[0];\n    if (presets.length > 1) {\n      [, midPreset] = presets;\n    }\n    const size = Math.max(width, height);\n    if (size >= 960 && midPreset) {\n      return encodingsFromPresets(width, height, [lowPreset, midPreset, original]);\n    }\n    if (size >= 480) {\n      return encodingsFromPresets(width, height, [lowPreset, original]);\n    }\n  }\n  return encodingsFromPresets(width, height, [original]);\n}\nfunction computeTrackBackupEncodings(track, videoCodec, opts) {\n  var _a, _b, _c, _d;\n  if (!opts.backupCodec || opts.backupCodec.codec === opts.videoCodec) {\n    return;\n  }\n  if (videoCodec !== opts.backupCodec.codec) {\n    livekitLogger.warn(\"requested a different codec than specified as backup\", {\n      serverRequested: videoCodec,\n      backup: opts.backupCodec.codec\n    });\n  }\n  opts.videoCodec = videoCodec;\n  opts.videoEncoding = opts.backupCodec.encoding;\n  const settings = track.mediaStreamTrack.getSettings();\n  const width = (_a = settings.width) !== null && _a !== void 0 ? _a : (_b = track.dimensions) === null || _b === void 0 ? void 0 : _b.width;\n  const height = (_c = settings.height) !== null && _c !== void 0 ? _c : (_d = track.dimensions) === null || _d === void 0 ? void 0 : _d.height;\n  const encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, width, height, opts);\n  return encodings;\n}\nfunction determineAppropriateEncoding(isScreenShare, width, height, codec) {\n  const presets = presetsForResolution(isScreenShare, width, height);\n  let {\n    encoding\n  } = presets[0];\n  const size = Math.max(width, height);\n  for (let i = 0; i < presets.length; i += 1) {\n    const preset = presets[i];\n    encoding = preset.encoding;\n    if (preset.width >= size) {\n      break;\n    }\n  }\n  if (codec) {\n    switch (codec) {\n      case \"av1\":\n        encoding = Object.assign({}, encoding);\n        encoding.maxBitrate = encoding.maxBitrate * 0.7;\n        break;\n      case \"vp9\":\n        encoding = Object.assign({}, encoding);\n        encoding.maxBitrate = encoding.maxBitrate * 0.85;\n        break;\n    }\n  }\n  return encoding;\n}\nfunction presetsForResolution(isScreenShare, width, height) {\n  if (isScreenShare) {\n    return presetsScreenShare;\n  }\n  const aspect = width > height ? width / height : height / width;\n  if (Math.abs(aspect - 16 / 9) < Math.abs(aspect - 4 / 3)) {\n    return presets169;\n  }\n  return presets43;\n}\nfunction defaultSimulcastLayers(isScreenShare, original) {\n  if (isScreenShare) {\n    return computeDefaultScreenShareSimulcastPresets(original);\n  }\n  const {\n    width,\n    height\n  } = original;\n  const aspect = width > height ? width / height : height / width;\n  if (Math.abs(aspect - 16 / 9) < Math.abs(aspect - 4 / 3)) {\n    return defaultSimulcastPresets169;\n  }\n  return defaultSimulcastPresets43;\n}\nfunction encodingsFromPresets(width, height, presets) {\n  const encodings = [];\n  presets.forEach((preset, idx) => {\n    if (idx >= videoRids.length) {\n      return;\n    }\n    const size = Math.min(width, height);\n    const rid = videoRids[idx];\n    const encoding = {\n      rid,\n      scaleResolutionDownBy: Math.max(1, size / Math.min(preset.width, preset.height)),\n      maxBitrate: preset.encoding.maxBitrate\n    };\n    if (preset.encoding.maxFramerate) {\n      encoding.maxFramerate = preset.encoding.maxFramerate;\n    }\n    if (preset.encoding.priority) {\n      encoding.priority = preset.encoding.priority;\n      encoding.networkPriority = preset.encoding.priority;\n    }\n    encodings.push(encoding);\n  });\n  return encodings;\n}\nfunction sortPresets(presets) {\n  if (!presets)\n    return;\n  return presets.sort((a, b) => {\n    const {\n      encoding: aEnc\n    } = a;\n    const {\n      encoding: bEnc\n    } = b;\n    if (aEnc.maxBitrate > bEnc.maxBitrate) {\n      return 1;\n    }\n    if (aEnc.maxBitrate < bEnc.maxBitrate)\n      return -1;\n    if (aEnc.maxBitrate === bEnc.maxBitrate && aEnc.maxFramerate && bEnc.maxFramerate) {\n      return aEnc.maxFramerate > bEnc.maxFramerate ? 1 : -1;\n    }\n    return 0;\n  });\n}\nvar LocalParticipant = class extends Participant {\n  /** @internal */\n  constructor(sid, identity, engine, options) {\n    super(sid, identity);\n    this.pendingPublishing = /* @__PURE__ */ new Set();\n    this.pendingPublishPromises = /* @__PURE__ */ new Map();\n    this.participantTrackPermissions = [];\n    this.allParticipantsAllowedToSubscribe = true;\n    this.handleReconnecting = () => {\n      if (!this.reconnectFuture) {\n        this.reconnectFuture = new Future();\n      }\n    };\n    this.handleReconnected = () => {\n      var _a, _b;\n      (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.resolve) === null || _b === void 0 ? void 0 : _b.call(_a);\n      this.reconnectFuture = void 0;\n      this.updateTrackSubscriptionPermissions();\n    };\n    this.handleDisconnected = () => {\n      var _a, _b;\n      (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.reject) === null || _b === void 0 ? void 0 : _b.call(_a, \"Got disconnected during publishing attempt\");\n      this.reconnectFuture = void 0;\n    };\n    this.updateTrackSubscriptionPermissions = () => {\n      livekitLogger.debug(\"updating track subscription permissions\", {\n        allParticipantsAllowed: this.allParticipantsAllowedToSubscribe,\n        participantTrackPermissions: this.participantTrackPermissions\n      });\n      this.engine.client.sendUpdateSubscriptionPermissions(this.allParticipantsAllowedToSubscribe, this.participantTrackPermissions.map((p) => trackPermissionToProto(p)));\n    };\n    this.onTrackUnmuted = (track) => {\n      this.onTrackMuted(track, track.isUpstreamPaused);\n    };\n    this.onTrackMuted = (track, muted) => {\n      if (muted === void 0) {\n        muted = true;\n      }\n      if (!track.sid) {\n        livekitLogger.error(\"could not update mute status for unpublished track\", track);\n        return;\n      }\n      this.engine.updateMuteStatus(track.sid, muted);\n    };\n    this.onTrackUpstreamPaused = (track) => {\n      livekitLogger.debug(\"upstream paused\");\n      this.onTrackMuted(track, true);\n    };\n    this.onTrackUpstreamResumed = (track) => {\n      livekitLogger.debug(\"upstream resumed\");\n      this.onTrackMuted(track, track.isMuted);\n    };\n    this.handleSubscribedQualityUpdate = (update) => __awaiter(this, void 0, void 0, function* () {\n      var _a, e_1, _b, _c;\n      var _d, _e;\n      if (!((_d = this.roomOptions) === null || _d === void 0 ? void 0 : _d.dynacast)) {\n        return;\n      }\n      const pub = this.videoTracks.get(update.trackSid);\n      if (!pub) {\n        livekitLogger.warn(\"received subscribed quality update for unknown track\", {\n          method: \"handleSubscribedQualityUpdate\",\n          sid: update.trackSid\n        });\n        return;\n      }\n      if (update.subscribedCodecs.length > 0) {\n        if (!pub.videoTrack) {\n          return;\n        }\n        const newCodecs = yield pub.videoTrack.setPublishingCodecs(update.subscribedCodecs);\n        try {\n          for (var _f = true, newCodecs_1 = __asyncValues(newCodecs), newCodecs_1_1; newCodecs_1_1 = yield newCodecs_1.next(), _a = newCodecs_1_1.done, !_a; ) {\n            _c = newCodecs_1_1.value;\n            _f = false;\n            try {\n              const codec = _c;\n              if (isBackupCodec(codec)) {\n                livekitLogger.debug(\"publish \".concat(codec, \" for \").concat(pub.videoTrack.sid));\n                yield this.publishAdditionalCodecForTrack(pub.videoTrack, codec, pub.options);\n              }\n            } finally {\n              _f = true;\n            }\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (!_f && !_a && (_b = newCodecs_1.return))\n              yield _b.call(newCodecs_1);\n          } finally {\n            if (e_1)\n              throw e_1.error;\n          }\n        }\n      } else if (update.subscribedQualities.length > 0) {\n        yield (_e = pub.videoTrack) === null || _e === void 0 ? void 0 : _e.setPublishingLayers(update.subscribedQualities);\n      }\n    });\n    this.handleLocalTrackUnpublished = (unpublished) => {\n      const track = this.tracks.get(unpublished.trackSid);\n      if (!track) {\n        livekitLogger.warn(\"received unpublished event for unknown track\", {\n          method: \"handleLocalTrackUnpublished\",\n          trackSid: unpublished.trackSid\n        });\n        return;\n      }\n      this.unpublishTrack(track.track);\n    };\n    this.handleTrackEnded = (track) => __awaiter(this, void 0, void 0, function* () {\n      if (track.source === Track.Source.ScreenShare || track.source === Track.Source.ScreenShareAudio) {\n        livekitLogger.debug(\"unpublishing local track due to TrackEnded\", {\n          track: track.sid\n        });\n        this.unpublishTrack(track);\n      } else if (track.isUserProvided) {\n        yield track.mute();\n      } else if (track instanceof LocalAudioTrack || track instanceof LocalVideoTrack) {\n        try {\n          if (isWeb()) {\n            try {\n              const currentPermissions = yield navigator === null || navigator === void 0 ? void 0 : navigator.permissions.query({\n                // the permission query for camera and microphone currently not supported in Safari and Firefox\n                // @ts-ignore\n                name: track.source === Track.Source.Camera ? \"camera\" : \"microphone\"\n              });\n              if (currentPermissions && currentPermissions.state === \"denied\") {\n                livekitLogger.warn(\"user has revoked access to \".concat(track.source));\n                currentPermissions.onchange = () => {\n                  if (currentPermissions.state !== \"denied\") {\n                    if (!track.isMuted) {\n                      track.restartTrack();\n                    }\n                    currentPermissions.onchange = null;\n                  }\n                };\n                throw new Error(\"GetUserMedia Permission denied\");\n              }\n            } catch (e) {\n            }\n          }\n          if (!track.isMuted) {\n            livekitLogger.debug(\"track ended, attempting to use a different device\");\n            yield track.restartTrack();\n          }\n        } catch (e) {\n          livekitLogger.warn(\"could not restart track, muting instead\");\n          yield track.mute();\n        }\n      }\n    });\n    this.audioTracks = /* @__PURE__ */ new Map();\n    this.videoTracks = /* @__PURE__ */ new Map();\n    this.tracks = /* @__PURE__ */ new Map();\n    this.engine = engine;\n    this.roomOptions = options;\n    this.setupEngine(engine);\n  }\n  get lastCameraError() {\n    return this.cameraError;\n  }\n  get lastMicrophoneError() {\n    return this.microphoneError;\n  }\n  getTrack(source) {\n    const track = super.getTrack(source);\n    if (track) {\n      return track;\n    }\n  }\n  getTrackByName(name) {\n    const track = super.getTrackByName(name);\n    if (track) {\n      return track;\n    }\n  }\n  /**\n   * @internal\n   */\n  setupEngine(engine) {\n    this.engine = engine;\n    this.engine.client.onRemoteMuteChanged = (trackSid, muted) => {\n      const pub = this.tracks.get(trackSid);\n      if (!pub || !pub.track) {\n        return;\n      }\n      if (muted) {\n        pub.mute();\n      } else {\n        pub.unmute();\n      }\n    };\n    this.engine.client.onSubscribedQualityUpdate = this.handleSubscribedQualityUpdate;\n    this.engine.client.onLocalTrackUnpublished = this.handleLocalTrackUnpublished;\n    this.engine.on(EngineEvent.Connected, this.handleReconnected).on(EngineEvent.Restarted, this.handleReconnected).on(EngineEvent.Resumed, this.handleReconnected).on(EngineEvent.Restarting, this.handleReconnecting).on(EngineEvent.Resuming, this.handleReconnecting).on(EngineEvent.Disconnected, this.handleDisconnected);\n  }\n  /**\n   * Sets and updates the metadata of the local participant.\n   * Note: this requires `canUpdateOwnMetadata` permission encoded in the token.\n   * @param metadata\n   */\n  setMetadata(metadata) {\n    var _a;\n    super.setMetadata(metadata);\n    this.engine.client.sendUpdateLocalMetadata(metadata, (_a = this.name) !== null && _a !== void 0 ? _a : \"\");\n  }\n  /**\n   * Sets and updates the name of the local participant.\n   * Note: this requires `canUpdateOwnMetadata` permission encoded in the token.\n   * @param metadata\n   */\n  setName(name) {\n    var _a;\n    super.setName(name);\n    this.engine.client.sendUpdateLocalMetadata((_a = this.metadata) !== null && _a !== void 0 ? _a : \"\", name);\n  }\n  /**\n   * Enable or disable a participant's camera track.\n   *\n   * If a track has already published, it'll mute or unmute the track.\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */\n  setCameraEnabled(enabled, options, publishOptions) {\n    return this.setTrackEnabled(Track.Source.Camera, enabled, options, publishOptions);\n  }\n  /**\n   * Enable or disable a participant's microphone track.\n   *\n   * If a track has already published, it'll mute or unmute the track.\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */\n  setMicrophoneEnabled(enabled, options, publishOptions) {\n    return this.setTrackEnabled(Track.Source.Microphone, enabled, options, publishOptions);\n  }\n  /**\n   * Start or stop sharing a participant's screen\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */\n  setScreenShareEnabled(enabled, options, publishOptions) {\n    return this.setTrackEnabled(Track.Source.ScreenShare, enabled, options, publishOptions);\n  }\n  setTrackEnabled(source, enabled, options, publishOptions) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      livekitLogger.debug(\"setTrackEnabled\", {\n        source,\n        enabled\n      });\n      let track = this.getTrack(source);\n      if (enabled) {\n        if (track) {\n          yield track.unmute();\n        } else {\n          let localTracks;\n          if (this.pendingPublishing.has(source)) {\n            livekitLogger.info(\"skipping duplicate published source\", {\n              source\n            });\n            return;\n          }\n          this.pendingPublishing.add(source);\n          try {\n            switch (source) {\n              case Track.Source.Camera:\n                localTracks = yield this.createTracks({\n                  video: (_a = options) !== null && _a !== void 0 ? _a : true\n                });\n                break;\n              case Track.Source.Microphone:\n                localTracks = yield this.createTracks({\n                  audio: (_b = options) !== null && _b !== void 0 ? _b : true\n                });\n                break;\n              case Track.Source.ScreenShare:\n                localTracks = yield this.createScreenTracks(Object.assign({}, options));\n                break;\n              default:\n                throw new TrackInvalidError(source);\n            }\n            const publishPromises = [];\n            for (const localTrack of localTracks) {\n              livekitLogger.info(\"publishing track\", {\n                localTrack\n              });\n              publishPromises.push(this.publishTrack(localTrack, publishOptions));\n            }\n            const publishedTracks = yield Promise.all(publishPromises);\n            [track] = publishedTracks;\n          } catch (e) {\n            if (e instanceof Error && !(e instanceof TrackInvalidError)) {\n              this.emit(ParticipantEvent.MediaDevicesError, e);\n            }\n            throw e;\n          } finally {\n            this.pendingPublishing.delete(source);\n          }\n        }\n      } else if (track && track.track) {\n        if (source === Track.Source.ScreenShare) {\n          track = yield this.unpublishTrack(track.track);\n          const screenAudioTrack = this.getTrack(Track.Source.ScreenShareAudio);\n          if (screenAudioTrack && screenAudioTrack.track) {\n            this.unpublishTrack(screenAudioTrack.track);\n          }\n        } else {\n          yield track.mute();\n        }\n      }\n      return track;\n    });\n  }\n  /**\n   * Publish both camera and microphone at the same time. This is useful for\n   * displaying a single Permission Dialog box to the end user.\n   */\n  enableCameraAndMicrophone() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.pendingPublishing.has(Track.Source.Camera) || this.pendingPublishing.has(Track.Source.Microphone)) {\n        return;\n      }\n      this.pendingPublishing.add(Track.Source.Camera);\n      this.pendingPublishing.add(Track.Source.Microphone);\n      try {\n        const tracks = yield this.createTracks({\n          audio: true,\n          video: true\n        });\n        yield Promise.all(tracks.map((track) => this.publishTrack(track)));\n      } finally {\n        this.pendingPublishing.delete(Track.Source.Camera);\n        this.pendingPublishing.delete(Track.Source.Microphone);\n      }\n    });\n  }\n  /**\n   * Create local camera and/or microphone tracks\n   * @param options\n   * @returns\n   */\n  createTracks(options) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const opts = mergeDefaultOptions(options, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.audioCaptureDefaults, (_b = this.roomOptions) === null || _b === void 0 ? void 0 : _b.videoCaptureDefaults);\n      const constraints = constraintsForOptions(opts);\n      let stream;\n      try {\n        stream = yield navigator.mediaDevices.getUserMedia(constraints);\n      } catch (err) {\n        if (err instanceof Error) {\n          if (constraints.audio) {\n            this.microphoneError = err;\n          }\n          if (constraints.video) {\n            this.cameraError = err;\n          }\n        }\n        throw err;\n      }\n      if (constraints.audio) {\n        this.microphoneError = void 0;\n      }\n      if (constraints.video) {\n        this.cameraError = void 0;\n      }\n      return stream.getTracks().map((mediaStreamTrack) => {\n        const isAudio = mediaStreamTrack.kind === \"audio\";\n        isAudio ? options.audio : options.video;\n        let trackConstraints;\n        const conOrBool = isAudio ? constraints.audio : constraints.video;\n        if (typeof conOrBool !== \"boolean\") {\n          trackConstraints = conOrBool;\n        }\n        const track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints);\n        if (track.kind === Track.Kind.Video) {\n          track.source = Track.Source.Camera;\n        } else if (track.kind === Track.Kind.Audio) {\n          track.source = Track.Source.Microphone;\n        }\n        track.mediaStream = stream;\n        return track;\n      });\n    });\n  }\n  /**\n   * Creates a screen capture tracks with getDisplayMedia().\n   * A LocalVideoTrack is always created and returned.\n   * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.\n   */\n  createScreenTracks(options) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (options === void 0) {\n        options = {};\n      }\n      if (options.resolution === void 0) {\n        options.resolution = ScreenSharePresets.h1080fps15.resolution;\n      }\n      let videoConstraints = true;\n      if (options.resolution) {\n        if (isSafari()) {\n          videoConstraints = {\n            width: {\n              max: options.resolution.width\n            },\n            height: {\n              max: options.resolution.height\n            },\n            frameRate: options.resolution.frameRate\n          };\n        } else {\n          videoConstraints = {\n            width: {\n              ideal: options.resolution.width\n            },\n            height: {\n              ideal: options.resolution.height\n            },\n            frameRate: options.resolution.frameRate\n          };\n        }\n      }\n      if (navigator.mediaDevices.getDisplayMedia === void 0) {\n        throw new DeviceUnsupportedError(\"getDisplayMedia not supported\");\n      }\n      const stream = yield navigator.mediaDevices.getDisplayMedia({\n        audio: (_a = options.audio) !== null && _a !== void 0 ? _a : false,\n        video: videoConstraints,\n        // @ts-expect-error support for experimental display media features\n        controller: options.controller,\n        selfBrowserSurface: options.selfBrowserSurface,\n        surfaceSwitching: options.surfaceSwitching,\n        systemAudio: options.systemAudio\n      });\n      const tracks = stream.getVideoTracks();\n      if (tracks.length === 0) {\n        throw new TrackInvalidError(\"no video track found\");\n      }\n      const screenVideo = new LocalVideoTrack(tracks[0], void 0, false);\n      screenVideo.source = Track.Source.ScreenShare;\n      const localTracks = [screenVideo];\n      if (stream.getAudioTracks().length > 0) {\n        const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], void 0, false);\n        screenAudio.source = Track.Source.ScreenShareAudio;\n        localTracks.push(screenAudio);\n      }\n      return localTracks;\n    });\n  }\n  /**\n   * Publish a new track to the room\n   * @param track\n   * @param options\n   */\n  publishTrack(track, options) {\n    var _a, _b, _c;\n    return __awaiter(this, void 0, void 0, function* () {\n      yield (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.promise;\n      if (track instanceof LocalTrack && this.pendingPublishPromises.has(track)) {\n        yield this.pendingPublishPromises.get(track);\n      }\n      if (track instanceof MediaStreamTrack) {\n        switch (track.kind) {\n          case \"audio\":\n            track = new LocalAudioTrack(track, void 0, true);\n            break;\n          case \"video\":\n            track = new LocalVideoTrack(track, void 0, true);\n            break;\n          default:\n            throw new TrackInvalidError(\"unsupported MediaStreamTrack kind \".concat(track.kind));\n        }\n      }\n      let existingPublication;\n      this.tracks.forEach((publication) => {\n        if (!publication.track) {\n          return;\n        }\n        if (publication.track === track) {\n          existingPublication = publication;\n        }\n      });\n      if (existingPublication) {\n        livekitLogger.warn(\"track has already been published, skipping\");\n        return existingPublication;\n      }\n      const isStereo = (options === null || options === void 0 ? void 0 : options.forceStereo) || \"channelCount\" in track.mediaStreamTrack.getSettings() && // @ts-ignore `channelCount` on getSettings() is currently only available for Safari, but is generally the best way to determine a stereo track https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/channelCount\n      track.mediaStreamTrack.getSettings().channelCount === 2 || track.mediaStreamTrack.getConstraints().channelCount === 2;\n      if (isStereo) {\n        if (!options) {\n          options = {};\n        }\n        if (options.dtx === void 0) {\n          livekitLogger.info(\"Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.\");\n        }\n        if (options.red === void 0) {\n          livekitLogger.info(\"Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work.\");\n        }\n        (_b = options.dtx) !== null && _b !== void 0 ? _b : options.dtx = false;\n        (_c = options.red) !== null && _c !== void 0 ? _c : options.red = false;\n      }\n      const opts = Object.assign(Object.assign({}, this.roomOptions.publishDefaults), options);\n      if (opts.source) {\n        track.source = opts.source;\n      }\n      const publishPromise = this.publish(track, opts, options, isStereo);\n      this.pendingPublishPromises.set(track, publishPromise);\n      try {\n        const publication = yield publishPromise;\n        return publication;\n      } catch (e) {\n        throw e;\n      } finally {\n        this.pendingPublishPromises.delete(track);\n      }\n    });\n  }\n  publish(track, opts, options, isStereo) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    return __awaiter(this, void 0, void 0, function* () {\n      const existingTrackOfSource = Array.from(this.tracks.values()).find((publishedTrack) => track instanceof LocalTrack && publishedTrack.source === track.source);\n      if (existingTrackOfSource && track.source !== Track.Source.Unknown) {\n        try {\n          throw Error(\"publishing a second track with the same source: \".concat(track.source));\n        } catch (e) {\n          if (e instanceof Error) {\n            livekitLogger.warn(e.message, {\n              oldTrack: existingTrackOfSource,\n              newTrack: track,\n              trace: e.stack\n            });\n          }\n        }\n      }\n      if (opts.stopMicTrackOnMute && track instanceof LocalAudioTrack) {\n        track.stopOnMute = true;\n      }\n      if (track.source === Track.Source.ScreenShare && isFireFox()) {\n        opts.simulcast = false;\n      }\n      if (opts.videoCodec === \"av1\" && !supportsAV1()) {\n        opts.videoCodec = void 0;\n      }\n      if (opts.videoCodec === \"vp9\" && !supportsVP9()) {\n        opts.videoCodec = void 0;\n      }\n      track.on(TrackEvent.Muted, this.onTrackMuted);\n      track.on(TrackEvent.Unmuted, this.onTrackUnmuted);\n      track.on(TrackEvent.Ended, this.handleTrackEnded);\n      track.on(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);\n      track.on(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);\n      const req = AddTrackRequest.fromPartial({\n        // get local track id for use during publishing\n        cid: track.mediaStreamTrack.id,\n        name: options === null || options === void 0 ? void 0 : options.name,\n        type: Track.kindToProto(track.kind),\n        muted: track.isMuted,\n        source: Track.sourceToProto(track.source),\n        disableDtx: !((_a = opts.dtx) !== null && _a !== void 0 ? _a : true),\n        stereo: isStereo,\n        disableRed: !((_b = opts.red) !== null && _b !== void 0 ? _b : true)\n      });\n      let encodings;\n      let simEncodings;\n      if (track.kind === Track.Kind.Video) {\n        let dims = {\n          width: 0,\n          height: 0\n        };\n        try {\n          dims = yield track.waitForDimensions();\n        } catch (e) {\n          livekitLogger.error(\"could not determine track dimensions\");\n        }\n        req.width = dims.width;\n        req.height = dims.height;\n        if (track instanceof LocalVideoTrack) {\n          if (isSVCCodec(opts.videoCodec)) {\n            opts.scalabilityMode = (_c = opts.scalabilityMode) !== null && _c !== void 0 ? _c : \"L3T3\";\n          }\n          if (opts.videoCodec && opts.backupCodec && opts.videoCodec !== opts.backupCodec.codec) {\n            const simOpts = Object.assign({}, opts);\n            simOpts.simulcast = true;\n            simEncodings = computeTrackBackupEncodings(track, opts.backupCodec.codec, simOpts);\n            req.simulcastCodecs = [{\n              codec: opts.videoCodec,\n              cid: track.mediaStreamTrack.id,\n              enableSimulcastLayers: true\n            }, {\n              codec: opts.backupCodec.codec,\n              cid: \"\",\n              enableSimulcastLayers: true\n            }];\n          }\n        }\n        encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, dims.width, dims.height, opts);\n        req.layers = videoLayersFromEncodings(req.width, req.height, simEncodings !== null && simEncodings !== void 0 ? simEncodings : encodings);\n      } else if (track.kind === Track.Kind.Audio) {\n        encodings = [{\n          maxBitrate: (_e = (_d = opts.audioPreset) === null || _d === void 0 ? void 0 : _d.maxBitrate) !== null && _e !== void 0 ? _e : opts.audioBitrate,\n          priority: (_g = (_f = opts.audioPreset) === null || _f === void 0 ? void 0 : _f.priority) !== null && _g !== void 0 ? _g : \"high\",\n          networkPriority: (_j = (_h = opts.audioPreset) === null || _h === void 0 ? void 0 : _h.priority) !== null && _j !== void 0 ? _j : \"high\"\n        }];\n      }\n      if (!this.engine || this.engine.isClosed) {\n        throw new UnexpectedConnectionState(\"cannot publish track when not connected\");\n      }\n      const ti = yield this.engine.addTrack(req);\n      let primaryCodecSupported = false;\n      let backupCodecSupported = false;\n      ti.codecs.forEach((c) => {\n        if (isCodecEqual(c.mimeType, opts.videoCodec)) {\n          primaryCodecSupported = true;\n        } else if (opts.backupCodec && isCodecEqual(c.mimeType, opts.backupCodec.codec)) {\n          backupCodecSupported = true;\n        }\n      });\n      if (req.simulcastCodecs.length > 0) {\n        if (!primaryCodecSupported && !backupCodecSupported) {\n          throw Error(\"cannot publish track, codec not supported by server\");\n        }\n        if (!primaryCodecSupported && opts.backupCodec) {\n          const backupCodec = opts.backupCodec;\n          opts = Object.assign({}, opts);\n          livekitLogger.debug(\"primary codec \".concat(opts.videoCodec, \" not supported, fallback to \").concat(backupCodec.codec));\n          opts.videoCodec = backupCodec.codec;\n          opts.videoEncoding = backupCodec.encoding;\n          encodings = simEncodings;\n        }\n      }\n      const publication = new LocalTrackPublication(track.kind, ti, track);\n      publication.options = opts;\n      track.sid = ti.sid;\n      if (!this.engine.publisher) {\n        throw new UnexpectedConnectionState(\"publisher is closed\");\n      }\n      livekitLogger.debug(\"publishing \".concat(track.kind, \" with encodings\"), {\n        encodings,\n        trackInfo: ti\n      });\n      track.sender = yield this.engine.createSender(track, opts, encodings);\n      if (track.codec && isSVCCodec(track.codec) && encodings && ((_k = encodings[0]) === null || _k === void 0 ? void 0 : _k.maxBitrate)) {\n        this.engine.publisher.setTrackCodecBitrate(req.cid, track.codec, encodings[0].maxBitrate / 1e3);\n      }\n      this.engine.negotiate();\n      if (track instanceof LocalVideoTrack) {\n        track.startMonitor(this.engine.client);\n      } else if (track instanceof LocalAudioTrack) {\n        track.startMonitor();\n      }\n      this.addTrackPublication(publication);\n      this.emit(ParticipantEvent.LocalTrackPublished, publication);\n      return publication;\n    });\n  }\n  get isLocal() {\n    return true;\n  }\n  /** @internal\n   * publish additional codec to existing track\n   */\n  publishAdditionalCodecForTrack(track, videoCodec, options) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      let existingPublication;\n      this.tracks.forEach((publication) => {\n        if (!publication.track) {\n          return;\n        }\n        if (publication.track === track) {\n          existingPublication = publication;\n        }\n      });\n      if (!existingPublication) {\n        throw new TrackInvalidError(\"track is not published\");\n      }\n      if (!(track instanceof LocalVideoTrack)) {\n        throw new TrackInvalidError(\"track is not a video track\");\n      }\n      const opts = Object.assign(Object.assign({}, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.publishDefaults), options);\n      const encodings = computeTrackBackupEncodings(track, videoCodec, opts);\n      if (!encodings) {\n        livekitLogger.info(\"backup codec has been disabled, ignoring request to add additional codec for track\");\n        return;\n      }\n      const simulcastTrack = track.addSimulcastTrack(videoCodec, encodings);\n      const req = AddTrackRequest.fromPartial({\n        cid: simulcastTrack.mediaStreamTrack.id,\n        type: Track.kindToProto(track.kind),\n        muted: track.isMuted,\n        source: Track.sourceToProto(track.source),\n        sid: track.sid,\n        simulcastCodecs: [{\n          codec: opts.videoCodec,\n          cid: simulcastTrack.mediaStreamTrack.id,\n          enableSimulcastLayers: opts.simulcast\n        }]\n      });\n      req.layers = videoLayersFromEncodings(req.width, req.height, encodings);\n      if (!this.engine || this.engine.isClosed) {\n        throw new UnexpectedConnectionState(\"cannot publish track when not connected\");\n      }\n      const ti = yield this.engine.addTrack(req);\n      yield this.engine.createSimulcastSender(track, simulcastTrack, opts, encodings);\n      this.engine.negotiate();\n      livekitLogger.debug(\"published \".concat(videoCodec, \" for track \").concat(track.sid), {\n        encodings,\n        trackInfo: ti\n      });\n    });\n  }\n  unpublishTrack(track, stopOnUnpublish) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const publication = this.getPublicationForTrack(track);\n      livekitLogger.debug(\"unpublishing track\", {\n        track,\n        method: \"unpublishTrack\"\n      });\n      if (!publication || !publication.track) {\n        livekitLogger.warn(\"track was not unpublished because no publication was found\", {\n          track,\n          method: \"unpublishTrack\"\n        });\n        return void 0;\n      }\n      track = publication.track;\n      track.off(TrackEvent.Muted, this.onTrackMuted);\n      track.off(TrackEvent.Unmuted, this.onTrackUnmuted);\n      track.off(TrackEvent.Ended, this.handleTrackEnded);\n      track.off(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);\n      track.off(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);\n      if (stopOnUnpublish === void 0) {\n        stopOnUnpublish = (_b = (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.stopLocalTrackOnUnpublish) !== null && _b !== void 0 ? _b : true;\n      }\n      if (stopOnUnpublish) {\n        track.stop();\n      }\n      let negotiationNeeded = false;\n      const trackSender = track.sender;\n      track.sender = void 0;\n      if (this.engine.publisher && this.engine.publisher.pc.connectionState !== \"closed\" && trackSender) {\n        try {\n          if (this.engine.removeTrack(trackSender)) {\n            negotiationNeeded = true;\n          }\n          if (track instanceof LocalVideoTrack) {\n            for (const [, trackInfo] of track.simulcastCodecs) {\n              if (trackInfo.sender) {\n                if (this.engine.removeTrack(trackInfo.sender)) {\n                  negotiationNeeded = true;\n                }\n                trackInfo.sender = void 0;\n              }\n            }\n            track.simulcastCodecs.clear();\n          }\n        } catch (e) {\n          livekitLogger.warn(\"failed to unpublish track\", {\n            error: e,\n            method: \"unpublishTrack\"\n          });\n        }\n      }\n      this.tracks.delete(publication.trackSid);\n      switch (publication.kind) {\n        case Track.Kind.Audio:\n          this.audioTracks.delete(publication.trackSid);\n          break;\n        case Track.Kind.Video:\n          this.videoTracks.delete(publication.trackSid);\n          break;\n      }\n      this.emit(ParticipantEvent.LocalTrackUnpublished, publication);\n      publication.setTrack(void 0);\n      if (negotiationNeeded) {\n        yield this.engine.negotiate();\n      }\n      return publication;\n    });\n  }\n  unpublishTracks(tracks) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const results = yield Promise.all(tracks.map((track) => this.unpublishTrack(track)));\n      return results.filter((track) => track instanceof LocalTrackPublication);\n    });\n  }\n  republishAllTracks(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const localPubs = [];\n      this.tracks.forEach((pub) => {\n        if (pub.track) {\n          if (options) {\n            pub.options = Object.assign(Object.assign({}, pub.options), options);\n          }\n          localPubs.push(pub);\n        }\n      });\n      yield Promise.all(localPubs.map((pub) => __awaiter(this, void 0, void 0, function* () {\n        const track = pub.track;\n        yield this.unpublishTrack(track, false);\n        yield this.publishTrack(track, pub.options);\n      })));\n    });\n  }\n  publishData(data, kind) {\n    let publishOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      const destination = Array.isArray(publishOptions) ? publishOptions : publishOptions === null || publishOptions === void 0 ? void 0 : publishOptions.destination;\n      const destinationSids = [];\n      const topic = !Array.isArray(publishOptions) ? publishOptions.topic : void 0;\n      if (destination !== void 0) {\n        destination.forEach((val) => {\n          if (val instanceof RemoteParticipant) {\n            destinationSids.push(val.sid);\n          } else {\n            destinationSids.push(val);\n          }\n        });\n      }\n      const packet = {\n        kind,\n        value: {\n          $case: \"user\",\n          user: {\n            participantSid: this.sid,\n            payload: data,\n            destinationSids,\n            topic\n          }\n        }\n      };\n      yield this.engine.sendDataPacket(packet, kind);\n    });\n  }\n  /**\n   * Control who can subscribe to LocalParticipant's published tracks.\n   *\n   * By default, all participants can subscribe. This allows fine-grained control over\n   * who is able to subscribe at a participant and track level.\n   *\n   * Note: if access is given at a track-level (i.e. both [allParticipantsAllowed] and\n   * [ParticipantTrackPermission.allTracksAllowed] are false), any newer published tracks\n   * will not grant permissions to any participants and will require a subsequent\n   * permissions update to allow subscription.\n   *\n   * @param allParticipantsAllowed Allows all participants to subscribe all tracks.\n   *  Takes precedence over [[participantTrackPermissions]] if set to true.\n   *  By default this is set to true.\n   * @param participantTrackPermissions Full list of individual permissions per\n   *  participant/track. Any omitted participants will not receive any permissions.\n   */\n  setTrackSubscriptionPermissions(allParticipantsAllowed) {\n    let participantTrackPermissions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n    this.participantTrackPermissions = participantTrackPermissions;\n    this.allParticipantsAllowedToSubscribe = allParticipantsAllowed;\n    if (this.engine.client.isConnected) {\n      this.updateTrackSubscriptionPermissions();\n    }\n  }\n  /** @internal */\n  updateInfo(info) {\n    if (info.sid !== this.sid) {\n      return false;\n    }\n    if (!super.updateInfo(info)) {\n      return false;\n    }\n    info.tracks.forEach((ti) => {\n      var _a, _b;\n      const pub = this.tracks.get(ti.sid);\n      if (pub) {\n        const mutedOnServer = pub.isMuted || ((_b = (_a = pub.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused) !== null && _b !== void 0 ? _b : false);\n        if (mutedOnServer !== ti.muted) {\n          livekitLogger.debug(\"updating server mute state after reconcile\", {\n            sid: ti.sid,\n            muted: mutedOnServer\n          });\n          this.engine.client.sendMuteTrack(ti.sid, mutedOnServer);\n        }\n      }\n    });\n    return true;\n  }\n  getPublicationForTrack(track) {\n    let publication;\n    this.tracks.forEach((pub) => {\n      const localTrack = pub.track;\n      if (!localTrack) {\n        return;\n      }\n      if (track instanceof MediaStreamTrack) {\n        if (localTrack instanceof LocalAudioTrack || localTrack instanceof LocalVideoTrack) {\n          if (localTrack.mediaStreamTrack === track) {\n            publication = pub;\n          }\n        }\n      } else if (track === localTrack) {\n        publication = pub;\n      }\n    });\n    return publication;\n  }\n  /** @internal */\n  publishedTracksInfo() {\n    const infos = [];\n    this.tracks.forEach((track) => {\n      if (track.track !== void 0) {\n        infos.push({\n          cid: track.track.mediaStreamID,\n          track: track.trackInfo\n        });\n      }\n    });\n    return infos;\n  }\n  /** @internal */\n  dataChannelsInfo() {\n    const infos = [];\n    const getInfo = (dc, target) => {\n      if ((dc === null || dc === void 0 ? void 0 : dc.id) !== void 0 && dc.id !== null) {\n        infos.push({\n          label: dc.label,\n          id: dc.id,\n          target\n        });\n      }\n    };\n    getInfo(this.engine.dataChannelForKind(DataPacket_Kind.LOSSY), SignalTarget.PUBLISHER);\n    getInfo(this.engine.dataChannelForKind(DataPacket_Kind.RELIABLE), SignalTarget.PUBLISHER);\n    getInfo(this.engine.dataChannelForKind(DataPacket_Kind.LOSSY, true), SignalTarget.SUBSCRIBER);\n    getInfo(this.engine.dataChannelForKind(DataPacket_Kind.RELIABLE, true), SignalTarget.SUBSCRIBER);\n    return infos;\n  }\n};\nvar ConnectionState;\n(function(ConnectionState2) {\n  ConnectionState2[\"Disconnected\"] = \"disconnected\";\n  ConnectionState2[\"Connecting\"] = \"connecting\";\n  ConnectionState2[\"Connected\"] = \"connected\";\n  ConnectionState2[\"Reconnecting\"] = \"reconnecting\";\n})(ConnectionState || (ConnectionState = {}));\nvar connectionReconcileFrequency = 2 * 1e3;\nvar RoomState = ConnectionState;\nvar Room = class extends eventsExports.EventEmitter {\n  /**\n   * Creates a new Room, the primary construct for a LiveKit session.\n   * @param options\n   */\n  constructor(options) {\n    var _this;\n    super();\n    _this = this;\n    this.state = ConnectionState.Disconnected;\n    this.activeSpeakers = [];\n    this.audioEnabled = true;\n    this.connect = (url, token, opts) => __awaiter(this, void 0, void 0, function* () {\n      const unlockDisconnect = yield this.disconnectLock.lock();\n      if (this.state === ConnectionState.Connected) {\n        livekitLogger.info(\"already connected to room \".concat(this.name));\n        unlockDisconnect();\n        return Promise.resolve();\n      }\n      if (this.connectFuture) {\n        unlockDisconnect();\n        return this.connectFuture.promise;\n      }\n      this.setAndEmitConnectionState(ConnectionState.Connecting);\n      const urlProvider = new RegionUrlProvider(url, token);\n      const connectFn = (resolve, reject, regionUrl) => __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        if (this.abortController) {\n          this.abortController.abort();\n        }\n        this.abortController = new AbortController();\n        unlockDisconnect === null || unlockDisconnect === void 0 ? void 0 : unlockDisconnect();\n        try {\n          yield this.attemptConnection(regionUrl !== null && regionUrl !== void 0 ? regionUrl : url, token, opts, this.abortController);\n          this.abortController = void 0;\n          resolve();\n        } catch (e) {\n          if (isCloud(new URL(url)) && e instanceof ConnectionError && e.reason !== 3) {\n            let nextUrl = null;\n            try {\n              nextUrl = yield urlProvider.getNextBestRegionUrl((_a = this.abortController) === null || _a === void 0 ? void 0 : _a.signal);\n            } catch (error) {\n              if (error instanceof ConnectionError && (error.status === 401 || error.reason === 3)) {\n                reject(error);\n                return;\n              }\n            }\n            if (nextUrl) {\n              livekitLogger.debug(\"initial connection failed, retrying with another region\");\n              yield connectFn(resolve, reject, nextUrl);\n            } else {\n              reject(e);\n            }\n          } else {\n            reject(e);\n          }\n        }\n      });\n      this.connectFuture = new Future(connectFn, () => {\n        this.clearConnectionFutures();\n      });\n      return this.connectFuture.promise;\n    });\n    this.connectSignal = (url, token, engine, connectOptions, roomOptions, abortController) => __awaiter(this, void 0, void 0, function* () {\n      const joinResponse = yield engine.join(url, token, {\n        autoSubscribe: connectOptions.autoSubscribe,\n        publishOnly: connectOptions.publishOnly,\n        adaptiveStream: typeof roomOptions.adaptiveStream === \"object\" ? true : roomOptions.adaptiveStream,\n        maxRetries: connectOptions.maxRetries\n      }, abortController.signal);\n      let serverInfo = joinResponse.serverInfo;\n      if (!serverInfo) {\n        serverInfo = {\n          version: joinResponse.serverVersion,\n          region: joinResponse.serverRegion\n        };\n      }\n      livekitLogger.debug(\"connected to Livekit Server \".concat(Object.entries(serverInfo).map((_ref) => {\n        let [key, value] = _ref;\n        return \"\".concat(key, \": \").concat(value);\n      }).join(\", \")));\n      if (!joinResponse.serverVersion) {\n        throw new UnsupportedServer(\"unknown server version\");\n      }\n      if (joinResponse.serverVersion === \"0.15.1\" && this.options.dynacast) {\n        livekitLogger.debug(\"disabling dynacast due to server version\");\n        roomOptions.dynacast = false;\n      }\n      return joinResponse;\n    });\n    this.applyJoinResponse = (joinResponse) => {\n      const pi = joinResponse.participant;\n      this.localParticipant.sid = pi.sid;\n      this.localParticipant.identity = pi.identity;\n      this.handleParticipantUpdates([pi, ...joinResponse.otherParticipants]);\n      if (joinResponse.room) {\n        this.handleRoomUpdate(joinResponse.room);\n      }\n    };\n    this.attemptConnection = (url, token, opts, abortController) => __awaiter(this, void 0, void 0, function* () {\n      var _b;\n      if (this.state === ConnectionState.Reconnecting) {\n        livekitLogger.info(\"Reconnection attempt replaced by new connection attempt\");\n        this.recreateEngine();\n      } else {\n        this.maybeCreateEngine();\n      }\n      this.acquireAudioContext();\n      this.connOptions = Object.assign(Object.assign({}, roomConnectOptionDefaults), opts);\n      if (this.connOptions.rtcConfig) {\n        this.engine.rtcConfig = this.connOptions.rtcConfig;\n      }\n      if (this.connOptions.peerConnectionTimeout) {\n        this.engine.peerConnectionTimeout = this.connOptions.peerConnectionTimeout;\n      }\n      try {\n        const joinResponse = yield this.connectSignal(url, token, this.engine, this.connOptions, this.options, abortController);\n        this.applyJoinResponse(joinResponse);\n        this.setupLocalParticipantEvents();\n        this.emit(RoomEvent.SignalConnected);\n      } catch (err) {\n        this.recreateEngine();\n        this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);\n        const resultingError = new ConnectionError(\"could not establish signal connection\");\n        if (err instanceof Error) {\n          resultingError.message = \"\".concat(resultingError.message, \": \").concat(err.message);\n        }\n        if (err instanceof ConnectionError) {\n          resultingError.reason = err.reason;\n          resultingError.status = err.status;\n        }\n        livekitLogger.debug(\"error trying to establish signal connection\", {\n          error: err\n        });\n        throw resultingError;\n      }\n      if (abortController.signal.aborted) {\n        this.recreateEngine();\n        this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);\n        throw new ConnectionError(\"Connection attempt aborted\");\n      }\n      try {\n        yield this.engine.waitForPCInitialConnection(this.connOptions.peerConnectionTimeout, abortController);\n      } catch (e) {\n        this.recreateEngine();\n        this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);\n        throw e;\n      }\n      if (isWeb() && this.options.disconnectOnPageLeave) {\n        window.addEventListener(\"pagehide\", this.onPageLeave);\n        window.addEventListener(\"beforeunload\", this.onPageLeave);\n        (_b = navigator.mediaDevices) === null || _b === void 0 ? void 0 : _b.addEventListener(\"devicechange\", this.handleDeviceChange);\n      }\n      this.setAndEmitConnectionState(ConnectionState.Connected);\n      this.emit(RoomEvent.Connected);\n      this.registerConnectionReconcile();\n    });\n    this.disconnect = function() {\n      let stopTracks = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n      return __awaiter(_this, void 0, void 0, function* () {\n        var _c, _d, _e, _f;\n        const unlock = yield this.disconnectLock.lock();\n        try {\n          if (this.state === ConnectionState.Disconnected) {\n            livekitLogger.debug(\"already disconnected\");\n            return;\n          }\n          livekitLogger.info(\"disconnect from room\", {\n            identity: this.localParticipant.identity\n          });\n          if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {\n            livekitLogger.warn(\"abort connection attempt\");\n            (_c = this.abortController) === null || _c === void 0 ? void 0 : _c.abort();\n            (_e = (_d = this.connectFuture) === null || _d === void 0 ? void 0 : _d.reject) === null || _e === void 0 ? void 0 : _e.call(_d, new ConnectionError(\"Client initiated disconnect\"));\n            this.connectFuture = void 0;\n          }\n          if ((_f = this.engine) === null || _f === void 0 ? void 0 : _f.client.isConnected) {\n            yield this.engine.client.sendLeave();\n          }\n          if (this.engine) {\n            yield this.engine.close();\n          }\n          this.handleDisconnect(stopTracks, DisconnectReason.CLIENT_INITIATED);\n          this.engine = void 0;\n        } finally {\n          unlock();\n        }\n      });\n    };\n    this.onPageLeave = () => __awaiter(this, void 0, void 0, function* () {\n      yield this.disconnect();\n    });\n    this.handleRestarting = () => {\n      this.clearConnectionReconcile();\n      for (const p of this.participants.values()) {\n        this.handleParticipantDisconnected(p.sid, p);\n      }\n      if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {\n        this.emit(RoomEvent.Reconnecting);\n      }\n    };\n    this.handleSignalRestarted = (joinResponse) => __awaiter(this, void 0, void 0, function* () {\n      livekitLogger.debug(\"signal reconnected to server\", {\n        region: joinResponse.serverRegion\n      });\n      this.cachedParticipantSids = [];\n      this.applyJoinResponse(joinResponse);\n      try {\n        const localPubs = [];\n        this.localParticipant.tracks.forEach((pub) => {\n          if (pub.track) {\n            localPubs.push(pub);\n          }\n        });\n        yield Promise.all(localPubs.map((pub) => __awaiter(this, void 0, void 0, function* () {\n          const track = pub.track;\n          this.localParticipant.unpublishTrack(track, false);\n          if (!track.isMuted) {\n            if ((track instanceof LocalAudioTrack || track instanceof LocalVideoTrack) && !track.isUserProvided) {\n              livekitLogger.debug(\"restarting existing track\", {\n                track: pub.trackSid\n              });\n              yield track.restartTrack();\n            }\n            livekitLogger.debug(\"publishing new track\", {\n              track: pub.trackSid\n            });\n            yield this.localParticipant.publishTrack(track, pub.options);\n          }\n        })));\n      } catch (error) {\n        livekitLogger.error(\"error trying to re-publish tracks after reconnection\", {\n          error\n        });\n      }\n      try {\n        yield this.engine.waitForRestarted();\n        livekitLogger.debug(\"fully reconnected to server\", {\n          region: joinResponse.serverRegion\n        });\n      } catch (_g) {\n        return;\n      }\n      this.setAndEmitConnectionState(ConnectionState.Connected);\n      this.emit(RoomEvent.Reconnected);\n      this.registerConnectionReconcile();\n      this.participants.forEach((participant) => {\n        this.emit(RoomEvent.ParticipantConnected, participant);\n      });\n    });\n    this.handleParticipantUpdates = (participantInfos) => {\n      participantInfos.forEach((info) => {\n        if (info.identity === this.localParticipant.identity) {\n          this.localParticipant.updateInfo(info);\n          return;\n        }\n        const sid = this.identityToSid.get(info.identity);\n        if (sid && sid !== info.sid) {\n          this.handleParticipantDisconnected(sid, this.participants.get(sid));\n        }\n        let remoteParticipant = this.participants.get(info.sid);\n        const isNewParticipant = !remoteParticipant;\n        if (info.state === ParticipantInfo_State.DISCONNECTED) {\n          this.handleParticipantDisconnected(info.sid, remoteParticipant);\n        } else {\n          remoteParticipant = this.getOrCreateParticipant(info.sid, info);\n          if (!isNewParticipant) {\n            remoteParticipant.updateInfo(info);\n          }\n        }\n      });\n    };\n    this.handleActiveSpeakersUpdate = (speakers) => {\n      const activeSpeakers = [];\n      const seenSids = {};\n      speakers.forEach((speaker) => {\n        seenSids[speaker.sid] = true;\n        if (speaker.sid === this.localParticipant.sid) {\n          this.localParticipant.audioLevel = speaker.level;\n          this.localParticipant.setIsSpeaking(true);\n          activeSpeakers.push(this.localParticipant);\n        } else {\n          const p = this.participants.get(speaker.sid);\n          if (p) {\n            p.audioLevel = speaker.level;\n            p.setIsSpeaking(true);\n            activeSpeakers.push(p);\n          }\n        }\n      });\n      if (!seenSids[this.localParticipant.sid]) {\n        this.localParticipant.audioLevel = 0;\n        this.localParticipant.setIsSpeaking(false);\n      }\n      this.participants.forEach((p) => {\n        if (!seenSids[p.sid]) {\n          p.audioLevel = 0;\n          p.setIsSpeaking(false);\n        }\n      });\n      this.activeSpeakers = activeSpeakers;\n      this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);\n    };\n    this.handleSpeakersChanged = (speakerUpdates) => {\n      const lastSpeakers = /* @__PURE__ */ new Map();\n      this.activeSpeakers.forEach((p) => {\n        lastSpeakers.set(p.sid, p);\n      });\n      speakerUpdates.forEach((speaker) => {\n        let p = this.participants.get(speaker.sid);\n        if (speaker.sid === this.localParticipant.sid) {\n          p = this.localParticipant;\n        }\n        if (!p) {\n          return;\n        }\n        p.audioLevel = speaker.level;\n        p.setIsSpeaking(speaker.active);\n        if (speaker.active) {\n          lastSpeakers.set(speaker.sid, p);\n        } else {\n          lastSpeakers.delete(speaker.sid);\n        }\n      });\n      const activeSpeakers = Array.from(lastSpeakers.values());\n      activeSpeakers.sort((a, b) => b.audioLevel - a.audioLevel);\n      this.activeSpeakers = activeSpeakers;\n      this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);\n    };\n    this.handleStreamStateUpdate = (streamStateUpdate) => {\n      streamStateUpdate.streamStates.forEach((streamState) => {\n        const participant = this.participants.get(streamState.participantSid);\n        if (!participant) {\n          return;\n        }\n        const pub = participant.getTrackPublication(streamState.trackSid);\n        if (!pub || !pub.track) {\n          return;\n        }\n        pub.track.streamState = Track.streamStateFromProto(streamState.state);\n        participant.emit(ParticipantEvent.TrackStreamStateChanged, pub, pub.track.streamState);\n        this.emitWhenConnected(RoomEvent.TrackStreamStateChanged, pub, pub.track.streamState, participant);\n      });\n    };\n    this.handleSubscriptionPermissionUpdate = (update) => {\n      const participant = this.participants.get(update.participantSid);\n      if (!participant) {\n        return;\n      }\n      const pub = participant.getTrackPublication(update.trackSid);\n      if (!pub) {\n        return;\n      }\n      pub.setAllowed(update.allowed);\n    };\n    this.handleDataPacket = (userPacket, kind) => {\n      const participant = this.participants.get(userPacket.participantSid);\n      this.emit(RoomEvent.DataReceived, userPacket.payload, participant, kind, userPacket.topic);\n      participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.DataReceived, userPacket.payload, kind);\n    };\n    this.handleAudioPlaybackStarted = () => {\n      if (this.canPlaybackAudio) {\n        return;\n      }\n      this.audioEnabled = true;\n      this.emit(RoomEvent.AudioPlaybackStatusChanged, true);\n    };\n    this.handleAudioPlaybackFailed = (e) => {\n      livekitLogger.warn(\"could not playback audio\", e);\n      if (!this.canPlaybackAudio) {\n        return;\n      }\n      this.audioEnabled = false;\n      this.emit(RoomEvent.AudioPlaybackStatusChanged, false);\n    };\n    this.handleDeviceChange = () => __awaiter(this, void 0, void 0, function* () {\n      this.emit(RoomEvent.MediaDevicesChanged);\n    });\n    this.handleRoomUpdate = (room) => {\n      const oldRoom = this.roomInfo;\n      this.roomInfo = room;\n      if (oldRoom && oldRoom.metadata !== room.metadata) {\n        this.emitWhenConnected(RoomEvent.RoomMetadataChanged, room.metadata);\n      }\n      if ((oldRoom === null || oldRoom === void 0 ? void 0 : oldRoom.activeRecording) !== room.activeRecording) {\n        this.emitWhenConnected(RoomEvent.RecordingStatusChanged, room.activeRecording);\n      }\n    };\n    this.handleConnectionQualityUpdate = (update) => {\n      update.updates.forEach((info) => {\n        if (info.participantSid === this.localParticipant.sid) {\n          this.localParticipant.setConnectionQuality(info.quality);\n          return;\n        }\n        const participant = this.participants.get(info.participantSid);\n        if (participant) {\n          participant.setConnectionQuality(info.quality);\n        }\n      });\n    };\n    this.onLocalParticipantMetadataChanged = (metadata) => {\n      this.emit(RoomEvent.ParticipantMetadataChanged, metadata, this.localParticipant);\n    };\n    this.onLocalParticipantNameChanged = (name) => {\n      this.emit(RoomEvent.ParticipantNameChanged, name, this.localParticipant);\n    };\n    this.onLocalTrackMuted = (pub) => {\n      this.emit(RoomEvent.TrackMuted, pub, this.localParticipant);\n    };\n    this.onLocalTrackUnmuted = (pub) => {\n      this.emit(RoomEvent.TrackUnmuted, pub, this.localParticipant);\n    };\n    this.onLocalTrackPublished = (pub) => __awaiter(this, void 0, void 0, function* () {\n      this.emit(RoomEvent.LocalTrackPublished, pub, this.localParticipant);\n      if (pub.track instanceof LocalAudioTrack) {\n        const trackIsSilent = yield pub.track.checkForSilence();\n        if (trackIsSilent) {\n          this.emit(RoomEvent.LocalAudioSilenceDetected, pub);\n        }\n      }\n    });\n    this.onLocalTrackUnpublished = (pub) => {\n      this.emit(RoomEvent.LocalTrackUnpublished, pub, this.localParticipant);\n    };\n    this.onLocalConnectionQualityChanged = (quality) => {\n      this.emit(RoomEvent.ConnectionQualityChanged, quality, this.localParticipant);\n    };\n    this.onMediaDevicesError = (e) => {\n      this.emit(RoomEvent.MediaDevicesError, e);\n    };\n    this.onLocalParticipantPermissionsChanged = (prevPermissions) => {\n      this.emit(RoomEvent.ParticipantPermissionsChanged, prevPermissions, this.localParticipant);\n    };\n    this.setMaxListeners(100);\n    this.participants = /* @__PURE__ */ new Map();\n    this.cachedParticipantSids = [];\n    this.identityToSid = /* @__PURE__ */ new Map();\n    this.options = Object.assign(Object.assign({}, roomOptionDefaults), options);\n    this.options.audioCaptureDefaults = Object.assign(Object.assign({}, audioDefaults), options === null || options === void 0 ? void 0 : options.audioCaptureDefaults);\n    this.options.videoCaptureDefaults = Object.assign(Object.assign({}, videoDefaults), options === null || options === void 0 ? void 0 : options.videoCaptureDefaults);\n    this.options.publishDefaults = Object.assign(Object.assign({}, publishDefaults), options === null || options === void 0 ? void 0 : options.publishDefaults);\n    this.maybeCreateEngine();\n    this.disconnectLock = new Mutex();\n    this.localParticipant = new LocalParticipant(\"\", \"\", this.engine, this.options);\n  }\n  /**\n   * if the current room has a participant with `recorder: true` in its JWT grant\n   **/\n  get isRecording() {\n    var _a, _b;\n    return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.activeRecording) !== null && _b !== void 0 ? _b : false;\n  }\n  /** server assigned unique room id */\n  get sid() {\n    var _a, _b;\n    return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.sid) !== null && _b !== void 0 ? _b : \"\";\n  }\n  /** user assigned name, derived from JWT token */\n  get name() {\n    var _a, _b;\n    return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : \"\";\n  }\n  /** room metadata */\n  get metadata() {\n    var _a;\n    return (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.metadata;\n  }\n  get numParticipants() {\n    var _a, _b;\n    return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numParticipants) !== null && _b !== void 0 ? _b : 0;\n  }\n  get numPublishers() {\n    var _a, _b;\n    return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numPublishers) !== null && _b !== void 0 ? _b : 0;\n  }\n  maybeCreateEngine() {\n    if (this.engine && !this.engine.isClosed) {\n      return;\n    }\n    this.engine = new RTCEngine(this.options);\n    this.engine.client.onParticipantUpdate = this.handleParticipantUpdates;\n    this.engine.client.onRoomUpdate = this.handleRoomUpdate;\n    this.engine.client.onSpeakersChanged = this.handleSpeakersChanged;\n    this.engine.client.onStreamStateUpdate = this.handleStreamStateUpdate;\n    this.engine.client.onSubscriptionPermissionUpdate = this.handleSubscriptionPermissionUpdate;\n    this.engine.client.onConnectionQuality = this.handleConnectionQualityUpdate;\n    this.engine.on(EngineEvent.MediaTrackAdded, (mediaTrack, stream, receiver) => {\n      this.onTrackAdded(mediaTrack, stream, receiver);\n    }).on(EngineEvent.Disconnected, (reason) => {\n      this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, reason);\n    }).on(EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate).on(EngineEvent.DataPacketReceived, this.handleDataPacket).on(EngineEvent.Resuming, () => {\n      this.clearConnectionReconcile();\n      if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {\n        this.emit(RoomEvent.Reconnecting);\n      }\n      this.cachedParticipantSids = Array.from(this.participants.keys());\n    }).on(EngineEvent.Resumed, () => {\n      this.setAndEmitConnectionState(ConnectionState.Connected);\n      this.emit(RoomEvent.Reconnected);\n      this.registerConnectionReconcile();\n      this.updateSubscriptions();\n      const diffParticipants = Array.from(this.participants.values()).filter((p) => !this.cachedParticipantSids.includes(p.sid));\n      diffParticipants.forEach((p) => this.emit(RoomEvent.ParticipantConnected, p));\n      this.cachedParticipantSids = [];\n    }).on(EngineEvent.SignalResumed, () => {\n      if (this.state === ConnectionState.Reconnecting) {\n        this.sendSyncState();\n      }\n    }).on(EngineEvent.Restarting, this.handleRestarting).on(EngineEvent.SignalRestarted, this.handleSignalRestarted).on(EngineEvent.DCBufferStatusChanged, (status, kind) => {\n      this.emit(RoomEvent.DCBufferStatusChanged, status, kind);\n    });\n    if (this.localParticipant) {\n      this.localParticipant.setupEngine(this.engine);\n    }\n  }\n  /**\n   * getLocalDevices abstracts navigator.mediaDevices.enumerateDevices.\n   * In particular, it handles Chrome's unique behavior of creating `default`\n   * devices. When encountered, it'll be removed from the list of devices.\n   * The actual default device will be placed at top.\n   * @param kind\n   * @returns a list of available local devices\n   */\n  static getLocalDevices(kind) {\n    let requestPermissions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n    return DeviceManager.getInstance().getDevices(kind, requestPermissions);\n  }\n  /**\n   * prepares the connection to the livekit server by sending a HEAD request in order to\n   * 1. speed up DNS resolution\n   * 2. speed up TLS setup\n   * on the actual connection request\n   * throws an error if server is not reachable after the request timeout\n   * @experimental\n   */\n  prepareConnection(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield fetch(\"http\".concat(url.substring(2)), {\n        method: \"HEAD\"\n      });\n    });\n  }\n  /**\n   * retrieves a participant by identity\n   * @param identity\n   * @returns\n   */\n  getParticipantByIdentity(identity) {\n    if (this.localParticipant.identity === identity) {\n      return this.localParticipant;\n    }\n    const sid = this.identityToSid.get(identity);\n    if (sid) {\n      return this.participants.get(sid);\n    }\n  }\n  clearConnectionFutures() {\n    this.connectFuture = void 0;\n  }\n  /**\n   * @internal for testing\n   */\n  simulateScenario(scenario) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let postAction = () => {\n      };\n      let req;\n      switch (scenario) {\n        case \"signal-reconnect\":\n          yield this.engine.client.close();\n          if (this.engine.client.onClose) {\n            this.engine.client.onClose(\"simulate disconnect\");\n          }\n          break;\n        case \"speaker\":\n          req = SimulateScenario.fromPartial({\n            scenario: {\n              $case: \"speakerUpdate\",\n              speakerUpdate: 3\n            }\n          });\n          break;\n        case \"node-failure\":\n          req = SimulateScenario.fromPartial({\n            scenario: {\n              $case: \"nodeFailure\",\n              nodeFailure: true\n            }\n          });\n          break;\n        case \"server-leave\":\n          req = SimulateScenario.fromPartial({\n            scenario: {\n              $case: \"serverLeave\",\n              serverLeave: true\n            }\n          });\n          break;\n        case \"migration\":\n          req = SimulateScenario.fromPartial({\n            scenario: {\n              $case: \"migration\",\n              migration: true\n            }\n          });\n          break;\n        case \"resume-reconnect\":\n          this.engine.failNext();\n          yield this.engine.client.close();\n          if (this.engine.client.onClose) {\n            this.engine.client.onClose(\"simulate resume-reconnect\");\n          }\n          break;\n        case \"full-reconnect\":\n          this.engine.fullReconnectOnNext = true;\n          yield this.engine.client.close();\n          if (this.engine.client.onClose) {\n            this.engine.client.onClose(\"simulate full-reconnect\");\n          }\n          break;\n        case \"force-tcp\":\n        case \"force-tls\":\n          req = SimulateScenario.fromPartial({\n            scenario: {\n              $case: \"switchCandidateProtocol\",\n              switchCandidateProtocol: scenario === \"force-tls\" ? 2 : 1\n            }\n          });\n          postAction = () => __awaiter(this, void 0, void 0, function* () {\n            const onLeave = this.engine.client.onLeave;\n            if (onLeave) {\n              onLeave({\n                reason: DisconnectReason.CLIENT_INITIATED,\n                canReconnect: true\n              });\n            }\n          });\n          break;\n      }\n      if (req) {\n        this.engine.client.sendSimulateScenario(req);\n        postAction();\n      }\n    });\n  }\n  /**\n   * Browsers have different policies regarding audio playback. Most requiring\n   * some form of user interaction (click/tap/etc).\n   * In those cases, audio will be silent until a click/tap triggering one of the following\n   * - `startAudio`\n   * - `getUserMedia`\n   */\n  startAudio() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.acquireAudioContext();\n      const elements = [];\n      this.participants.forEach((p) => {\n        p.audioTracks.forEach((t) => {\n          if (t.track) {\n            t.track.attachedElements.forEach((e) => {\n              elements.push(e);\n            });\n          }\n        });\n      });\n      try {\n        yield Promise.all(elements.map((e) => {\n          e.muted = false;\n          return e.play();\n        }));\n        this.handleAudioPlaybackStarted();\n      } catch (err) {\n        this.handleAudioPlaybackFailed(err);\n        throw err;\n      }\n    });\n  }\n  /**\n   * Returns true if audio playback is enabled\n   */\n  get canPlaybackAudio() {\n    return this.audioEnabled;\n  }\n  /**\n   * Returns the active audio output device used in this room.\n   *\n   * Note: to get the active `audioinput` or `videoinput` use [[LocalTrack.getDeviceId()]]\n   *\n   * @return the previously successfully set audio output device ID or an empty string if the default device is used.\n   */\n  getActiveAudioOutputDevice() {\n    var _a, _b;\n    return (_b = (_a = this.options.audioOutput) === null || _a === void 0 ? void 0 : _a.deviceId) !== null && _b !== void 0 ? _b : \"\";\n  }\n  /**\n   * Switches all active devices used in this room to the given device.\n   *\n   * Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility)\n   *\n   * @param kind use `videoinput` for camera track,\n   *  `audioinput` for microphone track,\n   *  `audiooutput` to set speaker for all incoming audio tracks\n   * @param deviceId\n   */\n  switchActiveDevice(kind, deviceId) {\n    let exact = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    var _a;\n    var _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const deviceConstraint = exact ? {\n        exact: deviceId\n      } : deviceId;\n      if (kind === \"audioinput\") {\n        const prevDeviceId = this.options.audioCaptureDefaults.deviceId;\n        this.options.audioCaptureDefaults.deviceId = deviceConstraint;\n        const tracks = Array.from(this.localParticipant.audioTracks.values()).filter((track) => track.source === Track.Source.Microphone);\n        try {\n          yield Promise.all(tracks.map((t) => {\n            var _a2;\n            return (_a2 = t.audioTrack) === null || _a2 === void 0 ? void 0 : _a2.setDeviceId(deviceConstraint);\n          }));\n        } catch (e) {\n          this.options.audioCaptureDefaults.deviceId = prevDeviceId;\n          throw e;\n        }\n      } else if (kind === \"videoinput\") {\n        const prevDeviceId = this.options.videoCaptureDefaults.deviceId;\n        this.options.videoCaptureDefaults.deviceId = deviceConstraint;\n        const tracks = Array.from(this.localParticipant.videoTracks.values()).filter((track) => track.source === Track.Source.Camera);\n        try {\n          yield Promise.all(tracks.map((t) => {\n            var _a2;\n            return (_a2 = t.videoTrack) === null || _a2 === void 0 ? void 0 : _a2.setDeviceId(deviceConstraint);\n          }));\n        } catch (e) {\n          this.options.videoCaptureDefaults.deviceId = prevDeviceId;\n          throw e;\n        }\n      } else if (kind === \"audiooutput\") {\n        if (!supportsSetSinkId()) {\n          throw new Error(\"cannot switch audio output, setSinkId not supported\");\n        }\n        (_a = (_b = this.options).audioOutput) !== null && _a !== void 0 ? _a : _b.audioOutput = {};\n        const prevDeviceId = this.options.audioOutput.deviceId;\n        this.options.audioOutput.deviceId = deviceId;\n        try {\n          yield Promise.all(Array.from(this.participants.values()).map((p) => p.setAudioOutput({\n            deviceId\n          })));\n        } catch (e) {\n          this.options.audioOutput.deviceId = prevDeviceId;\n          throw e;\n        }\n      }\n    });\n  }\n  setupLocalParticipantEvents() {\n    this.localParticipant.on(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).on(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).on(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).on(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).on(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).on(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).on(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).on(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).on(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);\n  }\n  recreateEngine() {\n    var _a;\n    (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();\n    this.engine = void 0;\n    this.participants.clear();\n    this.maybeCreateEngine();\n  }\n  onTrackAdded(mediaTrack, stream, receiver) {\n    if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {\n      const reconnectedHandler = () => {\n        this.onTrackAdded(mediaTrack, stream, receiver);\n        cleanup();\n      };\n      const cleanup = () => {\n        this.off(RoomEvent.Reconnected, reconnectedHandler);\n        this.off(RoomEvent.Connected, reconnectedHandler);\n        this.off(RoomEvent.Disconnected, cleanup);\n      };\n      this.once(RoomEvent.Reconnected, reconnectedHandler);\n      this.once(RoomEvent.Connected, reconnectedHandler);\n      this.once(RoomEvent.Disconnected, cleanup);\n      return;\n    }\n    if (this.state === ConnectionState.Disconnected) {\n      livekitLogger.warn(\"skipping incoming track after Room disconnected\");\n      return;\n    }\n    const parts = unpackStreamId(stream.id);\n    const participantId = parts[0];\n    let trackId = parts[1];\n    if (!trackId || trackId === \"\")\n      trackId = mediaTrack.id;\n    if (participantId === this.localParticipant.sid) {\n      livekitLogger.warn(\"tried to create RemoteParticipant for local participant\");\n      return;\n    }\n    const participant = this.getOrCreateParticipant(participantId);\n    let adaptiveStreamSettings;\n    if (this.options.adaptiveStream) {\n      if (typeof this.options.adaptiveStream === \"object\") {\n        adaptiveStreamSettings = this.options.adaptiveStream;\n      } else {\n        adaptiveStreamSettings = {};\n      }\n    }\n    participant.addSubscribedMediaTrack(mediaTrack, trackId, stream, receiver, adaptiveStreamSettings);\n  }\n  handleDisconnect() {\n    let shouldStopTracks = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n    let reason = arguments.length > 1 ? arguments[1] : void 0;\n    var _a;\n    this.clearConnectionReconcile();\n    if (this.state === ConnectionState.Disconnected) {\n      return;\n    }\n    try {\n      this.participants.forEach((p) => {\n        p.tracks.forEach((pub) => {\n          p.unpublishTrack(pub.trackSid);\n        });\n      });\n      this.localParticipant.tracks.forEach((pub) => {\n        var _a2, _b;\n        if (pub.track) {\n          this.localParticipant.unpublishTrack(pub.track, shouldStopTracks);\n        }\n        if (shouldStopTracks) {\n          (_a2 = pub.track) === null || _a2 === void 0 ? void 0 : _a2.detach();\n          (_b = pub.track) === null || _b === void 0 ? void 0 : _b.stop();\n        }\n      });\n      this.localParticipant.off(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).off(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).off(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).off(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).off(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).off(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).off(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).off(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).off(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);\n      this.localParticipant.tracks.clear();\n      this.localParticipant.videoTracks.clear();\n      this.localParticipant.audioTracks.clear();\n      this.participants.clear();\n      this.activeSpeakers = [];\n      if (this.audioContext && typeof this.options.expWebAudioMix === \"boolean\") {\n        this.audioContext.close();\n        this.audioContext = void 0;\n      }\n      if (isWeb()) {\n        window.removeEventListener(\"beforeunload\", this.onPageLeave);\n        window.removeEventListener(\"pagehide\", this.onPageLeave);\n        (_a = navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.removeEventListener(\"devicechange\", this.handleDeviceChange);\n      }\n    } finally {\n      this.setAndEmitConnectionState(ConnectionState.Disconnected);\n      this.emit(RoomEvent.Disconnected, reason);\n    }\n  }\n  handleParticipantDisconnected(sid, participant) {\n    this.participants.delete(sid);\n    if (!participant) {\n      return;\n    }\n    this.identityToSid.delete(participant.identity);\n    participant.tracks.forEach((publication) => {\n      participant.unpublishTrack(publication.trackSid, true);\n    });\n    this.emit(RoomEvent.ParticipantDisconnected, participant);\n  }\n  acquireAudioContext() {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (typeof this.options.expWebAudioMix !== \"boolean\" && this.options.expWebAudioMix.audioContext) {\n        this.audioContext = this.options.expWebAudioMix.audioContext;\n        yield this.audioContext.resume();\n      } else {\n        this.audioContext = (_a = getNewAudioContext()) !== null && _a !== void 0 ? _a : void 0;\n      }\n      if (this.options.expWebAudioMix) {\n        this.participants.forEach((participant) => participant.setAudioContext(this.audioContext));\n      }\n      const newContextIsRunning = ((_b = this.audioContext) === null || _b === void 0 ? void 0 : _b.state) === \"running\";\n      if (newContextIsRunning !== this.canPlaybackAudio) {\n        this.audioEnabled = newContextIsRunning;\n        this.emit(RoomEvent.AudioPlaybackStatusChanged, newContextIsRunning);\n      }\n    });\n  }\n  createParticipant(id, info) {\n    let participant;\n    if (info) {\n      participant = RemoteParticipant.fromParticipantInfo(this.engine.client, info);\n    } else {\n      participant = new RemoteParticipant(this.engine.client, id, \"\", void 0, void 0);\n    }\n    if (this.options.expWebAudioMix) {\n      participant.setAudioContext(this.audioContext);\n    }\n    return participant;\n  }\n  getOrCreateParticipant(id, info) {\n    if (this.participants.has(id)) {\n      return this.participants.get(id);\n    }\n    const participant = this.createParticipant(id, info);\n    this.participants.set(id, participant);\n    if (info) {\n      this.identityToSid.set(info.identity, info.sid);\n      this.emitWhenConnected(RoomEvent.ParticipantConnected, participant);\n    }\n    participant.on(ParticipantEvent.TrackPublished, (trackPublication) => {\n      this.emitWhenConnected(RoomEvent.TrackPublished, trackPublication, participant);\n    }).on(ParticipantEvent.TrackSubscribed, (track, publication) => {\n      if (track.kind === Track.Kind.Audio) {\n        track.on(TrackEvent.AudioPlaybackStarted, this.handleAudioPlaybackStarted);\n        track.on(TrackEvent.AudioPlaybackFailed, this.handleAudioPlaybackFailed);\n      }\n      this.emit(RoomEvent.TrackSubscribed, track, publication, participant);\n    }).on(ParticipantEvent.TrackUnpublished, (publication) => {\n      this.emit(RoomEvent.TrackUnpublished, publication, participant);\n    }).on(ParticipantEvent.TrackUnsubscribed, (track, publication) => {\n      this.emit(RoomEvent.TrackUnsubscribed, track, publication, participant);\n    }).on(ParticipantEvent.TrackSubscriptionFailed, (sid) => {\n      this.emit(RoomEvent.TrackSubscriptionFailed, sid, participant);\n    }).on(ParticipantEvent.TrackMuted, (pub) => {\n      this.emitWhenConnected(RoomEvent.TrackMuted, pub, participant);\n    }).on(ParticipantEvent.TrackUnmuted, (pub) => {\n      this.emitWhenConnected(RoomEvent.TrackUnmuted, pub, participant);\n    }).on(ParticipantEvent.ParticipantMetadataChanged, (metadata) => {\n      this.emitWhenConnected(RoomEvent.ParticipantMetadataChanged, metadata, participant);\n    }).on(ParticipantEvent.ParticipantNameChanged, (name) => {\n      this.emitWhenConnected(RoomEvent.ParticipantNameChanged, name, participant);\n    }).on(ParticipantEvent.ConnectionQualityChanged, (quality) => {\n      this.emitWhenConnected(RoomEvent.ConnectionQualityChanged, quality, participant);\n    }).on(ParticipantEvent.ParticipantPermissionsChanged, (prevPermissions) => {\n      this.emitWhenConnected(RoomEvent.ParticipantPermissionsChanged, prevPermissions, participant);\n    }).on(ParticipantEvent.TrackSubscriptionStatusChanged, (pub, status) => {\n      this.emitWhenConnected(RoomEvent.TrackSubscriptionStatusChanged, pub, status, participant);\n    }).on(ParticipantEvent.TrackSubscriptionPermissionChanged, (pub, status) => {\n      this.emitWhenConnected(RoomEvent.TrackSubscriptionPermissionChanged, pub, status, participant);\n    });\n    if (info) {\n      participant.updateInfo(info);\n    }\n    return participant;\n  }\n  sendSyncState() {\n    var _a, _b;\n    if (this.engine.subscriber === void 0 || this.engine.subscriber.pc.localDescription === null) {\n      return;\n    }\n    const previousAnswer = this.engine.subscriber.pc.localDescription;\n    const previousOffer = this.engine.subscriber.pc.remoteDescription;\n    const autoSubscribe = (_b = (_a = this.connOptions) === null || _a === void 0 ? void 0 : _a.autoSubscribe) !== null && _b !== void 0 ? _b : true;\n    const trackSids = new Array();\n    this.participants.forEach((participant) => {\n      participant.tracks.forEach((track) => {\n        if (track.isDesired !== autoSubscribe) {\n          trackSids.push(track.trackSid);\n        }\n      });\n    });\n    this.engine.client.sendSyncState({\n      answer: toProtoSessionDescription({\n        sdp: previousAnswer.sdp,\n        type: previousAnswer.type\n      }),\n      offer: previousOffer ? toProtoSessionDescription({\n        sdp: previousOffer.sdp,\n        type: previousOffer.type\n      }) : void 0,\n      subscription: {\n        trackSids,\n        subscribe: !autoSubscribe,\n        participantTracks: []\n      },\n      publishTracks: this.localParticipant.publishedTracksInfo(),\n      dataChannels: this.localParticipant.dataChannelsInfo()\n    });\n  }\n  /**\n   * After resuming, we'll need to notify the server of the current\n   * subscription settings.\n   */\n  updateSubscriptions() {\n    for (const p of this.participants.values()) {\n      for (const pub of p.videoTracks.values()) {\n        if (pub.isSubscribed && pub instanceof RemoteTrackPublication) {\n          pub.emitTrackUpdate();\n        }\n      }\n    }\n  }\n  registerConnectionReconcile() {\n    this.clearConnectionReconcile();\n    let consecutiveFailures = 0;\n    this.connectionReconcileInterval = CriticalTimers.setInterval(() => {\n      if (\n        // ensure we didn't tear it down\n        !this.engine || // engine detected close, but Room missed it\n        this.engine.isClosed || // transports failed without notifying engine\n        !this.engine.verifyTransport()\n      ) {\n        consecutiveFailures++;\n        livekitLogger.warn(\"detected connection state mismatch\", {\n          numFailures: consecutiveFailures\n        });\n        if (consecutiveFailures >= 3)\n          this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, DisconnectReason.UNKNOWN_REASON);\n      } else {\n        consecutiveFailures = 0;\n      }\n    }, connectionReconcileFrequency);\n  }\n  clearConnectionReconcile() {\n    if (this.connectionReconcileInterval) {\n      CriticalTimers.clearInterval(this.connectionReconcileInterval);\n    }\n  }\n  setAndEmitConnectionState(state) {\n    if (state === this.state) {\n      return false;\n    }\n    this.state = state;\n    this.emit(RoomEvent.ConnectionStateChanged, this.state);\n    return true;\n  }\n  emitWhenConnected(event) {\n    if (this.state === ConnectionState.Connected) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      return this.emit(event, ...args);\n    }\n    return false;\n  }\n  /**\n   * Allows to populate a room with simulated participants.\n   * No actual connection to a server will be established, all state is\n   * @experimental\n   */\n  simulateParticipants(options) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const publishOptions = Object.assign({\n        audio: true,\n        video: true,\n        useRealTracks: false\n      }, options.publish);\n      const participantOptions = Object.assign({\n        count: 9,\n        audio: false,\n        video: true,\n        aspectRatios: [1.66, 1.7, 1.3]\n      }, options.participants);\n      this.handleDisconnect();\n      this.roomInfo = {\n        sid: \"RM_SIMULATED\",\n        name: \"simulated-room\",\n        emptyTimeout: 0,\n        maxParticipants: 0,\n        creationTime: (/* @__PURE__ */ new Date()).getTime(),\n        metadata: \"\",\n        numParticipants: 1,\n        numPublishers: 1,\n        turnPassword: \"\",\n        enabledCodecs: [],\n        activeRecording: false\n      };\n      this.localParticipant.updateInfo(ParticipantInfo.fromPartial({\n        identity: \"simulated-local\",\n        name: \"local-name\"\n      }));\n      this.setupLocalParticipantEvents();\n      this.emit(RoomEvent.SignalConnected);\n      this.emit(RoomEvent.Connected);\n      this.setAndEmitConnectionState(ConnectionState.Connected);\n      if (publishOptions.video) {\n        const camPub = new LocalTrackPublication(Track.Kind.Video, TrackInfo.fromPartial({\n          source: TrackSource.CAMERA,\n          sid: Math.floor(Math.random() * 1e4).toString(),\n          type: TrackType.AUDIO,\n          name: \"video-dummy\"\n        }), new LocalVideoTrack(publishOptions.useRealTracks ? (yield navigator.mediaDevices.getUserMedia({\n          video: true\n        })).getVideoTracks()[0] : createDummyVideoStreamTrack((_a = 160 * participantOptions.aspectRatios[0]) !== null && _a !== void 0 ? _a : 1, 160, true, true)));\n        this.localParticipant.addTrackPublication(camPub);\n        this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, camPub);\n      }\n      if (publishOptions.audio) {\n        const audioPub = new LocalTrackPublication(Track.Kind.Audio, TrackInfo.fromPartial({\n          source: TrackSource.MICROPHONE,\n          sid: Math.floor(Math.random() * 1e4).toString(),\n          type: TrackType.AUDIO\n        }), new LocalAudioTrack(publishOptions.useRealTracks ? (yield navigator.mediaDevices.getUserMedia({\n          audio: true\n        })).getAudioTracks()[0] : getEmptyAudioStreamTrack()));\n        this.localParticipant.addTrackPublication(audioPub);\n        this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, audioPub);\n      }\n      for (let i = 0; i < participantOptions.count - 1; i += 1) {\n        let info = ParticipantInfo.fromPartial({\n          sid: Math.floor(Math.random() * 1e4).toString(),\n          identity: \"simulated-\".concat(i),\n          state: ParticipantInfo_State.ACTIVE,\n          tracks: [],\n          joinedAt: Date.now()\n        });\n        const p = this.getOrCreateParticipant(info.identity, info);\n        if (participantOptions.video) {\n          const dummyVideo = createDummyVideoStreamTrack((_b = 160 * participantOptions.aspectRatios[i % participantOptions.aspectRatios.length]) !== null && _b !== void 0 ? _b : 1, 160, false, true);\n          const videoTrack = TrackInfo.fromPartial({\n            source: TrackSource.CAMERA,\n            sid: Math.floor(Math.random() * 1e4).toString(),\n            type: TrackType.AUDIO\n          });\n          p.addSubscribedMediaTrack(dummyVideo, videoTrack.sid, new MediaStream([dummyVideo]));\n          info.tracks = [...info.tracks, videoTrack];\n        }\n        if (participantOptions.audio) {\n          const dummyTrack = getEmptyAudioStreamTrack();\n          const audioTrack = TrackInfo.fromPartial({\n            source: TrackSource.MICROPHONE,\n            sid: Math.floor(Math.random() * 1e4).toString(),\n            type: TrackType.AUDIO\n          });\n          p.addSubscribedMediaTrack(dummyTrack, audioTrack.sid, new MediaStream([dummyTrack]));\n          info.tracks = [...info.tracks, audioTrack];\n        }\n        p.updateInfo(info);\n      }\n    });\n  }\n  // /** @internal */\n  emit(event) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    if (event !== RoomEvent.ActiveSpeakersChanged) {\n      livekitLogger.debug(\"room event \".concat(event), {\n        event,\n        args\n      });\n    }\n    return super.emit(event, ...args);\n  }\n};\nvar CheckStatus;\n(function(CheckStatus2) {\n  CheckStatus2[CheckStatus2[\"IDLE\"] = 0] = \"IDLE\";\n  CheckStatus2[CheckStatus2[\"RUNNING\"] = 1] = \"RUNNING\";\n  CheckStatus2[CheckStatus2[\"SKIPPED\"] = 2] = \"SKIPPED\";\n  CheckStatus2[CheckStatus2[\"SUCCESS\"] = 3] = \"SUCCESS\";\n  CheckStatus2[CheckStatus2[\"FAILED\"] = 4] = \"FAILED\";\n})(CheckStatus || (CheckStatus = {}));\nvar Checker = class extends eventsExports.EventEmitter {\n  constructor(url, token) {\n    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    super();\n    this.status = CheckStatus.IDLE;\n    this.logs = [];\n    this.errorsAsWarnings = false;\n    this.url = url;\n    this.token = token;\n    this.name = this.constructor.name;\n    this.room = new Room(options.roomOptions);\n    this.connectOptions = options.connectOptions;\n    if (options.errorsAsWarnings) {\n      this.errorsAsWarnings = options.errorsAsWarnings;\n    }\n  }\n  run(onComplete) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.status !== CheckStatus.IDLE) {\n        throw Error(\"check is running already\");\n      }\n      this.setStatus(CheckStatus.RUNNING);\n      this.appendMessage(\"\".concat(this.name, \" started.\"));\n      try {\n        yield this.perform();\n      } catch (err) {\n        if (err instanceof Error) {\n          if (this.errorsAsWarnings) {\n            this.appendWarning(err.message);\n          } else {\n            this.appendError(err.message);\n          }\n        }\n      }\n      yield this.disconnect();\n      yield new Promise((resolve) => setTimeout(resolve, 500));\n      if (this.status !== CheckStatus.SKIPPED) {\n        this.setStatus(this.isSuccess() ? CheckStatus.SUCCESS : CheckStatus.FAILED);\n      }\n      if (onComplete) {\n        onComplete();\n      }\n      return this.getInfo();\n    });\n  }\n  isSuccess() {\n    return !this.logs.some((l) => l.level === \"error\");\n  }\n  connect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.room.state === ConnectionState.Connected) {\n        return this.room;\n      }\n      yield this.room.connect(this.url, this.token);\n      return this.room;\n    });\n  }\n  disconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.room && this.room.state !== ConnectionState.Disconnected) {\n        yield this.room.disconnect();\n        yield new Promise((resolve) => setTimeout(resolve, 500));\n      }\n    });\n  }\n  skip() {\n    this.setStatus(CheckStatus.SKIPPED);\n  }\n  appendMessage(message) {\n    this.logs.push({\n      level: \"info\",\n      message\n    });\n    this.emit(\"update\", this.getInfo());\n  }\n  appendWarning(message) {\n    this.logs.push({\n      level: \"warning\",\n      message\n    });\n    this.emit(\"update\", this.getInfo());\n  }\n  appendError(message) {\n    this.logs.push({\n      level: \"error\",\n      message\n    });\n    this.emit(\"update\", this.getInfo());\n  }\n  setStatus(status) {\n    this.status = status;\n    this.emit(\"update\", this.getInfo());\n  }\n  get engine() {\n    var _a;\n    return (_a = this.room) === null || _a === void 0 ? void 0 : _a.engine;\n  }\n  getInfo() {\n    return {\n      logs: this.logs,\n      name: this.name,\n      status: this.status,\n      description: this.description\n    };\n  }\n};\nfunction createLocalTracks(options) {\n  var _a, _b;\n  return __awaiter(this, void 0, void 0, function* () {\n    options !== null && options !== void 0 ? options : options = {};\n    (_a = options.audio) !== null && _a !== void 0 ? _a : options.audio = true;\n    (_b = options.video) !== null && _b !== void 0 ? _b : options.video = true;\n    const opts = mergeDefaultOptions(options, audioDefaults, videoDefaults);\n    const constraints = constraintsForOptions(opts);\n    const mediaPromise = navigator.mediaDevices.getUserMedia(constraints);\n    if (options.audio) {\n      DeviceManager.userMediaPromiseMap.set(\"audioinput\", mediaPromise);\n      mediaPromise.catch(() => DeviceManager.userMediaPromiseMap.delete(\"audioinput\"));\n    }\n    if (options.video) {\n      DeviceManager.userMediaPromiseMap.set(\"videoinput\", mediaPromise);\n      mediaPromise.catch(() => DeviceManager.userMediaPromiseMap.delete(\"videoinput\"));\n    }\n    const stream = yield mediaPromise;\n    return stream.getTracks().map((mediaStreamTrack) => {\n      const isAudio = mediaStreamTrack.kind === \"audio\";\n      isAudio ? options.audio : options.video;\n      let trackConstraints;\n      const conOrBool = isAudio ? constraints.audio : constraints.video;\n      if (typeof conOrBool !== \"boolean\") {\n        trackConstraints = conOrBool;\n      }\n      const track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints);\n      if (track.kind === Track.Kind.Video) {\n        track.source = Track.Source.Camera;\n      } else if (track.kind === Track.Kind.Audio) {\n        track.source = Track.Source.Microphone;\n      }\n      track.mediaStream = stream;\n      return track;\n    });\n  });\n}\nfunction createLocalVideoTrack(options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const tracks = yield createLocalTracks({\n      audio: false,\n      video: options\n    });\n    return tracks[0];\n  });\n}\nfunction createLocalAudioTrack(options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const tracks = yield createLocalTracks({\n      audio: options,\n      video: false\n    });\n    return tracks[0];\n  });\n}\nfunction createLocalScreenTracks(options) {\n  var _a;\n  return __awaiter(this, void 0, void 0, function* () {\n    if (options === void 0) {\n      options = {};\n    }\n    if (options.resolution === void 0) {\n      options.resolution = VideoPresets.h1080.resolution;\n    }\n    let videoConstraints = true;\n    if (options.resolution) {\n      videoConstraints = {\n        width: options.resolution.width,\n        height: options.resolution.height\n      };\n    }\n    if (navigator.mediaDevices.getDisplayMedia === void 0) {\n      throw new DeviceUnsupportedError(\"getDisplayMedia not supported\");\n    }\n    const stream = yield navigator.mediaDevices.getDisplayMedia({\n      audio: (_a = options.audio) !== null && _a !== void 0 ? _a : false,\n      video: videoConstraints\n    });\n    const tracks = stream.getVideoTracks();\n    if (tracks.length === 0) {\n      throw new TrackInvalidError(\"no video track found\");\n    }\n    const screenVideo = new LocalVideoTrack(tracks[0], void 0, false);\n    screenVideo.source = Track.Source.ScreenShare;\n    const localTracks = [screenVideo];\n    if (stream.getAudioTracks().length > 0) {\n      const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], void 0, false);\n      screenAudio.source = Track.Source.ScreenShareAudio;\n      localTracks.push(screenAudio);\n    }\n    return localTracks;\n  });\n}\nvar PublishAudioCheck = class extends Checker {\n  get description() {\n    return \"Can publish audio\";\n  }\n  perform() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const room = yield this.connect();\n      const track = yield createLocalAudioTrack();\n      room.localParticipant.publishTrack(track);\n      yield new Promise((resolve) => setTimeout(resolve, 3e3));\n      const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();\n      if (!stats) {\n        throw new Error(\"Could not get RTCStats\");\n      }\n      let numPackets = 0;\n      stats.forEach((stat) => {\n        if (stat.type === \"outbound-rtp\" && stat.mediaType === \"audio\") {\n          numPackets = stat.packetsSent;\n        }\n      });\n      if (numPackets === 0) {\n        throw new Error(\"Could not determine packets are sent\");\n      }\n      this.appendMessage(\"published \".concat(numPackets, \" audio packets\"));\n    });\n  }\n};\nvar PublishVideoCheck = class extends Checker {\n  get description() {\n    return \"Can publish video\";\n  }\n  perform() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const room = yield this.connect();\n      const track = yield createLocalVideoTrack();\n      room.localParticipant.publishTrack(track);\n      yield new Promise((resolve) => setTimeout(resolve, 3e3));\n      const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();\n      if (!stats) {\n        throw new Error(\"Could not get RTCStats\");\n      }\n      let numPackets = 0;\n      stats.forEach((stat) => {\n        if (stat.type === \"outbound-rtp\" && stat.mediaType === \"video\") {\n          numPackets = stat.packetsSent;\n        }\n      });\n      if (numPackets === 0) {\n        throw new Error(\"Could not determine packets are sent\");\n      }\n      this.appendMessage(\"published \".concat(numPackets, \" video packets\"));\n    });\n  }\n};\nvar ReconnectCheck = class extends Checker {\n  get description() {\n    return \"Resuming connection after interruption\";\n  }\n  perform() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const room = yield this.connect();\n      let reconnectingTriggered = false;\n      let reconnected = false;\n      let reconnectResolver;\n      const reconnectTimeout = new Promise((resolve) => {\n        setTimeout(resolve, 5e3);\n        reconnectResolver = resolve;\n      });\n      room.on(RoomEvent.Reconnecting, () => {\n        reconnectingTriggered = true;\n      }).on(RoomEvent.Reconnected, () => {\n        reconnected = true;\n        reconnectResolver(true);\n      });\n      (_a = room.engine.client.ws) === null || _a === void 0 ? void 0 : _a.close();\n      const onClose = room.engine.client.onClose;\n      if (onClose) {\n        onClose(\"\");\n      }\n      yield reconnectTimeout;\n      if (!reconnectingTriggered) {\n        throw new Error(\"Did not attempt to reconnect\");\n      } else if (!reconnected || room.state !== ConnectionState.Connected) {\n        this.appendWarning(\"reconnection is only possible in Redis-based configurations\");\n        throw new Error(\"Not able to reconnect\");\n      }\n    });\n  }\n};\nvar TURNCheck = class extends Checker {\n  get description() {\n    return \"Can connect via TURN\";\n  }\n  perform() {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const signalClient = new SignalClient();\n      const joinRes = yield signalClient.join(this.url, this.token, {\n        autoSubscribe: true,\n        maxRetries: 0\n      });\n      let hasTLS = false;\n      let hasTURN = false;\n      let hasSTUN = false;\n      for (let iceServer of joinRes.iceServers) {\n        for (let url of iceServer.urls) {\n          if (url.startsWith(\"turn:\")) {\n            hasTURN = true;\n            hasSTUN = true;\n          } else if (url.startsWith(\"turns:\")) {\n            hasTURN = true;\n            hasSTUN = true;\n            hasTLS = true;\n          }\n          if (url.startsWith(\"stun:\")) {\n            hasSTUN = true;\n          }\n        }\n      }\n      if (!hasSTUN) {\n        this.appendWarning(\"No STUN servers configured on server side.\");\n      } else if (hasTURN && !hasTLS) {\n        this.appendWarning(\"TURN is configured server side, but TURN/TLS is unavailable.\");\n      }\n      yield signalClient.close();\n      if (((_b = (_a = this.connectOptions) === null || _a === void 0 ? void 0 : _a.rtcConfig) === null || _b === void 0 ? void 0 : _b.iceServers) || hasTURN) {\n        yield this.room.connect(this.url, this.token, {\n          rtcConfig: {\n            iceTransportPolicy: \"relay\"\n          }\n        });\n      } else {\n        this.appendWarning(\"No TURN servers configured.\");\n        this.skip();\n        yield new Promise((resolve) => setTimeout(resolve, 0));\n      }\n    });\n  }\n};\nvar WebRTCCheck = class extends Checker {\n  get description() {\n    return \"Establishing WebRTC connection\";\n  }\n  perform() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        console.log(\"initiating room connection\");\n        this.room = yield this.connect();\n        console.log(\"now the room is connected\");\n      } catch (err) {\n        this.appendWarning(\"ports need to be open on firewall in order to connect.\");\n        throw err;\n      }\n    });\n  }\n};\nvar WebSocketCheck = class extends Checker {\n  get description() {\n    return \"Connecting to signal connection via WebSocket\";\n  }\n  perform() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.url.startsWith(\"ws:\") || this.url.startsWith(\"http:\")) {\n        this.appendWarning(\"Server is insecure, clients may block connections to it\");\n      }\n      let signalClient = new SignalClient();\n      const joinRes = yield signalClient.join(this.url, this.token, {\n        autoSubscribe: true,\n        maxRetries: 0\n      });\n      this.appendMessage(\"Connected to server, version \".concat(joinRes.serverVersion, \".\"));\n      yield signalClient.close();\n    });\n  }\n};\nvar ConnectionCheck = class extends eventsExports.EventEmitter {\n  constructor(url, token) {\n    super();\n    this.checkResults = /* @__PURE__ */ new Map();\n    this.url = url;\n    this.token = token;\n  }\n  getNextCheckId() {\n    const nextId = this.checkResults.size;\n    this.checkResults.set(nextId, {\n      logs: [],\n      status: CheckStatus.IDLE,\n      name: \"\",\n      description: \"\"\n    });\n    return nextId;\n  }\n  updateCheck(checkId, info) {\n    this.checkResults.set(checkId, info);\n    this.emit(\"checkUpdate\", checkId, info);\n  }\n  isSuccess() {\n    return Array.from(this.checkResults.values()).every((r2) => r2.status !== CheckStatus.FAILED);\n  }\n  getResults() {\n    return Array.from(this.checkResults.values());\n  }\n  createAndRunCheck(check) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const checkId = this.getNextCheckId();\n      const test = new check(this.url, this.token);\n      const handleUpdate = (info) => {\n        this.updateCheck(checkId, info);\n      };\n      test.on(\"update\", handleUpdate);\n      const result = yield test.run();\n      test.off(\"update\", handleUpdate);\n      return result;\n    });\n  }\n  checkWebsocket() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(WebSocketCheck);\n    });\n  }\n  checkWebRTC() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(WebRTCCheck);\n    });\n  }\n  checkTURN() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(TURNCheck);\n    });\n  }\n  checkReconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(ReconnectCheck);\n    });\n  }\n  checkPublishAudio() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(PublishAudioCheck);\n    });\n  }\n  checkPublishVideo() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(PublishVideoCheck);\n    });\n  }\n};\nexport {\n  AudioPresets,\n  ConnectionCheck,\n  ConnectionError,\n  ConnectionQuality,\n  ConnectionState,\n  CriticalTimers,\n  DataPacket_Kind,\n  DefaultReconnectPolicy,\n  DeviceUnsupportedError,\n  DisconnectReason,\n  EngineEvent,\n  LivekitError,\n  LocalAudioTrack,\n  LocalParticipant,\n  LocalTrack,\n  LocalTrackPublication,\n  LocalVideoTrack,\n  LogLevel,\n  MediaDeviceFailure,\n  NegotiationError,\n  Participant,\n  ParticipantEvent,\n  PublishDataError,\n  RemoteAudioTrack,\n  RemoteParticipant,\n  RemoteTrack,\n  RemoteTrackPublication,\n  RemoteVideoTrack,\n  Room,\n  RoomEvent,\n  RoomState,\n  ScreenSharePresets,\n  Track,\n  TrackEvent,\n  TrackInvalidError,\n  TrackPublication,\n  UnexpectedConnectionState,\n  UnsupportedServer,\n  VideoPreset,\n  VideoPresets,\n  VideoPresets43,\n  VideoQuality,\n  attachToElement,\n  createAudioAnalyser,\n  createLocalAudioTrack,\n  createLocalScreenTracks,\n  createLocalTracks,\n  createLocalVideoTrack,\n  detachTrack,\n  getEmptyAudioStreamTrack,\n  getEmptyVideoStreamTrack,\n  isBackupCodec,\n  isBrowserSupported,\n  isCodecEqual,\n  protocolVersion,\n  setLogExtension,\n  setLogLevel,\n  supportsAV1,\n  supportsAdaptiveStream,\n  supportsDynacast,\n  supportsVP9,\n  version\n};\n//# sourceMappingURL=livekit-client.js.map\n",
      "start": 1684204348449,
      "end": 1684204348526
    },
    {
      "name": "vite:import-analysis",
      "result": "// node_modules/livekit-client/dist/livekit-client.esm.mjs\nfunction _mergeNamespaces(n, m) {\n  m.forEach(function(e) {\n    e && typeof e !== \"string\" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n      if (k !== \"default\" && !(k in n)) {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function() {\n            return e[k];\n          }\n        });\n      }\n    });\n  });\n  return Object.freeze(n);\n}\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nfunction getDefaultExportFromCjs(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar loglevel = { exports: {} };\n(function(module) {\n  (function(root, definition) {\n    if (module.exports) {\n      module.exports = definition();\n    } else {\n      root.log = definition();\n    }\n  })(commonjsGlobal, function() {\n    var noop2 = function() {\n    };\n    var undefinedType = \"undefined\";\n    var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\\/|MSIE /.test(window.navigator.userAgent);\n    var logMethods = [\"trace\", \"debug\", \"info\", \"warn\", \"error\"];\n    function bindMethod(obj, methodName) {\n      var method = obj[methodName];\n      if (typeof method.bind === \"function\") {\n        return method.bind(obj);\n      } else {\n        try {\n          return Function.prototype.bind.call(method, obj);\n        } catch (e) {\n          return function() {\n            return Function.prototype.apply.apply(method, [obj, arguments]);\n          };\n        }\n      }\n    }\n    function traceForIE() {\n      if (console.log) {\n        if (console.log.apply) {\n          console.log.apply(console, arguments);\n        } else {\n          Function.prototype.apply.apply(console.log, [console, arguments]);\n        }\n      }\n      if (console.trace)\n        console.trace();\n    }\n    function realMethod(methodName) {\n      if (methodName === \"debug\") {\n        methodName = \"log\";\n      }\n      if (typeof console === undefinedType) {\n        return false;\n      } else if (methodName === \"trace\" && isIE) {\n        return traceForIE;\n      } else if (console[methodName] !== void 0) {\n        return bindMethod(console, methodName);\n      } else if (console.log !== void 0) {\n        return bindMethod(console, \"log\");\n      } else {\n        return noop2;\n      }\n    }\n    function replaceLoggingMethods(level, loggerName) {\n      for (var i = 0; i < logMethods.length; i++) {\n        var methodName = logMethods[i];\n        this[methodName] = i < level ? noop2 : this.methodFactory(methodName, level, loggerName);\n      }\n      this.log = this.debug;\n    }\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n      return function() {\n        if (typeof console !== undefinedType) {\n          replaceLoggingMethods.call(this, level, loggerName);\n          this[methodName].apply(this, arguments);\n        }\n      };\n    }\n    function defaultMethodFactory(methodName, level, loggerName) {\n      return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n    function Logger(name, defaultLevel, factory) {\n      var self2 = this;\n      var currentLevel;\n      defaultLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n      var storageKey = \"loglevel\";\n      if (typeof name === \"string\") {\n        storageKey += \":\" + name;\n      } else if (typeof name === \"symbol\") {\n        storageKey = void 0;\n      }\n      function persistLevelIfPossible(levelNum) {\n        var levelName = (logMethods[levelNum] || \"silent\").toUpperCase();\n        if (typeof window === undefinedType || !storageKey)\n          return;\n        try {\n          window.localStorage[storageKey] = levelName;\n          return;\n        } catch (ignore) {\n        }\n        try {\n          window.document.cookie = encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n        } catch (ignore) {\n        }\n      }\n      function getPersistedLevel() {\n        var storedLevel;\n        if (typeof window === undefinedType || !storageKey)\n          return;\n        try {\n          storedLevel = window.localStorage[storageKey];\n        } catch (ignore) {\n        }\n        if (typeof storedLevel === undefinedType) {\n          try {\n            var cookie = window.document.cookie;\n            var location = cookie.indexOf(encodeURIComponent(storageKey) + \"=\");\n            if (location !== -1) {\n              storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n            }\n          } catch (ignore) {\n          }\n        }\n        if (self2.levels[storedLevel] === void 0) {\n          storedLevel = void 0;\n        }\n        return storedLevel;\n      }\n      function clearPersistedLevel() {\n        if (typeof window === undefinedType || !storageKey)\n          return;\n        try {\n          window.localStorage.removeItem(storageKey);\n          return;\n        } catch (ignore) {\n        }\n        try {\n          window.document.cookie = encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n        } catch (ignore) {\n        }\n      }\n      self2.name = name;\n      self2.levels = {\n        \"TRACE\": 0,\n        \"DEBUG\": 1,\n        \"INFO\": 2,\n        \"WARN\": 3,\n        \"ERROR\": 4,\n        \"SILENT\": 5\n      };\n      self2.methodFactory = factory || defaultMethodFactory;\n      self2.getLevel = function() {\n        return currentLevel;\n      };\n      self2.setLevel = function(level, persist) {\n        if (typeof level === \"string\" && self2.levels[level.toUpperCase()] !== void 0) {\n          level = self2.levels[level.toUpperCase()];\n        }\n        if (typeof level === \"number\" && level >= 0 && level <= self2.levels.SILENT) {\n          currentLevel = level;\n          if (persist !== false) {\n            persistLevelIfPossible(level);\n          }\n          replaceLoggingMethods.call(self2, level, name);\n          if (typeof console === undefinedType && level < self2.levels.SILENT) {\n            return \"No console available for logging\";\n          }\n        } else {\n          throw \"log.setLevel() called with invalid level: \" + level;\n        }\n      };\n      self2.setDefaultLevel = function(level) {\n        defaultLevel = level;\n        if (!getPersistedLevel()) {\n          self2.setLevel(level, false);\n        }\n      };\n      self2.resetLevel = function() {\n        self2.setLevel(defaultLevel, false);\n        clearPersistedLevel();\n      };\n      self2.enableAll = function(persist) {\n        self2.setLevel(self2.levels.TRACE, persist);\n      };\n      self2.disableAll = function(persist) {\n        self2.setLevel(self2.levels.SILENT, persist);\n      };\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n        initialLevel = defaultLevel;\n      }\n      self2.setLevel(initialLevel, false);\n    }\n    var defaultLogger = new Logger();\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n      if (typeof name !== \"symbol\" && typeof name !== \"string\" || name === \"\") {\n        throw new TypeError(\"You must supply a name when creating a logger.\");\n      }\n      var logger = _loggersByName[name];\n      if (!logger) {\n        logger = _loggersByName[name] = new Logger(name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n      }\n      return logger;\n    };\n    var _log = typeof window !== undefinedType ? window.log : void 0;\n    defaultLogger.noConflict = function() {\n      if (typeof window !== undefinedType && window.log === defaultLogger) {\n        window.log = _log;\n      }\n      return defaultLogger;\n    };\n    defaultLogger.getLoggers = function getLoggers() {\n      return _loggersByName;\n    };\n    defaultLogger[\"default\"] = defaultLogger;\n    return defaultLogger;\n  });\n})(loglevel);\nvar loglevelExports = loglevel.exports;\nvar LogLevel;\n(function(LogLevel2) {\n  LogLevel2[LogLevel2[\"trace\"] = 0] = \"trace\";\n  LogLevel2[LogLevel2[\"debug\"] = 1] = \"debug\";\n  LogLevel2[LogLevel2[\"info\"] = 2] = \"info\";\n  LogLevel2[LogLevel2[\"warn\"] = 3] = \"warn\";\n  LogLevel2[LogLevel2[\"error\"] = 4] = \"error\";\n  LogLevel2[LogLevel2[\"silent\"] = 5] = \"silent\";\n})(LogLevel || (LogLevel = {}));\nvar livekitLogger = loglevelExports.getLogger(\"livekit\");\nlivekitLogger.setLevel(LogLevel.info);\nfunction setLogLevel(level) {\n  livekitLogger.setLevel(level);\n}\nfunction setLogExtension(extension) {\n  const originalFactory = livekitLogger.methodFactory;\n  livekitLogger.methodFactory = (methodName, logLevel, loggerName) => {\n    const rawMethod = originalFactory(methodName, logLevel, loggerName);\n    const configLevel = livekitLogger.getLevel();\n    const needLog = logLevel >= configLevel && logLevel < LogLevel.silent;\n    return (msg, context) => {\n      if (context)\n        rawMethod(msg, context);\n      else\n        rawMethod(msg);\n      if (needLog) {\n        extension(logLevel, msg, context);\n      }\n    };\n  };\n  livekitLogger.setLevel(livekitLogger.getLevel());\n}\nvar long = Long;\nvar wasm = null;\ntry {\n  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;\n} catch (e) {\n}\nfunction Long(low, high, unsigned) {\n  this.low = low | 0;\n  this.high = high | 0;\n  this.unsigned = !!unsigned;\n}\nLong.prototype.__isLong__;\nObject.defineProperty(Long.prototype, \"__isLong__\", {\n  value: true\n});\nfunction isLong(obj) {\n  return (obj && obj[\"__isLong__\"]) === true;\n}\nLong.isLong = isLong;\nvar INT_CACHE = {};\nvar UINT_CACHE = {};\nfunction fromInt(value, unsigned) {\n  var obj, cachedObj, cache;\n  if (unsigned) {\n    value >>>= 0;\n    if (cache = 0 <= value && value < 256) {\n      cachedObj = UINT_CACHE[value];\n      if (cachedObj)\n        return cachedObj;\n    }\n    obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\n    if (cache)\n      UINT_CACHE[value] = obj;\n    return obj;\n  } else {\n    value |= 0;\n    if (cache = -128 <= value && value < 128) {\n      cachedObj = INT_CACHE[value];\n      if (cachedObj)\n        return cachedObj;\n    }\n    obj = fromBits(value, value < 0 ? -1 : 0, false);\n    if (cache)\n      INT_CACHE[value] = obj;\n    return obj;\n  }\n}\nLong.fromInt = fromInt;\nfunction fromNumber(value, unsigned) {\n  if (isNaN(value))\n    return unsigned ? UZERO : ZERO;\n  if (unsigned) {\n    if (value < 0)\n      return UZERO;\n    if (value >= TWO_PWR_64_DBL)\n      return MAX_UNSIGNED_VALUE;\n  } else {\n    if (value <= -TWO_PWR_63_DBL)\n      return MIN_VALUE;\n    if (value + 1 >= TWO_PWR_63_DBL)\n      return MAX_VALUE;\n  }\n  if (value < 0)\n    return fromNumber(-value, unsigned).neg();\n  return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);\n}\nLong.fromNumber = fromNumber;\nfunction fromBits(lowBits, highBits, unsigned) {\n  return new Long(lowBits, highBits, unsigned);\n}\nLong.fromBits = fromBits;\nvar pow_dbl = Math.pow;\nfunction fromString(str, unsigned, radix) {\n  if (str.length === 0)\n    throw Error(\"empty string\");\n  if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\n    return ZERO;\n  if (typeof unsigned === \"number\") {\n    radix = unsigned, unsigned = false;\n  } else {\n    unsigned = !!unsigned;\n  }\n  radix = radix || 10;\n  if (radix < 2 || 36 < radix)\n    throw RangeError(\"radix\");\n  var p;\n  if ((p = str.indexOf(\"-\")) > 0)\n    throw Error(\"interior hyphen\");\n  else if (p === 0) {\n    return fromString(str.substring(1), unsigned, radix).neg();\n  }\n  var radixToPower = fromNumber(pow_dbl(radix, 8));\n  var result = ZERO;\n  for (var i = 0; i < str.length; i += 8) {\n    var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);\n    if (size < 8) {\n      var power = fromNumber(pow_dbl(radix, size));\n      result = result.mul(power).add(fromNumber(value));\n    } else {\n      result = result.mul(radixToPower);\n      result = result.add(fromNumber(value));\n    }\n  }\n  result.unsigned = unsigned;\n  return result;\n}\nLong.fromString = fromString;\nfunction fromValue(val, unsigned) {\n  if (typeof val === \"number\")\n    return fromNumber(val, unsigned);\n  if (typeof val === \"string\")\n    return fromString(val, unsigned);\n  return fromBits(val.low, val.high, typeof unsigned === \"boolean\" ? unsigned : val.unsigned);\n}\nLong.fromValue = fromValue;\nvar TWO_PWR_16_DBL = 1 << 16;\nvar TWO_PWR_24_DBL = 1 << 24;\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\nvar ZERO = fromInt(0);\nLong.ZERO = ZERO;\nvar UZERO = fromInt(0, true);\nLong.UZERO = UZERO;\nvar ONE = fromInt(1);\nLong.ONE = ONE;\nvar UONE = fromInt(1, true);\nLong.UONE = UONE;\nvar NEG_ONE = fromInt(-1);\nLong.NEG_ONE = NEG_ONE;\nvar MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);\nLong.MAX_VALUE = MAX_VALUE;\nvar MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);\nLong.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\nvar MIN_VALUE = fromBits(0, 2147483648 | 0, false);\nLong.MIN_VALUE = MIN_VALUE;\nvar LongPrototype = Long.prototype;\nLongPrototype.toInt = function toInt() {\n  return this.unsigned ? this.low >>> 0 : this.low;\n};\nLongPrototype.toNumber = function toNumber() {\n  if (this.unsigned)\n    return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n  return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n};\nLongPrototype.toString = function toString(radix) {\n  radix = radix || 10;\n  if (radix < 2 || 36 < radix)\n    throw RangeError(\"radix\");\n  if (this.isZero())\n    return \"0\";\n  if (this.isNegative()) {\n    if (this.eq(MIN_VALUE)) {\n      var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);\n      return div.toString(radix) + rem1.toInt().toString(radix);\n    } else\n      return \"-\" + this.neg().toString(radix);\n  }\n  var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;\n  var result = \"\";\n  while (true) {\n    var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);\n    rem = remDiv;\n    if (rem.isZero())\n      return digits + result;\n    else {\n      while (digits.length < 6)\n        digits = \"0\" + digits;\n      result = \"\" + digits + result;\n    }\n  }\n};\nLongPrototype.getHighBits = function getHighBits() {\n  return this.high;\n};\nLongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\n  return this.high >>> 0;\n};\nLongPrototype.getLowBits = function getLowBits() {\n  return this.low;\n};\nLongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\n  return this.low >>> 0;\n};\nLongPrototype.getNumBitsAbs = function getNumBitsAbs() {\n  if (this.isNegative())\n    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n  var val = this.high != 0 ? this.high : this.low;\n  for (var bit = 31; bit > 0; bit--)\n    if ((val & 1 << bit) != 0)\n      break;\n  return this.high != 0 ? bit + 33 : bit + 1;\n};\nLongPrototype.isZero = function isZero() {\n  return this.high === 0 && this.low === 0;\n};\nLongPrototype.eqz = LongPrototype.isZero;\nLongPrototype.isNegative = function isNegative() {\n  return !this.unsigned && this.high < 0;\n};\nLongPrototype.isPositive = function isPositive() {\n  return this.unsigned || this.high >= 0;\n};\nLongPrototype.isOdd = function isOdd() {\n  return (this.low & 1) === 1;\n};\nLongPrototype.isEven = function isEven() {\n  return (this.low & 1) === 0;\n};\nLongPrototype.equals = function equals(other) {\n  if (!isLong(other))\n    other = fromValue(other);\n  if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)\n    return false;\n  return this.high === other.high && this.low === other.low;\n};\nLongPrototype.eq = LongPrototype.equals;\nLongPrototype.notEquals = function notEquals(other) {\n  return !this.eq(\n    /* validates */\n    other\n  );\n};\nLongPrototype.neq = LongPrototype.notEquals;\nLongPrototype.ne = LongPrototype.notEquals;\nLongPrototype.lessThan = function lessThan(other) {\n  return this.comp(\n    /* validates */\n    other\n  ) < 0;\n};\nLongPrototype.lt = LongPrototype.lessThan;\nLongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\n  return this.comp(\n    /* validates */\n    other\n  ) <= 0;\n};\nLongPrototype.lte = LongPrototype.lessThanOrEqual;\nLongPrototype.le = LongPrototype.lessThanOrEqual;\nLongPrototype.greaterThan = function greaterThan(other) {\n  return this.comp(\n    /* validates */\n    other\n  ) > 0;\n};\nLongPrototype.gt = LongPrototype.greaterThan;\nLongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\n  return this.comp(\n    /* validates */\n    other\n  ) >= 0;\n};\nLongPrototype.gte = LongPrototype.greaterThanOrEqual;\nLongPrototype.ge = LongPrototype.greaterThanOrEqual;\nLongPrototype.compare = function compare(other) {\n  if (!isLong(other))\n    other = fromValue(other);\n  if (this.eq(other))\n    return 0;\n  var thisNeg = this.isNegative(), otherNeg = other.isNegative();\n  if (thisNeg && !otherNeg)\n    return -1;\n  if (!thisNeg && otherNeg)\n    return 1;\n  if (!this.unsigned)\n    return this.sub(other).isNegative() ? -1 : 1;\n  return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;\n};\nLongPrototype.comp = LongPrototype.compare;\nLongPrototype.negate = function negate() {\n  if (!this.unsigned && this.eq(MIN_VALUE))\n    return MIN_VALUE;\n  return this.not().add(ONE);\n};\nLongPrototype.neg = LongPrototype.negate;\nLongPrototype.add = function add(addend) {\n  if (!isLong(addend))\n    addend = fromValue(addend);\n  var a48 = this.high >>> 16;\n  var a32 = this.high & 65535;\n  var a16 = this.low >>> 16;\n  var a00 = this.low & 65535;\n  var b48 = addend.high >>> 16;\n  var b32 = addend.high & 65535;\n  var b16 = addend.low >>> 16;\n  var b00 = addend.low & 65535;\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 + b00;\n  c16 += c00 >>> 16;\n  c00 &= 65535;\n  c16 += a16 + b16;\n  c32 += c16 >>> 16;\n  c16 &= 65535;\n  c32 += a32 + b32;\n  c48 += c32 >>> 16;\n  c32 &= 65535;\n  c48 += a48 + b48;\n  c48 &= 65535;\n  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n};\nLongPrototype.subtract = function subtract(subtrahend) {\n  if (!isLong(subtrahend))\n    subtrahend = fromValue(subtrahend);\n  return this.add(subtrahend.neg());\n};\nLongPrototype.sub = LongPrototype.subtract;\nLongPrototype.multiply = function multiply(multiplier) {\n  if (this.isZero())\n    return ZERO;\n  if (!isLong(multiplier))\n    multiplier = fromValue(multiplier);\n  if (wasm) {\n    var low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);\n    return fromBits(low, wasm.get_high(), this.unsigned);\n  }\n  if (multiplier.isZero())\n    return ZERO;\n  if (this.eq(MIN_VALUE))\n    return multiplier.isOdd() ? MIN_VALUE : ZERO;\n  if (multiplier.eq(MIN_VALUE))\n    return this.isOdd() ? MIN_VALUE : ZERO;\n  if (this.isNegative()) {\n    if (multiplier.isNegative())\n      return this.neg().mul(multiplier.neg());\n    else\n      return this.neg().mul(multiplier).neg();\n  } else if (multiplier.isNegative())\n    return this.mul(multiplier.neg()).neg();\n  if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\n    return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\n  var a48 = this.high >>> 16;\n  var a32 = this.high & 65535;\n  var a16 = this.low >>> 16;\n  var a00 = this.low & 65535;\n  var b48 = multiplier.high >>> 16;\n  var b32 = multiplier.high & 65535;\n  var b16 = multiplier.low >>> 16;\n  var b00 = multiplier.low & 65535;\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 * b00;\n  c16 += c00 >>> 16;\n  c00 &= 65535;\n  c16 += a16 * b00;\n  c32 += c16 >>> 16;\n  c16 &= 65535;\n  c16 += a00 * b16;\n  c32 += c16 >>> 16;\n  c16 &= 65535;\n  c32 += a32 * b00;\n  c48 += c32 >>> 16;\n  c32 &= 65535;\n  c32 += a16 * b16;\n  c48 += c32 >>> 16;\n  c32 &= 65535;\n  c32 += a00 * b32;\n  c48 += c32 >>> 16;\n  c32 &= 65535;\n  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n  c48 &= 65535;\n  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n};\nLongPrototype.mul = LongPrototype.multiply;\nLongPrototype.divide = function divide(divisor) {\n  if (!isLong(divisor))\n    divisor = fromValue(divisor);\n  if (divisor.isZero())\n    throw Error(\"division by zero\");\n  if (wasm) {\n    if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {\n      return this;\n    }\n    var low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);\n    return fromBits(low, wasm.get_high(), this.unsigned);\n  }\n  if (this.isZero())\n    return this.unsigned ? UZERO : ZERO;\n  var approx, rem, res;\n  if (!this.unsigned) {\n    if (this.eq(MIN_VALUE)) {\n      if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\n        return MIN_VALUE;\n      else if (divisor.eq(MIN_VALUE))\n        return ONE;\n      else {\n        var halfThis = this.shr(1);\n        approx = halfThis.div(divisor).shl(1);\n        if (approx.eq(ZERO)) {\n          return divisor.isNegative() ? ONE : NEG_ONE;\n        } else {\n          rem = this.sub(divisor.mul(approx));\n          res = approx.add(rem.div(divisor));\n          return res;\n        }\n      }\n    } else if (divisor.eq(MIN_VALUE))\n      return this.unsigned ? UZERO : ZERO;\n    if (this.isNegative()) {\n      if (divisor.isNegative())\n        return this.neg().div(divisor.neg());\n      return this.neg().div(divisor).neg();\n    } else if (divisor.isNegative())\n      return this.div(divisor.neg()).neg();\n    res = ZERO;\n  } else {\n    if (!divisor.unsigned)\n      divisor = divisor.toUnsigned();\n    if (divisor.gt(this))\n      return UZERO;\n    if (divisor.gt(this.shru(1)))\n      return UONE;\n    res = UZERO;\n  }\n  rem = this;\n  while (rem.gte(divisor)) {\n    approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n    var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);\n    while (approxRem.isNegative() || approxRem.gt(rem)) {\n      approx -= delta;\n      approxRes = fromNumber(approx, this.unsigned);\n      approxRem = approxRes.mul(divisor);\n    }\n    if (approxRes.isZero())\n      approxRes = ONE;\n    res = res.add(approxRes);\n    rem = rem.sub(approxRem);\n  }\n  return res;\n};\nLongPrototype.div = LongPrototype.divide;\nLongPrototype.modulo = function modulo(divisor) {\n  if (!isLong(divisor))\n    divisor = fromValue(divisor);\n  if (wasm) {\n    var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);\n    return fromBits(low, wasm.get_high(), this.unsigned);\n  }\n  return this.sub(this.div(divisor).mul(divisor));\n};\nLongPrototype.mod = LongPrototype.modulo;\nLongPrototype.rem = LongPrototype.modulo;\nLongPrototype.not = function not() {\n  return fromBits(~this.low, ~this.high, this.unsigned);\n};\nLongPrototype.and = function and(other) {\n  if (!isLong(other))\n    other = fromValue(other);\n  return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n};\nLongPrototype.or = function or(other) {\n  if (!isLong(other))\n    other = fromValue(other);\n  return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n};\nLongPrototype.xor = function xor(other) {\n  if (!isLong(other))\n    other = fromValue(other);\n  return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n};\nLongPrototype.shiftLeft = function shiftLeft(numBits) {\n  if (isLong(numBits))\n    numBits = numBits.toInt();\n  if ((numBits &= 63) === 0)\n    return this;\n  else if (numBits < 32)\n    return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);\n  else\n    return fromBits(0, this.low << numBits - 32, this.unsigned);\n};\nLongPrototype.shl = LongPrototype.shiftLeft;\nLongPrototype.shiftRight = function shiftRight(numBits) {\n  if (isLong(numBits))\n    numBits = numBits.toInt();\n  if ((numBits &= 63) === 0)\n    return this;\n  else if (numBits < 32)\n    return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);\n  else\n    return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n};\nLongPrototype.shr = LongPrototype.shiftRight;\nLongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\n  if (isLong(numBits))\n    numBits = numBits.toInt();\n  numBits &= 63;\n  if (numBits === 0)\n    return this;\n  else {\n    var high = this.high;\n    if (numBits < 32) {\n      var low = this.low;\n      return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);\n    } else if (numBits === 32)\n      return fromBits(high, 0, this.unsigned);\n    else\n      return fromBits(high >>> numBits - 32, 0, this.unsigned);\n  }\n};\nLongPrototype.shru = LongPrototype.shiftRightUnsigned;\nLongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\nLongPrototype.toSigned = function toSigned() {\n  if (!this.unsigned)\n    return this;\n  return fromBits(this.low, this.high, false);\n};\nLongPrototype.toUnsigned = function toUnsigned() {\n  if (this.unsigned)\n    return this;\n  return fromBits(this.low, this.high, true);\n};\nLongPrototype.toBytes = function toBytes(le) {\n  return le ? this.toBytesLE() : this.toBytesBE();\n};\nLongPrototype.toBytesLE = function toBytesLE() {\n  var hi = this.high, lo = this.low;\n  return [lo & 255, lo >>> 8 & 255, lo >>> 16 & 255, lo >>> 24, hi & 255, hi >>> 8 & 255, hi >>> 16 & 255, hi >>> 24];\n};\nLongPrototype.toBytesBE = function toBytesBE() {\n  var hi = this.high, lo = this.low;\n  return [hi >>> 24, hi >>> 16 & 255, hi >>> 8 & 255, hi & 255, lo >>> 24, lo >>> 16 & 255, lo >>> 8 & 255, lo & 255];\n};\nLong.fromBytes = function fromBytes(bytes, unsigned, le) {\n  return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\n};\nLong.fromBytesLE = function fromBytesLE(bytes, unsigned) {\n  return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);\n};\nLong.fromBytesBE = function fromBytesBE(bytes, unsigned) {\n  return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);\n};\nvar Long$1 = getDefaultExportFromCjs(long);\nvar indexMinimal = {};\nvar minimal$1 = {};\nvar aspromise;\nvar hasRequiredAspromise;\nfunction requireAspromise() {\n  if (hasRequiredAspromise)\n    return aspromise;\n  hasRequiredAspromise = 1;\n  aspromise = asPromise;\n  function asPromise(fn, ctx) {\n    var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;\n    while (index < arguments.length)\n      params[offset++] = arguments[index++];\n    return new Promise(function executor(resolve, reject) {\n      params[offset] = function callback(err) {\n        if (pending) {\n          pending = false;\n          if (err)\n            reject(err);\n          else {\n            var params2 = new Array(arguments.length - 1), offset2 = 0;\n            while (offset2 < params2.length)\n              params2[offset2++] = arguments[offset2];\n            resolve.apply(null, params2);\n          }\n        }\n      };\n      try {\n        fn.apply(ctx || null, params);\n      } catch (err) {\n        if (pending) {\n          pending = false;\n          reject(err);\n        }\n      }\n    });\n  }\n  return aspromise;\n}\nvar base64$1 = {};\nvar hasRequiredBase64;\nfunction requireBase64() {\n  if (hasRequiredBase64)\n    return base64$1;\n  hasRequiredBase64 = 1;\n  (function(exports) {\n    var base642 = exports;\n    base642.length = function length(string) {\n      var p = string.length;\n      if (!p)\n        return 0;\n      var n = 0;\n      while (--p % 4 > 1 && string.charAt(p) === \"=\")\n        ++n;\n      return Math.ceil(string.length * 3) / 4 - n;\n    };\n    var b64 = new Array(64);\n    var s64 = new Array(123);\n    for (var i = 0; i < 64; )\n      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\n    base642.encode = function encode(buffer, start, end2) {\n      var parts = null, chunk = [];\n      var i2 = 0, j = 0, t;\n      while (start < end2) {\n        var b = buffer[start++];\n        switch (j) {\n          case 0:\n            chunk[i2++] = b64[b >> 2];\n            t = (b & 3) << 4;\n            j = 1;\n            break;\n          case 1:\n            chunk[i2++] = b64[t | b >> 4];\n            t = (b & 15) << 2;\n            j = 2;\n            break;\n          case 2:\n            chunk[i2++] = b64[t | b >> 6];\n            chunk[i2++] = b64[b & 63];\n            j = 0;\n            break;\n        }\n        if (i2 > 8191) {\n          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n          i2 = 0;\n        }\n      }\n      if (j) {\n        chunk[i2++] = b64[t];\n        chunk[i2++] = 61;\n        if (j === 1)\n          chunk[i2++] = 61;\n      }\n      if (parts) {\n        if (i2)\n          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));\n        return parts.join(\"\");\n      }\n      return String.fromCharCode.apply(String, chunk.slice(0, i2));\n    };\n    var invalidEncoding = \"invalid encoding\";\n    base642.decode = function decode(string, buffer, offset) {\n      var start = offset;\n      var j = 0, t;\n      for (var i2 = 0; i2 < string.length; ) {\n        var c = string.charCodeAt(i2++);\n        if (c === 61 && j > 1)\n          break;\n        if ((c = s64[c]) === void 0)\n          throw Error(invalidEncoding);\n        switch (j) {\n          case 0:\n            t = c;\n            j = 1;\n            break;\n          case 1:\n            buffer[offset++] = t << 2 | (c & 48) >> 4;\n            t = c;\n            j = 2;\n            break;\n          case 2:\n            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\n            t = c;\n            j = 3;\n            break;\n          case 3:\n            buffer[offset++] = (t & 3) << 6 | c;\n            j = 0;\n            break;\n        }\n      }\n      if (j === 1)\n        throw Error(invalidEncoding);\n      return offset - start;\n    };\n    base642.test = function test(string) {\n      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\n    };\n  })(base64$1);\n  return base64$1;\n}\nvar eventemitter;\nvar hasRequiredEventemitter;\nfunction requireEventemitter() {\n  if (hasRequiredEventemitter)\n    return eventemitter;\n  hasRequiredEventemitter = 1;\n  eventemitter = EventEmitter2;\n  function EventEmitter2() {\n    this._listeners = {};\n  }\n  EventEmitter2.prototype.on = function on(evt, fn, ctx) {\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\n      fn,\n      ctx: ctx || this\n    });\n    return this;\n  };\n  EventEmitter2.prototype.off = function off(evt, fn) {\n    if (evt === void 0)\n      this._listeners = {};\n    else {\n      if (fn === void 0)\n        this._listeners[evt] = [];\n      else {\n        var listeners2 = this._listeners[evt];\n        for (var i = 0; i < listeners2.length; )\n          if (listeners2[i].fn === fn)\n            listeners2.splice(i, 1);\n          else\n            ++i;\n      }\n    }\n    return this;\n  };\n  EventEmitter2.prototype.emit = function emit2(evt) {\n    var listeners2 = this._listeners[evt];\n    if (listeners2) {\n      var args = [], i = 1;\n      for (; i < arguments.length; )\n        args.push(arguments[i++]);\n      for (i = 0; i < listeners2.length; )\n        listeners2[i].fn.apply(listeners2[i++].ctx, args);\n    }\n    return this;\n  };\n  return eventemitter;\n}\nvar float;\nvar hasRequiredFloat;\nfunction requireFloat() {\n  if (hasRequiredFloat)\n    return float;\n  hasRequiredFloat = 1;\n  float = factory(factory);\n  function factory(exports) {\n    if (typeof Float32Array !== \"undefined\")\n      (function() {\n        var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;\n        function writeFloat_f32_cpy(val, buf, pos) {\n          f32[0] = val;\n          buf[pos] = f8b[0];\n          buf[pos + 1] = f8b[1];\n          buf[pos + 2] = f8b[2];\n          buf[pos + 3] = f8b[3];\n        }\n        function writeFloat_f32_rev(val, buf, pos) {\n          f32[0] = val;\n          buf[pos] = f8b[3];\n          buf[pos + 1] = f8b[2];\n          buf[pos + 2] = f8b[1];\n          buf[pos + 3] = f8b[0];\n        }\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\n        function readFloat_f32_cpy(buf, pos) {\n          f8b[0] = buf[pos];\n          f8b[1] = buf[pos + 1];\n          f8b[2] = buf[pos + 2];\n          f8b[3] = buf[pos + 3];\n          return f32[0];\n        }\n        function readFloat_f32_rev(buf, pos) {\n          f8b[3] = buf[pos];\n          f8b[2] = buf[pos + 1];\n          f8b[1] = buf[pos + 2];\n          f8b[0] = buf[pos + 3];\n          return f32[0];\n        }\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\n      })();\n    else\n      (function() {\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\n          var sign = val < 0 ? 1 : 0;\n          if (sign)\n            val = -val;\n          if (val === 0)\n            writeUint(1 / val > 0 ? (\n              /* positive */\n              0\n            ) : (\n              /* negative 0 */\n              2147483648\n            ), buf, pos);\n          else if (isNaN(val))\n            writeUint(2143289344, buf, pos);\n          else if (val > 34028234663852886e22)\n            writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\n          else if (val < 11754943508222875e-54)\n            writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);\n          else {\n            var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\n            writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\n          }\n        }\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\n        function readFloat_ieee754(readUint, buf, pos) {\n          var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;\n          return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\n        }\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\n      })();\n    if (typeof Float64Array !== \"undefined\")\n      (function() {\n        var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;\n        function writeDouble_f64_cpy(val, buf, pos) {\n          f64[0] = val;\n          buf[pos] = f8b[0];\n          buf[pos + 1] = f8b[1];\n          buf[pos + 2] = f8b[2];\n          buf[pos + 3] = f8b[3];\n          buf[pos + 4] = f8b[4];\n          buf[pos + 5] = f8b[5];\n          buf[pos + 6] = f8b[6];\n          buf[pos + 7] = f8b[7];\n        }\n        function writeDouble_f64_rev(val, buf, pos) {\n          f64[0] = val;\n          buf[pos] = f8b[7];\n          buf[pos + 1] = f8b[6];\n          buf[pos + 2] = f8b[5];\n          buf[pos + 3] = f8b[4];\n          buf[pos + 4] = f8b[3];\n          buf[pos + 5] = f8b[2];\n          buf[pos + 6] = f8b[1];\n          buf[pos + 7] = f8b[0];\n        }\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\n        function readDouble_f64_cpy(buf, pos) {\n          f8b[0] = buf[pos];\n          f8b[1] = buf[pos + 1];\n          f8b[2] = buf[pos + 2];\n          f8b[3] = buf[pos + 3];\n          f8b[4] = buf[pos + 4];\n          f8b[5] = buf[pos + 5];\n          f8b[6] = buf[pos + 6];\n          f8b[7] = buf[pos + 7];\n          return f64[0];\n        }\n        function readDouble_f64_rev(buf, pos) {\n          f8b[7] = buf[pos];\n          f8b[6] = buf[pos + 1];\n          f8b[5] = buf[pos + 2];\n          f8b[4] = buf[pos + 3];\n          f8b[3] = buf[pos + 4];\n          f8b[2] = buf[pos + 5];\n          f8b[1] = buf[pos + 6];\n          f8b[0] = buf[pos + 7];\n          return f64[0];\n        }\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\n      })();\n    else\n      (function() {\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\n          var sign = val < 0 ? 1 : 0;\n          if (sign)\n            val = -val;\n          if (val === 0) {\n            writeUint(0, buf, pos + off0);\n            writeUint(1 / val > 0 ? (\n              /* positive */\n              0\n            ) : (\n              /* negative 0 */\n              2147483648\n            ), buf, pos + off1);\n          } else if (isNaN(val)) {\n            writeUint(0, buf, pos + off0);\n            writeUint(2146959360, buf, pos + off1);\n          } else if (val > 17976931348623157e292) {\n            writeUint(0, buf, pos + off0);\n            writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\n          } else {\n            var mantissa;\n            if (val < 22250738585072014e-324) {\n              mantissa = val / 5e-324;\n              writeUint(mantissa >>> 0, buf, pos + off0);\n              writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\n            } else {\n              var exponent = Math.floor(Math.log(val) / Math.LN2);\n              if (exponent === 1024)\n                exponent = 1023;\n              mantissa = val * Math.pow(2, -exponent);\n              writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\n              writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\n            }\n          }\n        }\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\n          var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);\n          var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;\n          return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\n        }\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\n      })();\n    return exports;\n  }\n  function writeUintLE(val, buf, pos) {\n    buf[pos] = val & 255;\n    buf[pos + 1] = val >>> 8 & 255;\n    buf[pos + 2] = val >>> 16 & 255;\n    buf[pos + 3] = val >>> 24;\n  }\n  function writeUintBE(val, buf, pos) {\n    buf[pos] = val >>> 24;\n    buf[pos + 1] = val >>> 16 & 255;\n    buf[pos + 2] = val >>> 8 & 255;\n    buf[pos + 3] = val & 255;\n  }\n  function readUintLE(buf, pos) {\n    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;\n  }\n  function readUintBE(buf, pos) {\n    return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;\n  }\n  return float;\n}\nvar inquire_1;\nvar hasRequiredInquire;\nfunction requireInquire() {\n  if (hasRequiredInquire)\n    return inquire_1;\n  hasRequiredInquire = 1;\n  inquire_1 = inquire;\n  function inquire(moduleName) {\n    try {\n      var mod = void 0;\n      if (mod && (mod.length || Object.keys(mod).length))\n        return mod;\n    } catch (e) {\n    }\n    return null;\n  }\n  return inquire_1;\n}\nvar utf8$2 = {};\nvar hasRequiredUtf8;\nfunction requireUtf8() {\n  if (hasRequiredUtf8)\n    return utf8$2;\n  hasRequiredUtf8 = 1;\n  (function(exports) {\n    var utf82 = exports;\n    utf82.length = function utf8_length(string) {\n      var len = 0, c = 0;\n      for (var i = 0; i < string.length; ++i) {\n        c = string.charCodeAt(i);\n        if (c < 128)\n          len += 1;\n        else if (c < 2048)\n          len += 2;\n        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {\n          ++i;\n          len += 4;\n        } else\n          len += 3;\n      }\n      return len;\n    };\n    utf82.read = function utf8_read(buffer, start, end2) {\n      var len = end2 - start;\n      if (len < 1)\n        return \"\";\n      var parts = null, chunk = [], i = 0, t;\n      while (start < end2) {\n        t = buffer[start++];\n        if (t < 128)\n          chunk[i++] = t;\n        else if (t > 191 && t < 224)\n          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\n        else if (t > 239 && t < 365) {\n          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;\n          chunk[i++] = 55296 + (t >> 10);\n          chunk[i++] = 56320 + (t & 1023);\n        } else\n          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\n        if (i > 8191) {\n          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n          i = 0;\n        }\n      }\n      if (parts) {\n        if (i)\n          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n        return parts.join(\"\");\n      }\n      return String.fromCharCode.apply(String, chunk.slice(0, i));\n    };\n    utf82.write = function utf8_write(string, buffer, offset) {\n      var start = offset, c1, c2;\n      for (var i = 0; i < string.length; ++i) {\n        c1 = string.charCodeAt(i);\n        if (c1 < 128) {\n          buffer[offset++] = c1;\n        } else if (c1 < 2048) {\n          buffer[offset++] = c1 >> 6 | 192;\n          buffer[offset++] = c1 & 63 | 128;\n        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {\n          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);\n          ++i;\n          buffer[offset++] = c1 >> 18 | 240;\n          buffer[offset++] = c1 >> 12 & 63 | 128;\n          buffer[offset++] = c1 >> 6 & 63 | 128;\n          buffer[offset++] = c1 & 63 | 128;\n        } else {\n          buffer[offset++] = c1 >> 12 | 224;\n          buffer[offset++] = c1 >> 6 & 63 | 128;\n          buffer[offset++] = c1 & 63 | 128;\n        }\n      }\n      return offset - start;\n    };\n  })(utf8$2);\n  return utf8$2;\n}\nvar pool_1;\nvar hasRequiredPool;\nfunction requirePool() {\n  if (hasRequiredPool)\n    return pool_1;\n  hasRequiredPool = 1;\n  pool_1 = pool;\n  function pool(alloc2, slice, size) {\n    var SIZE = size || 8192;\n    var MAX = SIZE >>> 1;\n    var slab = null;\n    var offset = SIZE;\n    return function pool_alloc(size2) {\n      if (size2 < 1 || size2 > MAX)\n        return alloc2(size2);\n      if (offset + size2 > SIZE) {\n        slab = alloc2(SIZE);\n        offset = 0;\n      }\n      var buf = slice.call(slab, offset, offset += size2);\n      if (offset & 7)\n        offset = (offset | 7) + 1;\n      return buf;\n    };\n  }\n  return pool_1;\n}\nvar longbits;\nvar hasRequiredLongbits;\nfunction requireLongbits() {\n  if (hasRequiredLongbits)\n    return longbits;\n  hasRequiredLongbits = 1;\n  longbits = LongBits2;\n  var util2 = requireMinimal();\n  function LongBits2(lo, hi) {\n    this.lo = lo >>> 0;\n    this.hi = hi >>> 0;\n  }\n  var zero = LongBits2.zero = new LongBits2(0, 0);\n  zero.toNumber = function() {\n    return 0;\n  };\n  zero.zzEncode = zero.zzDecode = function() {\n    return this;\n  };\n  zero.length = function() {\n    return 1;\n  };\n  var zeroHash = LongBits2.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n  LongBits2.fromNumber = function fromNumber2(value) {\n    if (value === 0)\n      return zero;\n    var sign = value < 0;\n    if (sign)\n      value = -value;\n    var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n      hi = ~hi >>> 0;\n      lo = ~lo >>> 0;\n      if (++lo > 4294967295) {\n        lo = 0;\n        if (++hi > 4294967295)\n          hi = 0;\n      }\n    }\n    return new LongBits2(lo, hi);\n  };\n  LongBits2.from = function from(value) {\n    if (typeof value === \"number\")\n      return LongBits2.fromNumber(value);\n    if (util2.isString(value)) {\n      if (util2.Long)\n        value = util2.Long.fromString(value);\n      else\n        return LongBits2.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits2(value.low >>> 0, value.high >>> 0) : zero;\n  };\n  LongBits2.prototype.toNumber = function toNumber2(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n      var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;\n      if (!lo)\n        hi = hi + 1 >>> 0;\n      return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n  };\n  LongBits2.prototype.toLong = function toLong(unsigned) {\n    return util2.Long ? new util2.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : {\n      low: this.lo | 0,\n      high: this.hi | 0,\n      unsigned: Boolean(unsigned)\n    };\n  };\n  var charCodeAt = String.prototype.charCodeAt;\n  LongBits2.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n      return zero;\n    return new LongBits2((charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0, (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0);\n  };\n  LongBits2.prototype.toHash = function toHash() {\n    return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);\n  };\n  LongBits2.prototype.zzEncode = function zzEncode() {\n    var mask = this.hi >> 31;\n    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo = (this.lo << 1 ^ mask) >>> 0;\n    return this;\n  };\n  LongBits2.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi = (this.hi >>> 1 ^ mask) >>> 0;\n    return this;\n  };\n  LongBits2.prototype.length = function length() {\n    var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;\n    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;\n  };\n  return longbits;\n}\nvar hasRequiredMinimal;\nfunction requireMinimal() {\n  if (hasRequiredMinimal)\n    return minimal$1;\n  hasRequiredMinimal = 1;\n  (function(exports) {\n    var util2 = exports;\n    util2.asPromise = requireAspromise();\n    util2.base64 = requireBase64();\n    util2.EventEmitter = requireEventemitter();\n    util2.float = requireFloat();\n    util2.inquire = requireInquire();\n    util2.utf8 = requireUtf8();\n    util2.pool = requirePool();\n    util2.LongBits = requireLongbits();\n    util2.isNode = Boolean(typeof commonjsGlobal !== \"undefined\" && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node);\n    util2.global = util2.isNode && commonjsGlobal || typeof window !== \"undefined\" && window || typeof self !== \"undefined\" && self || commonjsGlobal;\n    util2.emptyArray = Object.freeze ? Object.freeze([]) : (\n      /* istanbul ignore next */\n      []\n    );\n    util2.emptyObject = Object.freeze ? Object.freeze({}) : (\n      /* istanbul ignore next */\n      {}\n    );\n    util2.isInteger = Number.isInteger || /* istanbul ignore next */\n    function isInteger(value) {\n      return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n    };\n    util2.isString = function isString(value) {\n      return typeof value === \"string\" || value instanceof String;\n    };\n    util2.isObject = function isObject2(value) {\n      return value && typeof value === \"object\";\n    };\n    util2.isset = /**\n     * Checks if a property on a message is considered to be present.\n     * @param {Object} obj Plain object or message instance\n     * @param {string} prop Property name\n     * @returns {boolean} `true` if considered to be present, otherwise `false`\n     */\n    util2.isSet = function isSet2(obj, prop) {\n      var value = obj[prop];\n      if (value != null && obj.hasOwnProperty(prop))\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n      return false;\n    };\n    util2.Buffer = function() {\n      try {\n        var Buffer = util2.inquire(\"buffer\").Buffer;\n        return Buffer.prototype.utf8Write ? Buffer : (\n          /* istanbul ignore next */\n          null\n        );\n      } catch (e) {\n        return null;\n      }\n    }();\n    util2._Buffer_from = null;\n    util2._Buffer_allocUnsafe = null;\n    util2.newBuffer = function newBuffer(sizeOrArray) {\n      return typeof sizeOrArray === \"number\" ? util2.Buffer ? util2._Buffer_allocUnsafe(sizeOrArray) : new util2.Array(sizeOrArray) : util2.Buffer ? util2._Buffer_from(sizeOrArray) : typeof Uint8Array === \"undefined\" ? sizeOrArray : new Uint8Array(sizeOrArray);\n    };\n    util2.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n    util2.Long = /* istanbul ignore next */\n    util2.global.dcodeIO && /* istanbul ignore next */\n    util2.global.dcodeIO.Long || /* istanbul ignore next */\n    util2.global.Long || util2.inquire(\"long\");\n    util2.key2Re = /^true|false|0|1$/;\n    util2.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n    util2.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n    util2.longToHash = function longToHash(value) {\n      return value ? util2.LongBits.from(value).toHash() : util2.LongBits.zeroHash;\n    };\n    util2.longFromHash = function longFromHash(hash, unsigned) {\n      var bits = util2.LongBits.fromHash(hash);\n      if (util2.Long)\n        return util2.Long.fromBits(bits.lo, bits.hi, unsigned);\n      return bits.toNumber(Boolean(unsigned));\n    };\n    function merge(dst, src, ifNotSet) {\n      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === void 0 || !ifNotSet)\n          dst[keys[i]] = src[keys[i]];\n      return dst;\n    }\n    util2.merge = merge;\n    util2.lcFirst = function lcFirst(str) {\n      return str.charAt(0).toLowerCase() + str.substring(1);\n    };\n    function newError(name) {\n      function CustomError(message, properties) {\n        if (!(this instanceof CustomError))\n          return new CustomError(message, properties);\n        Object.defineProperty(this, \"message\", {\n          get: function() {\n            return message;\n          }\n        });\n        if (Error.captureStackTrace)\n          Error.captureStackTrace(this, CustomError);\n        else\n          Object.defineProperty(this, \"stack\", {\n            value: new Error().stack || \"\"\n          });\n        if (properties)\n          merge(this, properties);\n      }\n      CustomError.prototype = Object.create(Error.prototype, {\n        constructor: {\n          value: CustomError,\n          writable: true,\n          enumerable: false,\n          configurable: true\n        },\n        name: {\n          get: function get() {\n            return name;\n          },\n          set: void 0,\n          enumerable: false,\n          // configurable: false would accurately preserve the behavior of\n          // the original, but I'm guessing that was not intentional.\n          // For an actual error subclass, this property would\n          // be configurable.\n          configurable: true\n        },\n        toString: {\n          value: function value() {\n            return this.name + \": \" + this.message;\n          },\n          writable: true,\n          enumerable: false,\n          configurable: true\n        }\n      });\n      return CustomError;\n    }\n    util2.newError = newError;\n    util2.ProtocolError = newError(\"ProtocolError\");\n    util2.oneOfGetter = function getOneOf(fieldNames) {\n      var fieldMap = {};\n      for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n      return function() {\n        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)\n          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)\n            return keys[i2];\n      };\n    };\n    util2.oneOfSetter = function setOneOf(fieldNames) {\n      return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n          if (fieldNames[i] !== name)\n            delete this[fieldNames[i]];\n      };\n    };\n    util2.toJSONOptions = {\n      longs: String,\n      enums: String,\n      bytes: String,\n      json: true\n    };\n    util2._configure = function() {\n      var Buffer = util2.Buffer;\n      if (!Buffer) {\n        util2._Buffer_from = util2._Buffer_allocUnsafe = null;\n        return;\n      }\n      util2._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from || /* istanbul ignore next */\n      function Buffer_from(value, encoding) {\n        return new Buffer(value, encoding);\n      };\n      util2._Buffer_allocUnsafe = Buffer.allocUnsafe || /* istanbul ignore next */\n      function Buffer_allocUnsafe(size) {\n        return new Buffer(size);\n      };\n    };\n  })(minimal$1);\n  return minimal$1;\n}\nvar writer$2 = Writer$1;\nvar util$4 = requireMinimal();\nvar BufferWriter$1;\nvar LongBits$1 = util$4.LongBits;\nvar base64 = util$4.base64;\nvar utf8$1 = util$4.utf8;\nfunction Op(fn, len, val) {\n  this.fn = fn;\n  this.len = len;\n  this.next = void 0;\n  this.val = val;\n}\nfunction noop() {\n}\nfunction State(writer2) {\n  this.head = writer2.head;\n  this.tail = writer2.tail;\n  this.len = writer2.len;\n  this.next = writer2.states;\n}\nfunction Writer$1() {\n  this.len = 0;\n  this.head = new Op(noop, 0, 0);\n  this.tail = this.head;\n  this.states = null;\n}\nvar create$1 = function create() {\n  return util$4.Buffer ? function create_buffer_setup() {\n    return (Writer$1.create = function create_buffer() {\n      return new BufferWriter$1();\n    })();\n  } : function create_array3() {\n    return new Writer$1();\n  };\n};\nWriter$1.create = create$1();\nWriter$1.alloc = function alloc(size) {\n  return new util$4.Array(size);\n};\nif (util$4.Array !== Array)\n  Writer$1.alloc = util$4.pool(Writer$1.alloc, util$4.Array.prototype.subarray);\nWriter$1.prototype._push = function push(fn, len, val) {\n  this.tail = this.tail.next = new Op(fn, len, val);\n  this.len += len;\n  return this;\n};\nfunction writeByte(val, buf, pos) {\n  buf[pos] = val & 255;\n}\nfunction writeVarint32(val, buf, pos) {\n  while (val > 127) {\n    buf[pos++] = val & 127 | 128;\n    val >>>= 7;\n  }\n  buf[pos] = val;\n}\nfunction VarintOp(len, val) {\n  this.len = len;\n  this.next = void 0;\n  this.val = val;\n}\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\nWriter$1.prototype.uint32 = function write_uint32(value) {\n  this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;\n  return this;\n};\nWriter$1.prototype.int32 = function write_int32(value) {\n  return value < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(value)) : this.uint32(value);\n};\nWriter$1.prototype.sint32 = function write_sint32(value) {\n  return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\nfunction writeVarint64(val, buf, pos) {\n  while (val.hi) {\n    buf[pos++] = val.lo & 127 | 128;\n    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n    val.hi >>>= 7;\n  }\n  while (val.lo > 127) {\n    buf[pos++] = val.lo & 127 | 128;\n    val.lo = val.lo >>> 7;\n  }\n  buf[pos++] = val.lo;\n}\nWriter$1.prototype.uint64 = function write_uint64(value) {\n  var bits = LongBits$1.from(value);\n  return this._push(writeVarint64, bits.length(), bits);\n};\nWriter$1.prototype.int64 = Writer$1.prototype.uint64;\nWriter$1.prototype.sint64 = function write_sint64(value) {\n  var bits = LongBits$1.from(value).zzEncode();\n  return this._push(writeVarint64, bits.length(), bits);\n};\nWriter$1.prototype.bool = function write_bool(value) {\n  return this._push(writeByte, 1, value ? 1 : 0);\n};\nfunction writeFixed32(val, buf, pos) {\n  buf[pos] = val & 255;\n  buf[pos + 1] = val >>> 8 & 255;\n  buf[pos + 2] = val >>> 16 & 255;\n  buf[pos + 3] = val >>> 24;\n}\nWriter$1.prototype.fixed32 = function write_fixed32(value) {\n  return this._push(writeFixed32, 4, value >>> 0);\n};\nWriter$1.prototype.sfixed32 = Writer$1.prototype.fixed32;\nWriter$1.prototype.fixed64 = function write_fixed64(value) {\n  var bits = LongBits$1.from(value);\n  return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\nWriter$1.prototype.sfixed64 = Writer$1.prototype.fixed64;\nWriter$1.prototype.float = function write_float(value) {\n  return this._push(util$4.float.writeFloatLE, 4, value);\n};\nWriter$1.prototype.double = function write_double(value) {\n  return this._push(util$4.float.writeDoubleLE, 8, value);\n};\nvar writeBytes = util$4.Array.prototype.set ? function writeBytes_set(val, buf, pos) {\n  buf.set(val, pos);\n} : function writeBytes_for(val, buf, pos) {\n  for (var i = 0; i < val.length; ++i)\n    buf[pos + i] = val[i];\n};\nWriter$1.prototype.bytes = function write_bytes(value) {\n  var len = value.length >>> 0;\n  if (!len)\n    return this._push(writeByte, 1, 0);\n  if (util$4.isString(value)) {\n    var buf = Writer$1.alloc(len = base64.length(value));\n    base64.decode(value, buf, 0);\n    value = buf;\n  }\n  return this.uint32(len)._push(writeBytes, len, value);\n};\nWriter$1.prototype.string = function write_string(value) {\n  var len = utf8$1.length(value);\n  return len ? this.uint32(len)._push(utf8$1.write, len, value) : this._push(writeByte, 1, 0);\n};\nWriter$1.prototype.fork = function fork() {\n  this.states = new State(this);\n  this.head = this.tail = new Op(noop, 0, 0);\n  this.len = 0;\n  return this;\n};\nWriter$1.prototype.reset = function reset() {\n  if (this.states) {\n    this.head = this.states.head;\n    this.tail = this.states.tail;\n    this.len = this.states.len;\n    this.states = this.states.next;\n  } else {\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n  }\n  return this;\n};\nWriter$1.prototype.ldelim = function ldelim() {\n  var head = this.head, tail = this.tail, len = this.len;\n  this.reset().uint32(len);\n  if (len) {\n    this.tail.next = head.next;\n    this.tail = tail;\n    this.len += len;\n  }\n  return this;\n};\nWriter$1.prototype.finish = function finish() {\n  var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;\n  while (head) {\n    head.fn(head.val, buf, pos);\n    pos += head.len;\n    head = head.next;\n  }\n  return buf;\n};\nWriter$1._configure = function(BufferWriter_) {\n  BufferWriter$1 = BufferWriter_;\n  Writer$1.create = create$1();\n  BufferWriter$1._configure();\n};\nvar writer_buffer = BufferWriter;\nvar Writer = writer$2;\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\nvar util$3 = requireMinimal();\nfunction BufferWriter() {\n  Writer.call(this);\n}\nBufferWriter._configure = function() {\n  BufferWriter.alloc = util$3._Buffer_allocUnsafe;\n  BufferWriter.writeBytesBuffer = util$3.Buffer && util$3.Buffer.prototype instanceof Uint8Array && util$3.Buffer.prototype.set.name === \"set\" ? function writeBytesBuffer_set(val, buf, pos) {\n    buf.set(val, pos);\n  } : function writeBytesBuffer_copy(val, buf, pos) {\n    if (val.copy)\n      val.copy(buf, pos, 0, val.length);\n    else\n      for (var i = 0; i < val.length; )\n        buf[pos++] = val[i++];\n  };\n};\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n  if (util$3.isString(value))\n    value = util$3._Buffer_from(value, \"base64\");\n  var len = value.length >>> 0;\n  this.uint32(len);\n  if (len)\n    this._push(BufferWriter.writeBytesBuffer, len, value);\n  return this;\n};\nfunction writeStringBuffer(val, buf, pos) {\n  if (val.length < 40)\n    util$3.utf8.write(val, buf, pos);\n  else if (buf.utf8Write)\n    buf.utf8Write(val, pos);\n  else\n    buf.write(val, pos);\n}\nBufferWriter.prototype.string = function write_string_buffer(value) {\n  var len = util$3.Buffer.byteLength(value);\n  this.uint32(len);\n  if (len)\n    this._push(writeStringBuffer, len, value);\n  return this;\n};\nBufferWriter._configure();\nvar reader = Reader$1;\nvar util$2 = requireMinimal();\nvar BufferReader$1;\nvar LongBits = util$2.LongBits;\nvar utf8 = util$2.utf8;\nfunction indexOutOfRange(reader2, writeLength) {\n  return RangeError(\"index out of range: \" + reader2.pos + \" + \" + (writeLength || 1) + \" > \" + reader2.len);\n}\nfunction Reader$1(buffer) {\n  this.buf = buffer;\n  this.pos = 0;\n  this.len = buffer.length;\n}\nvar create_array = typeof Uint8Array !== \"undefined\" ? function create_typed_array(buffer) {\n  if (buffer instanceof Uint8Array || Array.isArray(buffer))\n    return new Reader$1(buffer);\n  throw Error(\"illegal buffer\");\n} : function create_array2(buffer) {\n  if (Array.isArray(buffer))\n    return new Reader$1(buffer);\n  throw Error(\"illegal buffer\");\n};\nvar create2 = function create3() {\n  return util$2.Buffer ? function create_buffer_setup(buffer) {\n    return (Reader$1.create = function create_buffer(buffer2) {\n      return util$2.Buffer.isBuffer(buffer2) ? new BufferReader$1(buffer2) : create_array(buffer2);\n    })(buffer);\n  } : create_array;\n};\nReader$1.create = create2();\nReader$1.prototype._slice = util$2.Array.prototype.subarray || /* istanbul ignore next */\nutil$2.Array.prototype.slice;\nReader$1.prototype.uint32 = function read_uint32_setup() {\n  var value = 4294967295;\n  return function read_uint32() {\n    value = (this.buf[this.pos] & 127) >>> 0;\n    if (this.buf[this.pos++] < 128)\n      return value;\n    value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;\n    if (this.buf[this.pos++] < 128)\n      return value;\n    value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;\n    if (this.buf[this.pos++] < 128)\n      return value;\n    value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;\n    if (this.buf[this.pos++] < 128)\n      return value;\n    value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;\n    if (this.buf[this.pos++] < 128)\n      return value;\n    if ((this.pos += 5) > this.len) {\n      this.pos = this.len;\n      throw indexOutOfRange(this, 10);\n    }\n    return value;\n  };\n}();\nReader$1.prototype.int32 = function read_int32() {\n  return this.uint32() | 0;\n};\nReader$1.prototype.sint32 = function read_sint32() {\n  var value = this.uint32();\n  return value >>> 1 ^ -(value & 1) | 0;\n};\nfunction readLongVarint() {\n  var bits = new LongBits(0, 0);\n  var i = 0;\n  if (this.len - this.pos > 4) {\n    for (; i < 4; ++i) {\n      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n      if (this.buf[this.pos++] < 128)\n        return bits;\n    }\n    bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n    bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;\n    if (this.buf[this.pos++] < 128)\n      return bits;\n    i = 0;\n  } else {\n    for (; i < 3; ++i) {\n      if (this.pos >= this.len)\n        throw indexOutOfRange(this);\n      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n      if (this.buf[this.pos++] < 128)\n        return bits;\n    }\n    bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n    return bits;\n  }\n  if (this.len - this.pos > 4) {\n    for (; i < 5; ++i) {\n      bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n      if (this.buf[this.pos++] < 128)\n        return bits;\n    }\n  } else {\n    for (; i < 5; ++i) {\n      if (this.pos >= this.len)\n        throw indexOutOfRange(this);\n      bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n      if (this.buf[this.pos++] < 128)\n        return bits;\n    }\n  }\n  throw Error(\"invalid varint encoding\");\n}\nReader$1.prototype.bool = function read_bool() {\n  return this.uint32() !== 0;\n};\nfunction readFixed32_end(buf, end2) {\n  return (buf[end2 - 4] | buf[end2 - 3] << 8 | buf[end2 - 2] << 16 | buf[end2 - 1] << 24) >>> 0;\n}\nReader$1.prototype.fixed32 = function read_fixed32() {\n  if (this.pos + 4 > this.len)\n    throw indexOutOfRange(this, 4);\n  return readFixed32_end(this.buf, this.pos += 4);\n};\nReader$1.prototype.sfixed32 = function read_sfixed32() {\n  if (this.pos + 4 > this.len)\n    throw indexOutOfRange(this, 4);\n  return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\nfunction readFixed64() {\n  if (this.pos + 8 > this.len)\n    throw indexOutOfRange(this, 8);\n  return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\nReader$1.prototype.float = function read_float() {\n  if (this.pos + 4 > this.len)\n    throw indexOutOfRange(this, 4);\n  var value = util$2.float.readFloatLE(this.buf, this.pos);\n  this.pos += 4;\n  return value;\n};\nReader$1.prototype.double = function read_double() {\n  if (this.pos + 8 > this.len)\n    throw indexOutOfRange(this, 4);\n  var value = util$2.float.readDoubleLE(this.buf, this.pos);\n  this.pos += 8;\n  return value;\n};\nReader$1.prototype.bytes = function read_bytes() {\n  var length = this.uint32(), start = this.pos, end2 = this.pos + length;\n  if (end2 > this.len)\n    throw indexOutOfRange(this, length);\n  this.pos += length;\n  if (Array.isArray(this.buf))\n    return this.buf.slice(start, end2);\n  return start === end2 ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end2);\n};\nReader$1.prototype.string = function read_string() {\n  var bytes = this.bytes();\n  return utf8.read(bytes, 0, bytes.length);\n};\nReader$1.prototype.skip = function skip(length) {\n  if (typeof length === \"number\") {\n    if (this.pos + length > this.len)\n      throw indexOutOfRange(this, length);\n    this.pos += length;\n  } else {\n    do {\n      if (this.pos >= this.len)\n        throw indexOutOfRange(this);\n    } while (this.buf[this.pos++] & 128);\n  }\n  return this;\n};\nReader$1.prototype.skipType = function(wireType) {\n  switch (wireType) {\n    case 0:\n      this.skip();\n      break;\n    case 1:\n      this.skip(8);\n      break;\n    case 2:\n      this.skip(this.uint32());\n      break;\n    case 3:\n      while ((wireType = this.uint32() & 7) !== 4) {\n        this.skipType(wireType);\n      }\n      break;\n    case 5:\n      this.skip(4);\n      break;\n    default:\n      throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n  }\n  return this;\n};\nReader$1._configure = function(BufferReader_) {\n  BufferReader$1 = BufferReader_;\n  Reader$1.create = create2();\n  BufferReader$1._configure();\n  var fn = util$2.Long ? \"toLong\" : (\n    /* istanbul ignore next */\n    \"toNumber\"\n  );\n  util$2.merge(Reader$1.prototype, {\n    int64: function read_int64() {\n      return readLongVarint.call(this)[fn](false);\n    },\n    uint64: function read_uint64() {\n      return readLongVarint.call(this)[fn](true);\n    },\n    sint64: function read_sint64() {\n      return readLongVarint.call(this).zzDecode()[fn](false);\n    },\n    fixed64: function read_fixed64() {\n      return readFixed64.call(this)[fn](true);\n    },\n    sfixed64: function read_sfixed64() {\n      return readFixed64.call(this)[fn](false);\n    }\n  });\n};\nvar reader_buffer = BufferReader;\nvar Reader = reader;\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\nvar util$1 = requireMinimal();\nfunction BufferReader(buffer) {\n  Reader.call(this, buffer);\n}\nBufferReader._configure = function() {\n  if (util$1.Buffer)\n    BufferReader.prototype._slice = util$1.Buffer.prototype.slice;\n};\nBufferReader.prototype.string = function read_string_buffer() {\n  var len = this.uint32();\n  return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\nBufferReader._configure();\nvar rpc = {};\nvar service = Service;\nvar util = requireMinimal();\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n  if (typeof rpcImpl !== \"function\")\n    throw TypeError(\"rpcImpl must be a function\");\n  util.EventEmitter.call(this);\n  this.rpcImpl = rpcImpl;\n  this.requestDelimited = Boolean(requestDelimited);\n  this.responseDelimited = Boolean(responseDelimited);\n}\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n  if (!request)\n    throw TypeError(\"request must be specified\");\n  var self2 = this;\n  if (!callback)\n    return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);\n  if (!self2.rpcImpl) {\n    setTimeout(function() {\n      callback(Error(\"already ended\"));\n    }, 0);\n    return void 0;\n  }\n  try {\n    return self2.rpcImpl(method, requestCtor[self2.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(), function rpcCallback(err, response) {\n      if (err) {\n        self2.emit(\"error\", err, method);\n        return callback(err);\n      }\n      if (response === null) {\n        self2.end(\n          /* endedByRPC */\n          true\n        );\n        return void 0;\n      }\n      if (!(response instanceof responseCtor)) {\n        try {\n          response = responseCtor[self2.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n        } catch (err2) {\n          self2.emit(\"error\", err2, method);\n          return callback(err2);\n        }\n      }\n      self2.emit(\"data\", response, method);\n      return callback(null, response);\n    });\n  } catch (err) {\n    self2.emit(\"error\", err, method);\n    setTimeout(function() {\n      callback(err);\n    }, 0);\n    return void 0;\n  }\n};\nService.prototype.end = function end(endedByRPC) {\n  if (this.rpcImpl) {\n    if (!endedByRPC)\n      this.rpcImpl(null, null, null);\n    this.rpcImpl = null;\n    this.emit(\"end\").off();\n  }\n  return this;\n};\n(function(exports) {\n  var rpc2 = exports;\n  rpc2.Service = service;\n})(rpc);\nvar roots = {};\n(function(exports) {\n  var protobuf = exports;\n  protobuf.build = \"minimal\";\n  protobuf.Writer = writer$2;\n  protobuf.BufferWriter = writer_buffer;\n  protobuf.Reader = reader;\n  protobuf.BufferReader = reader_buffer;\n  protobuf.util = requireMinimal();\n  protobuf.rpc = rpc;\n  protobuf.roots = roots;\n  protobuf.configure = configure;\n  function configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n  }\n  configure();\n})(indexMinimal);\nvar minimal = indexMinimal;\nvar _m0 = getDefaultExportFromCjs(minimal);\n(() => {\n  if (typeof globalThis !== \"undefined\") {\n    return globalThis;\n  }\n  if (typeof self !== \"undefined\") {\n    return self;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n  throw \"Unable to locate global object\";\n})();\nif (_m0.util.Long !== Long$1) {\n  _m0.util.Long = Long$1;\n  _m0.configure();\n}\nvar AudioCodec;\n(function(AudioCodec2) {\n  AudioCodec2[AudioCodec2[\"DEFAULT_AC\"] = 0] = \"DEFAULT_AC\";\n  AudioCodec2[AudioCodec2[\"OPUS\"] = 1] = \"OPUS\";\n  AudioCodec2[AudioCodec2[\"AAC\"] = 2] = \"AAC\";\n  AudioCodec2[AudioCodec2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(AudioCodec || (AudioCodec = {}));\nvar VideoCodec;\n(function(VideoCodec2) {\n  VideoCodec2[VideoCodec2[\"DEFAULT_VC\"] = 0] = \"DEFAULT_VC\";\n  VideoCodec2[VideoCodec2[\"H264_BASELINE\"] = 1] = \"H264_BASELINE\";\n  VideoCodec2[VideoCodec2[\"H264_MAIN\"] = 2] = \"H264_MAIN\";\n  VideoCodec2[VideoCodec2[\"H264_HIGH\"] = 3] = \"H264_HIGH\";\n  VideoCodec2[VideoCodec2[\"VP8\"] = 4] = \"VP8\";\n  VideoCodec2[VideoCodec2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(VideoCodec || (VideoCodec = {}));\nvar TrackType;\n(function(TrackType2) {\n  TrackType2[TrackType2[\"AUDIO\"] = 0] = \"AUDIO\";\n  TrackType2[TrackType2[\"VIDEO\"] = 1] = \"VIDEO\";\n  TrackType2[TrackType2[\"DATA\"] = 2] = \"DATA\";\n  TrackType2[TrackType2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(TrackType || (TrackType = {}));\nfunction trackTypeFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"AUDIO\":\n      return TrackType.AUDIO;\n    case 1:\n    case \"VIDEO\":\n      return TrackType.VIDEO;\n    case 2:\n    case \"DATA\":\n      return TrackType.DATA;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return TrackType.UNRECOGNIZED;\n  }\n}\nfunction trackTypeToJSON(object) {\n  switch (object) {\n    case TrackType.AUDIO:\n      return \"AUDIO\";\n    case TrackType.VIDEO:\n      return \"VIDEO\";\n    case TrackType.DATA:\n      return \"DATA\";\n    case TrackType.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar TrackSource;\n(function(TrackSource2) {\n  TrackSource2[TrackSource2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  TrackSource2[TrackSource2[\"CAMERA\"] = 1] = \"CAMERA\";\n  TrackSource2[TrackSource2[\"MICROPHONE\"] = 2] = \"MICROPHONE\";\n  TrackSource2[TrackSource2[\"SCREEN_SHARE\"] = 3] = \"SCREEN_SHARE\";\n  TrackSource2[TrackSource2[\"SCREEN_SHARE_AUDIO\"] = 4] = \"SCREEN_SHARE_AUDIO\";\n  TrackSource2[TrackSource2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(TrackSource || (TrackSource = {}));\nfunction trackSourceFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"UNKNOWN\":\n      return TrackSource.UNKNOWN;\n    case 1:\n    case \"CAMERA\":\n      return TrackSource.CAMERA;\n    case 2:\n    case \"MICROPHONE\":\n      return TrackSource.MICROPHONE;\n    case 3:\n    case \"SCREEN_SHARE\":\n      return TrackSource.SCREEN_SHARE;\n    case 4:\n    case \"SCREEN_SHARE_AUDIO\":\n      return TrackSource.SCREEN_SHARE_AUDIO;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return TrackSource.UNRECOGNIZED;\n  }\n}\nfunction trackSourceToJSON(object) {\n  switch (object) {\n    case TrackSource.UNKNOWN:\n      return \"UNKNOWN\";\n    case TrackSource.CAMERA:\n      return \"CAMERA\";\n    case TrackSource.MICROPHONE:\n      return \"MICROPHONE\";\n    case TrackSource.SCREEN_SHARE:\n      return \"SCREEN_SHARE\";\n    case TrackSource.SCREEN_SHARE_AUDIO:\n      return \"SCREEN_SHARE_AUDIO\";\n    case TrackSource.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar VideoQuality;\n(function(VideoQuality2) {\n  VideoQuality2[VideoQuality2[\"LOW\"] = 0] = \"LOW\";\n  VideoQuality2[VideoQuality2[\"MEDIUM\"] = 1] = \"MEDIUM\";\n  VideoQuality2[VideoQuality2[\"HIGH\"] = 2] = \"HIGH\";\n  VideoQuality2[VideoQuality2[\"OFF\"] = 3] = \"OFF\";\n  VideoQuality2[VideoQuality2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(VideoQuality || (VideoQuality = {}));\nfunction videoQualityFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"LOW\":\n      return VideoQuality.LOW;\n    case 1:\n    case \"MEDIUM\":\n      return VideoQuality.MEDIUM;\n    case 2:\n    case \"HIGH\":\n      return VideoQuality.HIGH;\n    case 3:\n    case \"OFF\":\n      return VideoQuality.OFF;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return VideoQuality.UNRECOGNIZED;\n  }\n}\nfunction videoQualityToJSON(object) {\n  switch (object) {\n    case VideoQuality.LOW:\n      return \"LOW\";\n    case VideoQuality.MEDIUM:\n      return \"MEDIUM\";\n    case VideoQuality.HIGH:\n      return \"HIGH\";\n    case VideoQuality.OFF:\n      return \"OFF\";\n    case VideoQuality.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar ConnectionQuality$1;\n(function(ConnectionQuality2) {\n  ConnectionQuality2[ConnectionQuality2[\"POOR\"] = 0] = \"POOR\";\n  ConnectionQuality2[ConnectionQuality2[\"GOOD\"] = 1] = \"GOOD\";\n  ConnectionQuality2[ConnectionQuality2[\"EXCELLENT\"] = 2] = \"EXCELLENT\";\n  ConnectionQuality2[ConnectionQuality2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(ConnectionQuality$1 || (ConnectionQuality$1 = {}));\nfunction connectionQualityFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"POOR\":\n      return ConnectionQuality$1.POOR;\n    case 1:\n    case \"GOOD\":\n      return ConnectionQuality$1.GOOD;\n    case 2:\n    case \"EXCELLENT\":\n      return ConnectionQuality$1.EXCELLENT;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return ConnectionQuality$1.UNRECOGNIZED;\n  }\n}\nfunction connectionQualityToJSON(object) {\n  switch (object) {\n    case ConnectionQuality$1.POOR:\n      return \"POOR\";\n    case ConnectionQuality$1.GOOD:\n      return \"GOOD\";\n    case ConnectionQuality$1.EXCELLENT:\n      return \"EXCELLENT\";\n    case ConnectionQuality$1.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar ClientConfigSetting;\n(function(ClientConfigSetting2) {\n  ClientConfigSetting2[ClientConfigSetting2[\"UNSET\"] = 0] = \"UNSET\";\n  ClientConfigSetting2[ClientConfigSetting2[\"DISABLED\"] = 1] = \"DISABLED\";\n  ClientConfigSetting2[ClientConfigSetting2[\"ENABLED\"] = 2] = \"ENABLED\";\n  ClientConfigSetting2[ClientConfigSetting2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(ClientConfigSetting || (ClientConfigSetting = {}));\nfunction clientConfigSettingFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"UNSET\":\n      return ClientConfigSetting.UNSET;\n    case 1:\n    case \"DISABLED\":\n      return ClientConfigSetting.DISABLED;\n    case 2:\n    case \"ENABLED\":\n      return ClientConfigSetting.ENABLED;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return ClientConfigSetting.UNRECOGNIZED;\n  }\n}\nfunction clientConfigSettingToJSON(object) {\n  switch (object) {\n    case ClientConfigSetting.UNSET:\n      return \"UNSET\";\n    case ClientConfigSetting.DISABLED:\n      return \"DISABLED\";\n    case ClientConfigSetting.ENABLED:\n      return \"ENABLED\";\n    case ClientConfigSetting.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar DisconnectReason;\n(function(DisconnectReason2) {\n  DisconnectReason2[DisconnectReason2[\"UNKNOWN_REASON\"] = 0] = \"UNKNOWN_REASON\";\n  DisconnectReason2[DisconnectReason2[\"CLIENT_INITIATED\"] = 1] = \"CLIENT_INITIATED\";\n  DisconnectReason2[DisconnectReason2[\"DUPLICATE_IDENTITY\"] = 2] = \"DUPLICATE_IDENTITY\";\n  DisconnectReason2[DisconnectReason2[\"SERVER_SHUTDOWN\"] = 3] = \"SERVER_SHUTDOWN\";\n  DisconnectReason2[DisconnectReason2[\"PARTICIPANT_REMOVED\"] = 4] = \"PARTICIPANT_REMOVED\";\n  DisconnectReason2[DisconnectReason2[\"ROOM_DELETED\"] = 5] = \"ROOM_DELETED\";\n  DisconnectReason2[DisconnectReason2[\"STATE_MISMATCH\"] = 6] = \"STATE_MISMATCH\";\n  DisconnectReason2[DisconnectReason2[\"JOIN_FAILURE\"] = 7] = \"JOIN_FAILURE\";\n  DisconnectReason2[DisconnectReason2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(DisconnectReason || (DisconnectReason = {}));\nfunction disconnectReasonFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"UNKNOWN_REASON\":\n      return DisconnectReason.UNKNOWN_REASON;\n    case 1:\n    case \"CLIENT_INITIATED\":\n      return DisconnectReason.CLIENT_INITIATED;\n    case 2:\n    case \"DUPLICATE_IDENTITY\":\n      return DisconnectReason.DUPLICATE_IDENTITY;\n    case 3:\n    case \"SERVER_SHUTDOWN\":\n      return DisconnectReason.SERVER_SHUTDOWN;\n    case 4:\n    case \"PARTICIPANT_REMOVED\":\n      return DisconnectReason.PARTICIPANT_REMOVED;\n    case 5:\n    case \"ROOM_DELETED\":\n      return DisconnectReason.ROOM_DELETED;\n    case 6:\n    case \"STATE_MISMATCH\":\n      return DisconnectReason.STATE_MISMATCH;\n    case 7:\n    case \"JOIN_FAILURE\":\n      return DisconnectReason.JOIN_FAILURE;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return DisconnectReason.UNRECOGNIZED;\n  }\n}\nfunction disconnectReasonToJSON(object) {\n  switch (object) {\n    case DisconnectReason.UNKNOWN_REASON:\n      return \"UNKNOWN_REASON\";\n    case DisconnectReason.CLIENT_INITIATED:\n      return \"CLIENT_INITIATED\";\n    case DisconnectReason.DUPLICATE_IDENTITY:\n      return \"DUPLICATE_IDENTITY\";\n    case DisconnectReason.SERVER_SHUTDOWN:\n      return \"SERVER_SHUTDOWN\";\n    case DisconnectReason.PARTICIPANT_REMOVED:\n      return \"PARTICIPANT_REMOVED\";\n    case DisconnectReason.ROOM_DELETED:\n      return \"ROOM_DELETED\";\n    case DisconnectReason.STATE_MISMATCH:\n      return \"STATE_MISMATCH\";\n    case DisconnectReason.JOIN_FAILURE:\n      return \"JOIN_FAILURE\";\n    case DisconnectReason.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar ReconnectReason;\n(function(ReconnectReason2) {\n  ReconnectReason2[ReconnectReason2[\"RR_UNKOWN\"] = 0] = \"RR_UNKOWN\";\n  ReconnectReason2[ReconnectReason2[\"RR_SIGNAL_DISCONNECTED\"] = 1] = \"RR_SIGNAL_DISCONNECTED\";\n  ReconnectReason2[ReconnectReason2[\"RR_PUBLISHER_FAILED\"] = 2] = \"RR_PUBLISHER_FAILED\";\n  ReconnectReason2[ReconnectReason2[\"RR_SUBSCRIBER_FAILED\"] = 3] = \"RR_SUBSCRIBER_FAILED\";\n  ReconnectReason2[ReconnectReason2[\"RR_SWITCH_CANDIDATE\"] = 4] = \"RR_SWITCH_CANDIDATE\";\n  ReconnectReason2[ReconnectReason2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(ReconnectReason || (ReconnectReason = {}));\nvar ParticipantInfo_State;\n(function(ParticipantInfo_State2) {\n  ParticipantInfo_State2[ParticipantInfo_State2[\"JOINING\"] = 0] = \"JOINING\";\n  ParticipantInfo_State2[ParticipantInfo_State2[\"JOINED\"] = 1] = \"JOINED\";\n  ParticipantInfo_State2[ParticipantInfo_State2[\"ACTIVE\"] = 2] = \"ACTIVE\";\n  ParticipantInfo_State2[ParticipantInfo_State2[\"DISCONNECTED\"] = 3] = \"DISCONNECTED\";\n  ParticipantInfo_State2[ParticipantInfo_State2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(ParticipantInfo_State || (ParticipantInfo_State = {}));\nfunction participantInfo_StateFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"JOINING\":\n      return ParticipantInfo_State.JOINING;\n    case 1:\n    case \"JOINED\":\n      return ParticipantInfo_State.JOINED;\n    case 2:\n    case \"ACTIVE\":\n      return ParticipantInfo_State.ACTIVE;\n    case 3:\n    case \"DISCONNECTED\":\n      return ParticipantInfo_State.DISCONNECTED;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return ParticipantInfo_State.UNRECOGNIZED;\n  }\n}\nfunction participantInfo_StateToJSON(object) {\n  switch (object) {\n    case ParticipantInfo_State.JOINING:\n      return \"JOINING\";\n    case ParticipantInfo_State.JOINED:\n      return \"JOINED\";\n    case ParticipantInfo_State.ACTIVE:\n      return \"ACTIVE\";\n    case ParticipantInfo_State.DISCONNECTED:\n      return \"DISCONNECTED\";\n    case ParticipantInfo_State.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar Encryption_Type;\n(function(Encryption_Type2) {\n  Encryption_Type2[Encryption_Type2[\"NONE\"] = 0] = \"NONE\";\n  Encryption_Type2[Encryption_Type2[\"GCM\"] = 1] = \"GCM\";\n  Encryption_Type2[Encryption_Type2[\"CUSTOM\"] = 2] = \"CUSTOM\";\n  Encryption_Type2[Encryption_Type2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(Encryption_Type || (Encryption_Type = {}));\nfunction encryption_TypeFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"NONE\":\n      return Encryption_Type.NONE;\n    case 1:\n    case \"GCM\":\n      return Encryption_Type.GCM;\n    case 2:\n    case \"CUSTOM\":\n      return Encryption_Type.CUSTOM;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return Encryption_Type.UNRECOGNIZED;\n  }\n}\nfunction encryption_TypeToJSON(object) {\n  switch (object) {\n    case Encryption_Type.NONE:\n      return \"NONE\";\n    case Encryption_Type.GCM:\n      return \"GCM\";\n    case Encryption_Type.CUSTOM:\n      return \"CUSTOM\";\n    case Encryption_Type.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar DataPacket_Kind;\n(function(DataPacket_Kind2) {\n  DataPacket_Kind2[DataPacket_Kind2[\"RELIABLE\"] = 0] = \"RELIABLE\";\n  DataPacket_Kind2[DataPacket_Kind2[\"LOSSY\"] = 1] = \"LOSSY\";\n  DataPacket_Kind2[DataPacket_Kind2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(DataPacket_Kind || (DataPacket_Kind = {}));\nfunction dataPacket_KindFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"RELIABLE\":\n      return DataPacket_Kind.RELIABLE;\n    case 1:\n    case \"LOSSY\":\n      return DataPacket_Kind.LOSSY;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return DataPacket_Kind.UNRECOGNIZED;\n  }\n}\nfunction dataPacket_KindToJSON(object) {\n  switch (object) {\n    case DataPacket_Kind.RELIABLE:\n      return \"RELIABLE\";\n    case DataPacket_Kind.LOSSY:\n      return \"LOSSY\";\n    case DataPacket_Kind.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar ServerInfo_Edition;\n(function(ServerInfo_Edition2) {\n  ServerInfo_Edition2[ServerInfo_Edition2[\"Standard\"] = 0] = \"Standard\";\n  ServerInfo_Edition2[ServerInfo_Edition2[\"Cloud\"] = 1] = \"Cloud\";\n  ServerInfo_Edition2[ServerInfo_Edition2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(ServerInfo_Edition || (ServerInfo_Edition = {}));\nfunction serverInfo_EditionFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"Standard\":\n      return ServerInfo_Edition.Standard;\n    case 1:\n    case \"Cloud\":\n      return ServerInfo_Edition.Cloud;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return ServerInfo_Edition.UNRECOGNIZED;\n  }\n}\nfunction serverInfo_EditionToJSON(object) {\n  switch (object) {\n    case ServerInfo_Edition.Standard:\n      return \"Standard\";\n    case ServerInfo_Edition.Cloud:\n      return \"Cloud\";\n    case ServerInfo_Edition.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar ClientInfo_SDK;\n(function(ClientInfo_SDK2) {\n  ClientInfo_SDK2[ClientInfo_SDK2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  ClientInfo_SDK2[ClientInfo_SDK2[\"JS\"] = 1] = \"JS\";\n  ClientInfo_SDK2[ClientInfo_SDK2[\"SWIFT\"] = 2] = \"SWIFT\";\n  ClientInfo_SDK2[ClientInfo_SDK2[\"ANDROID\"] = 3] = \"ANDROID\";\n  ClientInfo_SDK2[ClientInfo_SDK2[\"FLUTTER\"] = 4] = \"FLUTTER\";\n  ClientInfo_SDK2[ClientInfo_SDK2[\"GO\"] = 5] = \"GO\";\n  ClientInfo_SDK2[ClientInfo_SDK2[\"UNITY\"] = 6] = \"UNITY\";\n  ClientInfo_SDK2[ClientInfo_SDK2[\"REACT_NATIVE\"] = 7] = \"REACT_NATIVE\";\n  ClientInfo_SDK2[ClientInfo_SDK2[\"RUST\"] = 8] = \"RUST\";\n  ClientInfo_SDK2[ClientInfo_SDK2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(ClientInfo_SDK || (ClientInfo_SDK = {}));\nfunction clientInfo_SDKFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"UNKNOWN\":\n      return ClientInfo_SDK.UNKNOWN;\n    case 1:\n    case \"JS\":\n      return ClientInfo_SDK.JS;\n    case 2:\n    case \"SWIFT\":\n      return ClientInfo_SDK.SWIFT;\n    case 3:\n    case \"ANDROID\":\n      return ClientInfo_SDK.ANDROID;\n    case 4:\n    case \"FLUTTER\":\n      return ClientInfo_SDK.FLUTTER;\n    case 5:\n    case \"GO\":\n      return ClientInfo_SDK.GO;\n    case 6:\n    case \"UNITY\":\n      return ClientInfo_SDK.UNITY;\n    case 7:\n    case \"REACT_NATIVE\":\n      return ClientInfo_SDK.REACT_NATIVE;\n    case 8:\n    case \"RUST\":\n      return ClientInfo_SDK.RUST;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return ClientInfo_SDK.UNRECOGNIZED;\n  }\n}\nfunction clientInfo_SDKToJSON(object) {\n  switch (object) {\n    case ClientInfo_SDK.UNKNOWN:\n      return \"UNKNOWN\";\n    case ClientInfo_SDK.JS:\n      return \"JS\";\n    case ClientInfo_SDK.SWIFT:\n      return \"SWIFT\";\n    case ClientInfo_SDK.ANDROID:\n      return \"ANDROID\";\n    case ClientInfo_SDK.FLUTTER:\n      return \"FLUTTER\";\n    case ClientInfo_SDK.GO:\n      return \"GO\";\n    case ClientInfo_SDK.UNITY:\n      return \"UNITY\";\n    case ClientInfo_SDK.REACT_NATIVE:\n      return \"REACT_NATIVE\";\n    case ClientInfo_SDK.RUST:\n      return \"RUST\";\n    case ClientInfo_SDK.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nfunction createBaseRoom() {\n  return {\n    sid: \"\",\n    name: \"\",\n    emptyTimeout: 0,\n    maxParticipants: 0,\n    creationTime: 0,\n    turnPassword: \"\",\n    enabledCodecs: [],\n    metadata: \"\",\n    numParticipants: 0,\n    numPublishers: 0,\n    activeRecording: false\n  };\n}\nvar Room$1 = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.sid !== \"\") {\n      writer2.uint32(10).string(message.sid);\n    }\n    if (message.name !== \"\") {\n      writer2.uint32(18).string(message.name);\n    }\n    if (message.emptyTimeout !== 0) {\n      writer2.uint32(24).uint32(message.emptyTimeout);\n    }\n    if (message.maxParticipants !== 0) {\n      writer2.uint32(32).uint32(message.maxParticipants);\n    }\n    if (message.creationTime !== 0) {\n      writer2.uint32(40).int64(message.creationTime);\n    }\n    if (message.turnPassword !== \"\") {\n      writer2.uint32(50).string(message.turnPassword);\n    }\n    for (const v of message.enabledCodecs) {\n      Codec.encode(v, writer2.uint32(58).fork()).ldelim();\n    }\n    if (message.metadata !== \"\") {\n      writer2.uint32(66).string(message.metadata);\n    }\n    if (message.numParticipants !== 0) {\n      writer2.uint32(72).uint32(message.numParticipants);\n    }\n    if (message.numPublishers !== 0) {\n      writer2.uint32(88).uint32(message.numPublishers);\n    }\n    if (message.activeRecording === true) {\n      writer2.uint32(80).bool(message.activeRecording);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseRoom();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.sid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.name = reader2.string();\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.emptyTimeout = reader2.uint32();\n          continue;\n        case 4:\n          if (tag != 32) {\n            break;\n          }\n          message.maxParticipants = reader2.uint32();\n          continue;\n        case 5:\n          if (tag != 40) {\n            break;\n          }\n          message.creationTime = longToNumber$1(reader2.int64());\n          continue;\n        case 6:\n          if (tag != 50) {\n            break;\n          }\n          message.turnPassword = reader2.string();\n          continue;\n        case 7:\n          if (tag != 58) {\n            break;\n          }\n          message.enabledCodecs.push(Codec.decode(reader2, reader2.uint32()));\n          continue;\n        case 8:\n          if (tag != 66) {\n            break;\n          }\n          message.metadata = reader2.string();\n          continue;\n        case 9:\n          if (tag != 72) {\n            break;\n          }\n          message.numParticipants = reader2.uint32();\n          continue;\n        case 11:\n          if (tag != 88) {\n            break;\n          }\n          message.numPublishers = reader2.uint32();\n          continue;\n        case 10:\n          if (tag != 80) {\n            break;\n          }\n          message.activeRecording = reader2.bool();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      sid: isSet$1(object.sid) ? String(object.sid) : \"\",\n      name: isSet$1(object.name) ? String(object.name) : \"\",\n      emptyTimeout: isSet$1(object.emptyTimeout) ? Number(object.emptyTimeout) : 0,\n      maxParticipants: isSet$1(object.maxParticipants) ? Number(object.maxParticipants) : 0,\n      creationTime: isSet$1(object.creationTime) ? Number(object.creationTime) : 0,\n      turnPassword: isSet$1(object.turnPassword) ? String(object.turnPassword) : \"\",\n      enabledCodecs: Array.isArray(object === null || object === void 0 ? void 0 : object.enabledCodecs) ? object.enabledCodecs.map((e) => Codec.fromJSON(e)) : [],\n      metadata: isSet$1(object.metadata) ? String(object.metadata) : \"\",\n      numParticipants: isSet$1(object.numParticipants) ? Number(object.numParticipants) : 0,\n      numPublishers: isSet$1(object.numPublishers) ? Number(object.numPublishers) : 0,\n      activeRecording: isSet$1(object.activeRecording) ? Boolean(object.activeRecording) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.sid !== void 0 && (obj.sid = message.sid);\n    message.name !== void 0 && (obj.name = message.name);\n    message.emptyTimeout !== void 0 && (obj.emptyTimeout = Math.round(message.emptyTimeout));\n    message.maxParticipants !== void 0 && (obj.maxParticipants = Math.round(message.maxParticipants));\n    message.creationTime !== void 0 && (obj.creationTime = Math.round(message.creationTime));\n    message.turnPassword !== void 0 && (obj.turnPassword = message.turnPassword);\n    if (message.enabledCodecs) {\n      obj.enabledCodecs = message.enabledCodecs.map((e) => e ? Codec.toJSON(e) : void 0);\n    } else {\n      obj.enabledCodecs = [];\n    }\n    message.metadata !== void 0 && (obj.metadata = message.metadata);\n    message.numParticipants !== void 0 && (obj.numParticipants = Math.round(message.numParticipants));\n    message.numPublishers !== void 0 && (obj.numPublishers = Math.round(message.numPublishers));\n    message.activeRecording !== void 0 && (obj.activeRecording = message.activeRecording);\n    return obj;\n  },\n  create(base) {\n    return Room$1.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n    const message = createBaseRoom();\n    message.sid = (_a = object.sid) !== null && _a !== void 0 ? _a : \"\";\n    message.name = (_b = object.name) !== null && _b !== void 0 ? _b : \"\";\n    message.emptyTimeout = (_c = object.emptyTimeout) !== null && _c !== void 0 ? _c : 0;\n    message.maxParticipants = (_d = object.maxParticipants) !== null && _d !== void 0 ? _d : 0;\n    message.creationTime = (_e = object.creationTime) !== null && _e !== void 0 ? _e : 0;\n    message.turnPassword = (_f = object.turnPassword) !== null && _f !== void 0 ? _f : \"\";\n    message.enabledCodecs = ((_g = object.enabledCodecs) === null || _g === void 0 ? void 0 : _g.map((e) => Codec.fromPartial(e))) || [];\n    message.metadata = (_h = object.metadata) !== null && _h !== void 0 ? _h : \"\";\n    message.numParticipants = (_j = object.numParticipants) !== null && _j !== void 0 ? _j : 0;\n    message.numPublishers = (_k = object.numPublishers) !== null && _k !== void 0 ? _k : 0;\n    message.activeRecording = (_l = object.activeRecording) !== null && _l !== void 0 ? _l : false;\n    return message;\n  }\n};\nfunction createBaseCodec() {\n  return {\n    mime: \"\",\n    fmtpLine: \"\"\n  };\n}\nvar Codec = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.mime !== \"\") {\n      writer2.uint32(10).string(message.mime);\n    }\n    if (message.fmtpLine !== \"\") {\n      writer2.uint32(18).string(message.fmtpLine);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseCodec();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.mime = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.fmtpLine = reader2.string();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      mime: isSet$1(object.mime) ? String(object.mime) : \"\",\n      fmtpLine: isSet$1(object.fmtpLine) ? String(object.fmtpLine) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.mime !== void 0 && (obj.mime = message.mime);\n    message.fmtpLine !== void 0 && (obj.fmtpLine = message.fmtpLine);\n    return obj;\n  },\n  create(base) {\n    return Codec.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseCodec();\n    message.mime = (_a = object.mime) !== null && _a !== void 0 ? _a : \"\";\n    message.fmtpLine = (_b = object.fmtpLine) !== null && _b !== void 0 ? _b : \"\";\n    return message;\n  }\n};\nfunction createBaseParticipantPermission() {\n  return {\n    canSubscribe: false,\n    canPublish: false,\n    canPublishData: false,\n    canPublishSources: [],\n    hidden: false,\n    recorder: false,\n    canUpdateMetadata: false\n  };\n}\nvar ParticipantPermission = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.canSubscribe === true) {\n      writer2.uint32(8).bool(message.canSubscribe);\n    }\n    if (message.canPublish === true) {\n      writer2.uint32(16).bool(message.canPublish);\n    }\n    if (message.canPublishData === true) {\n      writer2.uint32(24).bool(message.canPublishData);\n    }\n    writer2.uint32(74).fork();\n    for (const v of message.canPublishSources) {\n      writer2.int32(v);\n    }\n    writer2.ldelim();\n    if (message.hidden === true) {\n      writer2.uint32(56).bool(message.hidden);\n    }\n    if (message.recorder === true) {\n      writer2.uint32(64).bool(message.recorder);\n    }\n    if (message.canUpdateMetadata === true) {\n      writer2.uint32(80).bool(message.canUpdateMetadata);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseParticipantPermission();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 8) {\n            break;\n          }\n          message.canSubscribe = reader2.bool();\n          continue;\n        case 2:\n          if (tag != 16) {\n            break;\n          }\n          message.canPublish = reader2.bool();\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.canPublishData = reader2.bool();\n          continue;\n        case 9:\n          if (tag == 72) {\n            message.canPublishSources.push(reader2.int32());\n            continue;\n          }\n          if (tag == 74) {\n            const end22 = reader2.uint32() + reader2.pos;\n            while (reader2.pos < end22) {\n              message.canPublishSources.push(reader2.int32());\n            }\n            continue;\n          }\n          break;\n        case 7:\n          if (tag != 56) {\n            break;\n          }\n          message.hidden = reader2.bool();\n          continue;\n        case 8:\n          if (tag != 64) {\n            break;\n          }\n          message.recorder = reader2.bool();\n          continue;\n        case 10:\n          if (tag != 80) {\n            break;\n          }\n          message.canUpdateMetadata = reader2.bool();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      canSubscribe: isSet$1(object.canSubscribe) ? Boolean(object.canSubscribe) : false,\n      canPublish: isSet$1(object.canPublish) ? Boolean(object.canPublish) : false,\n      canPublishData: isSet$1(object.canPublishData) ? Boolean(object.canPublishData) : false,\n      canPublishSources: Array.isArray(object === null || object === void 0 ? void 0 : object.canPublishSources) ? object.canPublishSources.map((e) => trackSourceFromJSON(e)) : [],\n      hidden: isSet$1(object.hidden) ? Boolean(object.hidden) : false,\n      recorder: isSet$1(object.recorder) ? Boolean(object.recorder) : false,\n      canUpdateMetadata: isSet$1(object.canUpdateMetadata) ? Boolean(object.canUpdateMetadata) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.canSubscribe !== void 0 && (obj.canSubscribe = message.canSubscribe);\n    message.canPublish !== void 0 && (obj.canPublish = message.canPublish);\n    message.canPublishData !== void 0 && (obj.canPublishData = message.canPublishData);\n    if (message.canPublishSources) {\n      obj.canPublishSources = message.canPublishSources.map((e) => trackSourceToJSON(e));\n    } else {\n      obj.canPublishSources = [];\n    }\n    message.hidden !== void 0 && (obj.hidden = message.hidden);\n    message.recorder !== void 0 && (obj.recorder = message.recorder);\n    message.canUpdateMetadata !== void 0 && (obj.canUpdateMetadata = message.canUpdateMetadata);\n    return obj;\n  },\n  create(base) {\n    return ParticipantPermission.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const message = createBaseParticipantPermission();\n    message.canSubscribe = (_a = object.canSubscribe) !== null && _a !== void 0 ? _a : false;\n    message.canPublish = (_b = object.canPublish) !== null && _b !== void 0 ? _b : false;\n    message.canPublishData = (_c = object.canPublishData) !== null && _c !== void 0 ? _c : false;\n    message.canPublishSources = ((_d = object.canPublishSources) === null || _d === void 0 ? void 0 : _d.map((e) => e)) || [];\n    message.hidden = (_e = object.hidden) !== null && _e !== void 0 ? _e : false;\n    message.recorder = (_f = object.recorder) !== null && _f !== void 0 ? _f : false;\n    message.canUpdateMetadata = (_g = object.canUpdateMetadata) !== null && _g !== void 0 ? _g : false;\n    return message;\n  }\n};\nfunction createBaseParticipantInfo() {\n  return {\n    sid: \"\",\n    identity: \"\",\n    state: 0,\n    tracks: [],\n    metadata: \"\",\n    joinedAt: 0,\n    name: \"\",\n    version: 0,\n    permission: void 0,\n    region: \"\",\n    isPublisher: false\n  };\n}\nvar ParticipantInfo = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.sid !== \"\") {\n      writer2.uint32(10).string(message.sid);\n    }\n    if (message.identity !== \"\") {\n      writer2.uint32(18).string(message.identity);\n    }\n    if (message.state !== 0) {\n      writer2.uint32(24).int32(message.state);\n    }\n    for (const v of message.tracks) {\n      TrackInfo.encode(v, writer2.uint32(34).fork()).ldelim();\n    }\n    if (message.metadata !== \"\") {\n      writer2.uint32(42).string(message.metadata);\n    }\n    if (message.joinedAt !== 0) {\n      writer2.uint32(48).int64(message.joinedAt);\n    }\n    if (message.name !== \"\") {\n      writer2.uint32(74).string(message.name);\n    }\n    if (message.version !== 0) {\n      writer2.uint32(80).uint32(message.version);\n    }\n    if (message.permission !== void 0) {\n      ParticipantPermission.encode(message.permission, writer2.uint32(90).fork()).ldelim();\n    }\n    if (message.region !== \"\") {\n      writer2.uint32(98).string(message.region);\n    }\n    if (message.isPublisher === true) {\n      writer2.uint32(104).bool(message.isPublisher);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseParticipantInfo();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.sid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.identity = reader2.string();\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.state = reader2.int32();\n          continue;\n        case 4:\n          if (tag != 34) {\n            break;\n          }\n          message.tracks.push(TrackInfo.decode(reader2, reader2.uint32()));\n          continue;\n        case 5:\n          if (tag != 42) {\n            break;\n          }\n          message.metadata = reader2.string();\n          continue;\n        case 6:\n          if (tag != 48) {\n            break;\n          }\n          message.joinedAt = longToNumber$1(reader2.int64());\n          continue;\n        case 9:\n          if (tag != 74) {\n            break;\n          }\n          message.name = reader2.string();\n          continue;\n        case 10:\n          if (tag != 80) {\n            break;\n          }\n          message.version = reader2.uint32();\n          continue;\n        case 11:\n          if (tag != 90) {\n            break;\n          }\n          message.permission = ParticipantPermission.decode(reader2, reader2.uint32());\n          continue;\n        case 12:\n          if (tag != 98) {\n            break;\n          }\n          message.region = reader2.string();\n          continue;\n        case 13:\n          if (tag != 104) {\n            break;\n          }\n          message.isPublisher = reader2.bool();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      sid: isSet$1(object.sid) ? String(object.sid) : \"\",\n      identity: isSet$1(object.identity) ? String(object.identity) : \"\",\n      state: isSet$1(object.state) ? participantInfo_StateFromJSON(object.state) : 0,\n      tracks: Array.isArray(object === null || object === void 0 ? void 0 : object.tracks) ? object.tracks.map((e) => TrackInfo.fromJSON(e)) : [],\n      metadata: isSet$1(object.metadata) ? String(object.metadata) : \"\",\n      joinedAt: isSet$1(object.joinedAt) ? Number(object.joinedAt) : 0,\n      name: isSet$1(object.name) ? String(object.name) : \"\",\n      version: isSet$1(object.version) ? Number(object.version) : 0,\n      permission: isSet$1(object.permission) ? ParticipantPermission.fromJSON(object.permission) : void 0,\n      region: isSet$1(object.region) ? String(object.region) : \"\",\n      isPublisher: isSet$1(object.isPublisher) ? Boolean(object.isPublisher) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.sid !== void 0 && (obj.sid = message.sid);\n    message.identity !== void 0 && (obj.identity = message.identity);\n    message.state !== void 0 && (obj.state = participantInfo_StateToJSON(message.state));\n    if (message.tracks) {\n      obj.tracks = message.tracks.map((e) => e ? TrackInfo.toJSON(e) : void 0);\n    } else {\n      obj.tracks = [];\n    }\n    message.metadata !== void 0 && (obj.metadata = message.metadata);\n    message.joinedAt !== void 0 && (obj.joinedAt = Math.round(message.joinedAt));\n    message.name !== void 0 && (obj.name = message.name);\n    message.version !== void 0 && (obj.version = Math.round(message.version));\n    message.permission !== void 0 && (obj.permission = message.permission ? ParticipantPermission.toJSON(message.permission) : void 0);\n    message.region !== void 0 && (obj.region = message.region);\n    message.isPublisher !== void 0 && (obj.isPublisher = message.isPublisher);\n    return obj;\n  },\n  create(base) {\n    return ParticipantInfo.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    const message = createBaseParticipantInfo();\n    message.sid = (_a = object.sid) !== null && _a !== void 0 ? _a : \"\";\n    message.identity = (_b = object.identity) !== null && _b !== void 0 ? _b : \"\";\n    message.state = (_c = object.state) !== null && _c !== void 0 ? _c : 0;\n    message.tracks = ((_d = object.tracks) === null || _d === void 0 ? void 0 : _d.map((e) => TrackInfo.fromPartial(e))) || [];\n    message.metadata = (_e = object.metadata) !== null && _e !== void 0 ? _e : \"\";\n    message.joinedAt = (_f = object.joinedAt) !== null && _f !== void 0 ? _f : 0;\n    message.name = (_g = object.name) !== null && _g !== void 0 ? _g : \"\";\n    message.version = (_h = object.version) !== null && _h !== void 0 ? _h : 0;\n    message.permission = object.permission !== void 0 && object.permission !== null ? ParticipantPermission.fromPartial(object.permission) : void 0;\n    message.region = (_j = object.region) !== null && _j !== void 0 ? _j : \"\";\n    message.isPublisher = (_k = object.isPublisher) !== null && _k !== void 0 ? _k : false;\n    return message;\n  }\n};\nfunction createBaseSimulcastCodecInfo() {\n  return {\n    mimeType: \"\",\n    mid: \"\",\n    cid: \"\",\n    layers: []\n  };\n}\nvar SimulcastCodecInfo = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.mimeType !== \"\") {\n      writer2.uint32(10).string(message.mimeType);\n    }\n    if (message.mid !== \"\") {\n      writer2.uint32(18).string(message.mid);\n    }\n    if (message.cid !== \"\") {\n      writer2.uint32(26).string(message.cid);\n    }\n    for (const v of message.layers) {\n      VideoLayer.encode(v, writer2.uint32(34).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseSimulcastCodecInfo();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.mimeType = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.mid = reader2.string();\n          continue;\n        case 3:\n          if (tag != 26) {\n            break;\n          }\n          message.cid = reader2.string();\n          continue;\n        case 4:\n          if (tag != 34) {\n            break;\n          }\n          message.layers.push(VideoLayer.decode(reader2, reader2.uint32()));\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      mimeType: isSet$1(object.mimeType) ? String(object.mimeType) : \"\",\n      mid: isSet$1(object.mid) ? String(object.mid) : \"\",\n      cid: isSet$1(object.cid) ? String(object.cid) : \"\",\n      layers: Array.isArray(object === null || object === void 0 ? void 0 : object.layers) ? object.layers.map((e) => VideoLayer.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.mimeType !== void 0 && (obj.mimeType = message.mimeType);\n    message.mid !== void 0 && (obj.mid = message.mid);\n    message.cid !== void 0 && (obj.cid = message.cid);\n    if (message.layers) {\n      obj.layers = message.layers.map((e) => e ? VideoLayer.toJSON(e) : void 0);\n    } else {\n      obj.layers = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return SimulcastCodecInfo.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseSimulcastCodecInfo();\n    message.mimeType = (_a = object.mimeType) !== null && _a !== void 0 ? _a : \"\";\n    message.mid = (_b = object.mid) !== null && _b !== void 0 ? _b : \"\";\n    message.cid = (_c = object.cid) !== null && _c !== void 0 ? _c : \"\";\n    message.layers = ((_d = object.layers) === null || _d === void 0 ? void 0 : _d.map((e) => VideoLayer.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseTrackInfo() {\n  return {\n    sid: \"\",\n    type: 0,\n    name: \"\",\n    muted: false,\n    width: 0,\n    height: 0,\n    simulcast: false,\n    disableDtx: false,\n    source: 0,\n    layers: [],\n    mimeType: \"\",\n    mid: \"\",\n    codecs: [],\n    stereo: false,\n    disableRed: false,\n    encryption: 0\n  };\n}\nvar TrackInfo = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.sid !== \"\") {\n      writer2.uint32(10).string(message.sid);\n    }\n    if (message.type !== 0) {\n      writer2.uint32(16).int32(message.type);\n    }\n    if (message.name !== \"\") {\n      writer2.uint32(26).string(message.name);\n    }\n    if (message.muted === true) {\n      writer2.uint32(32).bool(message.muted);\n    }\n    if (message.width !== 0) {\n      writer2.uint32(40).uint32(message.width);\n    }\n    if (message.height !== 0) {\n      writer2.uint32(48).uint32(message.height);\n    }\n    if (message.simulcast === true) {\n      writer2.uint32(56).bool(message.simulcast);\n    }\n    if (message.disableDtx === true) {\n      writer2.uint32(64).bool(message.disableDtx);\n    }\n    if (message.source !== 0) {\n      writer2.uint32(72).int32(message.source);\n    }\n    for (const v of message.layers) {\n      VideoLayer.encode(v, writer2.uint32(82).fork()).ldelim();\n    }\n    if (message.mimeType !== \"\") {\n      writer2.uint32(90).string(message.mimeType);\n    }\n    if (message.mid !== \"\") {\n      writer2.uint32(98).string(message.mid);\n    }\n    for (const v of message.codecs) {\n      SimulcastCodecInfo.encode(v, writer2.uint32(106).fork()).ldelim();\n    }\n    if (message.stereo === true) {\n      writer2.uint32(112).bool(message.stereo);\n    }\n    if (message.disableRed === true) {\n      writer2.uint32(120).bool(message.disableRed);\n    }\n    if (message.encryption !== 0) {\n      writer2.uint32(128).int32(message.encryption);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseTrackInfo();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.sid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 16) {\n            break;\n          }\n          message.type = reader2.int32();\n          continue;\n        case 3:\n          if (tag != 26) {\n            break;\n          }\n          message.name = reader2.string();\n          continue;\n        case 4:\n          if (tag != 32) {\n            break;\n          }\n          message.muted = reader2.bool();\n          continue;\n        case 5:\n          if (tag != 40) {\n            break;\n          }\n          message.width = reader2.uint32();\n          continue;\n        case 6:\n          if (tag != 48) {\n            break;\n          }\n          message.height = reader2.uint32();\n          continue;\n        case 7:\n          if (tag != 56) {\n            break;\n          }\n          message.simulcast = reader2.bool();\n          continue;\n        case 8:\n          if (tag != 64) {\n            break;\n          }\n          message.disableDtx = reader2.bool();\n          continue;\n        case 9:\n          if (tag != 72) {\n            break;\n          }\n          message.source = reader2.int32();\n          continue;\n        case 10:\n          if (tag != 82) {\n            break;\n          }\n          message.layers.push(VideoLayer.decode(reader2, reader2.uint32()));\n          continue;\n        case 11:\n          if (tag != 90) {\n            break;\n          }\n          message.mimeType = reader2.string();\n          continue;\n        case 12:\n          if (tag != 98) {\n            break;\n          }\n          message.mid = reader2.string();\n          continue;\n        case 13:\n          if (tag != 106) {\n            break;\n          }\n          message.codecs.push(SimulcastCodecInfo.decode(reader2, reader2.uint32()));\n          continue;\n        case 14:\n          if (tag != 112) {\n            break;\n          }\n          message.stereo = reader2.bool();\n          continue;\n        case 15:\n          if (tag != 120) {\n            break;\n          }\n          message.disableRed = reader2.bool();\n          continue;\n        case 16:\n          if (tag != 128) {\n            break;\n          }\n          message.encryption = reader2.int32();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      sid: isSet$1(object.sid) ? String(object.sid) : \"\",\n      type: isSet$1(object.type) ? trackTypeFromJSON(object.type) : 0,\n      name: isSet$1(object.name) ? String(object.name) : \"\",\n      muted: isSet$1(object.muted) ? Boolean(object.muted) : false,\n      width: isSet$1(object.width) ? Number(object.width) : 0,\n      height: isSet$1(object.height) ? Number(object.height) : 0,\n      simulcast: isSet$1(object.simulcast) ? Boolean(object.simulcast) : false,\n      disableDtx: isSet$1(object.disableDtx) ? Boolean(object.disableDtx) : false,\n      source: isSet$1(object.source) ? trackSourceFromJSON(object.source) : 0,\n      layers: Array.isArray(object === null || object === void 0 ? void 0 : object.layers) ? object.layers.map((e) => VideoLayer.fromJSON(e)) : [],\n      mimeType: isSet$1(object.mimeType) ? String(object.mimeType) : \"\",\n      mid: isSet$1(object.mid) ? String(object.mid) : \"\",\n      codecs: Array.isArray(object === null || object === void 0 ? void 0 : object.codecs) ? object.codecs.map((e) => SimulcastCodecInfo.fromJSON(e)) : [],\n      stereo: isSet$1(object.stereo) ? Boolean(object.stereo) : false,\n      disableRed: isSet$1(object.disableRed) ? Boolean(object.disableRed) : false,\n      encryption: isSet$1(object.encryption) ? encryption_TypeFromJSON(object.encryption) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.sid !== void 0 && (obj.sid = message.sid);\n    message.type !== void 0 && (obj.type = trackTypeToJSON(message.type));\n    message.name !== void 0 && (obj.name = message.name);\n    message.muted !== void 0 && (obj.muted = message.muted);\n    message.width !== void 0 && (obj.width = Math.round(message.width));\n    message.height !== void 0 && (obj.height = Math.round(message.height));\n    message.simulcast !== void 0 && (obj.simulcast = message.simulcast);\n    message.disableDtx !== void 0 && (obj.disableDtx = message.disableDtx);\n    message.source !== void 0 && (obj.source = trackSourceToJSON(message.source));\n    if (message.layers) {\n      obj.layers = message.layers.map((e) => e ? VideoLayer.toJSON(e) : void 0);\n    } else {\n      obj.layers = [];\n    }\n    message.mimeType !== void 0 && (obj.mimeType = message.mimeType);\n    message.mid !== void 0 && (obj.mid = message.mid);\n    if (message.codecs) {\n      obj.codecs = message.codecs.map((e) => e ? SimulcastCodecInfo.toJSON(e) : void 0);\n    } else {\n      obj.codecs = [];\n    }\n    message.stereo !== void 0 && (obj.stereo = message.stereo);\n    message.disableRed !== void 0 && (obj.disableRed = message.disableRed);\n    message.encryption !== void 0 && (obj.encryption = encryption_TypeToJSON(message.encryption));\n    return obj;\n  },\n  create(base) {\n    return TrackInfo.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\n    const message = createBaseTrackInfo();\n    message.sid = (_a = object.sid) !== null && _a !== void 0 ? _a : \"\";\n    message.type = (_b = object.type) !== null && _b !== void 0 ? _b : 0;\n    message.name = (_c = object.name) !== null && _c !== void 0 ? _c : \"\";\n    message.muted = (_d = object.muted) !== null && _d !== void 0 ? _d : false;\n    message.width = (_e = object.width) !== null && _e !== void 0 ? _e : 0;\n    message.height = (_f = object.height) !== null && _f !== void 0 ? _f : 0;\n    message.simulcast = (_g = object.simulcast) !== null && _g !== void 0 ? _g : false;\n    message.disableDtx = (_h = object.disableDtx) !== null && _h !== void 0 ? _h : false;\n    message.source = (_j = object.source) !== null && _j !== void 0 ? _j : 0;\n    message.layers = ((_k = object.layers) === null || _k === void 0 ? void 0 : _k.map((e) => VideoLayer.fromPartial(e))) || [];\n    message.mimeType = (_l = object.mimeType) !== null && _l !== void 0 ? _l : \"\";\n    message.mid = (_m = object.mid) !== null && _m !== void 0 ? _m : \"\";\n    message.codecs = ((_o = object.codecs) === null || _o === void 0 ? void 0 : _o.map((e) => SimulcastCodecInfo.fromPartial(e))) || [];\n    message.stereo = (_p = object.stereo) !== null && _p !== void 0 ? _p : false;\n    message.disableRed = (_q = object.disableRed) !== null && _q !== void 0 ? _q : false;\n    message.encryption = (_r = object.encryption) !== null && _r !== void 0 ? _r : 0;\n    return message;\n  }\n};\nfunction createBaseVideoLayer() {\n  return {\n    quality: 0,\n    width: 0,\n    height: 0,\n    bitrate: 0,\n    ssrc: 0\n  };\n}\nvar VideoLayer = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.quality !== 0) {\n      writer2.uint32(8).int32(message.quality);\n    }\n    if (message.width !== 0) {\n      writer2.uint32(16).uint32(message.width);\n    }\n    if (message.height !== 0) {\n      writer2.uint32(24).uint32(message.height);\n    }\n    if (message.bitrate !== 0) {\n      writer2.uint32(32).uint32(message.bitrate);\n    }\n    if (message.ssrc !== 0) {\n      writer2.uint32(40).uint32(message.ssrc);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseVideoLayer();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 8) {\n            break;\n          }\n          message.quality = reader2.int32();\n          continue;\n        case 2:\n          if (tag != 16) {\n            break;\n          }\n          message.width = reader2.uint32();\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.height = reader2.uint32();\n          continue;\n        case 4:\n          if (tag != 32) {\n            break;\n          }\n          message.bitrate = reader2.uint32();\n          continue;\n        case 5:\n          if (tag != 40) {\n            break;\n          }\n          message.ssrc = reader2.uint32();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      quality: isSet$1(object.quality) ? videoQualityFromJSON(object.quality) : 0,\n      width: isSet$1(object.width) ? Number(object.width) : 0,\n      height: isSet$1(object.height) ? Number(object.height) : 0,\n      bitrate: isSet$1(object.bitrate) ? Number(object.bitrate) : 0,\n      ssrc: isSet$1(object.ssrc) ? Number(object.ssrc) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.quality !== void 0 && (obj.quality = videoQualityToJSON(message.quality));\n    message.width !== void 0 && (obj.width = Math.round(message.width));\n    message.height !== void 0 && (obj.height = Math.round(message.height));\n    message.bitrate !== void 0 && (obj.bitrate = Math.round(message.bitrate));\n    message.ssrc !== void 0 && (obj.ssrc = Math.round(message.ssrc));\n    return obj;\n  },\n  create(base) {\n    return VideoLayer.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e;\n    const message = createBaseVideoLayer();\n    message.quality = (_a = object.quality) !== null && _a !== void 0 ? _a : 0;\n    message.width = (_b = object.width) !== null && _b !== void 0 ? _b : 0;\n    message.height = (_c = object.height) !== null && _c !== void 0 ? _c : 0;\n    message.bitrate = (_d = object.bitrate) !== null && _d !== void 0 ? _d : 0;\n    message.ssrc = (_e = object.ssrc) !== null && _e !== void 0 ? _e : 0;\n    return message;\n  }\n};\nfunction createBaseDataPacket() {\n  return {\n    kind: 0,\n    value: void 0\n  };\n}\nvar DataPacket = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    var _a;\n    if (message.kind !== 0) {\n      writer2.uint32(8).int32(message.kind);\n    }\n    switch ((_a = message.value) === null || _a === void 0 ? void 0 : _a.$case) {\n      case \"user\":\n        UserPacket.encode(message.value.user, writer2.uint32(18).fork()).ldelim();\n        break;\n      case \"speaker\":\n        ActiveSpeakerUpdate.encode(message.value.speaker, writer2.uint32(26).fork()).ldelim();\n        break;\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseDataPacket();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 8) {\n            break;\n          }\n          message.kind = reader2.int32();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.value = {\n            $case: \"user\",\n            user: UserPacket.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 3:\n          if (tag != 26) {\n            break;\n          }\n          message.value = {\n            $case: \"speaker\",\n            speaker: ActiveSpeakerUpdate.decode(reader2, reader2.uint32())\n          };\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      kind: isSet$1(object.kind) ? dataPacket_KindFromJSON(object.kind) : 0,\n      value: isSet$1(object.user) ? {\n        $case: \"user\",\n        user: UserPacket.fromJSON(object.user)\n      } : isSet$1(object.speaker) ? {\n        $case: \"speaker\",\n        speaker: ActiveSpeakerUpdate.fromJSON(object.speaker)\n      } : void 0\n    };\n  },\n  toJSON(message) {\n    var _a, _b, _c, _d, _e, _f;\n    const obj = {};\n    message.kind !== void 0 && (obj.kind = dataPacket_KindToJSON(message.kind));\n    ((_a = message.value) === null || _a === void 0 ? void 0 : _a.$case) === \"user\" && (obj.user = ((_b = message.value) === null || _b === void 0 ? void 0 : _b.user) ? UserPacket.toJSON((_c = message.value) === null || _c === void 0 ? void 0 : _c.user) : void 0);\n    ((_d = message.value) === null || _d === void 0 ? void 0 : _d.$case) === \"speaker\" && (obj.speaker = ((_e = message.value) === null || _e === void 0 ? void 0 : _e.speaker) ? ActiveSpeakerUpdate.toJSON((_f = message.value) === null || _f === void 0 ? void 0 : _f.speaker) : void 0);\n    return obj;\n  },\n  create(base) {\n    return DataPacket.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const message = createBaseDataPacket();\n    message.kind = (_a = object.kind) !== null && _a !== void 0 ? _a : 0;\n    if (((_b = object.value) === null || _b === void 0 ? void 0 : _b.$case) === \"user\" && ((_c = object.value) === null || _c === void 0 ? void 0 : _c.user) !== void 0 && ((_d = object.value) === null || _d === void 0 ? void 0 : _d.user) !== null) {\n      message.value = {\n        $case: \"user\",\n        user: UserPacket.fromPartial(object.value.user)\n      };\n    }\n    if (((_e = object.value) === null || _e === void 0 ? void 0 : _e.$case) === \"speaker\" && ((_f = object.value) === null || _f === void 0 ? void 0 : _f.speaker) !== void 0 && ((_g = object.value) === null || _g === void 0 ? void 0 : _g.speaker) !== null) {\n      message.value = {\n        $case: \"speaker\",\n        speaker: ActiveSpeakerUpdate.fromPartial(object.value.speaker)\n      };\n    }\n    return message;\n  }\n};\nfunction createBaseActiveSpeakerUpdate() {\n  return {\n    speakers: []\n  };\n}\nvar ActiveSpeakerUpdate = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    for (const v of message.speakers) {\n      SpeakerInfo.encode(v, writer2.uint32(10).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseActiveSpeakerUpdate();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.speakers.push(SpeakerInfo.decode(reader2, reader2.uint32()));\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      speakers: Array.isArray(object === null || object === void 0 ? void 0 : object.speakers) ? object.speakers.map((e) => SpeakerInfo.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.speakers) {\n      obj.speakers = message.speakers.map((e) => e ? SpeakerInfo.toJSON(e) : void 0);\n    } else {\n      obj.speakers = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return ActiveSpeakerUpdate.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseActiveSpeakerUpdate();\n    message.speakers = ((_a = object.speakers) === null || _a === void 0 ? void 0 : _a.map((e) => SpeakerInfo.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseSpeakerInfo() {\n  return {\n    sid: \"\",\n    level: 0,\n    active: false\n  };\n}\nvar SpeakerInfo = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.sid !== \"\") {\n      writer2.uint32(10).string(message.sid);\n    }\n    if (message.level !== 0) {\n      writer2.uint32(21).float(message.level);\n    }\n    if (message.active === true) {\n      writer2.uint32(24).bool(message.active);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseSpeakerInfo();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.sid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 21) {\n            break;\n          }\n          message.level = reader2.float();\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.active = reader2.bool();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      sid: isSet$1(object.sid) ? String(object.sid) : \"\",\n      level: isSet$1(object.level) ? Number(object.level) : 0,\n      active: isSet$1(object.active) ? Boolean(object.active) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.sid !== void 0 && (obj.sid = message.sid);\n    message.level !== void 0 && (obj.level = message.level);\n    message.active !== void 0 && (obj.active = message.active);\n    return obj;\n  },\n  create(base) {\n    return SpeakerInfo.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseSpeakerInfo();\n    message.sid = (_a = object.sid) !== null && _a !== void 0 ? _a : \"\";\n    message.level = (_b = object.level) !== null && _b !== void 0 ? _b : 0;\n    message.active = (_c = object.active) !== null && _c !== void 0 ? _c : false;\n    return message;\n  }\n};\nfunction createBaseUserPacket() {\n  return {\n    participantSid: \"\",\n    payload: new Uint8Array(),\n    destinationSids: [],\n    topic: void 0\n  };\n}\nvar UserPacket = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.participantSid !== \"\") {\n      writer2.uint32(10).string(message.participantSid);\n    }\n    if (message.payload.length !== 0) {\n      writer2.uint32(18).bytes(message.payload);\n    }\n    for (const v of message.destinationSids) {\n      writer2.uint32(26).string(v);\n    }\n    if (message.topic !== void 0) {\n      writer2.uint32(34).string(message.topic);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseUserPacket();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.participantSid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.payload = reader2.bytes();\n          continue;\n        case 3:\n          if (tag != 26) {\n            break;\n          }\n          message.destinationSids.push(reader2.string());\n          continue;\n        case 4:\n          if (tag != 34) {\n            break;\n          }\n          message.topic = reader2.string();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      participantSid: isSet$1(object.participantSid) ? String(object.participantSid) : \"\",\n      payload: isSet$1(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(),\n      destinationSids: Array.isArray(object === null || object === void 0 ? void 0 : object.destinationSids) ? object.destinationSids.map((e) => String(e)) : [],\n      topic: isSet$1(object.topic) ? String(object.topic) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.participantSid !== void 0 && (obj.participantSid = message.participantSid);\n    message.payload !== void 0 && (obj.payload = base64FromBytes(message.payload !== void 0 ? message.payload : new Uint8Array()));\n    if (message.destinationSids) {\n      obj.destinationSids = message.destinationSids.map((e) => e);\n    } else {\n      obj.destinationSids = [];\n    }\n    message.topic !== void 0 && (obj.topic = message.topic);\n    return obj;\n  },\n  create(base) {\n    return UserPacket.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseUserPacket();\n    message.participantSid = (_a = object.participantSid) !== null && _a !== void 0 ? _a : \"\";\n    message.payload = (_b = object.payload) !== null && _b !== void 0 ? _b : new Uint8Array();\n    message.destinationSids = ((_c = object.destinationSids) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];\n    message.topic = (_d = object.topic) !== null && _d !== void 0 ? _d : void 0;\n    return message;\n  }\n};\nfunction createBaseParticipantTracks() {\n  return {\n    participantSid: \"\",\n    trackSids: []\n  };\n}\nvar ParticipantTracks = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.participantSid !== \"\") {\n      writer2.uint32(10).string(message.participantSid);\n    }\n    for (const v of message.trackSids) {\n      writer2.uint32(18).string(v);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseParticipantTracks();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.participantSid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.trackSids.push(reader2.string());\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      participantSid: isSet$1(object.participantSid) ? String(object.participantSid) : \"\",\n      trackSids: Array.isArray(object === null || object === void 0 ? void 0 : object.trackSids) ? object.trackSids.map((e) => String(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.participantSid !== void 0 && (obj.participantSid = message.participantSid);\n    if (message.trackSids) {\n      obj.trackSids = message.trackSids.map((e) => e);\n    } else {\n      obj.trackSids = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return ParticipantTracks.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseParticipantTracks();\n    message.participantSid = (_a = object.participantSid) !== null && _a !== void 0 ? _a : \"\";\n    message.trackSids = ((_b = object.trackSids) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];\n    return message;\n  }\n};\nfunction createBaseServerInfo() {\n  return {\n    edition: 0,\n    version: \"\",\n    protocol: 0,\n    region: \"\",\n    nodeId: \"\",\n    debugInfo: \"\"\n  };\n}\nvar ServerInfo = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.edition !== 0) {\n      writer2.uint32(8).int32(message.edition);\n    }\n    if (message.version !== \"\") {\n      writer2.uint32(18).string(message.version);\n    }\n    if (message.protocol !== 0) {\n      writer2.uint32(24).int32(message.protocol);\n    }\n    if (message.region !== \"\") {\n      writer2.uint32(34).string(message.region);\n    }\n    if (message.nodeId !== \"\") {\n      writer2.uint32(42).string(message.nodeId);\n    }\n    if (message.debugInfo !== \"\") {\n      writer2.uint32(50).string(message.debugInfo);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseServerInfo();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 8) {\n            break;\n          }\n          message.edition = reader2.int32();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.version = reader2.string();\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.protocol = reader2.int32();\n          continue;\n        case 4:\n          if (tag != 34) {\n            break;\n          }\n          message.region = reader2.string();\n          continue;\n        case 5:\n          if (tag != 42) {\n            break;\n          }\n          message.nodeId = reader2.string();\n          continue;\n        case 6:\n          if (tag != 50) {\n            break;\n          }\n          message.debugInfo = reader2.string();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      edition: isSet$1(object.edition) ? serverInfo_EditionFromJSON(object.edition) : 0,\n      version: isSet$1(object.version) ? String(object.version) : \"\",\n      protocol: isSet$1(object.protocol) ? Number(object.protocol) : 0,\n      region: isSet$1(object.region) ? String(object.region) : \"\",\n      nodeId: isSet$1(object.nodeId) ? String(object.nodeId) : \"\",\n      debugInfo: isSet$1(object.debugInfo) ? String(object.debugInfo) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.edition !== void 0 && (obj.edition = serverInfo_EditionToJSON(message.edition));\n    message.version !== void 0 && (obj.version = message.version);\n    message.protocol !== void 0 && (obj.protocol = Math.round(message.protocol));\n    message.region !== void 0 && (obj.region = message.region);\n    message.nodeId !== void 0 && (obj.nodeId = message.nodeId);\n    message.debugInfo !== void 0 && (obj.debugInfo = message.debugInfo);\n    return obj;\n  },\n  create(base) {\n    return ServerInfo.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f;\n    const message = createBaseServerInfo();\n    message.edition = (_a = object.edition) !== null && _a !== void 0 ? _a : 0;\n    message.version = (_b = object.version) !== null && _b !== void 0 ? _b : \"\";\n    message.protocol = (_c = object.protocol) !== null && _c !== void 0 ? _c : 0;\n    message.region = (_d = object.region) !== null && _d !== void 0 ? _d : \"\";\n    message.nodeId = (_e = object.nodeId) !== null && _e !== void 0 ? _e : \"\";\n    message.debugInfo = (_f = object.debugInfo) !== null && _f !== void 0 ? _f : \"\";\n    return message;\n  }\n};\nfunction createBaseClientInfo() {\n  return {\n    sdk: 0,\n    version: \"\",\n    protocol: 0,\n    os: \"\",\n    osVersion: \"\",\n    deviceModel: \"\",\n    browser: \"\",\n    browserVersion: \"\",\n    address: \"\",\n    network: \"\"\n  };\n}\nvar ClientInfo = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.sdk !== 0) {\n      writer2.uint32(8).int32(message.sdk);\n    }\n    if (message.version !== \"\") {\n      writer2.uint32(18).string(message.version);\n    }\n    if (message.protocol !== 0) {\n      writer2.uint32(24).int32(message.protocol);\n    }\n    if (message.os !== \"\") {\n      writer2.uint32(34).string(message.os);\n    }\n    if (message.osVersion !== \"\") {\n      writer2.uint32(42).string(message.osVersion);\n    }\n    if (message.deviceModel !== \"\") {\n      writer2.uint32(50).string(message.deviceModel);\n    }\n    if (message.browser !== \"\") {\n      writer2.uint32(58).string(message.browser);\n    }\n    if (message.browserVersion !== \"\") {\n      writer2.uint32(66).string(message.browserVersion);\n    }\n    if (message.address !== \"\") {\n      writer2.uint32(74).string(message.address);\n    }\n    if (message.network !== \"\") {\n      writer2.uint32(82).string(message.network);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseClientInfo();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 8) {\n            break;\n          }\n          message.sdk = reader2.int32();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.version = reader2.string();\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.protocol = reader2.int32();\n          continue;\n        case 4:\n          if (tag != 34) {\n            break;\n          }\n          message.os = reader2.string();\n          continue;\n        case 5:\n          if (tag != 42) {\n            break;\n          }\n          message.osVersion = reader2.string();\n          continue;\n        case 6:\n          if (tag != 50) {\n            break;\n          }\n          message.deviceModel = reader2.string();\n          continue;\n        case 7:\n          if (tag != 58) {\n            break;\n          }\n          message.browser = reader2.string();\n          continue;\n        case 8:\n          if (tag != 66) {\n            break;\n          }\n          message.browserVersion = reader2.string();\n          continue;\n        case 9:\n          if (tag != 74) {\n            break;\n          }\n          message.address = reader2.string();\n          continue;\n        case 10:\n          if (tag != 82) {\n            break;\n          }\n          message.network = reader2.string();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      sdk: isSet$1(object.sdk) ? clientInfo_SDKFromJSON(object.sdk) : 0,\n      version: isSet$1(object.version) ? String(object.version) : \"\",\n      protocol: isSet$1(object.protocol) ? Number(object.protocol) : 0,\n      os: isSet$1(object.os) ? String(object.os) : \"\",\n      osVersion: isSet$1(object.osVersion) ? String(object.osVersion) : \"\",\n      deviceModel: isSet$1(object.deviceModel) ? String(object.deviceModel) : \"\",\n      browser: isSet$1(object.browser) ? String(object.browser) : \"\",\n      browserVersion: isSet$1(object.browserVersion) ? String(object.browserVersion) : \"\",\n      address: isSet$1(object.address) ? String(object.address) : \"\",\n      network: isSet$1(object.network) ? String(object.network) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.sdk !== void 0 && (obj.sdk = clientInfo_SDKToJSON(message.sdk));\n    message.version !== void 0 && (obj.version = message.version);\n    message.protocol !== void 0 && (obj.protocol = Math.round(message.protocol));\n    message.os !== void 0 && (obj.os = message.os);\n    message.osVersion !== void 0 && (obj.osVersion = message.osVersion);\n    message.deviceModel !== void 0 && (obj.deviceModel = message.deviceModel);\n    message.browser !== void 0 && (obj.browser = message.browser);\n    message.browserVersion !== void 0 && (obj.browserVersion = message.browserVersion);\n    message.address !== void 0 && (obj.address = message.address);\n    message.network !== void 0 && (obj.network = message.network);\n    return obj;\n  },\n  create(base) {\n    return ClientInfo.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    const message = createBaseClientInfo();\n    message.sdk = (_a = object.sdk) !== null && _a !== void 0 ? _a : 0;\n    message.version = (_b = object.version) !== null && _b !== void 0 ? _b : \"\";\n    message.protocol = (_c = object.protocol) !== null && _c !== void 0 ? _c : 0;\n    message.os = (_d = object.os) !== null && _d !== void 0 ? _d : \"\";\n    message.osVersion = (_e = object.osVersion) !== null && _e !== void 0 ? _e : \"\";\n    message.deviceModel = (_f = object.deviceModel) !== null && _f !== void 0 ? _f : \"\";\n    message.browser = (_g = object.browser) !== null && _g !== void 0 ? _g : \"\";\n    message.browserVersion = (_h = object.browserVersion) !== null && _h !== void 0 ? _h : \"\";\n    message.address = (_j = object.address) !== null && _j !== void 0 ? _j : \"\";\n    message.network = (_k = object.network) !== null && _k !== void 0 ? _k : \"\";\n    return message;\n  }\n};\nfunction createBaseClientConfiguration() {\n  return {\n    video: void 0,\n    screen: void 0,\n    resumeConnection: 0,\n    disabledCodecs: void 0,\n    forceRelay: 0\n  };\n}\nvar ClientConfiguration = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.video !== void 0) {\n      VideoConfiguration.encode(message.video, writer2.uint32(10).fork()).ldelim();\n    }\n    if (message.screen !== void 0) {\n      VideoConfiguration.encode(message.screen, writer2.uint32(18).fork()).ldelim();\n    }\n    if (message.resumeConnection !== 0) {\n      writer2.uint32(24).int32(message.resumeConnection);\n    }\n    if (message.disabledCodecs !== void 0) {\n      DisabledCodecs.encode(message.disabledCodecs, writer2.uint32(34).fork()).ldelim();\n    }\n    if (message.forceRelay !== 0) {\n      writer2.uint32(40).int32(message.forceRelay);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseClientConfiguration();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.video = VideoConfiguration.decode(reader2, reader2.uint32());\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.screen = VideoConfiguration.decode(reader2, reader2.uint32());\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.resumeConnection = reader2.int32();\n          continue;\n        case 4:\n          if (tag != 34) {\n            break;\n          }\n          message.disabledCodecs = DisabledCodecs.decode(reader2, reader2.uint32());\n          continue;\n        case 5:\n          if (tag != 40) {\n            break;\n          }\n          message.forceRelay = reader2.int32();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      video: isSet$1(object.video) ? VideoConfiguration.fromJSON(object.video) : void 0,\n      screen: isSet$1(object.screen) ? VideoConfiguration.fromJSON(object.screen) : void 0,\n      resumeConnection: isSet$1(object.resumeConnection) ? clientConfigSettingFromJSON(object.resumeConnection) : 0,\n      disabledCodecs: isSet$1(object.disabledCodecs) ? DisabledCodecs.fromJSON(object.disabledCodecs) : void 0,\n      forceRelay: isSet$1(object.forceRelay) ? clientConfigSettingFromJSON(object.forceRelay) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.video !== void 0 && (obj.video = message.video ? VideoConfiguration.toJSON(message.video) : void 0);\n    message.screen !== void 0 && (obj.screen = message.screen ? VideoConfiguration.toJSON(message.screen) : void 0);\n    message.resumeConnection !== void 0 && (obj.resumeConnection = clientConfigSettingToJSON(message.resumeConnection));\n    message.disabledCodecs !== void 0 && (obj.disabledCodecs = message.disabledCodecs ? DisabledCodecs.toJSON(message.disabledCodecs) : void 0);\n    message.forceRelay !== void 0 && (obj.forceRelay = clientConfigSettingToJSON(message.forceRelay));\n    return obj;\n  },\n  create(base) {\n    return ClientConfiguration.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseClientConfiguration();\n    message.video = object.video !== void 0 && object.video !== null ? VideoConfiguration.fromPartial(object.video) : void 0;\n    message.screen = object.screen !== void 0 && object.screen !== null ? VideoConfiguration.fromPartial(object.screen) : void 0;\n    message.resumeConnection = (_a = object.resumeConnection) !== null && _a !== void 0 ? _a : 0;\n    message.disabledCodecs = object.disabledCodecs !== void 0 && object.disabledCodecs !== null ? DisabledCodecs.fromPartial(object.disabledCodecs) : void 0;\n    message.forceRelay = (_b = object.forceRelay) !== null && _b !== void 0 ? _b : 0;\n    return message;\n  }\n};\nfunction createBaseVideoConfiguration() {\n  return {\n    hardwareEncoder: 0\n  };\n}\nvar VideoConfiguration = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.hardwareEncoder !== 0) {\n      writer2.uint32(8).int32(message.hardwareEncoder);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseVideoConfiguration();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 8) {\n            break;\n          }\n          message.hardwareEncoder = reader2.int32();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      hardwareEncoder: isSet$1(object.hardwareEncoder) ? clientConfigSettingFromJSON(object.hardwareEncoder) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.hardwareEncoder !== void 0 && (obj.hardwareEncoder = clientConfigSettingToJSON(message.hardwareEncoder));\n    return obj;\n  },\n  create(base) {\n    return VideoConfiguration.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseVideoConfiguration();\n    message.hardwareEncoder = (_a = object.hardwareEncoder) !== null && _a !== void 0 ? _a : 0;\n    return message;\n  }\n};\nfunction createBaseDisabledCodecs() {\n  return {\n    codecs: []\n  };\n}\nvar DisabledCodecs = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    for (const v of message.codecs) {\n      Codec.encode(v, writer2.uint32(10).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseDisabledCodecs();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.codecs.push(Codec.decode(reader2, reader2.uint32()));\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      codecs: Array.isArray(object === null || object === void 0 ? void 0 : object.codecs) ? object.codecs.map((e) => Codec.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.codecs) {\n      obj.codecs = message.codecs.map((e) => e ? Codec.toJSON(e) : void 0);\n    } else {\n      obj.codecs = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return DisabledCodecs.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseDisabledCodecs();\n    message.codecs = ((_a = object.codecs) === null || _a === void 0 ? void 0 : _a.map((e) => Codec.fromPartial(e))) || [];\n    return message;\n  }\n};\nvar tsProtoGlobalThis$1 = (() => {\n  if (typeof globalThis !== \"undefined\") {\n    return globalThis;\n  }\n  if (typeof self !== \"undefined\") {\n    return self;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n  throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n  if (tsProtoGlobalThis$1.Buffer) {\n    return Uint8Array.from(tsProtoGlobalThis$1.Buffer.from(b64, \"base64\"));\n  } else {\n    const bin = tsProtoGlobalThis$1.atob(b64);\n    const arr = new Uint8Array(bin.length);\n    for (let i = 0; i < bin.length; ++i) {\n      arr[i] = bin.charCodeAt(i);\n    }\n    return arr;\n  }\n}\nfunction base64FromBytes(arr) {\n  if (tsProtoGlobalThis$1.Buffer) {\n    return tsProtoGlobalThis$1.Buffer.from(arr).toString(\"base64\");\n  } else {\n    const bin = [];\n    arr.forEach((byte) => {\n      bin.push(String.fromCharCode(byte));\n    });\n    return tsProtoGlobalThis$1.btoa(bin.join(\"\"));\n  }\n}\nfunction longToNumber$1(long2) {\n  if (long2.gt(Number.MAX_SAFE_INTEGER)) {\n    throw new tsProtoGlobalThis$1.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\n  }\n  return long2.toNumber();\n}\nif (_m0.util.Long !== Long$1) {\n  _m0.util.Long = Long$1;\n  _m0.configure();\n}\nfunction isSet$1(value) {\n  return value !== null && value !== void 0;\n}\nvar maxRetryDelay = 7e3;\nvar DEFAULT_RETRY_DELAYS_IN_MS = [0, 300, 2 * 2 * 300, 3 * 3 * 300, 4 * 4 * 300, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay];\nvar DefaultReconnectPolicy = class {\n  constructor(retryDelays) {\n    this._retryDelays = retryDelays !== void 0 ? [...retryDelays] : DEFAULT_RETRY_DELAYS_IN_MS;\n  }\n  nextRetryDelayInMs(context) {\n    if (context.retryCount >= this._retryDelays.length)\n      return null;\n    const retryDelay = this._retryDelays[context.retryCount];\n    if (context.retryCount <= 1)\n      return retryDelay;\n    return retryDelay + Math.random() * 1e3;\n  }\n};\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\nfunction __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m)\n    return m.call(o);\n  if (o && typeof o.length === \"number\")\n    return {\n      next: function() {\n        if (o && i >= o.length)\n          o = void 0;\n        return { value: o && o[i++], done: !o };\n      }\n    };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __asyncValues(o) {\n  if (!Symbol.asyncIterator)\n    throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n    return this;\n  }, i);\n  function verb(n) {\n    i[n] = o[n] && function(v) {\n      return new Promise(function(resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function(v2) {\n      resolve({ value: v2, done: d });\n    }, reject);\n  }\n}\nvar events = { exports: {} };\nvar R = typeof Reflect === \"object\" ? Reflect : null;\nvar ReflectApply = R && typeof R.apply === \"function\" ? R.apply : function ReflectApply2(target, receiver, args) {\n  return Function.prototype.apply.call(target, receiver, args);\n};\nvar ReflectOwnKeys;\nif (R && typeof R.ownKeys === \"function\") {\n  ReflectOwnKeys = R.ownKeys;\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys2(target) {\n    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys2(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn)\n    console.warn(warning);\n}\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {\n  return value !== value;\n};\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nevents.exports = EventEmitter;\nevents.exports.once = once2;\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.prototype._events = void 0;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = void 0;\nvar defaultMaxListeners = 10;\nfunction checkListener(listener) {\n  if (typeof listener !== \"function\") {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\nObject.defineProperty(EventEmitter, \"defaultMaxListeners\", {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== \"number\" || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + \".\");\n    }\n    defaultMaxListeners = arg;\n  }\n});\nEventEmitter.init = function() {\n  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = /* @__PURE__ */ Object.create(null);\n    this._eventsCount = 0;\n  }\n  this._maxListeners = this._maxListeners || void 0;\n};\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== \"number\" || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + \".\");\n  }\n  this._maxListeners = n;\n  return this;\n};\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === void 0)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++)\n    args.push(arguments[i]);\n  var doError = type === \"error\";\n  var events2 = this._events;\n  if (events2 !== void 0)\n    doError = doError && events2.error === void 0;\n  else if (!doError)\n    return false;\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      throw er;\n    }\n    var err = new Error(\"Unhandled error.\" + (er ? \" (\" + er.message + \")\" : \"\"));\n    err.context = er;\n    throw err;\n  }\n  var handler = events2[type];\n  if (handler === void 0)\n    return false;\n  if (typeof handler === \"function\") {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners2 = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners2[i], this, args);\n  }\n  return true;\n};\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events2;\n  var existing;\n  checkListener(listener);\n  events2 = target._events;\n  if (events2 === void 0) {\n    events2 = target._events = /* @__PURE__ */ Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    if (events2.newListener !== void 0) {\n      target.emit(\"newListener\", type, listener.listener ? listener.listener : listener);\n      events2 = target._events;\n    }\n    existing = events2[type];\n  }\n  if (existing === void 0) {\n    existing = events2[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === \"function\") {\n      existing = events2[type] = prepend ? [listener, existing] : [existing, listener];\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      var w = new Error(\"Possible EventEmitter memory leak detected. \" + existing.length + \" \" + String(type) + \" listeners added. Use emitter.setMaxListeners() to increase limit\");\n      w.name = \"MaxListenersExceededWarning\";\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n  return target;\n}\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n  return _addListener(this, type, listener, true);\n};\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\nfunction _onceWrap(target, type, listener) {\n  var state = {\n    fired: false,\n    wrapFn: void 0,\n    target,\n    type,\n    listener\n  };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n  checkListener(listener);\n  this.prependListener(type, _onceWrap(this, type, listener));\n  return this;\n};\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n  var list, events2, position, i, originalListener;\n  checkListener(listener);\n  events2 = this._events;\n  if (events2 === void 0)\n    return this;\n  list = events2[type];\n  if (list === void 0)\n    return this;\n  if (list === listener || list.listener === listener) {\n    if (--this._eventsCount === 0)\n      this._events = /* @__PURE__ */ Object.create(null);\n    else {\n      delete events2[type];\n      if (events2.removeListener)\n        this.emit(\"removeListener\", type, list.listener || listener);\n    }\n  } else if (typeof list !== \"function\") {\n    position = -1;\n    for (i = list.length - 1; i >= 0; i--) {\n      if (list[i] === listener || list[i].listener === listener) {\n        originalListener = list[i].listener;\n        position = i;\n        break;\n      }\n    }\n    if (position < 0)\n      return this;\n    if (position === 0)\n      list.shift();\n    else {\n      spliceOne(list, position);\n    }\n    if (list.length === 1)\n      events2[type] = list[0];\n    if (events2.removeListener !== void 0)\n      this.emit(\"removeListener\", type, originalListener || listener);\n  }\n  return this;\n};\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n  var listeners2, events2, i;\n  events2 = this._events;\n  if (events2 === void 0)\n    return this;\n  if (events2.removeListener === void 0) {\n    if (arguments.length === 0) {\n      this._events = /* @__PURE__ */ Object.create(null);\n      this._eventsCount = 0;\n    } else if (events2[type] !== void 0) {\n      if (--this._eventsCount === 0)\n        this._events = /* @__PURE__ */ Object.create(null);\n      else\n        delete events2[type];\n    }\n    return this;\n  }\n  if (arguments.length === 0) {\n    var keys = Object.keys(events2);\n    var key;\n    for (i = 0; i < keys.length; ++i) {\n      key = keys[i];\n      if (key === \"removeListener\")\n        continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners(\"removeListener\");\n    this._events = /* @__PURE__ */ Object.create(null);\n    this._eventsCount = 0;\n    return this;\n  }\n  listeners2 = events2[type];\n  if (typeof listeners2 === \"function\") {\n    this.removeListener(type, listeners2);\n  } else if (listeners2 !== void 0) {\n    for (i = listeners2.length - 1; i >= 0; i--) {\n      this.removeListener(type, listeners2[i]);\n    }\n  }\n  return this;\n};\nfunction _listeners(target, type, unwrap) {\n  var events2 = target._events;\n  if (events2 === void 0)\n    return [];\n  var evlistener = events2[type];\n  if (evlistener === void 0)\n    return [];\n  if (typeof evlistener === \"function\")\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === \"function\") {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events2 = this._events;\n  if (events2 !== void 0) {\n    var evlistener = events2[type];\n    if (typeof evlistener === \"function\") {\n      return 1;\n    } else if (evlistener !== void 0) {\n      return evlistener.length;\n    }\n  }\n  return 0;\n}\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\nfunction once2(emitter, name) {\n  return new Promise(function(resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n    function resolver() {\n      if (typeof emitter.removeListener === \"function\") {\n        emitter.removeListener(\"error\", errorListener);\n      }\n      resolve([].slice.call(arguments));\n    }\n    eventTargetAgnosticAddListener(emitter, name, resolver, {\n      once: true\n    });\n    if (name !== \"error\") {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, {\n        once: true\n      });\n    }\n  });\n}\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === \"function\") {\n    eventTargetAgnosticAddListener(emitter, \"error\", handler, flags);\n  }\n}\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === \"function\") {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === \"function\") {\n    emitter.addEventListener(name, function wrapListener(arg) {\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\nvar eventsExports = events.exports;\nvar logDisabled_ = true;\nvar deprecationWarnings_ = true;\nfunction extractVersion(uastring, expr, pos) {\n  const match = uastring.match(expr);\n  return match && match.length >= pos && parseInt(match[pos], 10);\n}\nfunction wrapPeerConnectionEvent(window2, eventNameToWrap, wrapper) {\n  if (!window2.RTCPeerConnection) {\n    return;\n  }\n  const proto = window2.RTCPeerConnection.prototype;\n  const nativeAddEventListener = proto.addEventListener;\n  proto.addEventListener = function(nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap) {\n      return nativeAddEventListener.apply(this, arguments);\n    }\n    const wrappedCallback = (e) => {\n      const modifiedEvent = wrapper(e);\n      if (modifiedEvent) {\n        if (cb.handleEvent) {\n          cb.handleEvent(modifiedEvent);\n        } else {\n          cb(modifiedEvent);\n        }\n      }\n    };\n    this._eventMap = this._eventMap || {};\n    if (!this._eventMap[eventNameToWrap]) {\n      this._eventMap[eventNameToWrap] = /* @__PURE__ */ new Map();\n    }\n    this._eventMap[eventNameToWrap].set(cb, wrappedCallback);\n    return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);\n  };\n  const nativeRemoveEventListener = proto.removeEventListener;\n  proto.removeEventListener = function(nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {\n      return nativeRemoveEventListener.apply(this, arguments);\n    }\n    if (!this._eventMap[eventNameToWrap].has(cb)) {\n      return nativeRemoveEventListener.apply(this, arguments);\n    }\n    const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);\n    this._eventMap[eventNameToWrap].delete(cb);\n    if (this._eventMap[eventNameToWrap].size === 0) {\n      delete this._eventMap[eventNameToWrap];\n    }\n    if (Object.keys(this._eventMap).length === 0) {\n      delete this._eventMap;\n    }\n    return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);\n  };\n  Object.defineProperty(proto, \"on\" + eventNameToWrap, {\n    get() {\n      return this[\"_on\" + eventNameToWrap];\n    },\n    set(cb) {\n      if (this[\"_on\" + eventNameToWrap]) {\n        this.removeEventListener(eventNameToWrap, this[\"_on\" + eventNameToWrap]);\n        delete this[\"_on\" + eventNameToWrap];\n      }\n      if (cb) {\n        this.addEventListener(eventNameToWrap, this[\"_on\" + eventNameToWrap] = cb);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n}\nfunction disableLog(bool) {\n  if (typeof bool !== \"boolean\") {\n    return new Error(\"Argument type: \" + typeof bool + \". Please use a boolean.\");\n  }\n  logDisabled_ = bool;\n  return bool ? \"adapter.js logging disabled\" : \"adapter.js logging enabled\";\n}\nfunction disableWarnings(bool) {\n  if (typeof bool !== \"boolean\") {\n    return new Error(\"Argument type: \" + typeof bool + \". Please use a boolean.\");\n  }\n  deprecationWarnings_ = !bool;\n  return \"adapter.js deprecation warnings \" + (bool ? \"disabled\" : \"enabled\");\n}\nfunction log() {\n  if (typeof window === \"object\") {\n    if (logDisabled_) {\n      return;\n    }\n    if (typeof console !== \"undefined\" && typeof console.log === \"function\") {\n      console.log.apply(console, arguments);\n    }\n  }\n}\nfunction deprecated(oldMethod, newMethod) {\n  if (!deprecationWarnings_) {\n    return;\n  }\n  console.warn(oldMethod + \" is deprecated, please use \" + newMethod + \" instead.\");\n}\nfunction detectBrowser(window2) {\n  const result = {\n    browser: null,\n    version: null\n  };\n  if (typeof window2 === \"undefined\" || !window2.navigator) {\n    result.browser = \"Not a browser.\";\n    return result;\n  }\n  const {\n    navigator: navigator2\n  } = window2;\n  if (navigator2.mozGetUserMedia) {\n    result.browser = \"firefox\";\n    result.version = extractVersion(navigator2.userAgent, /Firefox\\/(\\d+)\\./, 1);\n  } else if (navigator2.webkitGetUserMedia || window2.isSecureContext === false && window2.webkitRTCPeerConnection) {\n    result.browser = \"chrome\";\n    result.version = extractVersion(navigator2.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2);\n  } else if (window2.RTCPeerConnection && navigator2.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) {\n    result.browser = \"safari\";\n    result.version = extractVersion(navigator2.userAgent, /AppleWebKit\\/(\\d+)\\./, 1);\n    result.supportsUnifiedPlan = window2.RTCRtpTransceiver && \"currentDirection\" in window2.RTCRtpTransceiver.prototype;\n  } else {\n    result.browser = \"Not a supported browser.\";\n    return result;\n  }\n  return result;\n}\nfunction isObject(val) {\n  return Object.prototype.toString.call(val) === \"[object Object]\";\n}\nfunction compactObject(data) {\n  if (!isObject(data)) {\n    return data;\n  }\n  return Object.keys(data).reduce(function(accumulator, key) {\n    const isObj = isObject(data[key]);\n    const value = isObj ? compactObject(data[key]) : data[key];\n    const isEmptyObject = isObj && !Object.keys(value).length;\n    if (value === void 0 || isEmptyObject) {\n      return accumulator;\n    }\n    return Object.assign(accumulator, {\n      [key]: value\n    });\n  }, {});\n}\nfunction walkStats(stats, base, resultSet) {\n  if (!base || resultSet.has(base.id)) {\n    return;\n  }\n  resultSet.set(base.id, base);\n  Object.keys(base).forEach((name) => {\n    if (name.endsWith(\"Id\")) {\n      walkStats(stats, stats.get(base[name]), resultSet);\n    } else if (name.endsWith(\"Ids\")) {\n      base[name].forEach((id) => {\n        walkStats(stats, stats.get(id), resultSet);\n      });\n    }\n  });\n}\nfunction filterStats(result, track, outbound) {\n  const streamStatsType = outbound ? \"outbound-rtp\" : \"inbound-rtp\";\n  const filteredResult = /* @__PURE__ */ new Map();\n  if (track === null) {\n    return filteredResult;\n  }\n  const trackStats = [];\n  result.forEach((value) => {\n    if (value.type === \"track\" && value.trackIdentifier === track.id) {\n      trackStats.push(value);\n    }\n  });\n  trackStats.forEach((trackStat) => {\n    result.forEach((stats) => {\n      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {\n        walkStats(result, stats, filteredResult);\n      }\n    });\n  });\n  return filteredResult;\n}\nvar logging = log;\nfunction shimGetUserMedia$2(window2, browserDetails) {\n  const navigator2 = window2 && window2.navigator;\n  if (!navigator2.mediaDevices) {\n    return;\n  }\n  const constraintsToChrome_ = function(c) {\n    if (typeof c !== \"object\" || c.mandatory || c.optional) {\n      return c;\n    }\n    const cc = {};\n    Object.keys(c).forEach((key) => {\n      if (key === \"require\" || key === \"advanced\" || key === \"mediaSource\") {\n        return;\n      }\n      const r2 = typeof c[key] === \"object\" ? c[key] : {\n        ideal: c[key]\n      };\n      if (r2.exact !== void 0 && typeof r2.exact === \"number\") {\n        r2.min = r2.max = r2.exact;\n      }\n      const oldname_ = function(prefix, name) {\n        if (prefix) {\n          return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n        }\n        return name === \"deviceId\" ? \"sourceId\" : name;\n      };\n      if (r2.ideal !== void 0) {\n        cc.optional = cc.optional || [];\n        let oc = {};\n        if (typeof r2.ideal === \"number\") {\n          oc[oldname_(\"min\", key)] = r2.ideal;\n          cc.optional.push(oc);\n          oc = {};\n          oc[oldname_(\"max\", key)] = r2.ideal;\n          cc.optional.push(oc);\n        } else {\n          oc[oldname_(\"\", key)] = r2.ideal;\n          cc.optional.push(oc);\n        }\n      }\n      if (r2.exact !== void 0 && typeof r2.exact !== \"number\") {\n        cc.mandatory = cc.mandatory || {};\n        cc.mandatory[oldname_(\"\", key)] = r2.exact;\n      } else {\n        [\"min\", \"max\"].forEach((mix) => {\n          if (r2[mix] !== void 0) {\n            cc.mandatory = cc.mandatory || {};\n            cc.mandatory[oldname_(mix, key)] = r2[mix];\n          }\n        });\n      }\n    });\n    if (c.advanced) {\n      cc.optional = (cc.optional || []).concat(c.advanced);\n    }\n    return cc;\n  };\n  const shimConstraints_ = function(constraints, func) {\n    if (browserDetails.version >= 61) {\n      return func(constraints);\n    }\n    constraints = JSON.parse(JSON.stringify(constraints));\n    if (constraints && typeof constraints.audio === \"object\") {\n      const remap = function(obj, a, b) {\n        if (a in obj && !(b in obj)) {\n          obj[b] = obj[a];\n          delete obj[a];\n        }\n      };\n      constraints = JSON.parse(JSON.stringify(constraints));\n      remap(constraints.audio, \"autoGainControl\", \"googAutoGainControl\");\n      remap(constraints.audio, \"noiseSuppression\", \"googNoiseSuppression\");\n      constraints.audio = constraintsToChrome_(constraints.audio);\n    }\n    if (constraints && typeof constraints.video === \"object\") {\n      let face = constraints.video.facingMode;\n      face = face && (typeof face === \"object\" ? face : {\n        ideal: face\n      });\n      const getSupportedFacingModeLies = browserDetails.version < 66;\n      if (face && (face.exact === \"user\" || face.exact === \"environment\" || face.ideal === \"user\" || face.ideal === \"environment\") && !(navigator2.mediaDevices.getSupportedConstraints && navigator2.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {\n        delete constraints.video.facingMode;\n        let matches;\n        if (face.exact === \"environment\" || face.ideal === \"environment\") {\n          matches = [\"back\", \"rear\"];\n        } else if (face.exact === \"user\" || face.ideal === \"user\") {\n          matches = [\"front\"];\n        }\n        if (matches) {\n          return navigator2.mediaDevices.enumerateDevices().then((devices) => {\n            devices = devices.filter((d) => d.kind === \"videoinput\");\n            let dev = devices.find((d) => matches.some((match) => d.label.toLowerCase().includes(match)));\n            if (!dev && devices.length && matches.includes(\"back\")) {\n              dev = devices[devices.length - 1];\n            }\n            if (dev) {\n              constraints.video.deviceId = face.exact ? {\n                exact: dev.deviceId\n              } : {\n                ideal: dev.deviceId\n              };\n            }\n            constraints.video = constraintsToChrome_(constraints.video);\n            logging(\"chrome: \" + JSON.stringify(constraints));\n            return func(constraints);\n          });\n        }\n      }\n      constraints.video = constraintsToChrome_(constraints.video);\n    }\n    logging(\"chrome: \" + JSON.stringify(constraints));\n    return func(constraints);\n  };\n  const shimError_ = function(e) {\n    if (browserDetails.version >= 64) {\n      return e;\n    }\n    return {\n      name: {\n        PermissionDeniedError: \"NotAllowedError\",\n        PermissionDismissedError: \"NotAllowedError\",\n        InvalidStateError: \"NotAllowedError\",\n        DevicesNotFoundError: \"NotFoundError\",\n        ConstraintNotSatisfiedError: \"OverconstrainedError\",\n        TrackStartError: \"NotReadableError\",\n        MediaDeviceFailedDueToShutdown: \"NotAllowedError\",\n        MediaDeviceKillSwitchOn: \"NotAllowedError\",\n        TabCaptureError: \"AbortError\",\n        ScreenCaptureError: \"AbortError\",\n        DeviceCaptureError: \"AbortError\"\n      }[e.name] || e.name,\n      message: e.message,\n      constraint: e.constraint || e.constraintName,\n      toString() {\n        return this.name + (this.message && \": \") + this.message;\n      }\n    };\n  };\n  const getUserMedia_ = function(constraints, onSuccess, onError) {\n    shimConstraints_(constraints, (c) => {\n      navigator2.webkitGetUserMedia(c, onSuccess, (e) => {\n        if (onError) {\n          onError(shimError_(e));\n        }\n      });\n    });\n  };\n  navigator2.getUserMedia = getUserMedia_.bind(navigator2);\n  if (navigator2.mediaDevices.getUserMedia) {\n    const origGetUserMedia = navigator2.mediaDevices.getUserMedia.bind(navigator2.mediaDevices);\n    navigator2.mediaDevices.getUserMedia = function(cs) {\n      return shimConstraints_(cs, (c) => origGetUserMedia(c).then((stream) => {\n        if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {\n          stream.getTracks().forEach((track) => {\n            track.stop();\n          });\n          throw new DOMException(\"\", \"NotFoundError\");\n        }\n        return stream;\n      }, (e) => Promise.reject(shimError_(e))));\n    };\n  }\n}\nfunction shimGetDisplayMedia$1(window2, getSourceId) {\n  if (window2.navigator.mediaDevices && \"getDisplayMedia\" in window2.navigator.mediaDevices) {\n    return;\n  }\n  if (!window2.navigator.mediaDevices) {\n    return;\n  }\n  if (typeof getSourceId !== \"function\") {\n    console.error(\"shimGetDisplayMedia: getSourceId argument is not a function\");\n    return;\n  }\n  window2.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {\n    return getSourceId(constraints).then((sourceId) => {\n      const widthSpecified = constraints.video && constraints.video.width;\n      const heightSpecified = constraints.video && constraints.video.height;\n      const frameRateSpecified = constraints.video && constraints.video.frameRate;\n      constraints.video = {\n        mandatory: {\n          chromeMediaSource: \"desktop\",\n          chromeMediaSourceId: sourceId,\n          maxFrameRate: frameRateSpecified || 3\n        }\n      };\n      if (widthSpecified) {\n        constraints.video.mandatory.maxWidth = widthSpecified;\n      }\n      if (heightSpecified) {\n        constraints.video.mandatory.maxHeight = heightSpecified;\n      }\n      return window2.navigator.mediaDevices.getUserMedia(constraints);\n    });\n  };\n}\nfunction shimMediaStream(window2) {\n  window2.MediaStream = window2.MediaStream || window2.webkitMediaStream;\n}\nfunction shimOnTrack$1(window2) {\n  if (typeof window2 === \"object\" && window2.RTCPeerConnection && !(\"ontrack\" in window2.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window2.RTCPeerConnection.prototype, \"ontrack\", {\n      get() {\n        return this._ontrack;\n      },\n      set(f) {\n        if (this._ontrack) {\n          this.removeEventListener(\"track\", this._ontrack);\n        }\n        this.addEventListener(\"track\", this._ontrack = f);\n      },\n      enumerable: true,\n      configurable: true\n    });\n    const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;\n    window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n      if (!this._ontrackpoly) {\n        this._ontrackpoly = (e) => {\n          e.stream.addEventListener(\"addtrack\", (te) => {\n            let receiver;\n            if (window2.RTCPeerConnection.prototype.getReceivers) {\n              receiver = this.getReceivers().find((r2) => r2.track && r2.track.id === te.track.id);\n            } else {\n              receiver = {\n                track: te.track\n              };\n            }\n            const event = new Event(\"track\");\n            event.track = te.track;\n            event.receiver = receiver;\n            event.transceiver = {\n              receiver\n            };\n            event.streams = [e.stream];\n            this.dispatchEvent(event);\n          });\n          e.stream.getTracks().forEach((track) => {\n            let receiver;\n            if (window2.RTCPeerConnection.prototype.getReceivers) {\n              receiver = this.getReceivers().find((r2) => r2.track && r2.track.id === track.id);\n            } else {\n              receiver = {\n                track\n              };\n            }\n            const event = new Event(\"track\");\n            event.track = track;\n            event.receiver = receiver;\n            event.transceiver = {\n              receiver\n            };\n            event.streams = [e.stream];\n            this.dispatchEvent(event);\n          });\n        };\n        this.addEventListener(\"addstream\", this._ontrackpoly);\n      }\n      return origSetRemoteDescription.apply(this, arguments);\n    };\n  } else {\n    wrapPeerConnectionEvent(window2, \"track\", (e) => {\n      if (!e.transceiver) {\n        Object.defineProperty(e, \"transceiver\", {\n          value: {\n            receiver: e.receiver\n          }\n        });\n      }\n      return e;\n    });\n  }\n}\nfunction shimGetSendersWithDtmf(window2) {\n  if (typeof window2 === \"object\" && window2.RTCPeerConnection && !(\"getSenders\" in window2.RTCPeerConnection.prototype) && \"createDTMFSender\" in window2.RTCPeerConnection.prototype) {\n    const shimSenderWithDtmf = function(pc, track) {\n      return {\n        track,\n        get dtmf() {\n          if (this._dtmf === void 0) {\n            if (track.kind === \"audio\") {\n              this._dtmf = pc.createDTMFSender(track);\n            } else {\n              this._dtmf = null;\n            }\n          }\n          return this._dtmf;\n        },\n        _pc: pc\n      };\n    };\n    if (!window2.RTCPeerConnection.prototype.getSenders) {\n      window2.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        this._senders = this._senders || [];\n        return this._senders.slice();\n      };\n      const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;\n      window2.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n        let sender = origAddTrack.apply(this, arguments);\n        if (!sender) {\n          sender = shimSenderWithDtmf(this, track);\n          this._senders.push(sender);\n        }\n        return sender;\n      };\n      const origRemoveTrack = window2.RTCPeerConnection.prototype.removeTrack;\n      window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n        origRemoveTrack.apply(this, arguments);\n        const idx = this._senders.indexOf(sender);\n        if (idx !== -1) {\n          this._senders.splice(idx, 1);\n        }\n      };\n    }\n    const origAddStream = window2.RTCPeerConnection.prototype.addStream;\n    window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      this._senders = this._senders || [];\n      origAddStream.apply(this, [stream]);\n      stream.getTracks().forEach((track) => {\n        this._senders.push(shimSenderWithDtmf(this, track));\n      });\n    };\n    const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;\n    window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n      this._senders = this._senders || [];\n      origRemoveStream.apply(this, [stream]);\n      stream.getTracks().forEach((track) => {\n        const sender = this._senders.find((s) => s.track === track);\n        if (sender) {\n          this._senders.splice(this._senders.indexOf(sender), 1);\n        }\n      });\n    };\n  } else if (typeof window2 === \"object\" && window2.RTCPeerConnection && \"getSenders\" in window2.RTCPeerConnection.prototype && \"createDTMFSender\" in window2.RTCPeerConnection.prototype && window2.RTCRtpSender && !(\"dtmf\" in window2.RTCRtpSender.prototype)) {\n    const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;\n    window2.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach((sender) => sender._pc = this);\n      return senders;\n    };\n    Object.defineProperty(window2.RTCRtpSender.prototype, \"dtmf\", {\n      get() {\n        if (this._dtmf === void 0) {\n          if (this.track.kind === \"audio\") {\n            this._dtmf = this._pc.createDTMFSender(this.track);\n          } else {\n            this._dtmf = null;\n          }\n        }\n        return this._dtmf;\n      }\n    });\n  }\n}\nfunction shimGetStats(window2) {\n  if (!window2.RTCPeerConnection) {\n    return;\n  }\n  const origGetStats = window2.RTCPeerConnection.prototype.getStats;\n  window2.RTCPeerConnection.prototype.getStats = function getStats() {\n    const [selector, onSucc, onErr] = arguments;\n    if (arguments.length > 0 && typeof selector === \"function\") {\n      return origGetStats.apply(this, arguments);\n    }\n    if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== \"function\")) {\n      return origGetStats.apply(this, []);\n    }\n    const fixChromeStats_ = function(response) {\n      const standardReport = {};\n      const reports = response.result();\n      reports.forEach((report) => {\n        const standardStats = {\n          id: report.id,\n          timestamp: report.timestamp,\n          type: {\n            localcandidate: \"local-candidate\",\n            remotecandidate: \"remote-candidate\"\n          }[report.type] || report.type\n        };\n        report.names().forEach((name) => {\n          standardStats[name] = report.stat(name);\n        });\n        standardReport[standardStats.id] = standardStats;\n      });\n      return standardReport;\n    };\n    const makeMapStats = function(stats) {\n      return new Map(Object.keys(stats).map((key) => [key, stats[key]]));\n    };\n    if (arguments.length >= 2) {\n      const successCallbackWrapper_ = function(response) {\n        onSucc(makeMapStats(fixChromeStats_(response)));\n      };\n      return origGetStats.apply(this, [successCallbackWrapper_, selector]);\n    }\n    return new Promise((resolve, reject) => {\n      origGetStats.apply(this, [function(response) {\n        resolve(makeMapStats(fixChromeStats_(response)));\n      }, reject]);\n    }).then(onSucc, onErr);\n  };\n}\nfunction shimSenderReceiverGetStats(window2) {\n  if (!(typeof window2 === \"object\" && window2.RTCPeerConnection && window2.RTCRtpSender && window2.RTCRtpReceiver)) {\n    return;\n  }\n  if (!(\"getStats\" in window2.RTCRtpSender.prototype)) {\n    const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n      window2.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        const senders = origGetSenders.apply(this, []);\n        senders.forEach((sender) => sender._pc = this);\n        return senders;\n      };\n    }\n    const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n      window2.RTCPeerConnection.prototype.addTrack = function addTrack() {\n        const sender = origAddTrack.apply(this, arguments);\n        sender._pc = this;\n        return sender;\n      };\n    }\n    window2.RTCRtpSender.prototype.getStats = function getStats() {\n      const sender = this;\n      return this._pc.getStats().then((result) => (\n        /* Note: this will include stats of all senders that\n         *   send a track with the same id as sender.track as\n         *   it is not possible to identify the RTCRtpSender.\n         */\n        filterStats(result, sender.track, true)\n      ));\n    };\n  }\n  if (!(\"getStats\" in window2.RTCRtpReceiver.prototype)) {\n    const origGetReceivers = window2.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n      window2.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n        const receivers = origGetReceivers.apply(this, []);\n        receivers.forEach((receiver) => receiver._pc = this);\n        return receivers;\n      };\n    }\n    wrapPeerConnectionEvent(window2, \"track\", (e) => {\n      e.receiver._pc = e.srcElement;\n      return e;\n    });\n    window2.RTCRtpReceiver.prototype.getStats = function getStats() {\n      const receiver = this;\n      return this._pc.getStats().then((result) => filterStats(result, receiver.track, false));\n    };\n  }\n  if (!(\"getStats\" in window2.RTCRtpSender.prototype && \"getStats\" in window2.RTCRtpReceiver.prototype)) {\n    return;\n  }\n  const origGetStats = window2.RTCPeerConnection.prototype.getStats;\n  window2.RTCPeerConnection.prototype.getStats = function getStats() {\n    if (arguments.length > 0 && arguments[0] instanceof window2.MediaStreamTrack) {\n      const track = arguments[0];\n      let sender;\n      let receiver;\n      let err;\n      this.getSenders().forEach((s) => {\n        if (s.track === track) {\n          if (sender) {\n            err = true;\n          } else {\n            sender = s;\n          }\n        }\n      });\n      this.getReceivers().forEach((r2) => {\n        if (r2.track === track) {\n          if (receiver) {\n            err = true;\n          } else {\n            receiver = r2;\n          }\n        }\n        return r2.track === track;\n      });\n      if (err || sender && receiver) {\n        return Promise.reject(new DOMException(\"There are more than one sender or receiver for the track.\", \"InvalidAccessError\"));\n      } else if (sender) {\n        return sender.getStats();\n      } else if (receiver) {\n        return receiver.getStats();\n      }\n      return Promise.reject(new DOMException(\"There is no sender or receiver for the track.\", \"InvalidAccessError\"));\n    }\n    return origGetStats.apply(this, arguments);\n  };\n}\nfunction shimAddTrackRemoveTrackWithNative(window2) {\n  window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    return Object.keys(this._shimmedLocalStreams).map((streamId) => this._shimmedLocalStreams[streamId][0]);\n  };\n  const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;\n  window2.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n    if (!stream) {\n      return origAddTrack.apply(this, arguments);\n    }\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    const sender = origAddTrack.apply(this, arguments);\n    if (!this._shimmedLocalStreams[stream.id]) {\n      this._shimmedLocalStreams[stream.id] = [stream, sender];\n    } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n      this._shimmedLocalStreams[stream.id].push(sender);\n    }\n    return sender;\n  };\n  const origAddStream = window2.RTCPeerConnection.prototype.addStream;\n  window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    stream.getTracks().forEach((track) => {\n      const alreadyExists = this.getSenders().find((s) => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n      }\n    });\n    const existingSenders = this.getSenders();\n    origAddStream.apply(this, arguments);\n    const newSenders = this.getSenders().filter((newSender) => existingSenders.indexOf(newSender) === -1);\n    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);\n  };\n  const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;\n  window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    delete this._shimmedLocalStreams[stream.id];\n    return origRemoveStream.apply(this, arguments);\n  };\n  const origRemoveTrack = window2.RTCPeerConnection.prototype.removeTrack;\n  window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    if (sender) {\n      Object.keys(this._shimmedLocalStreams).forEach((streamId) => {\n        const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\n        if (idx !== -1) {\n          this._shimmedLocalStreams[streamId].splice(idx, 1);\n        }\n        if (this._shimmedLocalStreams[streamId].length === 1) {\n          delete this._shimmedLocalStreams[streamId];\n        }\n      });\n    }\n    return origRemoveTrack.apply(this, arguments);\n  };\n}\nfunction shimAddTrackRemoveTrack(window2, browserDetails) {\n  if (!window2.RTCPeerConnection) {\n    return;\n  }\n  if (window2.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {\n    return shimAddTrackRemoveTrackWithNative(window2);\n  }\n  const origGetLocalStreams = window2.RTCPeerConnection.prototype.getLocalStreams;\n  window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n    const nativeStreams = origGetLocalStreams.apply(this);\n    this._reverseStreams = this._reverseStreams || {};\n    return nativeStreams.map((stream) => this._reverseStreams[stream.id]);\n  };\n  const origAddStream = window2.RTCPeerConnection.prototype.addStream;\n  window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    stream.getTracks().forEach((track) => {\n      const alreadyExists = this.getSenders().find((s) => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n      }\n    });\n    if (!this._reverseStreams[stream.id]) {\n      const newStream = new window2.MediaStream(stream.getTracks());\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      stream = newStream;\n    }\n    origAddStream.apply(this, [stream]);\n  };\n  const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;\n  window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    origRemoveStream.apply(this, [this._streams[stream.id] || stream]);\n    delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];\n    delete this._streams[stream.id];\n  };\n  window2.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n    if (this.signalingState === \"closed\") {\n      throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\", \"InvalidStateError\");\n    }\n    const streams = [].slice.call(arguments, 1);\n    if (streams.length !== 1 || !streams[0].getTracks().find((t) => t === track)) {\n      throw new DOMException(\"The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.\", \"NotSupportedError\");\n    }\n    const alreadyExists = this.getSenders().find((s) => s.track === track);\n    if (alreadyExists) {\n      throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n    }\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    const oldStream = this._streams[stream.id];\n    if (oldStream) {\n      oldStream.addTrack(track);\n      Promise.resolve().then(() => {\n        this.dispatchEvent(new Event(\"negotiationneeded\"));\n      });\n    } else {\n      const newStream = new window2.MediaStream([track]);\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      this.addStream(newStream);\n    }\n    return this.getSenders().find((s) => s.track === track);\n  };\n  function replaceInternalStreamId(pc, description) {\n    let sdp2 = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach((internalId) => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp2 = sdp2.replace(new RegExp(internalStream.id, \"g\"), externalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp: sdp2\n    });\n  }\n  function replaceExternalStreamId(pc, description) {\n    let sdp2 = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach((internalId) => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp2 = sdp2.replace(new RegExp(externalStream.id, \"g\"), internalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp: sdp2\n    });\n  }\n  [\"createOffer\", \"createAnswer\"].forEach(function(method) {\n    const nativeMethod = window2.RTCPeerConnection.prototype[method];\n    const methodObj = {\n      [method]() {\n        const args = arguments;\n        const isLegacyCall = arguments.length && typeof arguments[0] === \"function\";\n        if (isLegacyCall) {\n          return nativeMethod.apply(this, [(description) => {\n            const desc = replaceInternalStreamId(this, description);\n            args[0].apply(null, [desc]);\n          }, (err) => {\n            if (args[1]) {\n              args[1].apply(null, err);\n            }\n          }, arguments[2]]);\n        }\n        return nativeMethod.apply(this, arguments).then((description) => replaceInternalStreamId(this, description));\n      }\n    };\n    window2.RTCPeerConnection.prototype[method] = methodObj[method];\n  });\n  const origSetLocalDescription = window2.RTCPeerConnection.prototype.setLocalDescription;\n  window2.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n    if (!arguments.length || !arguments[0].type) {\n      return origSetLocalDescription.apply(this, arguments);\n    }\n    arguments[0] = replaceExternalStreamId(this, arguments[0]);\n    return origSetLocalDescription.apply(this, arguments);\n  };\n  const origLocalDescription = Object.getOwnPropertyDescriptor(window2.RTCPeerConnection.prototype, \"localDescription\");\n  Object.defineProperty(window2.RTCPeerConnection.prototype, \"localDescription\", {\n    get() {\n      const description = origLocalDescription.get.apply(this);\n      if (description.type === \"\") {\n        return description;\n      }\n      return replaceInternalStreamId(this, description);\n    }\n  });\n  window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    if (this.signalingState === \"closed\") {\n      throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\", \"InvalidStateError\");\n    }\n    if (!sender._pc) {\n      throw new DOMException(\"Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.\", \"TypeError\");\n    }\n    const isLocal = sender._pc === this;\n    if (!isLocal) {\n      throw new DOMException(\"Sender was not created by this connection.\", \"InvalidAccessError\");\n    }\n    this._streams = this._streams || {};\n    let stream;\n    Object.keys(this._streams).forEach((streamid) => {\n      const hasTrack = this._streams[streamid].getTracks().find((track) => sender.track === track);\n      if (hasTrack) {\n        stream = this._streams[streamid];\n      }\n    });\n    if (stream) {\n      if (stream.getTracks().length === 1) {\n        this.removeStream(this._reverseStreams[stream.id]);\n      } else {\n        stream.removeTrack(sender.track);\n      }\n      this.dispatchEvent(new Event(\"negotiationneeded\"));\n    }\n  };\n}\nfunction shimPeerConnection$1(window2, browserDetails) {\n  if (!window2.RTCPeerConnection && window2.webkitRTCPeerConnection) {\n    window2.RTCPeerConnection = window2.webkitRTCPeerConnection;\n  }\n  if (!window2.RTCPeerConnection) {\n    return;\n  }\n  if (browserDetails.version < 53) {\n    [\"setLocalDescription\", \"setRemoteDescription\", \"addIceCandidate\"].forEach(function(method) {\n      const nativeMethod = window2.RTCPeerConnection.prototype[method];\n      const methodObj = {\n        [method]() {\n          arguments[0] = new (method === \"addIceCandidate\" ? window2.RTCIceCandidate : window2.RTCSessionDescription)(arguments[0]);\n          return nativeMethod.apply(this, arguments);\n        }\n      };\n      window2.RTCPeerConnection.prototype[method] = methodObj[method];\n    });\n  }\n}\nfunction fixNegotiationNeeded(window2, browserDetails) {\n  wrapPeerConnectionEvent(window2, \"negotiationneeded\", (e) => {\n    const pc = e.target;\n    if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === \"plan-b\") {\n      if (pc.signalingState !== \"stable\") {\n        return;\n      }\n    }\n    return e;\n  });\n}\nvar chromeShim = Object.freeze({\n  __proto__: null,\n  fixNegotiationNeeded,\n  shimAddTrackRemoveTrack,\n  shimAddTrackRemoveTrackWithNative,\n  shimGetDisplayMedia: shimGetDisplayMedia$1,\n  shimGetSendersWithDtmf,\n  shimGetStats,\n  shimGetUserMedia: shimGetUserMedia$2,\n  shimMediaStream,\n  shimOnTrack: shimOnTrack$1,\n  shimPeerConnection: shimPeerConnection$1,\n  shimSenderReceiverGetStats\n});\nfunction shimGetUserMedia$1(window2, browserDetails) {\n  const navigator2 = window2 && window2.navigator;\n  const MediaStreamTrack2 = window2 && window2.MediaStreamTrack;\n  navigator2.getUserMedia = function(constraints, onSuccess, onError) {\n    deprecated(\"navigator.getUserMedia\", \"navigator.mediaDevices.getUserMedia\");\n    navigator2.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\n  };\n  if (!(browserDetails.version > 55 && \"autoGainControl\" in navigator2.mediaDevices.getSupportedConstraints())) {\n    const remap = function(obj, a, b) {\n      if (a in obj && !(b in obj)) {\n        obj[b] = obj[a];\n        delete obj[a];\n      }\n    };\n    const nativeGetUserMedia = navigator2.mediaDevices.getUserMedia.bind(navigator2.mediaDevices);\n    navigator2.mediaDevices.getUserMedia = function(c) {\n      if (typeof c === \"object\" && typeof c.audio === \"object\") {\n        c = JSON.parse(JSON.stringify(c));\n        remap(c.audio, \"autoGainControl\", \"mozAutoGainControl\");\n        remap(c.audio, \"noiseSuppression\", \"mozNoiseSuppression\");\n      }\n      return nativeGetUserMedia(c);\n    };\n    if (MediaStreamTrack2 && MediaStreamTrack2.prototype.getSettings) {\n      const nativeGetSettings = MediaStreamTrack2.prototype.getSettings;\n      MediaStreamTrack2.prototype.getSettings = function() {\n        const obj = nativeGetSettings.apply(this, arguments);\n        remap(obj, \"mozAutoGainControl\", \"autoGainControl\");\n        remap(obj, \"mozNoiseSuppression\", \"noiseSuppression\");\n        return obj;\n      };\n    }\n    if (MediaStreamTrack2 && MediaStreamTrack2.prototype.applyConstraints) {\n      const nativeApplyConstraints = MediaStreamTrack2.prototype.applyConstraints;\n      MediaStreamTrack2.prototype.applyConstraints = function(c) {\n        if (this.kind === \"audio\" && typeof c === \"object\") {\n          c = JSON.parse(JSON.stringify(c));\n          remap(c, \"autoGainControl\", \"mozAutoGainControl\");\n          remap(c, \"noiseSuppression\", \"mozNoiseSuppression\");\n        }\n        return nativeApplyConstraints.apply(this, [c]);\n      };\n    }\n  }\n}\nfunction shimGetDisplayMedia(window2, preferredMediaSource) {\n  if (window2.navigator.mediaDevices && \"getDisplayMedia\" in window2.navigator.mediaDevices) {\n    return;\n  }\n  if (!window2.navigator.mediaDevices) {\n    return;\n  }\n  window2.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {\n    if (!(constraints && constraints.video)) {\n      const err = new DOMException(\"getDisplayMedia without video constraints is undefined\");\n      err.name = \"NotFoundError\";\n      err.code = 8;\n      return Promise.reject(err);\n    }\n    if (constraints.video === true) {\n      constraints.video = {\n        mediaSource: preferredMediaSource\n      };\n    } else {\n      constraints.video.mediaSource = preferredMediaSource;\n    }\n    return window2.navigator.mediaDevices.getUserMedia(constraints);\n  };\n}\nfunction shimOnTrack(window2) {\n  if (typeof window2 === \"object\" && window2.RTCTrackEvent && \"receiver\" in window2.RTCTrackEvent.prototype && !(\"transceiver\" in window2.RTCTrackEvent.prototype)) {\n    Object.defineProperty(window2.RTCTrackEvent.prototype, \"transceiver\", {\n      get() {\n        return {\n          receiver: this.receiver\n        };\n      }\n    });\n  }\n}\nfunction shimPeerConnection(window2, browserDetails) {\n  if (typeof window2 !== \"object\" || !(window2.RTCPeerConnection || window2.mozRTCPeerConnection)) {\n    return;\n  }\n  if (!window2.RTCPeerConnection && window2.mozRTCPeerConnection) {\n    window2.RTCPeerConnection = window2.mozRTCPeerConnection;\n  }\n  if (browserDetails.version < 53) {\n    [\"setLocalDescription\", \"setRemoteDescription\", \"addIceCandidate\"].forEach(function(method) {\n      const nativeMethod = window2.RTCPeerConnection.prototype[method];\n      const methodObj = {\n        [method]() {\n          arguments[0] = new (method === \"addIceCandidate\" ? window2.RTCIceCandidate : window2.RTCSessionDescription)(arguments[0]);\n          return nativeMethod.apply(this, arguments);\n        }\n      };\n      window2.RTCPeerConnection.prototype[method] = methodObj[method];\n    });\n  }\n  const modernStatsTypes = {\n    inboundrtp: \"inbound-rtp\",\n    outboundrtp: \"outbound-rtp\",\n    candidatepair: \"candidate-pair\",\n    localcandidate: \"local-candidate\",\n    remotecandidate: \"remote-candidate\"\n  };\n  const nativeGetStats = window2.RTCPeerConnection.prototype.getStats;\n  window2.RTCPeerConnection.prototype.getStats = function getStats() {\n    const [selector, onSucc, onErr] = arguments;\n    return nativeGetStats.apply(this, [selector || null]).then((stats) => {\n      if (browserDetails.version < 53 && !onSucc) {\n        try {\n          stats.forEach((stat) => {\n            stat.type = modernStatsTypes[stat.type] || stat.type;\n          });\n        } catch (e) {\n          if (e.name !== \"TypeError\") {\n            throw e;\n          }\n          stats.forEach((stat, i) => {\n            stats.set(i, Object.assign({}, stat, {\n              type: modernStatsTypes[stat.type] || stat.type\n            }));\n          });\n        }\n      }\n      return stats;\n    }).then(onSucc, onErr);\n  };\n}\nfunction shimSenderGetStats(window2) {\n  if (!(typeof window2 === \"object\" && window2.RTCPeerConnection && window2.RTCRtpSender)) {\n    return;\n  }\n  if (window2.RTCRtpSender && \"getStats\" in window2.RTCRtpSender.prototype) {\n    return;\n  }\n  const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;\n  if (origGetSenders) {\n    window2.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach((sender) => sender._pc = this);\n      return senders;\n    };\n  }\n  const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;\n  if (origAddTrack) {\n    window2.RTCPeerConnection.prototype.addTrack = function addTrack() {\n      const sender = origAddTrack.apply(this, arguments);\n      sender._pc = this;\n      return sender;\n    };\n  }\n  window2.RTCRtpSender.prototype.getStats = function getStats() {\n    return this.track ? this._pc.getStats(this.track) : Promise.resolve(/* @__PURE__ */ new Map());\n  };\n}\nfunction shimReceiverGetStats(window2) {\n  if (!(typeof window2 === \"object\" && window2.RTCPeerConnection && window2.RTCRtpSender)) {\n    return;\n  }\n  if (window2.RTCRtpSender && \"getStats\" in window2.RTCRtpReceiver.prototype) {\n    return;\n  }\n  const origGetReceivers = window2.RTCPeerConnection.prototype.getReceivers;\n  if (origGetReceivers) {\n    window2.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n      const receivers = origGetReceivers.apply(this, []);\n      receivers.forEach((receiver) => receiver._pc = this);\n      return receivers;\n    };\n  }\n  wrapPeerConnectionEvent(window2, \"track\", (e) => {\n    e.receiver._pc = e.srcElement;\n    return e;\n  });\n  window2.RTCRtpReceiver.prototype.getStats = function getStats() {\n    return this._pc.getStats(this.track);\n  };\n}\nfunction shimRemoveStream(window2) {\n  if (!window2.RTCPeerConnection || \"removeStream\" in window2.RTCPeerConnection.prototype) {\n    return;\n  }\n  window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n    deprecated(\"removeStream\", \"removeTrack\");\n    this.getSenders().forEach((sender) => {\n      if (sender.track && stream.getTracks().includes(sender.track)) {\n        this.removeTrack(sender);\n      }\n    });\n  };\n}\nfunction shimRTCDataChannel(window2) {\n  if (window2.DataChannel && !window2.RTCDataChannel) {\n    window2.RTCDataChannel = window2.DataChannel;\n  }\n}\nfunction shimAddTransceiver(window2) {\n  if (!(typeof window2 === \"object\" && window2.RTCPeerConnection)) {\n    return;\n  }\n  const origAddTransceiver = window2.RTCPeerConnection.prototype.addTransceiver;\n  if (origAddTransceiver) {\n    window2.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {\n      this.setParametersPromises = [];\n      let sendEncodings = arguments[1] && arguments[1].sendEncodings;\n      if (sendEncodings === void 0) {\n        sendEncodings = [];\n      }\n      sendEncodings = [...sendEncodings];\n      const shouldPerformCheck = sendEncodings.length > 0;\n      if (shouldPerformCheck) {\n        sendEncodings.forEach((encodingParam) => {\n          if (\"rid\" in encodingParam) {\n            const ridRegex = /^[a-z0-9]{0,16}$/i;\n            if (!ridRegex.test(encodingParam.rid)) {\n              throw new TypeError(\"Invalid RID value provided.\");\n            }\n          }\n          if (\"scaleResolutionDownBy\" in encodingParam) {\n            if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1)) {\n              throw new RangeError(\"scale_resolution_down_by must be >= 1.0\");\n            }\n          }\n          if (\"maxFramerate\" in encodingParam) {\n            if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {\n              throw new RangeError(\"max_framerate must be >= 0.0\");\n            }\n          }\n        });\n      }\n      const transceiver = origAddTransceiver.apply(this, arguments);\n      if (shouldPerformCheck) {\n        const {\n          sender\n        } = transceiver;\n        const params = sender.getParameters();\n        if (!(\"encodings\" in params) || // Avoid being fooled by patched getParameters() below.\n        params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {\n          params.encodings = sendEncodings;\n          sender.sendEncodings = sendEncodings;\n          this.setParametersPromises.push(sender.setParameters(params).then(() => {\n            delete sender.sendEncodings;\n          }).catch(() => {\n            delete sender.sendEncodings;\n          }));\n        }\n      }\n      return transceiver;\n    };\n  }\n}\nfunction shimGetParameters(window2) {\n  if (!(typeof window2 === \"object\" && window2.RTCRtpSender)) {\n    return;\n  }\n  const origGetParameters = window2.RTCRtpSender.prototype.getParameters;\n  if (origGetParameters) {\n    window2.RTCRtpSender.prototype.getParameters = function getParameters() {\n      const params = origGetParameters.apply(this, arguments);\n      if (!(\"encodings\" in params)) {\n        params.encodings = [].concat(this.sendEncodings || [{}]);\n      }\n      return params;\n    };\n  }\n}\nfunction shimCreateOffer(window2) {\n  if (!(typeof window2 === \"object\" && window2.RTCPeerConnection)) {\n    return;\n  }\n  const origCreateOffer = window2.RTCPeerConnection.prototype.createOffer;\n  window2.RTCPeerConnection.prototype.createOffer = function createOffer() {\n    if (this.setParametersPromises && this.setParametersPromises.length) {\n      return Promise.all(this.setParametersPromises).then(() => {\n        return origCreateOffer.apply(this, arguments);\n      }).finally(() => {\n        this.setParametersPromises = [];\n      });\n    }\n    return origCreateOffer.apply(this, arguments);\n  };\n}\nfunction shimCreateAnswer(window2) {\n  if (!(typeof window2 === \"object\" && window2.RTCPeerConnection)) {\n    return;\n  }\n  const origCreateAnswer = window2.RTCPeerConnection.prototype.createAnswer;\n  window2.RTCPeerConnection.prototype.createAnswer = function createAnswer() {\n    if (this.setParametersPromises && this.setParametersPromises.length) {\n      return Promise.all(this.setParametersPromises).then(() => {\n        return origCreateAnswer.apply(this, arguments);\n      }).finally(() => {\n        this.setParametersPromises = [];\n      });\n    }\n    return origCreateAnswer.apply(this, arguments);\n  };\n}\nvar firefoxShim = Object.freeze({\n  __proto__: null,\n  shimAddTransceiver,\n  shimCreateAnswer,\n  shimCreateOffer,\n  shimGetDisplayMedia,\n  shimGetParameters,\n  shimGetUserMedia: shimGetUserMedia$1,\n  shimOnTrack,\n  shimPeerConnection,\n  shimRTCDataChannel,\n  shimReceiverGetStats,\n  shimRemoveStream,\n  shimSenderGetStats\n});\nfunction shimLocalStreamsAPI(window2) {\n  if (typeof window2 !== \"object\" || !window2.RTCPeerConnection) {\n    return;\n  }\n  if (!(\"getLocalStreams\" in window2.RTCPeerConnection.prototype)) {\n    window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n      if (!this._localStreams) {\n        this._localStreams = [];\n      }\n      return this._localStreams;\n    };\n  }\n  if (!(\"addStream\" in window2.RTCPeerConnection.prototype)) {\n    const _addTrack = window2.RTCPeerConnection.prototype.addTrack;\n    window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      if (!this._localStreams) {\n        this._localStreams = [];\n      }\n      if (!this._localStreams.includes(stream)) {\n        this._localStreams.push(stream);\n      }\n      stream.getAudioTracks().forEach((track) => _addTrack.call(this, track, stream));\n      stream.getVideoTracks().forEach((track) => _addTrack.call(this, track, stream));\n    };\n    window2.RTCPeerConnection.prototype.addTrack = function addTrack(track) {\n      for (var _len = arguments.length, streams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        streams[_key - 1] = arguments[_key];\n      }\n      if (streams) {\n        streams.forEach((stream) => {\n          if (!this._localStreams) {\n            this._localStreams = [stream];\n          } else if (!this._localStreams.includes(stream)) {\n            this._localStreams.push(stream);\n          }\n        });\n      }\n      return _addTrack.apply(this, arguments);\n    };\n  }\n  if (!(\"removeStream\" in window2.RTCPeerConnection.prototype)) {\n    window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n      if (!this._localStreams) {\n        this._localStreams = [];\n      }\n      const index = this._localStreams.indexOf(stream);\n      if (index === -1) {\n        return;\n      }\n      this._localStreams.splice(index, 1);\n      const tracks = stream.getTracks();\n      this.getSenders().forEach((sender) => {\n        if (tracks.includes(sender.track)) {\n          this.removeTrack(sender);\n        }\n      });\n    };\n  }\n}\nfunction shimRemoteStreamsAPI(window2) {\n  if (typeof window2 !== \"object\" || !window2.RTCPeerConnection) {\n    return;\n  }\n  if (!(\"getRemoteStreams\" in window2.RTCPeerConnection.prototype)) {\n    window2.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {\n      return this._remoteStreams ? this._remoteStreams : [];\n    };\n  }\n  if (!(\"onaddstream\" in window2.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window2.RTCPeerConnection.prototype, \"onaddstream\", {\n      get() {\n        return this._onaddstream;\n      },\n      set(f) {\n        if (this._onaddstream) {\n          this.removeEventListener(\"addstream\", this._onaddstream);\n          this.removeEventListener(\"track\", this._onaddstreampoly);\n        }\n        this.addEventListener(\"addstream\", this._onaddstream = f);\n        this.addEventListener(\"track\", this._onaddstreampoly = (e) => {\n          e.streams.forEach((stream) => {\n            if (!this._remoteStreams) {\n              this._remoteStreams = [];\n            }\n            if (this._remoteStreams.includes(stream)) {\n              return;\n            }\n            this._remoteStreams.push(stream);\n            const event = new Event(\"addstream\");\n            event.stream = stream;\n            this.dispatchEvent(event);\n          });\n        });\n      }\n    });\n    const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;\n    window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n      const pc = this;\n      if (!this._onaddstreampoly) {\n        this.addEventListener(\"track\", this._onaddstreampoly = function(e) {\n          e.streams.forEach((stream) => {\n            if (!pc._remoteStreams) {\n              pc._remoteStreams = [];\n            }\n            if (pc._remoteStreams.indexOf(stream) >= 0) {\n              return;\n            }\n            pc._remoteStreams.push(stream);\n            const event = new Event(\"addstream\");\n            event.stream = stream;\n            pc.dispatchEvent(event);\n          });\n        });\n      }\n      return origSetRemoteDescription.apply(pc, arguments);\n    };\n  }\n}\nfunction shimCallbacksAPI(window2) {\n  if (typeof window2 !== \"object\" || !window2.RTCPeerConnection) {\n    return;\n  }\n  const prototype = window2.RTCPeerConnection.prototype;\n  const origCreateOffer = prototype.createOffer;\n  const origCreateAnswer = prototype.createAnswer;\n  const setLocalDescription = prototype.setLocalDescription;\n  const setRemoteDescription = prototype.setRemoteDescription;\n  const addIceCandidate = prototype.addIceCandidate;\n  prototype.createOffer = function createOffer(successCallback, failureCallback) {\n    const options = arguments.length >= 2 ? arguments[2] : arguments[0];\n    const promise = origCreateOffer.apply(this, [options]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.createAnswer = function createAnswer(successCallback, failureCallback) {\n    const options = arguments.length >= 2 ? arguments[2] : arguments[0];\n    const promise = origCreateAnswer.apply(this, [options]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  let withCallback = function(description, successCallback, failureCallback) {\n    const promise = setLocalDescription.apply(this, [description]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.setLocalDescription = withCallback;\n  withCallback = function(description, successCallback, failureCallback) {\n    const promise = setRemoteDescription.apply(this, [description]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.setRemoteDescription = withCallback;\n  withCallback = function(candidate, successCallback, failureCallback) {\n    const promise = addIceCandidate.apply(this, [candidate]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.addIceCandidate = withCallback;\n}\nfunction shimGetUserMedia(window2) {\n  const navigator2 = window2 && window2.navigator;\n  if (navigator2.mediaDevices && navigator2.mediaDevices.getUserMedia) {\n    const mediaDevices = navigator2.mediaDevices;\n    const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);\n    navigator2.mediaDevices.getUserMedia = (constraints) => {\n      return _getUserMedia(shimConstraints(constraints));\n    };\n  }\n  if (!navigator2.getUserMedia && navigator2.mediaDevices && navigator2.mediaDevices.getUserMedia) {\n    navigator2.getUserMedia = function getUserMedia(constraints, cb, errcb) {\n      navigator2.mediaDevices.getUserMedia(constraints).then(cb, errcb);\n    }.bind(navigator2);\n  }\n}\nfunction shimConstraints(constraints) {\n  if (constraints && constraints.video !== void 0) {\n    return Object.assign({}, constraints, {\n      video: compactObject(constraints.video)\n    });\n  }\n  return constraints;\n}\nfunction shimRTCIceServerUrls(window2) {\n  if (!window2.RTCPeerConnection) {\n    return;\n  }\n  const OrigPeerConnection = window2.RTCPeerConnection;\n  window2.RTCPeerConnection = function RTCPeerConnection2(pcConfig, pcConstraints) {\n    if (pcConfig && pcConfig.iceServers) {\n      const newIceServers = [];\n      for (let i = 0; i < pcConfig.iceServers.length; i++) {\n        let server = pcConfig.iceServers[i];\n        if (server.urls === void 0 && server.url) {\n          deprecated(\"RTCIceServer.url\", \"RTCIceServer.urls\");\n          server = JSON.parse(JSON.stringify(server));\n          server.urls = server.url;\n          delete server.url;\n          newIceServers.push(server);\n        } else {\n          newIceServers.push(pcConfig.iceServers[i]);\n        }\n      }\n      pcConfig.iceServers = newIceServers;\n    }\n    return new OrigPeerConnection(pcConfig, pcConstraints);\n  };\n  window2.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\n  if (\"generateCertificate\" in OrigPeerConnection) {\n    Object.defineProperty(window2.RTCPeerConnection, \"generateCertificate\", {\n      get() {\n        return OrigPeerConnection.generateCertificate;\n      }\n    });\n  }\n}\nfunction shimTrackEventTransceiver(window2) {\n  if (typeof window2 === \"object\" && window2.RTCTrackEvent && \"receiver\" in window2.RTCTrackEvent.prototype && !(\"transceiver\" in window2.RTCTrackEvent.prototype)) {\n    Object.defineProperty(window2.RTCTrackEvent.prototype, \"transceiver\", {\n      get() {\n        return {\n          receiver: this.receiver\n        };\n      }\n    });\n  }\n}\nfunction shimCreateOfferLegacy(window2) {\n  const origCreateOffer = window2.RTCPeerConnection.prototype.createOffer;\n  window2.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {\n    if (offerOptions) {\n      if (typeof offerOptions.offerToReceiveAudio !== \"undefined\") {\n        offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;\n      }\n      const audioTransceiver = this.getTransceivers().find((transceiver) => transceiver.receiver.track.kind === \"audio\");\n      if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {\n        if (audioTransceiver.direction === \"sendrecv\") {\n          if (audioTransceiver.setDirection) {\n            audioTransceiver.setDirection(\"sendonly\");\n          } else {\n            audioTransceiver.direction = \"sendonly\";\n          }\n        } else if (audioTransceiver.direction === \"recvonly\") {\n          if (audioTransceiver.setDirection) {\n            audioTransceiver.setDirection(\"inactive\");\n          } else {\n            audioTransceiver.direction = \"inactive\";\n          }\n        }\n      } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {\n        this.addTransceiver(\"audio\", {\n          direction: \"recvonly\"\n        });\n      }\n      if (typeof offerOptions.offerToReceiveVideo !== \"undefined\") {\n        offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;\n      }\n      const videoTransceiver = this.getTransceivers().find((transceiver) => transceiver.receiver.track.kind === \"video\");\n      if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {\n        if (videoTransceiver.direction === \"sendrecv\") {\n          if (videoTransceiver.setDirection) {\n            videoTransceiver.setDirection(\"sendonly\");\n          } else {\n            videoTransceiver.direction = \"sendonly\";\n          }\n        } else if (videoTransceiver.direction === \"recvonly\") {\n          if (videoTransceiver.setDirection) {\n            videoTransceiver.setDirection(\"inactive\");\n          } else {\n            videoTransceiver.direction = \"inactive\";\n          }\n        }\n      } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {\n        this.addTransceiver(\"video\", {\n          direction: \"recvonly\"\n        });\n      }\n    }\n    return origCreateOffer.apply(this, arguments);\n  };\n}\nfunction shimAudioContext(window2) {\n  if (typeof window2 !== \"object\" || window2.AudioContext) {\n    return;\n  }\n  window2.AudioContext = window2.webkitAudioContext;\n}\nvar safariShim = Object.freeze({\n  __proto__: null,\n  shimAudioContext,\n  shimCallbacksAPI,\n  shimConstraints,\n  shimCreateOfferLegacy,\n  shimGetUserMedia,\n  shimLocalStreamsAPI,\n  shimRTCIceServerUrls,\n  shimRemoteStreamsAPI,\n  shimTrackEventTransceiver\n});\nvar sdp$1 = { exports: {} };\n(function(module) {\n  const SDPUtils2 = {};\n  SDPUtils2.generateIdentifier = function() {\n    return Math.random().toString(36).substring(2, 12);\n  };\n  SDPUtils2.localCName = SDPUtils2.generateIdentifier();\n  SDPUtils2.splitLines = function(blob) {\n    return blob.trim().split(\"\\n\").map((line) => line.trim());\n  };\n  SDPUtils2.splitSections = function(blob) {\n    const parts = blob.split(\"\\nm=\");\n    return parts.map((part, index) => (index > 0 ? \"m=\" + part : part).trim() + \"\\r\\n\");\n  };\n  SDPUtils2.getDescription = function(blob) {\n    const sections = SDPUtils2.splitSections(blob);\n    return sections && sections[0];\n  };\n  SDPUtils2.getMediaSections = function(blob) {\n    const sections = SDPUtils2.splitSections(blob);\n    sections.shift();\n    return sections;\n  };\n  SDPUtils2.matchPrefix = function(blob, prefix) {\n    return SDPUtils2.splitLines(blob).filter((line) => line.indexOf(prefix) === 0);\n  };\n  SDPUtils2.parseCandidate = function(line) {\n    let parts;\n    if (line.indexOf(\"a=candidate:\") === 0) {\n      parts = line.substring(12).split(\" \");\n    } else {\n      parts = line.substring(10).split(\" \");\n    }\n    const candidate = {\n      foundation: parts[0],\n      component: {\n        1: \"rtp\",\n        2: \"rtcp\"\n      }[parts[1]] || parts[1],\n      protocol: parts[2].toLowerCase(),\n      priority: parseInt(parts[3], 10),\n      ip: parts[4],\n      address: parts[4],\n      // address is an alias for ip.\n      port: parseInt(parts[5], 10),\n      // skip parts[6] == 'typ'\n      type: parts[7]\n    };\n    for (let i = 8; i < parts.length; i += 2) {\n      switch (parts[i]) {\n        case \"raddr\":\n          candidate.relatedAddress = parts[i + 1];\n          break;\n        case \"rport\":\n          candidate.relatedPort = parseInt(parts[i + 1], 10);\n          break;\n        case \"tcptype\":\n          candidate.tcpType = parts[i + 1];\n          break;\n        case \"ufrag\":\n          candidate.ufrag = parts[i + 1];\n          candidate.usernameFragment = parts[i + 1];\n          break;\n        default:\n          if (candidate[parts[i]] === void 0) {\n            candidate[parts[i]] = parts[i + 1];\n          }\n          break;\n      }\n    }\n    return candidate;\n  };\n  SDPUtils2.writeCandidate = function(candidate) {\n    const sdp2 = [];\n    sdp2.push(candidate.foundation);\n    const component = candidate.component;\n    if (component === \"rtp\") {\n      sdp2.push(1);\n    } else if (component === \"rtcp\") {\n      sdp2.push(2);\n    } else {\n      sdp2.push(component);\n    }\n    sdp2.push(candidate.protocol.toUpperCase());\n    sdp2.push(candidate.priority);\n    sdp2.push(candidate.address || candidate.ip);\n    sdp2.push(candidate.port);\n    const type = candidate.type;\n    sdp2.push(\"typ\");\n    sdp2.push(type);\n    if (type !== \"host\" && candidate.relatedAddress && candidate.relatedPort) {\n      sdp2.push(\"raddr\");\n      sdp2.push(candidate.relatedAddress);\n      sdp2.push(\"rport\");\n      sdp2.push(candidate.relatedPort);\n    }\n    if (candidate.tcpType && candidate.protocol.toLowerCase() === \"tcp\") {\n      sdp2.push(\"tcptype\");\n      sdp2.push(candidate.tcpType);\n    }\n    if (candidate.usernameFragment || candidate.ufrag) {\n      sdp2.push(\"ufrag\");\n      sdp2.push(candidate.usernameFragment || candidate.ufrag);\n    }\n    return \"candidate:\" + sdp2.join(\" \");\n  };\n  SDPUtils2.parseIceOptions = function(line) {\n    return line.substring(14).split(\" \");\n  };\n  SDPUtils2.parseRtpMap = function(line) {\n    let parts = line.substring(9).split(\" \");\n    const parsed = {\n      payloadType: parseInt(parts.shift(), 10)\n      // was: id\n    };\n    parts = parts[0].split(\"/\");\n    parsed.name = parts[0];\n    parsed.clockRate = parseInt(parts[1], 10);\n    parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n    parsed.numChannels = parsed.channels;\n    return parsed;\n  };\n  SDPUtils2.writeRtpMap = function(codec) {\n    let pt = codec.payloadType;\n    if (codec.preferredPayloadType !== void 0) {\n      pt = codec.preferredPayloadType;\n    }\n    const channels = codec.channels || codec.numChannels || 1;\n    return \"a=rtpmap:\" + pt + \" \" + codec.name + \"/\" + codec.clockRate + (channels !== 1 ? \"/\" + channels : \"\") + \"\\r\\n\";\n  };\n  SDPUtils2.parseExtmap = function(line) {\n    const parts = line.substring(9).split(\" \");\n    return {\n      id: parseInt(parts[0], 10),\n      direction: parts[0].indexOf(\"/\") > 0 ? parts[0].split(\"/\")[1] : \"sendrecv\",\n      uri: parts[1],\n      attributes: parts.slice(2).join(\" \")\n    };\n  };\n  SDPUtils2.writeExtmap = function(headerExtension) {\n    return \"a=extmap:\" + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== \"sendrecv\" ? \"/\" + headerExtension.direction : \"\") + \" \" + headerExtension.uri + (headerExtension.attributes ? \" \" + headerExtension.attributes : \"\") + \"\\r\\n\";\n  };\n  SDPUtils2.parseFmtp = function(line) {\n    const parsed = {};\n    let kv;\n    const parts = line.substring(line.indexOf(\" \") + 1).split(\";\");\n    for (let j = 0; j < parts.length; j++) {\n      kv = parts[j].trim().split(\"=\");\n      parsed[kv[0].trim()] = kv[1];\n    }\n    return parsed;\n  };\n  SDPUtils2.writeFmtp = function(codec) {\n    let line = \"\";\n    let pt = codec.payloadType;\n    if (codec.preferredPayloadType !== void 0) {\n      pt = codec.preferredPayloadType;\n    }\n    if (codec.parameters && Object.keys(codec.parameters).length) {\n      const params = [];\n      Object.keys(codec.parameters).forEach((param) => {\n        if (codec.parameters[param] !== void 0) {\n          params.push(param + \"=\" + codec.parameters[param]);\n        } else {\n          params.push(param);\n        }\n      });\n      line += \"a=fmtp:\" + pt + \" \" + params.join(\";\") + \"\\r\\n\";\n    }\n    return line;\n  };\n  SDPUtils2.parseRtcpFb = function(line) {\n    const parts = line.substring(line.indexOf(\" \") + 1).split(\" \");\n    return {\n      type: parts.shift(),\n      parameter: parts.join(\" \")\n    };\n  };\n  SDPUtils2.writeRtcpFb = function(codec) {\n    let lines = \"\";\n    let pt = codec.payloadType;\n    if (codec.preferredPayloadType !== void 0) {\n      pt = codec.preferredPayloadType;\n    }\n    if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n      codec.rtcpFeedback.forEach((fb) => {\n        lines += \"a=rtcp-fb:\" + pt + \" \" + fb.type + (fb.parameter && fb.parameter.length ? \" \" + fb.parameter : \"\") + \"\\r\\n\";\n      });\n    }\n    return lines;\n  };\n  SDPUtils2.parseSsrcMedia = function(line) {\n    const sp = line.indexOf(\" \");\n    const parts = {\n      ssrc: parseInt(line.substring(7, sp), 10)\n    };\n    const colon = line.indexOf(\":\", sp);\n    if (colon > -1) {\n      parts.attribute = line.substring(sp + 1, colon);\n      parts.value = line.substring(colon + 1);\n    } else {\n      parts.attribute = line.substring(sp + 1);\n    }\n    return parts;\n  };\n  SDPUtils2.parseSsrcGroup = function(line) {\n    const parts = line.substring(13).split(\" \");\n    return {\n      semantics: parts.shift(),\n      ssrcs: parts.map((ssrc) => parseInt(ssrc, 10))\n    };\n  };\n  SDPUtils2.getMid = function(mediaSection) {\n    const mid = SDPUtils2.matchPrefix(mediaSection, \"a=mid:\")[0];\n    if (mid) {\n      return mid.substring(6);\n    }\n  };\n  SDPUtils2.parseFingerprint = function(line) {\n    const parts = line.substring(14).split(\" \");\n    return {\n      algorithm: parts[0].toLowerCase(),\n      // algorithm is case-sensitive in Edge.\n      value: parts[1].toUpperCase()\n      // the definition is upper-case in RFC 4572.\n    };\n  };\n  SDPUtils2.getDtlsParameters = function(mediaSection, sessionpart) {\n    const lines = SDPUtils2.matchPrefix(mediaSection + sessionpart, \"a=fingerprint:\");\n    return {\n      role: \"auto\",\n      fingerprints: lines.map(SDPUtils2.parseFingerprint)\n    };\n  };\n  SDPUtils2.writeDtlsParameters = function(params, setupType) {\n    let sdp2 = \"a=setup:\" + setupType + \"\\r\\n\";\n    params.fingerprints.forEach((fp) => {\n      sdp2 += \"a=fingerprint:\" + fp.algorithm + \" \" + fp.value + \"\\r\\n\";\n    });\n    return sdp2;\n  };\n  SDPUtils2.parseCryptoLine = function(line) {\n    const parts = line.substring(9).split(\" \");\n    return {\n      tag: parseInt(parts[0], 10),\n      cryptoSuite: parts[1],\n      keyParams: parts[2],\n      sessionParams: parts.slice(3)\n    };\n  };\n  SDPUtils2.writeCryptoLine = function(parameters) {\n    return \"a=crypto:\" + parameters.tag + \" \" + parameters.cryptoSuite + \" \" + (typeof parameters.keyParams === \"object\" ? SDPUtils2.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? \" \" + parameters.sessionParams.join(\" \") : \"\") + \"\\r\\n\";\n  };\n  SDPUtils2.parseCryptoKeyParams = function(keyParams) {\n    if (keyParams.indexOf(\"inline:\") !== 0) {\n      return null;\n    }\n    const parts = keyParams.substring(7).split(\"|\");\n    return {\n      keyMethod: \"inline\",\n      keySalt: parts[0],\n      lifeTime: parts[1],\n      mkiValue: parts[2] ? parts[2].split(\":\")[0] : void 0,\n      mkiLength: parts[2] ? parts[2].split(\":\")[1] : void 0\n    };\n  };\n  SDPUtils2.writeCryptoKeyParams = function(keyParams) {\n    return keyParams.keyMethod + \":\" + keyParams.keySalt + (keyParams.lifeTime ? \"|\" + keyParams.lifeTime : \"\") + (keyParams.mkiValue && keyParams.mkiLength ? \"|\" + keyParams.mkiValue + \":\" + keyParams.mkiLength : \"\");\n  };\n  SDPUtils2.getCryptoParameters = function(mediaSection, sessionpart) {\n    const lines = SDPUtils2.matchPrefix(mediaSection + sessionpart, \"a=crypto:\");\n    return lines.map(SDPUtils2.parseCryptoLine);\n  };\n  SDPUtils2.getIceParameters = function(mediaSection, sessionpart) {\n    const ufrag = SDPUtils2.matchPrefix(mediaSection + sessionpart, \"a=ice-ufrag:\")[0];\n    const pwd = SDPUtils2.matchPrefix(mediaSection + sessionpart, \"a=ice-pwd:\")[0];\n    if (!(ufrag && pwd)) {\n      return null;\n    }\n    return {\n      usernameFragment: ufrag.substring(12),\n      password: pwd.substring(10)\n    };\n  };\n  SDPUtils2.writeIceParameters = function(params) {\n    let sdp2 = \"a=ice-ufrag:\" + params.usernameFragment + \"\\r\\na=ice-pwd:\" + params.password + \"\\r\\n\";\n    if (params.iceLite) {\n      sdp2 += \"a=ice-lite\\r\\n\";\n    }\n    return sdp2;\n  };\n  SDPUtils2.parseRtpParameters = function(mediaSection) {\n    const description = {\n      codecs: [],\n      headerExtensions: [],\n      fecMechanisms: [],\n      rtcp: []\n    };\n    const lines = SDPUtils2.splitLines(mediaSection);\n    const mline = lines[0].split(\" \");\n    description.profile = mline[2];\n    for (let i = 3; i < mline.length; i++) {\n      const pt = mline[i];\n      const rtpmapline = SDPUtils2.matchPrefix(mediaSection, \"a=rtpmap:\" + pt + \" \")[0];\n      if (rtpmapline) {\n        const codec = SDPUtils2.parseRtpMap(rtpmapline);\n        const fmtps = SDPUtils2.matchPrefix(mediaSection, \"a=fmtp:\" + pt + \" \");\n        codec.parameters = fmtps.length ? SDPUtils2.parseFmtp(fmtps[0]) : {};\n        codec.rtcpFeedback = SDPUtils2.matchPrefix(mediaSection, \"a=rtcp-fb:\" + pt + \" \").map(SDPUtils2.parseRtcpFb);\n        description.codecs.push(codec);\n        switch (codec.name.toUpperCase()) {\n          case \"RED\":\n          case \"ULPFEC\":\n            description.fecMechanisms.push(codec.name.toUpperCase());\n            break;\n        }\n      }\n    }\n    SDPUtils2.matchPrefix(mediaSection, \"a=extmap:\").forEach((line) => {\n      description.headerExtensions.push(SDPUtils2.parseExtmap(line));\n    });\n    const wildcardRtcpFb = SDPUtils2.matchPrefix(mediaSection, \"a=rtcp-fb:* \").map(SDPUtils2.parseRtcpFb);\n    description.codecs.forEach((codec) => {\n      wildcardRtcpFb.forEach((fb) => {\n        const duplicate = codec.rtcpFeedback.find((existingFeedback) => {\n          return existingFeedback.type === fb.type && existingFeedback.parameter === fb.parameter;\n        });\n        if (!duplicate) {\n          codec.rtcpFeedback.push(fb);\n        }\n      });\n    });\n    return description;\n  };\n  SDPUtils2.writeRtpDescription = function(kind, caps) {\n    let sdp2 = \"\";\n    sdp2 += \"m=\" + kind + \" \";\n    sdp2 += caps.codecs.length > 0 ? \"9\" : \"0\";\n    sdp2 += \" \" + (caps.profile || \"UDP/TLS/RTP/SAVPF\") + \" \";\n    sdp2 += caps.codecs.map((codec) => {\n      if (codec.preferredPayloadType !== void 0) {\n        return codec.preferredPayloadType;\n      }\n      return codec.payloadType;\n    }).join(\" \") + \"\\r\\n\";\n    sdp2 += \"c=IN IP4 0.0.0.0\\r\\n\";\n    sdp2 += \"a=rtcp:9 IN IP4 0.0.0.0\\r\\n\";\n    caps.codecs.forEach((codec) => {\n      sdp2 += SDPUtils2.writeRtpMap(codec);\n      sdp2 += SDPUtils2.writeFmtp(codec);\n      sdp2 += SDPUtils2.writeRtcpFb(codec);\n    });\n    let maxptime = 0;\n    caps.codecs.forEach((codec) => {\n      if (codec.maxptime > maxptime) {\n        maxptime = codec.maxptime;\n      }\n    });\n    if (maxptime > 0) {\n      sdp2 += \"a=maxptime:\" + maxptime + \"\\r\\n\";\n    }\n    if (caps.headerExtensions) {\n      caps.headerExtensions.forEach((extension) => {\n        sdp2 += SDPUtils2.writeExtmap(extension);\n      });\n    }\n    return sdp2;\n  };\n  SDPUtils2.parseRtpEncodingParameters = function(mediaSection) {\n    const encodingParameters = [];\n    const description = SDPUtils2.parseRtpParameters(mediaSection);\n    const hasRed = description.fecMechanisms.indexOf(\"RED\") !== -1;\n    const hasUlpfec = description.fecMechanisms.indexOf(\"ULPFEC\") !== -1;\n    const ssrcs = SDPUtils2.matchPrefix(mediaSection, \"a=ssrc:\").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((parts) => parts.attribute === \"cname\");\n    const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n    let secondarySsrc;\n    const flows = SDPUtils2.matchPrefix(mediaSection, \"a=ssrc-group:FID\").map((line) => {\n      const parts = line.substring(17).split(\" \");\n      return parts.map((part) => parseInt(part, 10));\n    });\n    if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n      secondarySsrc = flows[0][1];\n    }\n    description.codecs.forEach((codec) => {\n      if (codec.name.toUpperCase() === \"RTX\" && codec.parameters.apt) {\n        let encParam = {\n          ssrc: primarySsrc,\n          codecPayloadType: parseInt(codec.parameters.apt, 10)\n        };\n        if (primarySsrc && secondarySsrc) {\n          encParam.rtx = {\n            ssrc: secondarySsrc\n          };\n        }\n        encodingParameters.push(encParam);\n        if (hasRed) {\n          encParam = JSON.parse(JSON.stringify(encParam));\n          encParam.fec = {\n            ssrc: primarySsrc,\n            mechanism: hasUlpfec ? \"red+ulpfec\" : \"red\"\n          };\n          encodingParameters.push(encParam);\n        }\n      }\n    });\n    if (encodingParameters.length === 0 && primarySsrc) {\n      encodingParameters.push({\n        ssrc: primarySsrc\n      });\n    }\n    let bandwidth = SDPUtils2.matchPrefix(mediaSection, \"b=\");\n    if (bandwidth.length) {\n      if (bandwidth[0].indexOf(\"b=TIAS:\") === 0) {\n        bandwidth = parseInt(bandwidth[0].substring(7), 10);\n      } else if (bandwidth[0].indexOf(\"b=AS:\") === 0) {\n        bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1e3 * 0.95 - 50 * 40 * 8;\n      } else {\n        bandwidth = void 0;\n      }\n      encodingParameters.forEach((params) => {\n        params.maxBitrate = bandwidth;\n      });\n    }\n    return encodingParameters;\n  };\n  SDPUtils2.parseRtcpParameters = function(mediaSection) {\n    const rtcpParameters = {};\n    const remoteSsrc = SDPUtils2.matchPrefix(mediaSection, \"a=ssrc:\").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((obj) => obj.attribute === \"cname\")[0];\n    if (remoteSsrc) {\n      rtcpParameters.cname = remoteSsrc.value;\n      rtcpParameters.ssrc = remoteSsrc.ssrc;\n    }\n    const rsize = SDPUtils2.matchPrefix(mediaSection, \"a=rtcp-rsize\");\n    rtcpParameters.reducedSize = rsize.length > 0;\n    rtcpParameters.compound = rsize.length === 0;\n    const mux = SDPUtils2.matchPrefix(mediaSection, \"a=rtcp-mux\");\n    rtcpParameters.mux = mux.length > 0;\n    return rtcpParameters;\n  };\n  SDPUtils2.writeRtcpParameters = function(rtcpParameters) {\n    let sdp2 = \"\";\n    if (rtcpParameters.reducedSize) {\n      sdp2 += \"a=rtcp-rsize\\r\\n\";\n    }\n    if (rtcpParameters.mux) {\n      sdp2 += \"a=rtcp-mux\\r\\n\";\n    }\n    if (rtcpParameters.ssrc !== void 0 && rtcpParameters.cname) {\n      sdp2 += \"a=ssrc:\" + rtcpParameters.ssrc + \" cname:\" + rtcpParameters.cname + \"\\r\\n\";\n    }\n    return sdp2;\n  };\n  SDPUtils2.parseMsid = function(mediaSection) {\n    let parts;\n    const spec = SDPUtils2.matchPrefix(mediaSection, \"a=msid:\");\n    if (spec.length === 1) {\n      parts = spec[0].substring(7).split(\" \");\n      return {\n        stream: parts[0],\n        track: parts[1]\n      };\n    }\n    const planB = SDPUtils2.matchPrefix(mediaSection, \"a=ssrc:\").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((msidParts) => msidParts.attribute === \"msid\");\n    if (planB.length > 0) {\n      parts = planB[0].value.split(\" \");\n      return {\n        stream: parts[0],\n        track: parts[1]\n      };\n    }\n  };\n  SDPUtils2.parseSctpDescription = function(mediaSection) {\n    const mline = SDPUtils2.parseMLine(mediaSection);\n    const maxSizeLine = SDPUtils2.matchPrefix(mediaSection, \"a=max-message-size:\");\n    let maxMessageSize;\n    if (maxSizeLine.length > 0) {\n      maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);\n    }\n    if (isNaN(maxMessageSize)) {\n      maxMessageSize = 65536;\n    }\n    const sctpPort = SDPUtils2.matchPrefix(mediaSection, \"a=sctp-port:\");\n    if (sctpPort.length > 0) {\n      return {\n        port: parseInt(sctpPort[0].substring(12), 10),\n        protocol: mline.fmt,\n        maxMessageSize\n      };\n    }\n    const sctpMapLines = SDPUtils2.matchPrefix(mediaSection, \"a=sctpmap:\");\n    if (sctpMapLines.length > 0) {\n      const parts = sctpMapLines[0].substring(10).split(\" \");\n      return {\n        port: parseInt(parts[0], 10),\n        protocol: parts[1],\n        maxMessageSize\n      };\n    }\n  };\n  SDPUtils2.writeSctpDescription = function(media, sctp) {\n    let output = [];\n    if (media.protocol !== \"DTLS/SCTP\") {\n      output = [\"m=\" + media.kind + \" 9 \" + media.protocol + \" \" + sctp.protocol + \"\\r\\n\", \"c=IN IP4 0.0.0.0\\r\\n\", \"a=sctp-port:\" + sctp.port + \"\\r\\n\"];\n    } else {\n      output = [\"m=\" + media.kind + \" 9 \" + media.protocol + \" \" + sctp.port + \"\\r\\n\", \"c=IN IP4 0.0.0.0\\r\\n\", \"a=sctpmap:\" + sctp.port + \" \" + sctp.protocol + \" 65535\\r\\n\"];\n    }\n    if (sctp.maxMessageSize !== void 0) {\n      output.push(\"a=max-message-size:\" + sctp.maxMessageSize + \"\\r\\n\");\n    }\n    return output.join(\"\");\n  };\n  SDPUtils2.generateSessionId = function() {\n    return Math.random().toString().substr(2, 22);\n  };\n  SDPUtils2.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {\n    let sessionId;\n    const version2 = sessVer !== void 0 ? sessVer : 2;\n    if (sessId) {\n      sessionId = sessId;\n    } else {\n      sessionId = SDPUtils2.generateSessionId();\n    }\n    const user = sessUser || \"thisisadapterortc\";\n    return \"v=0\\r\\no=\" + user + \" \" + sessionId + \" \" + version2 + \" IN IP4 127.0.0.1\\r\\ns=-\\r\\nt=0 0\\r\\n\";\n  };\n  SDPUtils2.getDirection = function(mediaSection, sessionpart) {\n    const lines = SDPUtils2.splitLines(mediaSection);\n    for (let i = 0; i < lines.length; i++) {\n      switch (lines[i]) {\n        case \"a=sendrecv\":\n        case \"a=sendonly\":\n        case \"a=recvonly\":\n        case \"a=inactive\":\n          return lines[i].substring(2);\n      }\n    }\n    if (sessionpart) {\n      return SDPUtils2.getDirection(sessionpart);\n    }\n    return \"sendrecv\";\n  };\n  SDPUtils2.getKind = function(mediaSection) {\n    const lines = SDPUtils2.splitLines(mediaSection);\n    const mline = lines[0].split(\" \");\n    return mline[0].substring(2);\n  };\n  SDPUtils2.isRejected = function(mediaSection) {\n    return mediaSection.split(\" \", 2)[1] === \"0\";\n  };\n  SDPUtils2.parseMLine = function(mediaSection) {\n    const lines = SDPUtils2.splitLines(mediaSection);\n    const parts = lines[0].substring(2).split(\" \");\n    return {\n      kind: parts[0],\n      port: parseInt(parts[1], 10),\n      protocol: parts[2],\n      fmt: parts.slice(3).join(\" \")\n    };\n  };\n  SDPUtils2.parseOLine = function(mediaSection) {\n    const line = SDPUtils2.matchPrefix(mediaSection, \"o=\")[0];\n    const parts = line.substring(2).split(\" \");\n    return {\n      username: parts[0],\n      sessionId: parts[1],\n      sessionVersion: parseInt(parts[2], 10),\n      netType: parts[3],\n      addressType: parts[4],\n      address: parts[5]\n    };\n  };\n  SDPUtils2.isValidSDP = function(blob) {\n    if (typeof blob !== \"string\" || blob.length === 0) {\n      return false;\n    }\n    const lines = SDPUtils2.splitLines(blob);\n    for (let i = 0; i < lines.length; i++) {\n      if (lines[i].length < 2 || lines[i].charAt(1) !== \"=\") {\n        return false;\n      }\n    }\n    return true;\n  };\n  {\n    module.exports = SDPUtils2;\n  }\n})(sdp$1);\nvar sdpExports = sdp$1.exports;\nvar SDPUtils = getDefaultExportFromCjs(sdpExports);\nvar sdp = _mergeNamespaces({\n  __proto__: null,\n  default: SDPUtils\n}, [sdpExports]);\nfunction shimRTCIceCandidate(window2) {\n  if (!window2.RTCIceCandidate || window2.RTCIceCandidate && \"foundation\" in window2.RTCIceCandidate.prototype) {\n    return;\n  }\n  const NativeRTCIceCandidate = window2.RTCIceCandidate;\n  window2.RTCIceCandidate = function RTCIceCandidate(args) {\n    if (typeof args === \"object\" && args.candidate && args.candidate.indexOf(\"a=\") === 0) {\n      args = JSON.parse(JSON.stringify(args));\n      args.candidate = args.candidate.substring(2);\n    }\n    if (args.candidate && args.candidate.length) {\n      const nativeCandidate = new NativeRTCIceCandidate(args);\n      const parsedCandidate = SDPUtils.parseCandidate(args.candidate);\n      for (const key in parsedCandidate) {\n        if (!(key in nativeCandidate)) {\n          Object.defineProperty(nativeCandidate, key, {\n            value: parsedCandidate[key]\n          });\n        }\n      }\n      nativeCandidate.toJSON = function toJSON() {\n        return {\n          candidate: nativeCandidate.candidate,\n          sdpMid: nativeCandidate.sdpMid,\n          sdpMLineIndex: nativeCandidate.sdpMLineIndex,\n          usernameFragment: nativeCandidate.usernameFragment\n        };\n      };\n      return nativeCandidate;\n    }\n    return new NativeRTCIceCandidate(args);\n  };\n  window2.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;\n  wrapPeerConnectionEvent(window2, \"icecandidate\", (e) => {\n    if (e.candidate) {\n      Object.defineProperty(e, \"candidate\", {\n        value: new window2.RTCIceCandidate(e.candidate),\n        writable: \"false\"\n      });\n    }\n    return e;\n  });\n}\nfunction shimRTCIceCandidateRelayProtocol(window2) {\n  if (!window2.RTCIceCandidate || window2.RTCIceCandidate && \"relayProtocol\" in window2.RTCIceCandidate.prototype) {\n    return;\n  }\n  wrapPeerConnectionEvent(window2, \"icecandidate\", (e) => {\n    if (e.candidate) {\n      const parsedCandidate = SDPUtils.parseCandidate(e.candidate.candidate);\n      if (parsedCandidate.type === \"relay\") {\n        e.candidate.relayProtocol = {\n          0: \"tls\",\n          1: \"tcp\",\n          2: \"udp\"\n        }[parsedCandidate.priority >> 24];\n      }\n    }\n    return e;\n  });\n}\nfunction shimMaxMessageSize(window2, browserDetails) {\n  if (!window2.RTCPeerConnection) {\n    return;\n  }\n  if (!(\"sctp\" in window2.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window2.RTCPeerConnection.prototype, \"sctp\", {\n      get() {\n        return typeof this._sctp === \"undefined\" ? null : this._sctp;\n      }\n    });\n  }\n  const sctpInDescription = function(description) {\n    if (!description || !description.sdp) {\n      return false;\n    }\n    const sections = SDPUtils.splitSections(description.sdp);\n    sections.shift();\n    return sections.some((mediaSection) => {\n      const mLine = SDPUtils.parseMLine(mediaSection);\n      return mLine && mLine.kind === \"application\" && mLine.protocol.indexOf(\"SCTP\") !== -1;\n    });\n  };\n  const getRemoteFirefoxVersion = function(description) {\n    const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n    if (match === null || match.length < 2) {\n      return -1;\n    }\n    const version2 = parseInt(match[1], 10);\n    return version2 !== version2 ? -1 : version2;\n  };\n  const getCanSendMaxMessageSize = function(remoteIsFirefox) {\n    let canSendMaxMessageSize = 65536;\n    if (browserDetails.browser === \"firefox\") {\n      if (browserDetails.version < 57) {\n        if (remoteIsFirefox === -1) {\n          canSendMaxMessageSize = 16384;\n        } else {\n          canSendMaxMessageSize = 2147483637;\n        }\n      } else if (browserDetails.version < 60) {\n        canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;\n      } else {\n        canSendMaxMessageSize = 2147483637;\n      }\n    }\n    return canSendMaxMessageSize;\n  };\n  const getMaxMessageSize = function(description, remoteIsFirefox) {\n    let maxMessageSize = 65536;\n    if (browserDetails.browser === \"firefox\" && browserDetails.version === 57) {\n      maxMessageSize = 65535;\n    }\n    const match = SDPUtils.matchPrefix(description.sdp, \"a=max-message-size:\");\n    if (match.length > 0) {\n      maxMessageSize = parseInt(match[0].substring(19), 10);\n    } else if (browserDetails.browser === \"firefox\" && remoteIsFirefox !== -1) {\n      maxMessageSize = 2147483637;\n    }\n    return maxMessageSize;\n  };\n  const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;\n  window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n    this._sctp = null;\n    if (browserDetails.browser === \"chrome\" && browserDetails.version >= 76) {\n      const {\n        sdpSemantics\n      } = this.getConfiguration();\n      if (sdpSemantics === \"plan-b\") {\n        Object.defineProperty(this, \"sctp\", {\n          get() {\n            return typeof this._sctp === \"undefined\" ? null : this._sctp;\n          },\n          enumerable: true,\n          configurable: true\n        });\n      }\n    }\n    if (sctpInDescription(arguments[0])) {\n      const isFirefox = getRemoteFirefoxVersion(arguments[0]);\n      const canSendMMS = getCanSendMaxMessageSize(isFirefox);\n      const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);\n      let maxMessageSize;\n      if (canSendMMS === 0 && remoteMMS === 0) {\n        maxMessageSize = Number.POSITIVE_INFINITY;\n      } else if (canSendMMS === 0 || remoteMMS === 0) {\n        maxMessageSize = Math.max(canSendMMS, remoteMMS);\n      } else {\n        maxMessageSize = Math.min(canSendMMS, remoteMMS);\n      }\n      const sctp = {};\n      Object.defineProperty(sctp, \"maxMessageSize\", {\n        get() {\n          return maxMessageSize;\n        }\n      });\n      this._sctp = sctp;\n    }\n    return origSetRemoteDescription.apply(this, arguments);\n  };\n}\nfunction shimSendThrowTypeError(window2) {\n  if (!(window2.RTCPeerConnection && \"createDataChannel\" in window2.RTCPeerConnection.prototype)) {\n    return;\n  }\n  function wrapDcSend(dc, pc) {\n    const origDataChannelSend = dc.send;\n    dc.send = function send() {\n      const data = arguments[0];\n      const length = data.length || data.size || data.byteLength;\n      if (dc.readyState === \"open\" && pc.sctp && length > pc.sctp.maxMessageSize) {\n        throw new TypeError(\"Message too large (can send a maximum of \" + pc.sctp.maxMessageSize + \" bytes)\");\n      }\n      return origDataChannelSend.apply(dc, arguments);\n    };\n  }\n  const origCreateDataChannel = window2.RTCPeerConnection.prototype.createDataChannel;\n  window2.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {\n    const dataChannel = origCreateDataChannel.apply(this, arguments);\n    wrapDcSend(dataChannel, this);\n    return dataChannel;\n  };\n  wrapPeerConnectionEvent(window2, \"datachannel\", (e) => {\n    wrapDcSend(e.channel, e.target);\n    return e;\n  });\n}\nfunction shimConnectionState(window2) {\n  if (!window2.RTCPeerConnection || \"connectionState\" in window2.RTCPeerConnection.prototype) {\n    return;\n  }\n  const proto = window2.RTCPeerConnection.prototype;\n  Object.defineProperty(proto, \"connectionState\", {\n    get() {\n      return {\n        completed: \"connected\",\n        checking: \"connecting\"\n      }[this.iceConnectionState] || this.iceConnectionState;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(proto, \"onconnectionstatechange\", {\n    get() {\n      return this._onconnectionstatechange || null;\n    },\n    set(cb) {\n      if (this._onconnectionstatechange) {\n        this.removeEventListener(\"connectionstatechange\", this._onconnectionstatechange);\n        delete this._onconnectionstatechange;\n      }\n      if (cb) {\n        this.addEventListener(\"connectionstatechange\", this._onconnectionstatechange = cb);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  [\"setLocalDescription\", \"setRemoteDescription\"].forEach((method) => {\n    const origMethod = proto[method];\n    proto[method] = function() {\n      if (!this._connectionstatechangepoly) {\n        this._connectionstatechangepoly = (e) => {\n          const pc = e.target;\n          if (pc._lastConnectionState !== pc.connectionState) {\n            pc._lastConnectionState = pc.connectionState;\n            const newEvent = new Event(\"connectionstatechange\", e);\n            pc.dispatchEvent(newEvent);\n          }\n          return e;\n        };\n        this.addEventListener(\"iceconnectionstatechange\", this._connectionstatechangepoly);\n      }\n      return origMethod.apply(this, arguments);\n    };\n  });\n}\nfunction removeExtmapAllowMixed(window2, browserDetails) {\n  if (!window2.RTCPeerConnection) {\n    return;\n  }\n  if (browserDetails.browser === \"chrome\" && browserDetails.version >= 71) {\n    return;\n  }\n  if (browserDetails.browser === \"safari\" && browserDetails.version >= 605) {\n    return;\n  }\n  const nativeSRD = window2.RTCPeerConnection.prototype.setRemoteDescription;\n  window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {\n    if (desc && desc.sdp && desc.sdp.indexOf(\"\\na=extmap-allow-mixed\") !== -1) {\n      const sdp2 = desc.sdp.split(\"\\n\").filter((line) => {\n        return line.trim() !== \"a=extmap-allow-mixed\";\n      }).join(\"\\n\");\n      if (window2.RTCSessionDescription && desc instanceof window2.RTCSessionDescription) {\n        arguments[0] = new window2.RTCSessionDescription({\n          type: desc.type,\n          sdp: sdp2\n        });\n      } else {\n        desc.sdp = sdp2;\n      }\n    }\n    return nativeSRD.apply(this, arguments);\n  };\n}\nfunction shimAddIceCandidateNullOrEmpty(window2, browserDetails) {\n  if (!(window2.RTCPeerConnection && window2.RTCPeerConnection.prototype)) {\n    return;\n  }\n  const nativeAddIceCandidate = window2.RTCPeerConnection.prototype.addIceCandidate;\n  if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {\n    return;\n  }\n  window2.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {\n    if (!arguments[0]) {\n      if (arguments[1]) {\n        arguments[1].apply(null);\n      }\n      return Promise.resolve();\n    }\n    if ((browserDetails.browser === \"chrome\" && browserDetails.version < 78 || browserDetails.browser === \"firefox\" && browserDetails.version < 68 || browserDetails.browser === \"safari\") && arguments[0] && arguments[0].candidate === \"\") {\n      return Promise.resolve();\n    }\n    return nativeAddIceCandidate.apply(this, arguments);\n  };\n}\nfunction shimParameterlessSetLocalDescription(window2, browserDetails) {\n  if (!(window2.RTCPeerConnection && window2.RTCPeerConnection.prototype)) {\n    return;\n  }\n  const nativeSetLocalDescription = window2.RTCPeerConnection.prototype.setLocalDescription;\n  if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {\n    return;\n  }\n  window2.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n    let desc = arguments[0] || {};\n    if (typeof desc !== \"object\" || desc.type && desc.sdp) {\n      return nativeSetLocalDescription.apply(this, arguments);\n    }\n    desc = {\n      type: desc.type,\n      sdp: desc.sdp\n    };\n    if (!desc.type) {\n      switch (this.signalingState) {\n        case \"stable\":\n        case \"have-local-offer\":\n        case \"have-remote-pranswer\":\n          desc.type = \"offer\";\n          break;\n        default:\n          desc.type = \"answer\";\n          break;\n      }\n    }\n    if (desc.sdp || desc.type !== \"offer\" && desc.type !== \"answer\") {\n      return nativeSetLocalDescription.apply(this, [desc]);\n    }\n    const func = desc.type === \"offer\" ? this.createOffer : this.createAnswer;\n    return func.apply(this).then((d) => nativeSetLocalDescription.apply(this, [d]));\n  };\n}\nvar commonShim = Object.freeze({\n  __proto__: null,\n  removeExtmapAllowMixed,\n  shimAddIceCandidateNullOrEmpty,\n  shimConnectionState,\n  shimMaxMessageSize,\n  shimParameterlessSetLocalDescription,\n  shimRTCIceCandidate,\n  shimRTCIceCandidateRelayProtocol,\n  shimSendThrowTypeError\n});\nfunction adapterFactory() {\n  let {\n    window: window2\n  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n    shimChrome: true,\n    shimFirefox: true,\n    shimSafari: true\n  };\n  const logging2 = log;\n  const browserDetails = detectBrowser(window2);\n  const adapter = {\n    browserDetails,\n    commonShim,\n    extractVersion,\n    disableLog,\n    disableWarnings,\n    // Expose sdp as a convenience. For production apps include directly.\n    sdp\n  };\n  switch (browserDetails.browser) {\n    case \"chrome\":\n      if (!chromeShim || !shimPeerConnection$1 || !options.shimChrome) {\n        logging2(\"Chrome shim is not included in this adapter release.\");\n        return adapter;\n      }\n      if (browserDetails.version === null) {\n        logging2(\"Chrome shim can not determine version, not shimming.\");\n        return adapter;\n      }\n      logging2(\"adapter.js shimming chrome.\");\n      adapter.browserShim = chromeShim;\n      shimAddIceCandidateNullOrEmpty(window2, browserDetails);\n      shimParameterlessSetLocalDescription(window2);\n      shimGetUserMedia$2(window2, browserDetails);\n      shimMediaStream(window2);\n      shimPeerConnection$1(window2, browserDetails);\n      shimOnTrack$1(window2);\n      shimAddTrackRemoveTrack(window2, browserDetails);\n      shimGetSendersWithDtmf(window2);\n      shimGetStats(window2);\n      shimSenderReceiverGetStats(window2);\n      fixNegotiationNeeded(window2, browserDetails);\n      shimRTCIceCandidate(window2);\n      shimRTCIceCandidateRelayProtocol(window2);\n      shimConnectionState(window2);\n      shimMaxMessageSize(window2, browserDetails);\n      shimSendThrowTypeError(window2);\n      removeExtmapAllowMixed(window2, browserDetails);\n      break;\n    case \"firefox\":\n      if (!firefoxShim || !shimPeerConnection || !options.shimFirefox) {\n        logging2(\"Firefox shim is not included in this adapter release.\");\n        return adapter;\n      }\n      logging2(\"adapter.js shimming firefox.\");\n      adapter.browserShim = firefoxShim;\n      shimAddIceCandidateNullOrEmpty(window2, browserDetails);\n      shimParameterlessSetLocalDescription(window2);\n      shimGetUserMedia$1(window2, browserDetails);\n      shimPeerConnection(window2, browserDetails);\n      shimOnTrack(window2);\n      shimRemoveStream(window2);\n      shimSenderGetStats(window2);\n      shimReceiverGetStats(window2);\n      shimRTCDataChannel(window2);\n      shimAddTransceiver(window2);\n      shimGetParameters(window2);\n      shimCreateOffer(window2);\n      shimCreateAnswer(window2);\n      shimRTCIceCandidate(window2);\n      shimConnectionState(window2);\n      shimMaxMessageSize(window2, browserDetails);\n      shimSendThrowTypeError(window2);\n      break;\n    case \"safari\":\n      if (!safariShim || !options.shimSafari) {\n        logging2(\"Safari shim is not included in this adapter release.\");\n        return adapter;\n      }\n      logging2(\"adapter.js shimming safari.\");\n      adapter.browserShim = safariShim;\n      shimAddIceCandidateNullOrEmpty(window2, browserDetails);\n      shimParameterlessSetLocalDescription(window2);\n      shimRTCIceServerUrls(window2);\n      shimCreateOfferLegacy(window2);\n      shimCallbacksAPI(window2);\n      shimLocalStreamsAPI(window2);\n      shimRemoteStreamsAPI(window2);\n      shimTrackEventTransceiver(window2);\n      shimGetUserMedia(window2);\n      shimAudioContext(window2);\n      shimRTCIceCandidate(window2);\n      shimRTCIceCandidateRelayProtocol(window2);\n      shimMaxMessageSize(window2, browserDetails);\n      shimSendThrowTypeError(window2);\n      removeExtmapAllowMixed(window2, browserDetails);\n      break;\n    default:\n      logging2(\"Unsupported browser!\");\n      break;\n  }\n  return adapter;\n}\nadapterFactory({\n  window: typeof window === \"undefined\" ? void 0 : window\n});\nvar uaParser = { exports: {} };\n(function(module, exports) {\n  (function(window2, undefined$1) {\n    var LIBVERSION = \"1.0.35\", EMPTY = \"\", UNKNOWN = \"?\", FUNC_TYPE = \"function\", UNDEF_TYPE = \"undefined\", OBJ_TYPE = \"object\", STR_TYPE = \"string\", MAJOR = \"major\", MODEL = \"model\", NAME = \"name\", TYPE = \"type\", VENDOR = \"vendor\", VERSION = \"version\", ARCHITECTURE = \"architecture\", CONSOLE = \"console\", MOBILE = \"mobile\", TABLET = \"tablet\", SMARTTV = \"smarttv\", WEARABLE = \"wearable\", EMBEDDED = \"embedded\", UA_MAX_LENGTH = 350;\n    var AMAZON = \"Amazon\", APPLE = \"Apple\", ASUS = \"ASUS\", BLACKBERRY = \"BlackBerry\", BROWSER = \"Browser\", CHROME = \"Chrome\", EDGE = \"Edge\", FIREFOX = \"Firefox\", GOOGLE = \"Google\", HUAWEI = \"Huawei\", LG = \"LG\", MICROSOFT = \"Microsoft\", MOTOROLA = \"Motorola\", OPERA = \"Opera\", SAMSUNG = \"Samsung\", SHARP = \"Sharp\", SONY = \"Sony\", XIAOMI = \"Xiaomi\", ZEBRA = \"Zebra\", FACEBOOK = \"Facebook\", CHROMIUM_OS = \"Chromium OS\", MAC_OS = \"Mac OS\";\n    var extend = function(regexes2, extensions) {\n      var mergedRegexes = {};\n      for (var i in regexes2) {\n        if (extensions[i] && extensions[i].length % 2 === 0) {\n          mergedRegexes[i] = extensions[i].concat(regexes2[i]);\n        } else {\n          mergedRegexes[i] = regexes2[i];\n        }\n      }\n      return mergedRegexes;\n    }, enumerize = function(arr) {\n      var enums = {};\n      for (var i = 0; i < arr.length; i++) {\n        enums[arr[i].toUpperCase()] = arr[i];\n      }\n      return enums;\n    }, has = function(str1, str2) {\n      return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;\n    }, lowerize = function(str) {\n      return str.toLowerCase();\n    }, majorize = function(version2) {\n      return typeof version2 === STR_TYPE ? version2.replace(/[^\\d\\.]/g, EMPTY).split(\".\")[0] : undefined$1;\n    }, trim = function(str, len) {\n      if (typeof str === STR_TYPE) {\n        str = str.replace(/^\\s\\s*/, EMPTY);\n        return typeof len === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);\n      }\n    };\n    var rgxMapper = function(ua, arrays) {\n      var i = 0, j, k, p, q, matches, match;\n      while (i < arrays.length && !matches) {\n        var regex = arrays[i], props = arrays[i + 1];\n        j = k = 0;\n        while (j < regex.length && !matches) {\n          if (!regex[j]) {\n            break;\n          }\n          matches = regex[j++].exec(ua);\n          if (!!matches) {\n            for (p = 0; p < props.length; p++) {\n              match = matches[++k];\n              q = props[p];\n              if (typeof q === OBJ_TYPE && q.length > 0) {\n                if (q.length === 2) {\n                  if (typeof q[1] == FUNC_TYPE) {\n                    this[q[0]] = q[1].call(this, match);\n                  } else {\n                    this[q[0]] = q[1];\n                  }\n                } else if (q.length === 3) {\n                  if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {\n                    this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined$1;\n                  } else {\n                    this[q[0]] = match ? match.replace(q[1], q[2]) : undefined$1;\n                  }\n                } else if (q.length === 4) {\n                  this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined$1;\n                }\n              } else {\n                this[q] = match ? match : undefined$1;\n              }\n            }\n          }\n        }\n        i += 2;\n      }\n    }, strMapper = function(str, map) {\n      for (var i in map) {\n        if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {\n          for (var j = 0; j < map[i].length; j++) {\n            if (has(map[i][j], str)) {\n              return i === UNKNOWN ? undefined$1 : i;\n            }\n          }\n        } else if (has(map[i], str)) {\n          return i === UNKNOWN ? undefined$1 : i;\n        }\n      }\n      return str;\n    };\n    var oldSafariMap = {\n      \"1.0\": \"/8\",\n      \"1.2\": \"/1\",\n      \"1.3\": \"/3\",\n      \"2.0\": \"/412\",\n      \"2.0.2\": \"/416\",\n      \"2.0.3\": \"/417\",\n      \"2.0.4\": \"/419\",\n      \"?\": \"/\"\n    }, windowsVersionMap = {\n      \"ME\": \"4.90\",\n      \"NT 3.11\": \"NT3.51\",\n      \"NT 4.0\": \"NT4.0\",\n      \"2000\": \"NT 5.0\",\n      \"XP\": [\"NT 5.1\", \"NT 5.2\"],\n      \"Vista\": \"NT 6.0\",\n      \"7\": \"NT 6.1\",\n      \"8\": \"NT 6.2\",\n      \"8.1\": \"NT 6.3\",\n      \"10\": [\"NT 6.4\", \"NT 10.0\"],\n      \"RT\": \"ARM\"\n    };\n    var regexes = {\n      browser: [[\n        /\\b(?:crmo|crios)\\/([\\w\\.]+)/i\n        // Chrome for Android/iOS\n      ], [VERSION, [NAME, \"Chrome\"]], [\n        /edg(?:e|ios|a)?\\/([\\w\\.]+)/i\n        // Microsoft Edge\n      ], [VERSION, [NAME, \"Edge\"]], [\n        // Presto based\n        /(opera mini)\\/([-\\w\\.]+)/i,\n        // Opera Mini\n        /(opera [mobiletab]{3,6})\\b.+version\\/([-\\w\\.]+)/i,\n        // Opera Mobi/Tablet\n        /(opera)(?:.+version\\/|[\\/ ]+)([\\w\\.]+)/i\n        // Opera\n      ], [NAME, VERSION], [\n        /opios[\\/ ]+([\\w\\.]+)/i\n        // Opera mini on iphone >= 8.0\n      ], [VERSION, [NAME, OPERA + \" Mini\"]], [\n        /\\bopr\\/([\\w\\.]+)/i\n        // Opera Webkit\n      ], [VERSION, [NAME, OPERA]], [\n        // Mixed\n        /(kindle)\\/([\\w\\.]+)/i,\n        // Kindle\n        /(lunascape|maxthon|netfront|jasmine|blazer)[\\/ ]?([\\w\\.]*)/i,\n        // Lunascape/Maxthon/Netfront/Jasmine/Blazer\n        // Trident based\n        /(avant |iemobile|slim)(?:browser)?[\\/ ]?([\\w\\.]*)/i,\n        // Avant/IEMobile/SlimBrowser\n        /(ba?idubrowser)[\\/ ]?([\\w\\.]+)/i,\n        // Baidu Browser\n        /(?:ms|\\()(ie) ([\\w\\.]+)/i,\n        // Internet Explorer\n        // Webkit/KHTML based                                               // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon\n        /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\\/([-\\w\\.]+)/i,\n        // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ, aka ShouQ\n        /(heytap|ovi)browser\\/([\\d\\.]+)/i,\n        // Heytap/Ovi\n        /(weibo)__([\\d\\.]+)/i\n        // Weibo\n      ], [NAME, VERSION], [\n        /(?:\\buc? ?browser|(?:juc.+)ucweb)[\\/ ]?([\\w\\.]+)/i\n        // UCBrowser\n      ], [VERSION, [NAME, \"UC\" + BROWSER]], [\n        /microm.+\\bqbcore\\/([\\w\\.]+)/i,\n        // WeChat Desktop for Windows Built-in Browser\n        /\\bqbcore\\/([\\w\\.]+).+microm/i\n      ], [VERSION, [NAME, \"WeChat(Win) Desktop\"]], [\n        /micromessenger\\/([\\w\\.]+)/i\n        // WeChat\n      ], [VERSION, [NAME, \"WeChat\"]], [\n        /konqueror\\/([\\w\\.]+)/i\n        // Konqueror\n      ], [VERSION, [NAME, \"Konqueror\"]], [\n        /trident.+rv[: ]([\\w\\.]{1,9})\\b.+like gecko/i\n        // IE11\n      ], [VERSION, [NAME, \"IE\"]], [\n        /ya(?:search)?browser\\/([\\w\\.]+)/i\n        // Yandex\n      ], [VERSION, [NAME, \"Yandex\"]], [\n        /(avast|avg)\\/([\\w\\.]+)/i\n        // Avast/AVG Secure Browser\n      ], [[NAME, /(.+)/, \"$1 Secure \" + BROWSER], VERSION], [\n        /\\bfocus\\/([\\w\\.]+)/i\n        // Firefox Focus\n      ], [VERSION, [NAME, FIREFOX + \" Focus\"]], [\n        /\\bopt\\/([\\w\\.]+)/i\n        // Opera Touch\n      ], [VERSION, [NAME, OPERA + \" Touch\"]], [\n        /coc_coc\\w+\\/([\\w\\.]+)/i\n        // Coc Coc Browser\n      ], [VERSION, [NAME, \"Coc Coc\"]], [\n        /dolfin\\/([\\w\\.]+)/i\n        // Dolphin\n      ], [VERSION, [NAME, \"Dolphin\"]], [\n        /coast\\/([\\w\\.]+)/i\n        // Opera Coast\n      ], [VERSION, [NAME, OPERA + \" Coast\"]], [\n        /miuibrowser\\/([\\w\\.]+)/i\n        // MIUI Browser\n      ], [VERSION, [NAME, \"MIUI \" + BROWSER]], [\n        /fxios\\/([-\\w\\.]+)/i\n        // Firefox for iOS\n      ], [VERSION, [NAME, FIREFOX]], [\n        /\\bqihu|(qi?ho?o?|360)browser/i\n        // 360\n      ], [[NAME, \"360 \" + BROWSER]], [/(oculus|samsung|sailfish|huawei)browser\\/([\\w\\.]+)/i], [[NAME, /(.+)/, \"$1 \" + BROWSER], VERSION], [\n        // Oculus/Samsung/Sailfish/Huawei Browser\n        /(comodo_dragon)\\/([\\w\\.]+)/i\n        // Comodo Dragon\n      ], [[NAME, /_/g, \" \"], VERSION], [\n        /(electron)\\/([\\w\\.]+) safari/i,\n        // Electron-based App\n        /(tesla)(?: qtcarbrowser|\\/(20\\d\\d\\.[-\\w\\.]+))/i,\n        // Tesla\n        /m?(qqbrowser|baiduboxapp|2345Explorer)[\\/ ]?([\\w\\.]+)/i\n        // QQBrowser/Baidu App/2345 Browser\n      ], [NAME, VERSION], [\n        /(metasr)[\\/ ]?([\\w\\.]+)/i,\n        // SouGouBrowser\n        /(lbbrowser)/i,\n        // LieBao Browser\n        /\\[(linkedin)app\\]/i\n        // LinkedIn App for iOS & Android\n      ], [NAME], [\n        // WebView\n        /((?:fban\\/fbios|fb_iab\\/fb4a)(?!.+fbav)|;fbav\\/([\\w\\.]+);)/i\n        // Facebook App for iOS & Android\n      ], [[NAME, FACEBOOK], VERSION], [\n        /(kakao(?:talk|story))[\\/ ]([\\w\\.]+)/i,\n        // Kakao App\n        /(naver)\\(.*?(\\d+\\.[\\w\\.]+).*\\)/i,\n        // Naver InApp\n        /safari (line)\\/([\\w\\.]+)/i,\n        // Line App for iOS\n        /\\b(line)\\/([\\w\\.]+)\\/iab/i,\n        // Line App for Android\n        /(chromium|instagram)[\\/ ]([-\\w\\.]+)/i\n        // Chromium/Instagram\n      ], [NAME, VERSION], [\n        /\\bgsa\\/([\\w\\.]+) .*safari\\//i\n        // Google Search Appliance on iOS\n      ], [VERSION, [NAME, \"GSA\"]], [\n        /musical_ly(?:.+app_?version\\/|_)([\\w\\.]+)/i\n        // TikTok\n      ], [VERSION, [NAME, \"TikTok\"]], [\n        /headlesschrome(?:\\/([\\w\\.]+)| )/i\n        // Chrome Headless\n      ], [VERSION, [NAME, CHROME + \" Headless\"]], [\n        / wv\\).+(chrome)\\/([\\w\\.]+)/i\n        // Chrome WebView\n      ], [[NAME, CHROME + \" WebView\"], VERSION], [\n        /droid.+ version\\/([\\w\\.]+)\\b.+(?:mobile safari|safari)/i\n        // Android Browser\n      ], [VERSION, [NAME, \"Android \" + BROWSER]], [\n        /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\\/v?([\\w\\.]+)/i\n        // Chrome/OmniWeb/Arora/Tizen/Nokia\n      ], [NAME, VERSION], [\n        /version\\/([\\w\\.\\,]+) .*mobile\\/\\w+ (safari)/i\n        // Mobile Safari\n      ], [VERSION, [NAME, \"Mobile Safari\"]], [\n        /version\\/([\\w(\\.|\\,)]+) .*(mobile ?safari|safari)/i\n        // Safari & Safari Mobile\n      ], [VERSION, NAME], [\n        /webkit.+?(mobile ?safari|safari)(\\/[\\w\\.]+)/i\n        // Safari < 3.0\n      ], [NAME, [VERSION, strMapper, oldSafariMap]], [/(webkit|khtml)\\/([\\w\\.]+)/i], [NAME, VERSION], [\n        // Gecko based\n        /(navigator|netscape\\d?)\\/([-\\w\\.]+)/i\n        // Netscape\n      ], [[NAME, \"Netscape\"], VERSION], [\n        /mobile vr; rv:([\\w\\.]+)\\).+firefox/i\n        // Firefox Reality\n      ], [VERSION, [NAME, FIREFOX + \" Reality\"]], [\n        /ekiohf.+(flow)\\/([\\w\\.]+)/i,\n        // Flow\n        /(swiftfox)/i,\n        // Swiftfox\n        /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\\/ ]?([\\w\\.\\+]+)/i,\n        // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror/Klar\n        /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\\/([-\\w\\.]+)$/i,\n        // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix\n        /(firefox)\\/([\\w\\.]+)/i,\n        // Other Firefox-based\n        /(mozilla)\\/([\\w\\.]+) .+rv\\:.+gecko\\/\\d+/i,\n        // Mozilla\n        // Other\n        /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\\. ]?browser)[-\\/ ]?v?([\\w\\.]+)/i,\n        // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir/Obigo/Mosaic/Go/ICE/UP.Browser\n        /(links) \\(([\\w\\.]+)/i,\n        // Links\n        /panasonic;(viera)/i\n        // Panasonic Viera\n      ], [NAME, VERSION], [\n        /(cobalt)\\/([\\w\\.]+)/i\n        // Cobalt\n      ], [NAME, [VERSION, /master.|lts./, \"\"]]],\n      cpu: [[\n        /(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\\)]/i\n        // AMD64 (x64)\n      ], [[ARCHITECTURE, \"amd64\"]], [\n        /(ia32(?=;))/i\n        // IA32 (quicktime)\n      ], [[ARCHITECTURE, lowerize]], [\n        /((?:i[346]|x)86)[;\\)]/i\n        // IA32 (x86)\n      ], [[ARCHITECTURE, \"ia32\"]], [\n        /\\b(aarch64|arm(v?8e?l?|_?64))\\b/i\n        // ARM64\n      ], [[ARCHITECTURE, \"arm64\"]], [\n        /\\b(arm(?:v[67])?ht?n?[fl]p?)\\b/i\n        // ARMHF\n      ], [[ARCHITECTURE, \"armhf\"]], [\n        // PocketPC mistakenly identified as PowerPC\n        /windows (ce|mobile); ppc;/i\n      ], [[ARCHITECTURE, \"arm\"]], [\n        /((?:ppc|powerpc)(?:64)?)(?: mac|;|\\))/i\n        // PowerPC\n      ], [[ARCHITECTURE, /ower/, EMPTY, lowerize]], [\n        /(sun4\\w)[;\\)]/i\n        // SPARC\n      ], [[ARCHITECTURE, \"sparc\"]], [\n        /((?:avr32|ia64(?=;))|68k(?=\\))|\\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\\b|pa-risc)/i\n        // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC\n      ], [[ARCHITECTURE, lowerize]]],\n      device: [[\n        //////////////////////////\n        // MOBILES & TABLETS\n        /////////////////////////\n        // Samsung\n        /\\b(sch-i[89]0\\d|shw-m380s|sm-[ptx]\\w{2,4}|gt-[pn]\\d{2,4}|sgh-t8[56]9|nexus 10)/i\n      ], [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]], [/\\b((?:s[cgp]h|gt|sm)-\\w+|sc[g-]?[\\d]+a?|galaxy nexus)/i, /samsung[- ]([-\\w]+)/i, /sec-(sgh\\w+)/i], [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]], [\n        // Apple\n        /(?:\\/|\\()(ip(?:hone|od)[\\w, ]*)(?:\\/|;)/i\n        // iPod/iPhone\n      ], [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]], [\n        /\\((ipad);[-\\w\\),; ]+apple/i,\n        // iPad\n        /applecoremedia\\/[\\w\\.]+ \\((ipad)/i,\n        /\\b(ipad)\\d\\d?,\\d\\d?[;\\]].+ios/i\n      ], [MODEL, [VENDOR, APPLE], [TYPE, TABLET]], [/(macintosh);/i], [MODEL, [VENDOR, APPLE]], [\n        // Sharp\n        /\\b(sh-?[altvz]?\\d\\d[a-ekm]?)/i\n      ], [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]], [\n        // Huawei\n        /\\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\\d{2})\\b(?!.+d\\/s)/i\n      ], [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]], [/(?:huawei|honor)([-\\w ]+)[;\\)]/i, /\\b(nexus 6p|\\w{2,4}e?-[atu]?[ln][\\dx][012359c][adn]?)\\b(?!.+d\\/s)/i], [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]], [\n        // Xiaomi\n        /\\b(poco[\\w ]+)(?: bui|\\))/i,\n        // Xiaomi POCO\n        /\\b; (\\w+) build\\/hm\\1/i,\n        // Xiaomi Hongmi 'numeric' models\n        /\\b(hm[-_ ]?note?[_ ]?(?:\\d\\w)?) bui/i,\n        // Xiaomi Hongmi\n        /\\b(redmi[\\-_ ]?(?:note|k)?[\\w_ ]+)(?: bui|\\))/i,\n        // Xiaomi Redmi\n        /\\b(mi[-_ ]?(?:a\\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\\d?\\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\\))/i\n        // Xiaomi Mi\n      ], [[MODEL, /_/g, \" \"], [VENDOR, XIAOMI], [TYPE, MOBILE]], [\n        /\\b(mi[-_ ]?(?:pad)(?:[\\w_ ]+))(?: bui|\\))/i\n        // Mi Pad tablets\n      ], [[MODEL, /_/g, \" \"], [VENDOR, XIAOMI], [TYPE, TABLET]], [\n        // OPPO\n        /; (\\w+) bui.+ oppo/i,\n        /\\b(cph[12]\\d{3}|p(?:af|c[al]|d\\w|e[ar])[mt]\\d0|x9007|a101op)\\b/i\n      ], [MODEL, [VENDOR, \"OPPO\"], [TYPE, MOBILE]], [\n        // Vivo\n        /vivo (\\w+)(?: bui|\\))/i,\n        /\\b(v[12]\\d{3}\\w?[at])(?: bui|;)/i\n      ], [MODEL, [VENDOR, \"Vivo\"], [TYPE, MOBILE]], [\n        // Realme\n        /\\b(rmx[12]\\d{3})(?: bui|;|\\))/i\n      ], [MODEL, [VENDOR, \"Realme\"], [TYPE, MOBILE]], [\n        // Motorola\n        /\\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\\b[\\w ]+build\\//i,\n        /\\bmot(?:orola)?[- ](\\w*)/i,\n        /((?:moto[\\w\\(\\) ]+|xt\\d{3,4}|nexus 6)(?= bui|\\)))/i\n      ], [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]], [/\\b(mz60\\d|xoom[2 ]{0,2}) build\\//i], [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]], [\n        // LG\n        /((?=lg)?[vl]k\\-?\\d{3}) bui| 3\\.[-\\w; ]{10}lg?-([06cv9]{3,4})/i\n      ], [MODEL, [VENDOR, LG], [TYPE, TABLET]], [/(lm(?:-?f100[nv]?|-[\\w\\.]+)(?= bui|\\))|nexus [45])/i, /\\blg[-e;\\/ ]+((?!browser|netcast|android tv)\\w+)/i, /\\blg-?([\\d\\w]+) bui/i], [MODEL, [VENDOR, LG], [TYPE, MOBILE]], [\n        // Lenovo\n        /(ideatab[-\\w ]+)/i,\n        /lenovo ?(s[56]000[-\\w]+|tab(?:[\\w ]+)|yt[-\\d\\w]{6}|tb[-\\d\\w]{6})/i\n      ], [MODEL, [VENDOR, \"Lenovo\"], [TYPE, TABLET]], [\n        // Nokia\n        /(?:maemo|nokia).*(n900|lumia \\d+)/i,\n        /nokia[-_ ]?([-\\w\\.]*)/i\n      ], [[MODEL, /_/g, \" \"], [VENDOR, \"Nokia\"], [TYPE, MOBILE]], [\n        // Google\n        /(pixel c)\\b/i\n        // Google Pixel C\n      ], [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]], [\n        /droid.+; (pixel[\\daxl ]{0,6})(?: bui|\\))/i\n        // Google Pixel\n      ], [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]], [\n        // Sony\n        /droid.+ (a?\\d[0-2]{2}so|[c-g]\\d{4}|so[-gl]\\w+|xq-a\\w[4-7][12])(?= bui|\\).+chrome\\/(?![1-6]{0,1}\\d\\.))/i\n      ], [MODEL, [VENDOR, SONY], [TYPE, MOBILE]], [/sony tablet [ps]/i, /\\b(?:sony)?sgp\\w+(?: bui|\\))/i], [[MODEL, \"Xperia Tablet\"], [VENDOR, SONY], [TYPE, TABLET]], [\n        // OnePlus\n        / (kb2005|in20[12]5|be20[12][59])\\b/i,\n        /(?:one)?(?:plus)? (a\\d0\\d\\d)(?: b|\\))/i\n      ], [MODEL, [VENDOR, \"OnePlus\"], [TYPE, MOBILE]], [\n        // Amazon\n        /(alexa)webm/i,\n        /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\\))/i,\n        // Kindle Fire without Silk / Echo Show\n        /(kf[a-z]+)( bui|\\)).+silk\\//i\n        // Kindle Fire HD\n      ], [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]], [\n        /((?:sd|kf)[0349hijorstuw]+)( bui|\\)).+silk\\//i\n        // Fire Phone\n      ], [[MODEL, /(.+)/g, \"Fire Phone $1\"], [VENDOR, AMAZON], [TYPE, MOBILE]], [\n        // BlackBerry\n        /(playbook);[-\\w\\),; ]+(rim)/i\n        // BlackBerry PlayBook\n      ], [MODEL, VENDOR, [TYPE, TABLET]], [\n        /\\b((?:bb[a-f]|st[hv])100-\\d)/i,\n        /\\(bb10; (\\w+)/i\n        // BlackBerry 10\n      ], [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]], [\n        // Asus\n        /(?:\\b|asus_)(transfo[prime ]{4,10} \\w+|eeepc|slider \\w+|nexus 7|padfone|p00[cj])/i\n      ], [MODEL, [VENDOR, ASUS], [TYPE, TABLET]], [/ (z[bes]6[027][012][km][ls]|zenfone \\d\\w?)\\b/i], [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]], [\n        // HTC\n        /(nexus 9)/i\n        // HTC Nexus 9\n      ], [MODEL, [VENDOR, \"HTC\"], [TYPE, TABLET]], [\n        /(htc)[-;_ ]{1,2}([\\w ]+(?=\\)| bui)|\\w+)/i,\n        // HTC\n        // ZTE\n        /(zte)[- ]([\\w ]+?)(?: bui|\\/|\\))/i,\n        /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\\.))|sony(?!-bra))[-_ ]?([-\\w]*)/i\n        // Alcatel/GeeksPhone/Nexian/Panasonic/Sony\n      ], [VENDOR, [MODEL, /_/g, \" \"], [TYPE, MOBILE]], [\n        // Acer\n        /droid.+; ([ab][1-7]-?[0178a]\\d\\d?)/i\n      ], [MODEL, [VENDOR, \"Acer\"], [TYPE, TABLET]], [\n        // Meizu\n        /droid.+; (m[1-5] note) bui/i,\n        /\\bmz-([-\\w]{2,})/i\n      ], [MODEL, [VENDOR, \"Meizu\"], [TYPE, MOBILE]], [\n        // MIXED\n        /(blackberry|benq|palm(?=\\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\\w]*)/i,\n        // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron\n        /(hp) ([\\w ]+\\w)/i,\n        // HP iPAQ\n        /(asus)-?(\\w+)/i,\n        // Asus\n        /(microsoft); (lumia[\\w ]+)/i,\n        // Microsoft Lumia\n        /(lenovo)[-_ ]?([-\\w]+)/i,\n        // Lenovo\n        /(jolla)/i,\n        // Jolla\n        /(oppo) ?([\\w ]+) bui/i\n        // OPPO\n      ], [VENDOR, MODEL, [TYPE, MOBILE]], [\n        /(kobo)\\s(ereader|touch)/i,\n        // Kobo\n        /(archos) (gamepad2?)/i,\n        // Archos\n        /(hp).+(touchpad(?!.+tablet)|tablet)/i,\n        // HP TouchPad\n        /(kindle)\\/([\\w\\.]+)/i,\n        // Kindle\n        /(nook)[\\w ]+build\\/(\\w+)/i,\n        // Nook\n        /(dell) (strea[kpr\\d ]*[\\dko])/i,\n        // Dell Streak\n        /(le[- ]+pan)[- ]+(\\w{1,9}) bui/i,\n        // Le Pan Tablets\n        /(trinity)[- ]*(t\\d{3}) bui/i,\n        // Trinity Tablets\n        /(gigaset)[- ]+(q\\w{1,9}) bui/i,\n        // Gigaset Tablets\n        /(vodafone) ([\\w ]+)(?:\\)| bui)/i\n        // Vodafone\n      ], [VENDOR, MODEL, [TYPE, TABLET]], [\n        /(surface duo)/i\n        // Surface Duo\n      ], [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]], [\n        /droid [\\d\\.]+; (fp\\du?)(?: b|\\))/i\n        // Fairphone\n      ], [MODEL, [VENDOR, \"Fairphone\"], [TYPE, MOBILE]], [\n        /(u304aa)/i\n        // AT&T\n      ], [MODEL, [VENDOR, \"AT&T\"], [TYPE, MOBILE]], [\n        /\\bsie-(\\w*)/i\n        // Siemens\n      ], [MODEL, [VENDOR, \"Siemens\"], [TYPE, MOBILE]], [\n        /\\b(rct\\w+) b/i\n        // RCA Tablets\n      ], [MODEL, [VENDOR, \"RCA\"], [TYPE, TABLET]], [\n        /\\b(venue[\\d ]{2,7}) b/i\n        // Dell Venue Tablets\n      ], [MODEL, [VENDOR, \"Dell\"], [TYPE, TABLET]], [\n        /\\b(q(?:mv|ta)\\w+) b/i\n        // Verizon Tablet\n      ], [MODEL, [VENDOR, \"Verizon\"], [TYPE, TABLET]], [\n        /\\b(?:barnes[& ]+noble |bn[rt])([\\w\\+ ]*) b/i\n        // Barnes & Noble Tablet\n      ], [MODEL, [VENDOR, \"Barnes & Noble\"], [TYPE, TABLET]], [/\\b(tm\\d{3}\\w+) b/i], [MODEL, [VENDOR, \"NuVision\"], [TYPE, TABLET]], [\n        /\\b(k88) b/i\n        // ZTE K Series Tablet\n      ], [MODEL, [VENDOR, \"ZTE\"], [TYPE, TABLET]], [\n        /\\b(nx\\d{3}j) b/i\n        // ZTE Nubia\n      ], [MODEL, [VENDOR, \"ZTE\"], [TYPE, MOBILE]], [\n        /\\b(gen\\d{3}) b.+49h/i\n        // Swiss GEN Mobile\n      ], [MODEL, [VENDOR, \"Swiss\"], [TYPE, MOBILE]], [\n        /\\b(zur\\d{3}) b/i\n        // Swiss ZUR Tablet\n      ], [MODEL, [VENDOR, \"Swiss\"], [TYPE, TABLET]], [\n        /\\b((zeki)?tb.*\\b) b/i\n        // Zeki Tablets\n      ], [MODEL, [VENDOR, \"Zeki\"], [TYPE, TABLET]], [\n        /\\b([yr]\\d{2}) b/i,\n        /\\b(dragon[- ]+touch |dt)(\\w{5}) b/i\n        // Dragon Touch Tablet\n      ], [[VENDOR, \"Dragon Touch\"], MODEL, [TYPE, TABLET]], [\n        /\\b(ns-?\\w{0,9}) b/i\n        // Insignia Tablets\n      ], [MODEL, [VENDOR, \"Insignia\"], [TYPE, TABLET]], [\n        /\\b((nxa|next)-?\\w{0,9}) b/i\n        // NextBook Tablets\n      ], [MODEL, [VENDOR, \"NextBook\"], [TYPE, TABLET]], [\n        /\\b(xtreme\\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i\n        // Voice Xtreme Phones\n      ], [[VENDOR, \"Voice\"], MODEL, [TYPE, MOBILE]], [\n        /\\b(lvtel\\-)?(v1[12]) b/i\n        // LvTel Phones\n      ], [[VENDOR, \"LvTel\"], MODEL, [TYPE, MOBILE]], [\n        /\\b(ph-1) /i\n        // Essential PH-1\n      ], [MODEL, [VENDOR, \"Essential\"], [TYPE, MOBILE]], [\n        /\\b(v(100md|700na|7011|917g).*\\b) b/i\n        // Envizen Tablets\n      ], [MODEL, [VENDOR, \"Envizen\"], [TYPE, TABLET]], [\n        /\\b(trio[-\\w\\. ]+) b/i\n        // MachSpeed Tablets\n      ], [MODEL, [VENDOR, \"MachSpeed\"], [TYPE, TABLET]], [\n        /\\btu_(1491) b/i\n        // Rotor Tablets\n      ], [MODEL, [VENDOR, \"Rotor\"], [TYPE, TABLET]], [\n        /(shield[\\w ]+) b/i\n        // Nvidia Shield Tablets\n      ], [MODEL, [VENDOR, \"Nvidia\"], [TYPE, TABLET]], [\n        /(sprint) (\\w+)/i\n        // Sprint Phones\n      ], [VENDOR, MODEL, [TYPE, MOBILE]], [\n        /(kin\\.[onetw]{3})/i\n        // Microsoft Kin\n      ], [[MODEL, /\\./g, \" \"], [VENDOR, MICROSOFT], [TYPE, MOBILE]], [\n        /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\\)/i\n        // Zebra\n      ], [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]], [/droid.+; (ec30|ps20|tc[2-8]\\d[kx])\\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]], [\n        ///////////////////\n        // SMARTTVS\n        ///////////////////\n        /smart-tv.+(samsung)/i\n        // Samsung\n      ], [VENDOR, [TYPE, SMARTTV]], [/hbbtv.+maple;(\\d+)/i], [[MODEL, /^/, \"SmartTV\"], [VENDOR, SAMSUNG], [TYPE, SMARTTV]], [\n        /(nux; netcast.+smarttv|lg (netcast\\.tv-201\\d|android tv))/i\n        // LG SmartTV\n      ], [[VENDOR, LG], [TYPE, SMARTTV]], [\n        /(apple) ?tv/i\n        // Apple TV\n      ], [VENDOR, [MODEL, APPLE + \" TV\"], [TYPE, SMARTTV]], [\n        /crkey/i\n        // Google Chromecast\n      ], [[MODEL, CHROME + \"cast\"], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [\n        /droid.+aft(\\w)( bui|\\))/i\n        // Fire TV\n      ], [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]], [\n        /\\(dtv[\\);].+(aquos)/i,\n        /(aquos-tv[\\w ]+)\\)/i\n        // Sharp\n      ], [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]], [\n        /(bravia[\\w ]+)( bui|\\))/i\n        // Sony\n      ], [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]], [\n        /(mitv-\\w{5}) bui/i\n        // Xiaomi\n      ], [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]], [\n        /Hbbtv.*(technisat) (.*);/i\n        // TechniSAT\n      ], [VENDOR, MODEL, [TYPE, SMARTTV]], [\n        /\\b(roku)[\\dx]*[\\)\\/]((?:dvp-)?[\\d\\.]*)/i,\n        // Roku\n        /hbbtv\\/\\d+\\.\\d+\\.\\d+ +\\([\\w\\+ ]*; *([\\w\\d][^;]*);([^;]*)/i\n        // HbbTV devices\n      ], [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]], [\n        /\\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\\b/i\n        // SmartTV from Unidentified Vendors\n      ], [[TYPE, SMARTTV]], [\n        ///////////////////\n        // CONSOLES\n        ///////////////////\n        /(ouya)/i,\n        // Ouya\n        /(nintendo) ([wids3utch]+)/i\n        // Nintendo\n      ], [VENDOR, MODEL, [TYPE, CONSOLE]], [\n        /droid.+; (shield) bui/i\n        // Nvidia\n      ], [MODEL, [VENDOR, \"Nvidia\"], [TYPE, CONSOLE]], [\n        /(playstation [345portablevi]+)/i\n        // Playstation\n      ], [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]], [\n        /\\b(xbox(?: one)?(?!; xbox))[\\); ]/i\n        // Microsoft Xbox\n      ], [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]], [\n        ///////////////////\n        // WEARABLES\n        ///////////////////\n        /((pebble))app/i\n        // Pebble\n      ], [VENDOR, MODEL, [TYPE, WEARABLE]], [\n        /(watch)(?: ?os[,\\/]|\\d,\\d\\/)[\\d\\.]+/i\n        // Apple Watch\n      ], [MODEL, [VENDOR, APPLE], [TYPE, WEARABLE]], [\n        /droid.+; (glass) \\d/i\n        // Google Glass\n      ], [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]], [/droid.+; (wt63?0{2,3})\\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]], [\n        /(quest( 2| pro)?)/i\n        // Oculus Quest\n      ], [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]], [\n        ///////////////////\n        // EMBEDDED\n        ///////////////////\n        /(tesla)(?: qtcarbrowser|\\/[-\\w\\.]+)/i\n        // Tesla\n      ], [VENDOR, [TYPE, EMBEDDED]], [\n        /(aeobc)\\b/i\n        // Echo Dot\n      ], [MODEL, [VENDOR, AMAZON], [TYPE, EMBEDDED]], [\n        ////////////////////\n        // MIXED (GENERIC)\n        ///////////////////\n        /droid .+?; ([^;]+?)(?: bui|\\) applew).+? mobile safari/i\n        // Android Phones from Unidentified Vendors\n      ], [MODEL, [TYPE, MOBILE]], [\n        /droid .+?; ([^;]+?)(?: bui|\\) applew).+?(?! mobile) safari/i\n        // Android Tablets from Unidentified Vendors\n      ], [MODEL, [TYPE, TABLET]], [\n        /\\b((tablet|tab)[;\\/]|focus\\/\\d(?!.+mobile))/i\n        // Unidentifiable Tablet\n      ], [[TYPE, TABLET]], [\n        /(phone|mobile(?:[;\\/]| [ \\w\\/\\.]*safari)|pda(?=.+windows ce))/i\n        // Unidentifiable Mobile\n      ], [[TYPE, MOBILE]], [\n        /(android[-\\w\\. ]{0,9});.+buil/i\n        // Generic Android Device\n      ], [MODEL, [VENDOR, \"Generic\"]]],\n      engine: [[\n        /windows.+ edge\\/([\\w\\.]+)/i\n        // EdgeHTML\n      ], [VERSION, [NAME, EDGE + \"HTML\"]], [\n        /webkit\\/537\\.36.+chrome\\/(?!27)([\\w\\.]+)/i\n        // Blink\n      ], [VERSION, [NAME, \"Blink\"]], [\n        /(presto)\\/([\\w\\.]+)/i,\n        // Presto\n        /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\\/([\\w\\.]+)/i,\n        // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna\n        /ekioh(flow)\\/([\\w\\.]+)/i,\n        // Flow\n        /(khtml|tasman|links)[\\/ ]\\(?([\\w\\.]+)/i,\n        // KHTML/Tasman/Links\n        /(icab)[\\/ ]([23]\\.[\\d\\.]+)/i,\n        // iCab\n        /\\b(libweb)/i\n      ], [NAME, VERSION], [\n        /rv\\:([\\w\\.]{1,9})\\b.+(gecko)/i\n        // Gecko\n      ], [VERSION, NAME]],\n      os: [[\n        // Windows\n        /microsoft (windows) (vista|xp)/i\n        // Windows (iTunes)\n      ], [NAME, VERSION], [\n        /(windows) nt 6\\.2; (arm)/i,\n        // Windows RT\n        /(windows (?:phone(?: os)?|mobile))[\\/ ]?([\\d\\.\\w ]*)/i,\n        // Windows Phone\n        /(windows)[\\/ ]?([ntce\\d\\. ]+\\w)(?!.+xbox)/i\n      ], [NAME, [VERSION, strMapper, windowsVersionMap]], [/(win(?=3|9|n)|win 9x )([nt\\d\\.]+)/i], [[NAME, \"Windows\"], [VERSION, strMapper, windowsVersionMap]], [\n        // iOS/macOS\n        /ip[honead]{2,4}\\b(?:.*os ([\\w]+) like mac|; opera)/i,\n        // iOS\n        /ios;fbsv\\/([\\d\\.]+)/i,\n        /cfnetwork\\/.+darwin/i\n      ], [[VERSION, /_/g, \".\"], [NAME, \"iOS\"]], [\n        /(mac os x) ?([\\w\\. ]*)/i,\n        /(macintosh|mac_powerpc\\b)(?!.+haiku)/i\n        // Mac OS\n      ], [[NAME, MAC_OS], [VERSION, /_/g, \".\"]], [\n        // Mobile OSes\n        /droid ([\\w\\.]+)\\b.+(android[- ]x86|harmonyos)/i\n        // Android-x86/HarmonyOS\n      ], [VERSION, NAME], [\n        // Android/WebOS/QNX/Bada/RIM/Maemo/MeeGo/Sailfish OS\n        /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\\/ ]?([\\w\\.]*)/i,\n        /(blackberry)\\w*\\/([\\w\\.]*)/i,\n        // Blackberry\n        /(tizen|kaios)[\\/ ]([\\w\\.]+)/i,\n        // Tizen/KaiOS\n        /\\((series40);/i\n        // Series 40\n      ], [NAME, VERSION], [\n        /\\(bb(10);/i\n        // BlackBerry 10\n      ], [VERSION, [NAME, BLACKBERRY]], [\n        /(?:symbian ?os|symbos|s60(?=;)|series60)[-\\/ ]?([\\w\\.]*)/i\n        // Symbian\n      ], [VERSION, [NAME, \"Symbian\"]], [\n        /mozilla\\/[\\d\\.]+ \\((?:mobile|tablet|tv|mobile; [\\w ]+); rv:.+ gecko\\/([\\w\\.]+)/i\n        // Firefox OS\n      ], [VERSION, [NAME, FIREFOX + \" OS\"]], [\n        /web0s;.+rt(tv)/i,\n        /\\b(?:hp)?wos(?:browser)?\\/([\\w\\.]+)/i\n        // WebOS\n      ], [VERSION, [NAME, \"webOS\"]], [\n        /watch(?: ?os[,\\/]|\\d,\\d\\/)([\\d\\.]+)/i\n        // watchOS\n      ], [VERSION, [NAME, \"watchOS\"]], [\n        // Google Chromecast\n        /crkey\\/([\\d\\.]+)/i\n        // Google Chromecast\n      ], [VERSION, [NAME, CHROME + \"cast\"]], [\n        /(cros) [\\w]+(?:\\)| ([\\w\\.]+)\\b)/i\n        // Chromium OS\n      ], [[NAME, CHROMIUM_OS], VERSION], [\n        // Smart TVs\n        /panasonic;(viera)/i,\n        // Panasonic Viera\n        /(netrange)mmh/i,\n        // Netrange\n        /(nettv)\\/(\\d+\\.[\\w\\.]+)/i,\n        // NetTV\n        // Console\n        /(nintendo|playstation) ([wids345portablevuch]+)/i,\n        // Nintendo/Playstation\n        /(xbox); +xbox ([^\\);]+)/i,\n        // Microsoft Xbox (360, One, X, S, Series X, Series S)\n        // Other\n        /\\b(joli|palm)\\b ?(?:os)?\\/?([\\w\\.]*)/i,\n        // Joli/Palm\n        /(mint)[\\/\\(\\) ]?(\\w*)/i,\n        // Mint\n        /(mageia|vectorlinux)[; ]/i,\n        // Mageia/VectorLinux\n        /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\\/ ]?(?!chrom|package)([-\\w\\.]*)/i,\n        // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire\n        /(hurd|linux) ?([\\w\\.]*)/i,\n        // Hurd/Linux\n        /(gnu) ?([\\w\\.]*)/i,\n        // GNU\n        /\\b([-frentopcghs]{0,5}bsd|dragonfly)[\\/ ]?(?!amd|[ix346]{1,2}86)([\\w\\.]*)/i,\n        // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly\n        /(haiku) (\\w+)/i\n        // Haiku\n      ], [NAME, VERSION], [\n        /(sunos) ?([\\w\\.\\d]*)/i\n        // Solaris\n      ], [[NAME, \"Solaris\"], VERSION], [\n        /((?:open)?solaris)[-\\/ ]?([\\w\\.]*)/i,\n        // Solaris\n        /(aix) ((\\d)(?=\\.|\\)| )[\\w\\.])*/i,\n        // AIX\n        /\\b(beos|os\\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i,\n        // BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX/SerenityOS\n        /(unix) ?([\\w\\.]*)/i\n        // UNIX\n      ], [NAME, VERSION]]\n    };\n    var UAParser2 = function(ua, extensions) {\n      if (typeof ua === OBJ_TYPE) {\n        extensions = ua;\n        ua = undefined$1;\n      }\n      if (!(this instanceof UAParser2)) {\n        return new UAParser2(ua, extensions).getResult();\n      }\n      var _navigator = typeof window2 !== UNDEF_TYPE && window2.navigator ? window2.navigator : undefined$1;\n      var _ua = ua || (_navigator && _navigator.userAgent ? _navigator.userAgent : EMPTY);\n      var _uach = _navigator && _navigator.userAgentData ? _navigator.userAgentData : undefined$1;\n      var _rgxmap = extensions ? extend(regexes, extensions) : regexes;\n      var _isSelfNav = _navigator && _navigator.userAgent == _ua;\n      this.getBrowser = function() {\n        var _browser = {};\n        _browser[NAME] = undefined$1;\n        _browser[VERSION] = undefined$1;\n        rgxMapper.call(_browser, _ua, _rgxmap.browser);\n        _browser[MAJOR] = majorize(_browser[VERSION]);\n        if (_isSelfNav && _navigator && _navigator.brave && typeof _navigator.brave.isBrave == FUNC_TYPE) {\n          _browser[NAME] = \"Brave\";\n        }\n        return _browser;\n      };\n      this.getCPU = function() {\n        var _cpu = {};\n        _cpu[ARCHITECTURE] = undefined$1;\n        rgxMapper.call(_cpu, _ua, _rgxmap.cpu);\n        return _cpu;\n      };\n      this.getDevice = function() {\n        var _device = {};\n        _device[VENDOR] = undefined$1;\n        _device[MODEL] = undefined$1;\n        _device[TYPE] = undefined$1;\n        rgxMapper.call(_device, _ua, _rgxmap.device);\n        if (_isSelfNav && !_device[TYPE] && _uach && _uach.mobile) {\n          _device[TYPE] = MOBILE;\n        }\n        if (_isSelfNav && _device[MODEL] == \"Macintosh\" && _navigator && typeof _navigator.standalone !== UNDEF_TYPE && _navigator.maxTouchPoints && _navigator.maxTouchPoints > 2) {\n          _device[MODEL] = \"iPad\";\n          _device[TYPE] = TABLET;\n        }\n        return _device;\n      };\n      this.getEngine = function() {\n        var _engine = {};\n        _engine[NAME] = undefined$1;\n        _engine[VERSION] = undefined$1;\n        rgxMapper.call(_engine, _ua, _rgxmap.engine);\n        return _engine;\n      };\n      this.getOS = function() {\n        var _os = {};\n        _os[NAME] = undefined$1;\n        _os[VERSION] = undefined$1;\n        rgxMapper.call(_os, _ua, _rgxmap.os);\n        if (_isSelfNav && !_os[NAME] && _uach && _uach.platform != \"Unknown\") {\n          _os[NAME] = _uach.platform.replace(/chrome os/i, CHROMIUM_OS).replace(/macos/i, MAC_OS);\n        }\n        return _os;\n      };\n      this.getResult = function() {\n        return {\n          ua: this.getUA(),\n          browser: this.getBrowser(),\n          engine: this.getEngine(),\n          os: this.getOS(),\n          device: this.getDevice(),\n          cpu: this.getCPU()\n        };\n      };\n      this.getUA = function() {\n        return _ua;\n      };\n      this.setUA = function(ua2) {\n        _ua = typeof ua2 === STR_TYPE && ua2.length > UA_MAX_LENGTH ? trim(ua2, UA_MAX_LENGTH) : ua2;\n        return this;\n      };\n      this.setUA(_ua);\n      return this;\n    };\n    UAParser2.VERSION = LIBVERSION;\n    UAParser2.BROWSER = enumerize([NAME, VERSION, MAJOR]);\n    UAParser2.CPU = enumerize([ARCHITECTURE]);\n    UAParser2.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);\n    UAParser2.ENGINE = UAParser2.OS = enumerize([NAME, VERSION]);\n    {\n      if (module.exports) {\n        exports = module.exports = UAParser2;\n      }\n      exports.UAParser = UAParser2;\n    }\n    var $ = typeof window2 !== UNDEF_TYPE && (window2.jQuery || window2.Zepto);\n    if ($ && !$.ua) {\n      var parser2 = new UAParser2();\n      $.ua = parser2.getResult();\n      $.ua.get = function() {\n        return parser2.getUA();\n      };\n      $.ua.set = function(ua) {\n        parser2.setUA(ua);\n        var result = parser2.getResult();\n        for (var prop in result) {\n          $.ua[prop] = result[prop];\n        }\n      };\n    }\n  })(typeof window === \"object\" ? window : commonjsGlobal);\n})(uaParser, uaParser.exports);\nvar uaParserExports = uaParser.exports;\nvar UAParser = getDefaultExportFromCjs(uaParserExports);\nvar version$1 = \"1.9.4\";\nvar version = version$1;\nvar protocolVersion = 9;\nfunction mergeDefaultOptions(options, audioDefaults2, videoDefaults2) {\n  const opts = Object.assign({}, options);\n  if (opts.audio === true)\n    opts.audio = {};\n  if (opts.video === true)\n    opts.video = {};\n  if (opts.audio) {\n    mergeObjectWithoutOverwriting(opts.audio, audioDefaults2);\n  }\n  if (opts.video) {\n    mergeObjectWithoutOverwriting(opts.video, videoDefaults2);\n  }\n  return opts;\n}\nfunction mergeObjectWithoutOverwriting(mainObject, objectToMerge) {\n  Object.keys(objectToMerge).forEach((key) => {\n    if (mainObject[key] === void 0)\n      mainObject[key] = objectToMerge[key];\n  });\n  return mainObject;\n}\nfunction constraintsForOptions(options) {\n  const constraints = {};\n  if (options.video) {\n    if (typeof options.video === \"object\") {\n      const videoOptions = {};\n      const target = videoOptions;\n      const source = options.video;\n      Object.keys(source).forEach((key) => {\n        switch (key) {\n          case \"resolution\":\n            mergeObjectWithoutOverwriting(target, source.resolution);\n            break;\n          default:\n            target[key] = source[key];\n        }\n      });\n      constraints.video = videoOptions;\n    } else {\n      constraints.video = options.video;\n    }\n  } else {\n    constraints.video = false;\n  }\n  if (options.audio) {\n    if (typeof options.audio === \"object\") {\n      constraints.audio = options.audio;\n    } else {\n      constraints.audio = true;\n    }\n  } else {\n    constraints.audio = false;\n  }\n  return constraints;\n}\nfunction detectSilence(track) {\n  let timeOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;\n  return __awaiter(this, void 0, void 0, function* () {\n    const ctx = getNewAudioContext();\n    if (ctx) {\n      const analyser = ctx.createAnalyser();\n      analyser.fftSize = 2048;\n      const bufferLength = analyser.frequencyBinCount;\n      const dataArray = new Uint8Array(bufferLength);\n      const source = ctx.createMediaStreamSource(new MediaStream([track.mediaStreamTrack]));\n      source.connect(analyser);\n      yield sleep(timeOffset);\n      analyser.getByteTimeDomainData(dataArray);\n      const someNoise = dataArray.some((sample) => sample !== 128 && sample !== 0);\n      ctx.close();\n      return !someNoise;\n    }\n    return false;\n  });\n}\nfunction getNewAudioContext() {\n  const AudioContext2 = (\n    // @ts-ignore\n    typeof window !== \"undefined\" && (window.AudioContext || window.webkitAudioContext)\n  );\n  if (AudioContext2) {\n    return new AudioContext2({\n      latencyHint: \"interactive\"\n    });\n  }\n}\nvar separator = \"|\";\nvar ddExtensionURI = \"https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension\";\nfunction unpackStreamId(packed) {\n  const parts = packed.split(separator);\n  if (parts.length > 1) {\n    return [parts[0], packed.substr(parts[0].length + 1)];\n  }\n  return [packed, \"\"];\n}\nfunction sleep(duration) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return new Promise((resolve) => setTimeout(resolve, duration));\n  });\n}\nfunction supportsTransceiver() {\n  return \"addTransceiver\" in RTCPeerConnection.prototype;\n}\nfunction supportsAddTrack() {\n  return \"addTrack\" in RTCPeerConnection.prototype;\n}\nfunction supportsAdaptiveStream() {\n  return typeof ResizeObserver !== void 0 && typeof IntersectionObserver !== void 0;\n}\nfunction supportsDynacast() {\n  return supportsTransceiver();\n}\nfunction supportsAV1() {\n  if (!(\"getCapabilities\" in RTCRtpSender)) {\n    return false;\n  }\n  const capabilities = RTCRtpSender.getCapabilities(\"video\");\n  let hasAV1 = false;\n  if (capabilities) {\n    for (const codec of capabilities.codecs) {\n      if (codec.mimeType === \"video/AV1\") {\n        hasAV1 = true;\n        break;\n      }\n    }\n  }\n  return hasAV1;\n}\nfunction supportsVP9() {\n  if (!(\"getCapabilities\" in RTCRtpSender)) {\n    return false;\n  }\n  const capabilities = RTCRtpSender.getCapabilities(\"video\");\n  let hasVP9 = false;\n  if (capabilities) {\n    for (const codec of capabilities.codecs) {\n      if (codec.mimeType === \"video/VP9\") {\n        hasVP9 = true;\n        break;\n      }\n    }\n  }\n  return hasVP9;\n}\nfunction isSVCCodec(codec) {\n  return codec === \"av1\" || codec === \"vp9\";\n}\nfunction supportsSetSinkId(elm) {\n  if (!document) {\n    return false;\n  }\n  if (!elm) {\n    elm = document.createElement(\"audio\");\n  }\n  return \"setSinkId\" in elm;\n}\nvar setCodecPreferencesVersions = {\n  Chrome: \"100\",\n  Chromium: \"100\",\n  Safari: \"15\",\n  Firefox: \"100\",\n  Edge: \"100\",\n  Brave: \"1.40\"\n};\nfunction supportsSetCodecPreferences(transceiver) {\n  if (!isWeb()) {\n    return false;\n  }\n  if (!(\"setCodecPreferences\" in transceiver)) {\n    return false;\n  }\n  const uap = UAParser();\n  if (!uap.browser.name || !uap.browser.version) {\n    return false;\n  }\n  const v = setCodecPreferencesVersions[uap.browser.name];\n  if (v) {\n    return compareVersions(uap.browser.version, v) >= 0;\n  }\n  return false;\n}\nfunction isBrowserSupported() {\n  return supportsTransceiver() || supportsAddTrack();\n}\nfunction isFireFox() {\n  if (!isWeb())\n    return false;\n  return navigator.userAgent.indexOf(\"Firefox\") !== -1;\n}\nfunction isChromiumBased() {\n  if (!isWeb())\n    return false;\n  return navigator.userAgent.indexOf(\"Chrom\") !== -1;\n}\nfunction isSafari() {\n  if (!isWeb())\n    return false;\n  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n}\nfunction isMobile() {\n  if (!isWeb())\n    return false;\n  return /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent);\n}\nfunction isWeb() {\n  return typeof document !== \"undefined\";\n}\nfunction isReactNative() {\n  return navigator.product == \"ReactNative\";\n}\nfunction isCloud(serverUrl) {\n  return serverUrl.hostname.endsWith(\".livekit.cloud\");\n}\nfunction getLKReactNativeInfo() {\n  if (global && global.LiveKitReactNativeGlobal) {\n    return global.LiveKitReactNativeGlobal;\n  }\n  return void 0;\n}\nfunction getReactNativeOs() {\n  if (!isReactNative()) {\n    return void 0;\n  }\n  let info = getLKReactNativeInfo();\n  if (info) {\n    return info.platform;\n  }\n  return void 0;\n}\nfunction getDevicePixelRatio() {\n  if (isWeb()) {\n    return window.devicePixelRatio;\n  }\n  if (isReactNative()) {\n    let info = getLKReactNativeInfo();\n    if (info) {\n      return info.devicePixelRatio;\n    }\n  }\n  return 1;\n}\nfunction compareVersions(v1, v2) {\n  const parts1 = v1.split(\".\");\n  const parts2 = v2.split(\".\");\n  const k = Math.min(v1.length, v2.length);\n  for (let i = 0; i < k; ++i) {\n    const p1 = parseInt(parts1[i], 10);\n    const p2 = parseInt(parts2[i], 10);\n    if (p1 > p2)\n      return 1;\n    if (p1 < p2)\n      return -1;\n  }\n  return parts1.length == parts2.length ? 0 : parts1.length < parts2.length ? -1 : 1;\n}\nfunction roDispatchCallback(entries) {\n  for (const entry of entries) {\n    entry.target.handleResize(entry);\n  }\n}\nfunction ioDispatchCallback(entries) {\n  for (const entry of entries) {\n    entry.target.handleVisibilityChanged(entry);\n  }\n}\nvar resizeObserver = null;\nvar getResizeObserver = () => {\n  if (!resizeObserver)\n    resizeObserver = new ResizeObserver(roDispatchCallback);\n  return resizeObserver;\n};\nvar intersectionObserver = null;\nvar getIntersectionObserver = () => {\n  if (!intersectionObserver)\n    intersectionObserver = new IntersectionObserver(ioDispatchCallback, {\n      root: document,\n      rootMargin: \"0px\"\n    });\n  return intersectionObserver;\n};\nfunction getClientInfo() {\n  var _a;\n  const info = ClientInfo.fromPartial({\n    sdk: ClientInfo_SDK.JS,\n    protocol: protocolVersion,\n    version\n  });\n  if (isReactNative()) {\n    info.os = (_a = getReactNativeOs()) !== null && _a !== void 0 ? _a : \"\";\n  }\n  return info;\n}\nvar emptyVideoStreamTrack;\nfunction getEmptyVideoStreamTrack() {\n  if (!emptyVideoStreamTrack) {\n    emptyVideoStreamTrack = createDummyVideoStreamTrack();\n  }\n  return emptyVideoStreamTrack;\n}\nfunction createDummyVideoStreamTrack() {\n  let width = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16;\n  let height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 16;\n  let enabled = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n  let paintContent = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = width;\n  canvas.height = height;\n  const ctx = canvas.getContext(\"2d\");\n  ctx === null || ctx === void 0 ? void 0 : ctx.fillRect(0, 0, canvas.width, canvas.height);\n  if (paintContent && ctx) {\n    ctx.beginPath();\n    ctx.arc(width / 2, height / 2, 50, 0, Math.PI * 2, true);\n    ctx.closePath();\n    ctx.fillStyle = \"grey\";\n    ctx.fill();\n  }\n  const dummyStream = canvas.captureStream();\n  const [dummyTrack] = dummyStream.getTracks();\n  if (!dummyTrack) {\n    throw Error(\"Could not get empty media stream video track\");\n  }\n  dummyTrack.enabled = enabled;\n  return dummyTrack;\n}\nvar emptyAudioStreamTrack;\nfunction getEmptyAudioStreamTrack() {\n  if (!emptyAudioStreamTrack) {\n    const ctx = new AudioContext();\n    const oscillator = ctx.createOscillator();\n    const dst = ctx.createMediaStreamDestination();\n    oscillator.connect(dst);\n    oscillator.start();\n    [emptyAudioStreamTrack] = dst.stream.getAudioTracks();\n    if (!emptyAudioStreamTrack) {\n      throw Error(\"Could not get empty media stream audio track\");\n    }\n    emptyAudioStreamTrack.enabled = false;\n  }\n  return emptyAudioStreamTrack;\n}\nvar Future = class {\n  constructor(futureBase, onFinally) {\n    this.onFinally = onFinally;\n    this.promise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n      this.resolve = resolve;\n      this.reject = reject;\n      if (futureBase) {\n        yield futureBase(resolve, reject);\n      }\n    })).finally(() => {\n      var _a;\n      return (_a = this.onFinally) === null || _a === void 0 ? void 0 : _a.call(this);\n    });\n  }\n};\nfunction createAudioAnalyser(track, options) {\n  const opts = Object.assign({\n    cloneTrack: false,\n    fftSize: 2048,\n    smoothingTimeConstant: 0.8,\n    minDecibels: -100,\n    maxDecibels: -80\n  }, options);\n  const audioContext = getNewAudioContext();\n  if (!audioContext) {\n    throw new Error(\"Audio Context not supported on this browser\");\n  }\n  const streamTrack = opts.cloneTrack ? track.mediaStreamTrack.clone() : track.mediaStreamTrack;\n  const mediaStreamSource = audioContext.createMediaStreamSource(new MediaStream([streamTrack]));\n  const analyser = audioContext.createAnalyser();\n  analyser.minDecibels = opts.minDecibels;\n  analyser.maxDecibels = opts.maxDecibels;\n  analyser.fftSize = opts.fftSize;\n  analyser.smoothingTimeConstant = opts.smoothingTimeConstant;\n  mediaStreamSource.connect(analyser);\n  const dataArray = new Uint8Array(analyser.frequencyBinCount);\n  const calculateVolume = () => {\n    analyser.getByteFrequencyData(dataArray);\n    let sum = 0;\n    for (const amplitude of dataArray) {\n      sum += Math.pow(amplitude / 255, 2);\n    }\n    const volume = Math.sqrt(sum / dataArray.length);\n    return volume;\n  };\n  const cleanup = () => {\n    audioContext.close();\n    if (opts.cloneTrack) {\n      streamTrack.stop();\n    }\n  };\n  return {\n    calculateVolume,\n    analyser,\n    cleanup\n  };\n}\nvar Mutex = class {\n  constructor() {\n    this._locking = Promise.resolve();\n    this._locks = 0;\n  }\n  isLocked() {\n    return this._locks > 0;\n  }\n  lock() {\n    this._locks += 1;\n    let unlockNext;\n    const willLock = new Promise((resolve) => unlockNext = () => {\n      this._locks -= 1;\n      resolve();\n    });\n    const willUnlock = this._locking.then(() => unlockNext);\n    this._locking = this._locking.then(() => willLock);\n    return willUnlock;\n  }\n};\nvar QueueTaskStatus;\n(function(QueueTaskStatus2) {\n  QueueTaskStatus2[QueueTaskStatus2[\"WAITING\"] = 0] = \"WAITING\";\n  QueueTaskStatus2[QueueTaskStatus2[\"RUNNING\"] = 1] = \"RUNNING\";\n  QueueTaskStatus2[QueueTaskStatus2[\"COMPLETED\"] = 2] = \"COMPLETED\";\n})(QueueTaskStatus || (QueueTaskStatus = {}));\nvar AsyncQueue = class {\n  constructor() {\n    this.pendingTasks = /* @__PURE__ */ new Map();\n    this.taskMutex = new Mutex();\n    this.nextTaskIndex = 0;\n  }\n  run(task) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const taskInfo = {\n        id: this.nextTaskIndex++,\n        enqueuedAt: Date.now(),\n        status: QueueTaskStatus.WAITING\n      };\n      this.pendingTasks.set(taskInfo.id, taskInfo);\n      const unlock = yield this.taskMutex.lock();\n      try {\n        taskInfo.executedAt = Date.now();\n        taskInfo.status = QueueTaskStatus.RUNNING;\n        return yield task();\n      } finally {\n        taskInfo.status = QueueTaskStatus.COMPLETED;\n        this.pendingTasks.delete(taskInfo.id);\n        unlock();\n      }\n    });\n  }\n  flush() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.run(() => __awaiter(this, void 0, void 0, function* () {\n      }));\n    });\n  }\n  snapshot() {\n    return Array.from(this.pendingTasks.values());\n  }\n};\nvar SignalTarget;\n(function(SignalTarget2) {\n  SignalTarget2[SignalTarget2[\"PUBLISHER\"] = 0] = \"PUBLISHER\";\n  SignalTarget2[SignalTarget2[\"SUBSCRIBER\"] = 1] = \"SUBSCRIBER\";\n  SignalTarget2[SignalTarget2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(SignalTarget || (SignalTarget = {}));\nfunction signalTargetFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"PUBLISHER\":\n      return SignalTarget.PUBLISHER;\n    case 1:\n    case \"SUBSCRIBER\":\n      return SignalTarget.SUBSCRIBER;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return SignalTarget.UNRECOGNIZED;\n  }\n}\nfunction signalTargetToJSON(object) {\n  switch (object) {\n    case SignalTarget.PUBLISHER:\n      return \"PUBLISHER\";\n    case SignalTarget.SUBSCRIBER:\n      return \"SUBSCRIBER\";\n    case SignalTarget.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar StreamState;\n(function(StreamState2) {\n  StreamState2[StreamState2[\"ACTIVE\"] = 0] = \"ACTIVE\";\n  StreamState2[StreamState2[\"PAUSED\"] = 1] = \"PAUSED\";\n  StreamState2[StreamState2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(StreamState || (StreamState = {}));\nfunction streamStateFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"ACTIVE\":\n      return StreamState.ACTIVE;\n    case 1:\n    case \"PAUSED\":\n      return StreamState.PAUSED;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return StreamState.UNRECOGNIZED;\n  }\n}\nfunction streamStateToJSON(object) {\n  switch (object) {\n    case StreamState.ACTIVE:\n      return \"ACTIVE\";\n    case StreamState.PAUSED:\n      return \"PAUSED\";\n    case StreamState.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nvar CandidateProtocol;\n(function(CandidateProtocol2) {\n  CandidateProtocol2[CandidateProtocol2[\"UDP\"] = 0] = \"UDP\";\n  CandidateProtocol2[CandidateProtocol2[\"TCP\"] = 1] = \"TCP\";\n  CandidateProtocol2[CandidateProtocol2[\"TLS\"] = 2] = \"TLS\";\n  CandidateProtocol2[CandidateProtocol2[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(CandidateProtocol || (CandidateProtocol = {}));\nfunction candidateProtocolFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"UDP\":\n      return CandidateProtocol.UDP;\n    case 1:\n    case \"TCP\":\n      return CandidateProtocol.TCP;\n    case 2:\n    case \"TLS\":\n      return CandidateProtocol.TLS;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return CandidateProtocol.UNRECOGNIZED;\n  }\n}\nfunction candidateProtocolToJSON(object) {\n  switch (object) {\n    case CandidateProtocol.UDP:\n      return \"UDP\";\n    case CandidateProtocol.TCP:\n      return \"TCP\";\n    case CandidateProtocol.TLS:\n      return \"TLS\";\n    case CandidateProtocol.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\nfunction createBaseSignalRequest() {\n  return {\n    message: void 0\n  };\n}\nvar SignalRequest = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    var _a;\n    switch ((_a = message.message) === null || _a === void 0 ? void 0 : _a.$case) {\n      case \"offer\":\n        SessionDescription.encode(message.message.offer, writer2.uint32(10).fork()).ldelim();\n        break;\n      case \"answer\":\n        SessionDescription.encode(message.message.answer, writer2.uint32(18).fork()).ldelim();\n        break;\n      case \"trickle\":\n        TrickleRequest.encode(message.message.trickle, writer2.uint32(26).fork()).ldelim();\n        break;\n      case \"addTrack\":\n        AddTrackRequest.encode(message.message.addTrack, writer2.uint32(34).fork()).ldelim();\n        break;\n      case \"mute\":\n        MuteTrackRequest.encode(message.message.mute, writer2.uint32(42).fork()).ldelim();\n        break;\n      case \"subscription\":\n        UpdateSubscription.encode(message.message.subscription, writer2.uint32(50).fork()).ldelim();\n        break;\n      case \"trackSetting\":\n        UpdateTrackSettings.encode(message.message.trackSetting, writer2.uint32(58).fork()).ldelim();\n        break;\n      case \"leave\":\n        LeaveRequest.encode(message.message.leave, writer2.uint32(66).fork()).ldelim();\n        break;\n      case \"updateLayers\":\n        UpdateVideoLayers.encode(message.message.updateLayers, writer2.uint32(82).fork()).ldelim();\n        break;\n      case \"subscriptionPermission\":\n        SubscriptionPermission.encode(message.message.subscriptionPermission, writer2.uint32(90).fork()).ldelim();\n        break;\n      case \"syncState\":\n        SyncState.encode(message.message.syncState, writer2.uint32(98).fork()).ldelim();\n        break;\n      case \"simulate\":\n        SimulateScenario.encode(message.message.simulate, writer2.uint32(106).fork()).ldelim();\n        break;\n      case \"ping\":\n        writer2.uint32(112).int64(message.message.ping);\n        break;\n      case \"updateMetadata\":\n        UpdateParticipantMetadata.encode(message.message.updateMetadata, writer2.uint32(122).fork()).ldelim();\n        break;\n      case \"pingReq\":\n        Ping.encode(message.message.pingReq, writer2.uint32(130).fork()).ldelim();\n        break;\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseSignalRequest();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.message = {\n            $case: \"offer\",\n            offer: SessionDescription.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.message = {\n            $case: \"answer\",\n            answer: SessionDescription.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 3:\n          if (tag != 26) {\n            break;\n          }\n          message.message = {\n            $case: \"trickle\",\n            trickle: TrickleRequest.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 4:\n          if (tag != 34) {\n            break;\n          }\n          message.message = {\n            $case: \"addTrack\",\n            addTrack: AddTrackRequest.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 5:\n          if (tag != 42) {\n            break;\n          }\n          message.message = {\n            $case: \"mute\",\n            mute: MuteTrackRequest.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 6:\n          if (tag != 50) {\n            break;\n          }\n          message.message = {\n            $case: \"subscription\",\n            subscription: UpdateSubscription.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 7:\n          if (tag != 58) {\n            break;\n          }\n          message.message = {\n            $case: \"trackSetting\",\n            trackSetting: UpdateTrackSettings.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 8:\n          if (tag != 66) {\n            break;\n          }\n          message.message = {\n            $case: \"leave\",\n            leave: LeaveRequest.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 10:\n          if (tag != 82) {\n            break;\n          }\n          message.message = {\n            $case: \"updateLayers\",\n            updateLayers: UpdateVideoLayers.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 11:\n          if (tag != 90) {\n            break;\n          }\n          message.message = {\n            $case: \"subscriptionPermission\",\n            subscriptionPermission: SubscriptionPermission.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 12:\n          if (tag != 98) {\n            break;\n          }\n          message.message = {\n            $case: \"syncState\",\n            syncState: SyncState.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 13:\n          if (tag != 106) {\n            break;\n          }\n          message.message = {\n            $case: \"simulate\",\n            simulate: SimulateScenario.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 14:\n          if (tag != 112) {\n            break;\n          }\n          message.message = {\n            $case: \"ping\",\n            ping: longToNumber(reader2.int64())\n          };\n          continue;\n        case 15:\n          if (tag != 122) {\n            break;\n          }\n          message.message = {\n            $case: \"updateMetadata\",\n            updateMetadata: UpdateParticipantMetadata.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 16:\n          if (tag != 130) {\n            break;\n          }\n          message.message = {\n            $case: \"pingReq\",\n            pingReq: Ping.decode(reader2, reader2.uint32())\n          };\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      message: isSet(object.offer) ? {\n        $case: \"offer\",\n        offer: SessionDescription.fromJSON(object.offer)\n      } : isSet(object.answer) ? {\n        $case: \"answer\",\n        answer: SessionDescription.fromJSON(object.answer)\n      } : isSet(object.trickle) ? {\n        $case: \"trickle\",\n        trickle: TrickleRequest.fromJSON(object.trickle)\n      } : isSet(object.addTrack) ? {\n        $case: \"addTrack\",\n        addTrack: AddTrackRequest.fromJSON(object.addTrack)\n      } : isSet(object.mute) ? {\n        $case: \"mute\",\n        mute: MuteTrackRequest.fromJSON(object.mute)\n      } : isSet(object.subscription) ? {\n        $case: \"subscription\",\n        subscription: UpdateSubscription.fromJSON(object.subscription)\n      } : isSet(object.trackSetting) ? {\n        $case: \"trackSetting\",\n        trackSetting: UpdateTrackSettings.fromJSON(object.trackSetting)\n      } : isSet(object.leave) ? {\n        $case: \"leave\",\n        leave: LeaveRequest.fromJSON(object.leave)\n      } : isSet(object.updateLayers) ? {\n        $case: \"updateLayers\",\n        updateLayers: UpdateVideoLayers.fromJSON(object.updateLayers)\n      } : isSet(object.subscriptionPermission) ? {\n        $case: \"subscriptionPermission\",\n        subscriptionPermission: SubscriptionPermission.fromJSON(object.subscriptionPermission)\n      } : isSet(object.syncState) ? {\n        $case: \"syncState\",\n        syncState: SyncState.fromJSON(object.syncState)\n      } : isSet(object.simulate) ? {\n        $case: \"simulate\",\n        simulate: SimulateScenario.fromJSON(object.simulate)\n      } : isSet(object.ping) ? {\n        $case: \"ping\",\n        ping: Number(object.ping)\n      } : isSet(object.updateMetadata) ? {\n        $case: \"updateMetadata\",\n        updateMetadata: UpdateParticipantMetadata.fromJSON(object.updateMetadata)\n      } : isSet(object.pingReq) ? {\n        $case: \"pingReq\",\n        pingReq: Ping.fromJSON(object.pingReq)\n      } : void 0\n    };\n  },\n  toJSON(message) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19;\n    const obj = {};\n    ((_a = message.message) === null || _a === void 0 ? void 0 : _a.$case) === \"offer\" && (obj.offer = ((_b = message.message) === null || _b === void 0 ? void 0 : _b.offer) ? SessionDescription.toJSON((_c = message.message) === null || _c === void 0 ? void 0 : _c.offer) : void 0);\n    ((_d = message.message) === null || _d === void 0 ? void 0 : _d.$case) === \"answer\" && (obj.answer = ((_e = message.message) === null || _e === void 0 ? void 0 : _e.answer) ? SessionDescription.toJSON((_f = message.message) === null || _f === void 0 ? void 0 : _f.answer) : void 0);\n    ((_g = message.message) === null || _g === void 0 ? void 0 : _g.$case) === \"trickle\" && (obj.trickle = ((_h = message.message) === null || _h === void 0 ? void 0 : _h.trickle) ? TrickleRequest.toJSON((_j = message.message) === null || _j === void 0 ? void 0 : _j.trickle) : void 0);\n    ((_k = message.message) === null || _k === void 0 ? void 0 : _k.$case) === \"addTrack\" && (obj.addTrack = ((_l = message.message) === null || _l === void 0 ? void 0 : _l.addTrack) ? AddTrackRequest.toJSON((_m = message.message) === null || _m === void 0 ? void 0 : _m.addTrack) : void 0);\n    ((_o = message.message) === null || _o === void 0 ? void 0 : _o.$case) === \"mute\" && (obj.mute = ((_p = message.message) === null || _p === void 0 ? void 0 : _p.mute) ? MuteTrackRequest.toJSON((_q = message.message) === null || _q === void 0 ? void 0 : _q.mute) : void 0);\n    ((_r = message.message) === null || _r === void 0 ? void 0 : _r.$case) === \"subscription\" && (obj.subscription = ((_s = message.message) === null || _s === void 0 ? void 0 : _s.subscription) ? UpdateSubscription.toJSON((_t = message.message) === null || _t === void 0 ? void 0 : _t.subscription) : void 0);\n    ((_u = message.message) === null || _u === void 0 ? void 0 : _u.$case) === \"trackSetting\" && (obj.trackSetting = ((_v = message.message) === null || _v === void 0 ? void 0 : _v.trackSetting) ? UpdateTrackSettings.toJSON((_w = message.message) === null || _w === void 0 ? void 0 : _w.trackSetting) : void 0);\n    ((_x = message.message) === null || _x === void 0 ? void 0 : _x.$case) === \"leave\" && (obj.leave = ((_y = message.message) === null || _y === void 0 ? void 0 : _y.leave) ? LeaveRequest.toJSON((_z = message.message) === null || _z === void 0 ? void 0 : _z.leave) : void 0);\n    ((_0 = message.message) === null || _0 === void 0 ? void 0 : _0.$case) === \"updateLayers\" && (obj.updateLayers = ((_1 = message.message) === null || _1 === void 0 ? void 0 : _1.updateLayers) ? UpdateVideoLayers.toJSON((_2 = message.message) === null || _2 === void 0 ? void 0 : _2.updateLayers) : void 0);\n    ((_3 = message.message) === null || _3 === void 0 ? void 0 : _3.$case) === \"subscriptionPermission\" && (obj.subscriptionPermission = ((_4 = message.message) === null || _4 === void 0 ? void 0 : _4.subscriptionPermission) ? SubscriptionPermission.toJSON((_5 = message.message) === null || _5 === void 0 ? void 0 : _5.subscriptionPermission) : void 0);\n    ((_6 = message.message) === null || _6 === void 0 ? void 0 : _6.$case) === \"syncState\" && (obj.syncState = ((_7 = message.message) === null || _7 === void 0 ? void 0 : _7.syncState) ? SyncState.toJSON((_8 = message.message) === null || _8 === void 0 ? void 0 : _8.syncState) : void 0);\n    ((_9 = message.message) === null || _9 === void 0 ? void 0 : _9.$case) === \"simulate\" && (obj.simulate = ((_10 = message.message) === null || _10 === void 0 ? void 0 : _10.simulate) ? SimulateScenario.toJSON((_11 = message.message) === null || _11 === void 0 ? void 0 : _11.simulate) : void 0);\n    ((_12 = message.message) === null || _12 === void 0 ? void 0 : _12.$case) === \"ping\" && (obj.ping = Math.round((_13 = message.message) === null || _13 === void 0 ? void 0 : _13.ping));\n    ((_14 = message.message) === null || _14 === void 0 ? void 0 : _14.$case) === \"updateMetadata\" && (obj.updateMetadata = ((_15 = message.message) === null || _15 === void 0 ? void 0 : _15.updateMetadata) ? UpdateParticipantMetadata.toJSON((_16 = message.message) === null || _16 === void 0 ? void 0 : _16.updateMetadata) : void 0);\n    ((_17 = message.message) === null || _17 === void 0 ? void 0 : _17.$case) === \"pingReq\" && (obj.pingReq = ((_18 = message.message) === null || _18 === void 0 ? void 0 : _18.pingReq) ? Ping.toJSON((_19 = message.message) === null || _19 === void 0 ? void 0 : _19.pingReq) : void 0);\n    return obj;\n  },\n  create(base) {\n    return SignalRequest.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20;\n    const message = createBaseSignalRequest();\n    if (((_a = object.message) === null || _a === void 0 ? void 0 : _a.$case) === \"offer\" && ((_b = object.message) === null || _b === void 0 ? void 0 : _b.offer) !== void 0 && ((_c = object.message) === null || _c === void 0 ? void 0 : _c.offer) !== null) {\n      message.message = {\n        $case: \"offer\",\n        offer: SessionDescription.fromPartial(object.message.offer)\n      };\n    }\n    if (((_d = object.message) === null || _d === void 0 ? void 0 : _d.$case) === \"answer\" && ((_e = object.message) === null || _e === void 0 ? void 0 : _e.answer) !== void 0 && ((_f = object.message) === null || _f === void 0 ? void 0 : _f.answer) !== null) {\n      message.message = {\n        $case: \"answer\",\n        answer: SessionDescription.fromPartial(object.message.answer)\n      };\n    }\n    if (((_g = object.message) === null || _g === void 0 ? void 0 : _g.$case) === \"trickle\" && ((_h = object.message) === null || _h === void 0 ? void 0 : _h.trickle) !== void 0 && ((_j = object.message) === null || _j === void 0 ? void 0 : _j.trickle) !== null) {\n      message.message = {\n        $case: \"trickle\",\n        trickle: TrickleRequest.fromPartial(object.message.trickle)\n      };\n    }\n    if (((_k = object.message) === null || _k === void 0 ? void 0 : _k.$case) === \"addTrack\" && ((_l = object.message) === null || _l === void 0 ? void 0 : _l.addTrack) !== void 0 && ((_m = object.message) === null || _m === void 0 ? void 0 : _m.addTrack) !== null) {\n      message.message = {\n        $case: \"addTrack\",\n        addTrack: AddTrackRequest.fromPartial(object.message.addTrack)\n      };\n    }\n    if (((_o = object.message) === null || _o === void 0 ? void 0 : _o.$case) === \"mute\" && ((_p = object.message) === null || _p === void 0 ? void 0 : _p.mute) !== void 0 && ((_q = object.message) === null || _q === void 0 ? void 0 : _q.mute) !== null) {\n      message.message = {\n        $case: \"mute\",\n        mute: MuteTrackRequest.fromPartial(object.message.mute)\n      };\n    }\n    if (((_r = object.message) === null || _r === void 0 ? void 0 : _r.$case) === \"subscription\" && ((_s = object.message) === null || _s === void 0 ? void 0 : _s.subscription) !== void 0 && ((_t = object.message) === null || _t === void 0 ? void 0 : _t.subscription) !== null) {\n      message.message = {\n        $case: \"subscription\",\n        subscription: UpdateSubscription.fromPartial(object.message.subscription)\n      };\n    }\n    if (((_u = object.message) === null || _u === void 0 ? void 0 : _u.$case) === \"trackSetting\" && ((_v = object.message) === null || _v === void 0 ? void 0 : _v.trackSetting) !== void 0 && ((_w = object.message) === null || _w === void 0 ? void 0 : _w.trackSetting) !== null) {\n      message.message = {\n        $case: \"trackSetting\",\n        trackSetting: UpdateTrackSettings.fromPartial(object.message.trackSetting)\n      };\n    }\n    if (((_x = object.message) === null || _x === void 0 ? void 0 : _x.$case) === \"leave\" && ((_y = object.message) === null || _y === void 0 ? void 0 : _y.leave) !== void 0 && ((_z = object.message) === null || _z === void 0 ? void 0 : _z.leave) !== null) {\n      message.message = {\n        $case: \"leave\",\n        leave: LeaveRequest.fromPartial(object.message.leave)\n      };\n    }\n    if (((_0 = object.message) === null || _0 === void 0 ? void 0 : _0.$case) === \"updateLayers\" && ((_1 = object.message) === null || _1 === void 0 ? void 0 : _1.updateLayers) !== void 0 && ((_2 = object.message) === null || _2 === void 0 ? void 0 : _2.updateLayers) !== null) {\n      message.message = {\n        $case: \"updateLayers\",\n        updateLayers: UpdateVideoLayers.fromPartial(object.message.updateLayers)\n      };\n    }\n    if (((_3 = object.message) === null || _3 === void 0 ? void 0 : _3.$case) === \"subscriptionPermission\" && ((_4 = object.message) === null || _4 === void 0 ? void 0 : _4.subscriptionPermission) !== void 0 && ((_5 = object.message) === null || _5 === void 0 ? void 0 : _5.subscriptionPermission) !== null) {\n      message.message = {\n        $case: \"subscriptionPermission\",\n        subscriptionPermission: SubscriptionPermission.fromPartial(object.message.subscriptionPermission)\n      };\n    }\n    if (((_6 = object.message) === null || _6 === void 0 ? void 0 : _6.$case) === \"syncState\" && ((_7 = object.message) === null || _7 === void 0 ? void 0 : _7.syncState) !== void 0 && ((_8 = object.message) === null || _8 === void 0 ? void 0 : _8.syncState) !== null) {\n      message.message = {\n        $case: \"syncState\",\n        syncState: SyncState.fromPartial(object.message.syncState)\n      };\n    }\n    if (((_9 = object.message) === null || _9 === void 0 ? void 0 : _9.$case) === \"simulate\" && ((_10 = object.message) === null || _10 === void 0 ? void 0 : _10.simulate) !== void 0 && ((_11 = object.message) === null || _11 === void 0 ? void 0 : _11.simulate) !== null) {\n      message.message = {\n        $case: \"simulate\",\n        simulate: SimulateScenario.fromPartial(object.message.simulate)\n      };\n    }\n    if (((_12 = object.message) === null || _12 === void 0 ? void 0 : _12.$case) === \"ping\" && ((_13 = object.message) === null || _13 === void 0 ? void 0 : _13.ping) !== void 0 && ((_14 = object.message) === null || _14 === void 0 ? void 0 : _14.ping) !== null) {\n      message.message = {\n        $case: \"ping\",\n        ping: object.message.ping\n      };\n    }\n    if (((_15 = object.message) === null || _15 === void 0 ? void 0 : _15.$case) === \"updateMetadata\" && ((_16 = object.message) === null || _16 === void 0 ? void 0 : _16.updateMetadata) !== void 0 && ((_17 = object.message) === null || _17 === void 0 ? void 0 : _17.updateMetadata) !== null) {\n      message.message = {\n        $case: \"updateMetadata\",\n        updateMetadata: UpdateParticipantMetadata.fromPartial(object.message.updateMetadata)\n      };\n    }\n    if (((_18 = object.message) === null || _18 === void 0 ? void 0 : _18.$case) === \"pingReq\" && ((_19 = object.message) === null || _19 === void 0 ? void 0 : _19.pingReq) !== void 0 && ((_20 = object.message) === null || _20 === void 0 ? void 0 : _20.pingReq) !== null) {\n      message.message = {\n        $case: \"pingReq\",\n        pingReq: Ping.fromPartial(object.message.pingReq)\n      };\n    }\n    return message;\n  }\n};\nfunction createBaseSignalResponse() {\n  return {\n    message: void 0\n  };\n}\nvar SignalResponse = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    var _a;\n    switch ((_a = message.message) === null || _a === void 0 ? void 0 : _a.$case) {\n      case \"join\":\n        JoinResponse.encode(message.message.join, writer2.uint32(10).fork()).ldelim();\n        break;\n      case \"answer\":\n        SessionDescription.encode(message.message.answer, writer2.uint32(18).fork()).ldelim();\n        break;\n      case \"offer\":\n        SessionDescription.encode(message.message.offer, writer2.uint32(26).fork()).ldelim();\n        break;\n      case \"trickle\":\n        TrickleRequest.encode(message.message.trickle, writer2.uint32(34).fork()).ldelim();\n        break;\n      case \"update\":\n        ParticipantUpdate.encode(message.message.update, writer2.uint32(42).fork()).ldelim();\n        break;\n      case \"trackPublished\":\n        TrackPublishedResponse.encode(message.message.trackPublished, writer2.uint32(50).fork()).ldelim();\n        break;\n      case \"leave\":\n        LeaveRequest.encode(message.message.leave, writer2.uint32(66).fork()).ldelim();\n        break;\n      case \"mute\":\n        MuteTrackRequest.encode(message.message.mute, writer2.uint32(74).fork()).ldelim();\n        break;\n      case \"speakersChanged\":\n        SpeakersChanged.encode(message.message.speakersChanged, writer2.uint32(82).fork()).ldelim();\n        break;\n      case \"roomUpdate\":\n        RoomUpdate.encode(message.message.roomUpdate, writer2.uint32(90).fork()).ldelim();\n        break;\n      case \"connectionQuality\":\n        ConnectionQualityUpdate.encode(message.message.connectionQuality, writer2.uint32(98).fork()).ldelim();\n        break;\n      case \"streamStateUpdate\":\n        StreamStateUpdate.encode(message.message.streamStateUpdate, writer2.uint32(106).fork()).ldelim();\n        break;\n      case \"subscribedQualityUpdate\":\n        SubscribedQualityUpdate.encode(message.message.subscribedQualityUpdate, writer2.uint32(114).fork()).ldelim();\n        break;\n      case \"subscriptionPermissionUpdate\":\n        SubscriptionPermissionUpdate.encode(message.message.subscriptionPermissionUpdate, writer2.uint32(122).fork()).ldelim();\n        break;\n      case \"refreshToken\":\n        writer2.uint32(130).string(message.message.refreshToken);\n        break;\n      case \"trackUnpublished\":\n        TrackUnpublishedResponse.encode(message.message.trackUnpublished, writer2.uint32(138).fork()).ldelim();\n        break;\n      case \"pong\":\n        writer2.uint32(144).int64(message.message.pong);\n        break;\n      case \"reconnect\":\n        ReconnectResponse.encode(message.message.reconnect, writer2.uint32(154).fork()).ldelim();\n        break;\n      case \"pongResp\":\n        Pong.encode(message.message.pongResp, writer2.uint32(162).fork()).ldelim();\n        break;\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseSignalResponse();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.message = {\n            $case: \"join\",\n            join: JoinResponse.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.message = {\n            $case: \"answer\",\n            answer: SessionDescription.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 3:\n          if (tag != 26) {\n            break;\n          }\n          message.message = {\n            $case: \"offer\",\n            offer: SessionDescription.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 4:\n          if (tag != 34) {\n            break;\n          }\n          message.message = {\n            $case: \"trickle\",\n            trickle: TrickleRequest.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 5:\n          if (tag != 42) {\n            break;\n          }\n          message.message = {\n            $case: \"update\",\n            update: ParticipantUpdate.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 6:\n          if (tag != 50) {\n            break;\n          }\n          message.message = {\n            $case: \"trackPublished\",\n            trackPublished: TrackPublishedResponse.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 8:\n          if (tag != 66) {\n            break;\n          }\n          message.message = {\n            $case: \"leave\",\n            leave: LeaveRequest.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 9:\n          if (tag != 74) {\n            break;\n          }\n          message.message = {\n            $case: \"mute\",\n            mute: MuteTrackRequest.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 10:\n          if (tag != 82) {\n            break;\n          }\n          message.message = {\n            $case: \"speakersChanged\",\n            speakersChanged: SpeakersChanged.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 11:\n          if (tag != 90) {\n            break;\n          }\n          message.message = {\n            $case: \"roomUpdate\",\n            roomUpdate: RoomUpdate.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 12:\n          if (tag != 98) {\n            break;\n          }\n          message.message = {\n            $case: \"connectionQuality\",\n            connectionQuality: ConnectionQualityUpdate.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 13:\n          if (tag != 106) {\n            break;\n          }\n          message.message = {\n            $case: \"streamStateUpdate\",\n            streamStateUpdate: StreamStateUpdate.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 14:\n          if (tag != 114) {\n            break;\n          }\n          message.message = {\n            $case: \"subscribedQualityUpdate\",\n            subscribedQualityUpdate: SubscribedQualityUpdate.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 15:\n          if (tag != 122) {\n            break;\n          }\n          message.message = {\n            $case: \"subscriptionPermissionUpdate\",\n            subscriptionPermissionUpdate: SubscriptionPermissionUpdate.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 16:\n          if (tag != 130) {\n            break;\n          }\n          message.message = {\n            $case: \"refreshToken\",\n            refreshToken: reader2.string()\n          };\n          continue;\n        case 17:\n          if (tag != 138) {\n            break;\n          }\n          message.message = {\n            $case: \"trackUnpublished\",\n            trackUnpublished: TrackUnpublishedResponse.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 18:\n          if (tag != 144) {\n            break;\n          }\n          message.message = {\n            $case: \"pong\",\n            pong: longToNumber(reader2.int64())\n          };\n          continue;\n        case 19:\n          if (tag != 154) {\n            break;\n          }\n          message.message = {\n            $case: \"reconnect\",\n            reconnect: ReconnectResponse.decode(reader2, reader2.uint32())\n          };\n          continue;\n        case 20:\n          if (tag != 162) {\n            break;\n          }\n          message.message = {\n            $case: \"pongResp\",\n            pongResp: Pong.decode(reader2, reader2.uint32())\n          };\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      message: isSet(object.join) ? {\n        $case: \"join\",\n        join: JoinResponse.fromJSON(object.join)\n      } : isSet(object.answer) ? {\n        $case: \"answer\",\n        answer: SessionDescription.fromJSON(object.answer)\n      } : isSet(object.offer) ? {\n        $case: \"offer\",\n        offer: SessionDescription.fromJSON(object.offer)\n      } : isSet(object.trickle) ? {\n        $case: \"trickle\",\n        trickle: TrickleRequest.fromJSON(object.trickle)\n      } : isSet(object.update) ? {\n        $case: \"update\",\n        update: ParticipantUpdate.fromJSON(object.update)\n      } : isSet(object.trackPublished) ? {\n        $case: \"trackPublished\",\n        trackPublished: TrackPublishedResponse.fromJSON(object.trackPublished)\n      } : isSet(object.leave) ? {\n        $case: \"leave\",\n        leave: LeaveRequest.fromJSON(object.leave)\n      } : isSet(object.mute) ? {\n        $case: \"mute\",\n        mute: MuteTrackRequest.fromJSON(object.mute)\n      } : isSet(object.speakersChanged) ? {\n        $case: \"speakersChanged\",\n        speakersChanged: SpeakersChanged.fromJSON(object.speakersChanged)\n      } : isSet(object.roomUpdate) ? {\n        $case: \"roomUpdate\",\n        roomUpdate: RoomUpdate.fromJSON(object.roomUpdate)\n      } : isSet(object.connectionQuality) ? {\n        $case: \"connectionQuality\",\n        connectionQuality: ConnectionQualityUpdate.fromJSON(object.connectionQuality)\n      } : isSet(object.streamStateUpdate) ? {\n        $case: \"streamStateUpdate\",\n        streamStateUpdate: StreamStateUpdate.fromJSON(object.streamStateUpdate)\n      } : isSet(object.subscribedQualityUpdate) ? {\n        $case: \"subscribedQualityUpdate\",\n        subscribedQualityUpdate: SubscribedQualityUpdate.fromJSON(object.subscribedQualityUpdate)\n      } : isSet(object.subscriptionPermissionUpdate) ? {\n        $case: \"subscriptionPermissionUpdate\",\n        subscriptionPermissionUpdate: SubscriptionPermissionUpdate.fromJSON(object.subscriptionPermissionUpdate)\n      } : isSet(object.refreshToken) ? {\n        $case: \"refreshToken\",\n        refreshToken: String(object.refreshToken)\n      } : isSet(object.trackUnpublished) ? {\n        $case: \"trackUnpublished\",\n        trackUnpublished: TrackUnpublishedResponse.fromJSON(object.trackUnpublished)\n      } : isSet(object.pong) ? {\n        $case: \"pong\",\n        pong: Number(object.pong)\n      } : isSet(object.reconnect) ? {\n        $case: \"reconnect\",\n        reconnect: ReconnectResponse.fromJSON(object.reconnect)\n      } : isSet(object.pongResp) ? {\n        $case: \"pongResp\",\n        pongResp: Pong.fromJSON(object.pongResp)\n      } : void 0\n    };\n  },\n  toJSON(message) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30;\n    const obj = {};\n    ((_a = message.message) === null || _a === void 0 ? void 0 : _a.$case) === \"join\" && (obj.join = ((_b = message.message) === null || _b === void 0 ? void 0 : _b.join) ? JoinResponse.toJSON((_c = message.message) === null || _c === void 0 ? void 0 : _c.join) : void 0);\n    ((_d = message.message) === null || _d === void 0 ? void 0 : _d.$case) === \"answer\" && (obj.answer = ((_e = message.message) === null || _e === void 0 ? void 0 : _e.answer) ? SessionDescription.toJSON((_f = message.message) === null || _f === void 0 ? void 0 : _f.answer) : void 0);\n    ((_g = message.message) === null || _g === void 0 ? void 0 : _g.$case) === \"offer\" && (obj.offer = ((_h = message.message) === null || _h === void 0 ? void 0 : _h.offer) ? SessionDescription.toJSON((_j = message.message) === null || _j === void 0 ? void 0 : _j.offer) : void 0);\n    ((_k = message.message) === null || _k === void 0 ? void 0 : _k.$case) === \"trickle\" && (obj.trickle = ((_l = message.message) === null || _l === void 0 ? void 0 : _l.trickle) ? TrickleRequest.toJSON((_m = message.message) === null || _m === void 0 ? void 0 : _m.trickle) : void 0);\n    ((_o = message.message) === null || _o === void 0 ? void 0 : _o.$case) === \"update\" && (obj.update = ((_p = message.message) === null || _p === void 0 ? void 0 : _p.update) ? ParticipantUpdate.toJSON((_q = message.message) === null || _q === void 0 ? void 0 : _q.update) : void 0);\n    ((_r = message.message) === null || _r === void 0 ? void 0 : _r.$case) === \"trackPublished\" && (obj.trackPublished = ((_s = message.message) === null || _s === void 0 ? void 0 : _s.trackPublished) ? TrackPublishedResponse.toJSON((_t = message.message) === null || _t === void 0 ? void 0 : _t.trackPublished) : void 0);\n    ((_u = message.message) === null || _u === void 0 ? void 0 : _u.$case) === \"leave\" && (obj.leave = ((_v = message.message) === null || _v === void 0 ? void 0 : _v.leave) ? LeaveRequest.toJSON((_w = message.message) === null || _w === void 0 ? void 0 : _w.leave) : void 0);\n    ((_x = message.message) === null || _x === void 0 ? void 0 : _x.$case) === \"mute\" && (obj.mute = ((_y = message.message) === null || _y === void 0 ? void 0 : _y.mute) ? MuteTrackRequest.toJSON((_z = message.message) === null || _z === void 0 ? void 0 : _z.mute) : void 0);\n    ((_0 = message.message) === null || _0 === void 0 ? void 0 : _0.$case) === \"speakersChanged\" && (obj.speakersChanged = ((_1 = message.message) === null || _1 === void 0 ? void 0 : _1.speakersChanged) ? SpeakersChanged.toJSON((_2 = message.message) === null || _2 === void 0 ? void 0 : _2.speakersChanged) : void 0);\n    ((_3 = message.message) === null || _3 === void 0 ? void 0 : _3.$case) === \"roomUpdate\" && (obj.roomUpdate = ((_4 = message.message) === null || _4 === void 0 ? void 0 : _4.roomUpdate) ? RoomUpdate.toJSON((_5 = message.message) === null || _5 === void 0 ? void 0 : _5.roomUpdate) : void 0);\n    ((_6 = message.message) === null || _6 === void 0 ? void 0 : _6.$case) === \"connectionQuality\" && (obj.connectionQuality = ((_7 = message.message) === null || _7 === void 0 ? void 0 : _7.connectionQuality) ? ConnectionQualityUpdate.toJSON((_8 = message.message) === null || _8 === void 0 ? void 0 : _8.connectionQuality) : void 0);\n    ((_9 = message.message) === null || _9 === void 0 ? void 0 : _9.$case) === \"streamStateUpdate\" && (obj.streamStateUpdate = ((_10 = message.message) === null || _10 === void 0 ? void 0 : _10.streamStateUpdate) ? StreamStateUpdate.toJSON((_11 = message.message) === null || _11 === void 0 ? void 0 : _11.streamStateUpdate) : void 0);\n    ((_12 = message.message) === null || _12 === void 0 ? void 0 : _12.$case) === \"subscribedQualityUpdate\" && (obj.subscribedQualityUpdate = ((_13 = message.message) === null || _13 === void 0 ? void 0 : _13.subscribedQualityUpdate) ? SubscribedQualityUpdate.toJSON((_14 = message.message) === null || _14 === void 0 ? void 0 : _14.subscribedQualityUpdate) : void 0);\n    ((_15 = message.message) === null || _15 === void 0 ? void 0 : _15.$case) === \"subscriptionPermissionUpdate\" && (obj.subscriptionPermissionUpdate = ((_16 = message.message) === null || _16 === void 0 ? void 0 : _16.subscriptionPermissionUpdate) ? SubscriptionPermissionUpdate.toJSON((_17 = message.message) === null || _17 === void 0 ? void 0 : _17.subscriptionPermissionUpdate) : void 0);\n    ((_18 = message.message) === null || _18 === void 0 ? void 0 : _18.$case) === \"refreshToken\" && (obj.refreshToken = (_19 = message.message) === null || _19 === void 0 ? void 0 : _19.refreshToken);\n    ((_20 = message.message) === null || _20 === void 0 ? void 0 : _20.$case) === \"trackUnpublished\" && (obj.trackUnpublished = ((_21 = message.message) === null || _21 === void 0 ? void 0 : _21.trackUnpublished) ? TrackUnpublishedResponse.toJSON((_22 = message.message) === null || _22 === void 0 ? void 0 : _22.trackUnpublished) : void 0);\n    ((_23 = message.message) === null || _23 === void 0 ? void 0 : _23.$case) === \"pong\" && (obj.pong = Math.round((_24 = message.message) === null || _24 === void 0 ? void 0 : _24.pong));\n    ((_25 = message.message) === null || _25 === void 0 ? void 0 : _25.$case) === \"reconnect\" && (obj.reconnect = ((_26 = message.message) === null || _26 === void 0 ? void 0 : _26.reconnect) ? ReconnectResponse.toJSON((_27 = message.message) === null || _27 === void 0 ? void 0 : _27.reconnect) : void 0);\n    ((_28 = message.message) === null || _28 === void 0 ? void 0 : _28.$case) === \"pongResp\" && (obj.pongResp = ((_29 = message.message) === null || _29 === void 0 ? void 0 : _29.pongResp) ? Pong.toJSON((_30 = message.message) === null || _30 === void 0 ? void 0 : _30.pongResp) : void 0);\n    return obj;\n  },\n  create(base) {\n    return SignalResponse.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32;\n    const message = createBaseSignalResponse();\n    if (((_a = object.message) === null || _a === void 0 ? void 0 : _a.$case) === \"join\" && ((_b = object.message) === null || _b === void 0 ? void 0 : _b.join) !== void 0 && ((_c = object.message) === null || _c === void 0 ? void 0 : _c.join) !== null) {\n      message.message = {\n        $case: \"join\",\n        join: JoinResponse.fromPartial(object.message.join)\n      };\n    }\n    if (((_d = object.message) === null || _d === void 0 ? void 0 : _d.$case) === \"answer\" && ((_e = object.message) === null || _e === void 0 ? void 0 : _e.answer) !== void 0 && ((_f = object.message) === null || _f === void 0 ? void 0 : _f.answer) !== null) {\n      message.message = {\n        $case: \"answer\",\n        answer: SessionDescription.fromPartial(object.message.answer)\n      };\n    }\n    if (((_g = object.message) === null || _g === void 0 ? void 0 : _g.$case) === \"offer\" && ((_h = object.message) === null || _h === void 0 ? void 0 : _h.offer) !== void 0 && ((_j = object.message) === null || _j === void 0 ? void 0 : _j.offer) !== null) {\n      message.message = {\n        $case: \"offer\",\n        offer: SessionDescription.fromPartial(object.message.offer)\n      };\n    }\n    if (((_k = object.message) === null || _k === void 0 ? void 0 : _k.$case) === \"trickle\" && ((_l = object.message) === null || _l === void 0 ? void 0 : _l.trickle) !== void 0 && ((_m = object.message) === null || _m === void 0 ? void 0 : _m.trickle) !== null) {\n      message.message = {\n        $case: \"trickle\",\n        trickle: TrickleRequest.fromPartial(object.message.trickle)\n      };\n    }\n    if (((_o = object.message) === null || _o === void 0 ? void 0 : _o.$case) === \"update\" && ((_p = object.message) === null || _p === void 0 ? void 0 : _p.update) !== void 0 && ((_q = object.message) === null || _q === void 0 ? void 0 : _q.update) !== null) {\n      message.message = {\n        $case: \"update\",\n        update: ParticipantUpdate.fromPartial(object.message.update)\n      };\n    }\n    if (((_r = object.message) === null || _r === void 0 ? void 0 : _r.$case) === \"trackPublished\" && ((_s = object.message) === null || _s === void 0 ? void 0 : _s.trackPublished) !== void 0 && ((_t = object.message) === null || _t === void 0 ? void 0 : _t.trackPublished) !== null) {\n      message.message = {\n        $case: \"trackPublished\",\n        trackPublished: TrackPublishedResponse.fromPartial(object.message.trackPublished)\n      };\n    }\n    if (((_u = object.message) === null || _u === void 0 ? void 0 : _u.$case) === \"leave\" && ((_v = object.message) === null || _v === void 0 ? void 0 : _v.leave) !== void 0 && ((_w = object.message) === null || _w === void 0 ? void 0 : _w.leave) !== null) {\n      message.message = {\n        $case: \"leave\",\n        leave: LeaveRequest.fromPartial(object.message.leave)\n      };\n    }\n    if (((_x = object.message) === null || _x === void 0 ? void 0 : _x.$case) === \"mute\" && ((_y = object.message) === null || _y === void 0 ? void 0 : _y.mute) !== void 0 && ((_z = object.message) === null || _z === void 0 ? void 0 : _z.mute) !== null) {\n      message.message = {\n        $case: \"mute\",\n        mute: MuteTrackRequest.fromPartial(object.message.mute)\n      };\n    }\n    if (((_0 = object.message) === null || _0 === void 0 ? void 0 : _0.$case) === \"speakersChanged\" && ((_1 = object.message) === null || _1 === void 0 ? void 0 : _1.speakersChanged) !== void 0 && ((_2 = object.message) === null || _2 === void 0 ? void 0 : _2.speakersChanged) !== null) {\n      message.message = {\n        $case: \"speakersChanged\",\n        speakersChanged: SpeakersChanged.fromPartial(object.message.speakersChanged)\n      };\n    }\n    if (((_3 = object.message) === null || _3 === void 0 ? void 0 : _3.$case) === \"roomUpdate\" && ((_4 = object.message) === null || _4 === void 0 ? void 0 : _4.roomUpdate) !== void 0 && ((_5 = object.message) === null || _5 === void 0 ? void 0 : _5.roomUpdate) !== null) {\n      message.message = {\n        $case: \"roomUpdate\",\n        roomUpdate: RoomUpdate.fromPartial(object.message.roomUpdate)\n      };\n    }\n    if (((_6 = object.message) === null || _6 === void 0 ? void 0 : _6.$case) === \"connectionQuality\" && ((_7 = object.message) === null || _7 === void 0 ? void 0 : _7.connectionQuality) !== void 0 && ((_8 = object.message) === null || _8 === void 0 ? void 0 : _8.connectionQuality) !== null) {\n      message.message = {\n        $case: \"connectionQuality\",\n        connectionQuality: ConnectionQualityUpdate.fromPartial(object.message.connectionQuality)\n      };\n    }\n    if (((_9 = object.message) === null || _9 === void 0 ? void 0 : _9.$case) === \"streamStateUpdate\" && ((_10 = object.message) === null || _10 === void 0 ? void 0 : _10.streamStateUpdate) !== void 0 && ((_11 = object.message) === null || _11 === void 0 ? void 0 : _11.streamStateUpdate) !== null) {\n      message.message = {\n        $case: \"streamStateUpdate\",\n        streamStateUpdate: StreamStateUpdate.fromPartial(object.message.streamStateUpdate)\n      };\n    }\n    if (((_12 = object.message) === null || _12 === void 0 ? void 0 : _12.$case) === \"subscribedQualityUpdate\" && ((_13 = object.message) === null || _13 === void 0 ? void 0 : _13.subscribedQualityUpdate) !== void 0 && ((_14 = object.message) === null || _14 === void 0 ? void 0 : _14.subscribedQualityUpdate) !== null) {\n      message.message = {\n        $case: \"subscribedQualityUpdate\",\n        subscribedQualityUpdate: SubscribedQualityUpdate.fromPartial(object.message.subscribedQualityUpdate)\n      };\n    }\n    if (((_15 = object.message) === null || _15 === void 0 ? void 0 : _15.$case) === \"subscriptionPermissionUpdate\" && ((_16 = object.message) === null || _16 === void 0 ? void 0 : _16.subscriptionPermissionUpdate) !== void 0 && ((_17 = object.message) === null || _17 === void 0 ? void 0 : _17.subscriptionPermissionUpdate) !== null) {\n      message.message = {\n        $case: \"subscriptionPermissionUpdate\",\n        subscriptionPermissionUpdate: SubscriptionPermissionUpdate.fromPartial(object.message.subscriptionPermissionUpdate)\n      };\n    }\n    if (((_18 = object.message) === null || _18 === void 0 ? void 0 : _18.$case) === \"refreshToken\" && ((_19 = object.message) === null || _19 === void 0 ? void 0 : _19.refreshToken) !== void 0 && ((_20 = object.message) === null || _20 === void 0 ? void 0 : _20.refreshToken) !== null) {\n      message.message = {\n        $case: \"refreshToken\",\n        refreshToken: object.message.refreshToken\n      };\n    }\n    if (((_21 = object.message) === null || _21 === void 0 ? void 0 : _21.$case) === \"trackUnpublished\" && ((_22 = object.message) === null || _22 === void 0 ? void 0 : _22.trackUnpublished) !== void 0 && ((_23 = object.message) === null || _23 === void 0 ? void 0 : _23.trackUnpublished) !== null) {\n      message.message = {\n        $case: \"trackUnpublished\",\n        trackUnpublished: TrackUnpublishedResponse.fromPartial(object.message.trackUnpublished)\n      };\n    }\n    if (((_24 = object.message) === null || _24 === void 0 ? void 0 : _24.$case) === \"pong\" && ((_25 = object.message) === null || _25 === void 0 ? void 0 : _25.pong) !== void 0 && ((_26 = object.message) === null || _26 === void 0 ? void 0 : _26.pong) !== null) {\n      message.message = {\n        $case: \"pong\",\n        pong: object.message.pong\n      };\n    }\n    if (((_27 = object.message) === null || _27 === void 0 ? void 0 : _27.$case) === \"reconnect\" && ((_28 = object.message) === null || _28 === void 0 ? void 0 : _28.reconnect) !== void 0 && ((_29 = object.message) === null || _29 === void 0 ? void 0 : _29.reconnect) !== null) {\n      message.message = {\n        $case: \"reconnect\",\n        reconnect: ReconnectResponse.fromPartial(object.message.reconnect)\n      };\n    }\n    if (((_30 = object.message) === null || _30 === void 0 ? void 0 : _30.$case) === \"pongResp\" && ((_31 = object.message) === null || _31 === void 0 ? void 0 : _31.pongResp) !== void 0 && ((_32 = object.message) === null || _32 === void 0 ? void 0 : _32.pongResp) !== null) {\n      message.message = {\n        $case: \"pongResp\",\n        pongResp: Pong.fromPartial(object.message.pongResp)\n      };\n    }\n    return message;\n  }\n};\nfunction createBaseSimulcastCodec() {\n  return {\n    codec: \"\",\n    cid: \"\",\n    enableSimulcastLayers: false\n  };\n}\nvar SimulcastCodec = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.codec !== \"\") {\n      writer2.uint32(10).string(message.codec);\n    }\n    if (message.cid !== \"\") {\n      writer2.uint32(18).string(message.cid);\n    }\n    if (message.enableSimulcastLayers === true) {\n      writer2.uint32(24).bool(message.enableSimulcastLayers);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseSimulcastCodec();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.codec = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.cid = reader2.string();\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.enableSimulcastLayers = reader2.bool();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      codec: isSet(object.codec) ? String(object.codec) : \"\",\n      cid: isSet(object.cid) ? String(object.cid) : \"\",\n      enableSimulcastLayers: isSet(object.enableSimulcastLayers) ? Boolean(object.enableSimulcastLayers) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.codec !== void 0 && (obj.codec = message.codec);\n    message.cid !== void 0 && (obj.cid = message.cid);\n    message.enableSimulcastLayers !== void 0 && (obj.enableSimulcastLayers = message.enableSimulcastLayers);\n    return obj;\n  },\n  create(base) {\n    return SimulcastCodec.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseSimulcastCodec();\n    message.codec = (_a = object.codec) !== null && _a !== void 0 ? _a : \"\";\n    message.cid = (_b = object.cid) !== null && _b !== void 0 ? _b : \"\";\n    message.enableSimulcastLayers = (_c = object.enableSimulcastLayers) !== null && _c !== void 0 ? _c : false;\n    return message;\n  }\n};\nfunction createBaseAddTrackRequest() {\n  return {\n    cid: \"\",\n    name: \"\",\n    type: 0,\n    width: 0,\n    height: 0,\n    muted: false,\n    disableDtx: false,\n    source: 0,\n    layers: [],\n    simulcastCodecs: [],\n    sid: \"\",\n    stereo: false,\n    disableRed: false,\n    encryption: 0\n  };\n}\nvar AddTrackRequest = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.cid !== \"\") {\n      writer2.uint32(10).string(message.cid);\n    }\n    if (message.name !== \"\") {\n      writer2.uint32(18).string(message.name);\n    }\n    if (message.type !== 0) {\n      writer2.uint32(24).int32(message.type);\n    }\n    if (message.width !== 0) {\n      writer2.uint32(32).uint32(message.width);\n    }\n    if (message.height !== 0) {\n      writer2.uint32(40).uint32(message.height);\n    }\n    if (message.muted === true) {\n      writer2.uint32(48).bool(message.muted);\n    }\n    if (message.disableDtx === true) {\n      writer2.uint32(56).bool(message.disableDtx);\n    }\n    if (message.source !== 0) {\n      writer2.uint32(64).int32(message.source);\n    }\n    for (const v of message.layers) {\n      VideoLayer.encode(v, writer2.uint32(74).fork()).ldelim();\n    }\n    for (const v of message.simulcastCodecs) {\n      SimulcastCodec.encode(v, writer2.uint32(82).fork()).ldelim();\n    }\n    if (message.sid !== \"\") {\n      writer2.uint32(90).string(message.sid);\n    }\n    if (message.stereo === true) {\n      writer2.uint32(96).bool(message.stereo);\n    }\n    if (message.disableRed === true) {\n      writer2.uint32(104).bool(message.disableRed);\n    }\n    if (message.encryption !== 0) {\n      writer2.uint32(112).int32(message.encryption);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseAddTrackRequest();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.cid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.name = reader2.string();\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.type = reader2.int32();\n          continue;\n        case 4:\n          if (tag != 32) {\n            break;\n          }\n          message.width = reader2.uint32();\n          continue;\n        case 5:\n          if (tag != 40) {\n            break;\n          }\n          message.height = reader2.uint32();\n          continue;\n        case 6:\n          if (tag != 48) {\n            break;\n          }\n          message.muted = reader2.bool();\n          continue;\n        case 7:\n          if (tag != 56) {\n            break;\n          }\n          message.disableDtx = reader2.bool();\n          continue;\n        case 8:\n          if (tag != 64) {\n            break;\n          }\n          message.source = reader2.int32();\n          continue;\n        case 9:\n          if (tag != 74) {\n            break;\n          }\n          message.layers.push(VideoLayer.decode(reader2, reader2.uint32()));\n          continue;\n        case 10:\n          if (tag != 82) {\n            break;\n          }\n          message.simulcastCodecs.push(SimulcastCodec.decode(reader2, reader2.uint32()));\n          continue;\n        case 11:\n          if (tag != 90) {\n            break;\n          }\n          message.sid = reader2.string();\n          continue;\n        case 12:\n          if (tag != 96) {\n            break;\n          }\n          message.stereo = reader2.bool();\n          continue;\n        case 13:\n          if (tag != 104) {\n            break;\n          }\n          message.disableRed = reader2.bool();\n          continue;\n        case 14:\n          if (tag != 112) {\n            break;\n          }\n          message.encryption = reader2.int32();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      cid: isSet(object.cid) ? String(object.cid) : \"\",\n      name: isSet(object.name) ? String(object.name) : \"\",\n      type: isSet(object.type) ? trackTypeFromJSON(object.type) : 0,\n      width: isSet(object.width) ? Number(object.width) : 0,\n      height: isSet(object.height) ? Number(object.height) : 0,\n      muted: isSet(object.muted) ? Boolean(object.muted) : false,\n      disableDtx: isSet(object.disableDtx) ? Boolean(object.disableDtx) : false,\n      source: isSet(object.source) ? trackSourceFromJSON(object.source) : 0,\n      layers: Array.isArray(object === null || object === void 0 ? void 0 : object.layers) ? object.layers.map((e) => VideoLayer.fromJSON(e)) : [],\n      simulcastCodecs: Array.isArray(object === null || object === void 0 ? void 0 : object.simulcastCodecs) ? object.simulcastCodecs.map((e) => SimulcastCodec.fromJSON(e)) : [],\n      sid: isSet(object.sid) ? String(object.sid) : \"\",\n      stereo: isSet(object.stereo) ? Boolean(object.stereo) : false,\n      disableRed: isSet(object.disableRed) ? Boolean(object.disableRed) : false,\n      encryption: isSet(object.encryption) ? encryption_TypeFromJSON(object.encryption) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.cid !== void 0 && (obj.cid = message.cid);\n    message.name !== void 0 && (obj.name = message.name);\n    message.type !== void 0 && (obj.type = trackTypeToJSON(message.type));\n    message.width !== void 0 && (obj.width = Math.round(message.width));\n    message.height !== void 0 && (obj.height = Math.round(message.height));\n    message.muted !== void 0 && (obj.muted = message.muted);\n    message.disableDtx !== void 0 && (obj.disableDtx = message.disableDtx);\n    message.source !== void 0 && (obj.source = trackSourceToJSON(message.source));\n    if (message.layers) {\n      obj.layers = message.layers.map((e) => e ? VideoLayer.toJSON(e) : void 0);\n    } else {\n      obj.layers = [];\n    }\n    if (message.simulcastCodecs) {\n      obj.simulcastCodecs = message.simulcastCodecs.map((e) => e ? SimulcastCodec.toJSON(e) : void 0);\n    } else {\n      obj.simulcastCodecs = [];\n    }\n    message.sid !== void 0 && (obj.sid = message.sid);\n    message.stereo !== void 0 && (obj.stereo = message.stereo);\n    message.disableRed !== void 0 && (obj.disableRed = message.disableRed);\n    message.encryption !== void 0 && (obj.encryption = encryption_TypeToJSON(message.encryption));\n    return obj;\n  },\n  create(base) {\n    return AddTrackRequest.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;\n    const message = createBaseAddTrackRequest();\n    message.cid = (_a = object.cid) !== null && _a !== void 0 ? _a : \"\";\n    message.name = (_b = object.name) !== null && _b !== void 0 ? _b : \"\";\n    message.type = (_c = object.type) !== null && _c !== void 0 ? _c : 0;\n    message.width = (_d = object.width) !== null && _d !== void 0 ? _d : 0;\n    message.height = (_e = object.height) !== null && _e !== void 0 ? _e : 0;\n    message.muted = (_f = object.muted) !== null && _f !== void 0 ? _f : false;\n    message.disableDtx = (_g = object.disableDtx) !== null && _g !== void 0 ? _g : false;\n    message.source = (_h = object.source) !== null && _h !== void 0 ? _h : 0;\n    message.layers = ((_j = object.layers) === null || _j === void 0 ? void 0 : _j.map((e) => VideoLayer.fromPartial(e))) || [];\n    message.simulcastCodecs = ((_k = object.simulcastCodecs) === null || _k === void 0 ? void 0 : _k.map((e) => SimulcastCodec.fromPartial(e))) || [];\n    message.sid = (_l = object.sid) !== null && _l !== void 0 ? _l : \"\";\n    message.stereo = (_m = object.stereo) !== null && _m !== void 0 ? _m : false;\n    message.disableRed = (_o = object.disableRed) !== null && _o !== void 0 ? _o : false;\n    message.encryption = (_p = object.encryption) !== null && _p !== void 0 ? _p : 0;\n    return message;\n  }\n};\nfunction createBaseTrickleRequest() {\n  return {\n    candidateInit: \"\",\n    target: 0\n  };\n}\nvar TrickleRequest = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.candidateInit !== \"\") {\n      writer2.uint32(10).string(message.candidateInit);\n    }\n    if (message.target !== 0) {\n      writer2.uint32(16).int32(message.target);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseTrickleRequest();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.candidateInit = reader2.string();\n          continue;\n        case 2:\n          if (tag != 16) {\n            break;\n          }\n          message.target = reader2.int32();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      candidateInit: isSet(object.candidateInit) ? String(object.candidateInit) : \"\",\n      target: isSet(object.target) ? signalTargetFromJSON(object.target) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.candidateInit !== void 0 && (obj.candidateInit = message.candidateInit);\n    message.target !== void 0 && (obj.target = signalTargetToJSON(message.target));\n    return obj;\n  },\n  create(base) {\n    return TrickleRequest.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseTrickleRequest();\n    message.candidateInit = (_a = object.candidateInit) !== null && _a !== void 0 ? _a : \"\";\n    message.target = (_b = object.target) !== null && _b !== void 0 ? _b : 0;\n    return message;\n  }\n};\nfunction createBaseMuteTrackRequest() {\n  return {\n    sid: \"\",\n    muted: false\n  };\n}\nvar MuteTrackRequest = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.sid !== \"\") {\n      writer2.uint32(10).string(message.sid);\n    }\n    if (message.muted === true) {\n      writer2.uint32(16).bool(message.muted);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseMuteTrackRequest();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.sid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 16) {\n            break;\n          }\n          message.muted = reader2.bool();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      sid: isSet(object.sid) ? String(object.sid) : \"\",\n      muted: isSet(object.muted) ? Boolean(object.muted) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.sid !== void 0 && (obj.sid = message.sid);\n    message.muted !== void 0 && (obj.muted = message.muted);\n    return obj;\n  },\n  create(base) {\n    return MuteTrackRequest.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseMuteTrackRequest();\n    message.sid = (_a = object.sid) !== null && _a !== void 0 ? _a : \"\";\n    message.muted = (_b = object.muted) !== null && _b !== void 0 ? _b : false;\n    return message;\n  }\n};\nfunction createBaseJoinResponse() {\n  return {\n    room: void 0,\n    participant: void 0,\n    otherParticipants: [],\n    serverVersion: \"\",\n    iceServers: [],\n    subscriberPrimary: false,\n    alternativeUrl: \"\",\n    clientConfiguration: void 0,\n    serverRegion: \"\",\n    pingTimeout: 0,\n    pingInterval: 0,\n    serverInfo: void 0\n  };\n}\nvar JoinResponse = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.room !== void 0) {\n      Room$1.encode(message.room, writer2.uint32(10).fork()).ldelim();\n    }\n    if (message.participant !== void 0) {\n      ParticipantInfo.encode(message.participant, writer2.uint32(18).fork()).ldelim();\n    }\n    for (const v of message.otherParticipants) {\n      ParticipantInfo.encode(v, writer2.uint32(26).fork()).ldelim();\n    }\n    if (message.serverVersion !== \"\") {\n      writer2.uint32(34).string(message.serverVersion);\n    }\n    for (const v of message.iceServers) {\n      ICEServer.encode(v, writer2.uint32(42).fork()).ldelim();\n    }\n    if (message.subscriberPrimary === true) {\n      writer2.uint32(48).bool(message.subscriberPrimary);\n    }\n    if (message.alternativeUrl !== \"\") {\n      writer2.uint32(58).string(message.alternativeUrl);\n    }\n    if (message.clientConfiguration !== void 0) {\n      ClientConfiguration.encode(message.clientConfiguration, writer2.uint32(66).fork()).ldelim();\n    }\n    if (message.serverRegion !== \"\") {\n      writer2.uint32(74).string(message.serverRegion);\n    }\n    if (message.pingTimeout !== 0) {\n      writer2.uint32(80).int32(message.pingTimeout);\n    }\n    if (message.pingInterval !== 0) {\n      writer2.uint32(88).int32(message.pingInterval);\n    }\n    if (message.serverInfo !== void 0) {\n      ServerInfo.encode(message.serverInfo, writer2.uint32(98).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseJoinResponse();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.room = Room$1.decode(reader2, reader2.uint32());\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.participant = ParticipantInfo.decode(reader2, reader2.uint32());\n          continue;\n        case 3:\n          if (tag != 26) {\n            break;\n          }\n          message.otherParticipants.push(ParticipantInfo.decode(reader2, reader2.uint32()));\n          continue;\n        case 4:\n          if (tag != 34) {\n            break;\n          }\n          message.serverVersion = reader2.string();\n          continue;\n        case 5:\n          if (tag != 42) {\n            break;\n          }\n          message.iceServers.push(ICEServer.decode(reader2, reader2.uint32()));\n          continue;\n        case 6:\n          if (tag != 48) {\n            break;\n          }\n          message.subscriberPrimary = reader2.bool();\n          continue;\n        case 7:\n          if (tag != 58) {\n            break;\n          }\n          message.alternativeUrl = reader2.string();\n          continue;\n        case 8:\n          if (tag != 66) {\n            break;\n          }\n          message.clientConfiguration = ClientConfiguration.decode(reader2, reader2.uint32());\n          continue;\n        case 9:\n          if (tag != 74) {\n            break;\n          }\n          message.serverRegion = reader2.string();\n          continue;\n        case 10:\n          if (tag != 80) {\n            break;\n          }\n          message.pingTimeout = reader2.int32();\n          continue;\n        case 11:\n          if (tag != 88) {\n            break;\n          }\n          message.pingInterval = reader2.int32();\n          continue;\n        case 12:\n          if (tag != 98) {\n            break;\n          }\n          message.serverInfo = ServerInfo.decode(reader2, reader2.uint32());\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      room: isSet(object.room) ? Room$1.fromJSON(object.room) : void 0,\n      participant: isSet(object.participant) ? ParticipantInfo.fromJSON(object.participant) : void 0,\n      otherParticipants: Array.isArray(object === null || object === void 0 ? void 0 : object.otherParticipants) ? object.otherParticipants.map((e) => ParticipantInfo.fromJSON(e)) : [],\n      serverVersion: isSet(object.serverVersion) ? String(object.serverVersion) : \"\",\n      iceServers: Array.isArray(object === null || object === void 0 ? void 0 : object.iceServers) ? object.iceServers.map((e) => ICEServer.fromJSON(e)) : [],\n      subscriberPrimary: isSet(object.subscriberPrimary) ? Boolean(object.subscriberPrimary) : false,\n      alternativeUrl: isSet(object.alternativeUrl) ? String(object.alternativeUrl) : \"\",\n      clientConfiguration: isSet(object.clientConfiguration) ? ClientConfiguration.fromJSON(object.clientConfiguration) : void 0,\n      serverRegion: isSet(object.serverRegion) ? String(object.serverRegion) : \"\",\n      pingTimeout: isSet(object.pingTimeout) ? Number(object.pingTimeout) : 0,\n      pingInterval: isSet(object.pingInterval) ? Number(object.pingInterval) : 0,\n      serverInfo: isSet(object.serverInfo) ? ServerInfo.fromJSON(object.serverInfo) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.room !== void 0 && (obj.room = message.room ? Room$1.toJSON(message.room) : void 0);\n    message.participant !== void 0 && (obj.participant = message.participant ? ParticipantInfo.toJSON(message.participant) : void 0);\n    if (message.otherParticipants) {\n      obj.otherParticipants = message.otherParticipants.map((e) => e ? ParticipantInfo.toJSON(e) : void 0);\n    } else {\n      obj.otherParticipants = [];\n    }\n    message.serverVersion !== void 0 && (obj.serverVersion = message.serverVersion);\n    if (message.iceServers) {\n      obj.iceServers = message.iceServers.map((e) => e ? ICEServer.toJSON(e) : void 0);\n    } else {\n      obj.iceServers = [];\n    }\n    message.subscriberPrimary !== void 0 && (obj.subscriberPrimary = message.subscriberPrimary);\n    message.alternativeUrl !== void 0 && (obj.alternativeUrl = message.alternativeUrl);\n    message.clientConfiguration !== void 0 && (obj.clientConfiguration = message.clientConfiguration ? ClientConfiguration.toJSON(message.clientConfiguration) : void 0);\n    message.serverRegion !== void 0 && (obj.serverRegion = message.serverRegion);\n    message.pingTimeout !== void 0 && (obj.pingTimeout = Math.round(message.pingTimeout));\n    message.pingInterval !== void 0 && (obj.pingInterval = Math.round(message.pingInterval));\n    message.serverInfo !== void 0 && (obj.serverInfo = message.serverInfo ? ServerInfo.toJSON(message.serverInfo) : void 0);\n    return obj;\n  },\n  create(base) {\n    return JoinResponse.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const message = createBaseJoinResponse();\n    message.room = object.room !== void 0 && object.room !== null ? Room$1.fromPartial(object.room) : void 0;\n    message.participant = object.participant !== void 0 && object.participant !== null ? ParticipantInfo.fromPartial(object.participant) : void 0;\n    message.otherParticipants = ((_a = object.otherParticipants) === null || _a === void 0 ? void 0 : _a.map((e) => ParticipantInfo.fromPartial(e))) || [];\n    message.serverVersion = (_b = object.serverVersion) !== null && _b !== void 0 ? _b : \"\";\n    message.iceServers = ((_c = object.iceServers) === null || _c === void 0 ? void 0 : _c.map((e) => ICEServer.fromPartial(e))) || [];\n    message.subscriberPrimary = (_d = object.subscriberPrimary) !== null && _d !== void 0 ? _d : false;\n    message.alternativeUrl = (_e = object.alternativeUrl) !== null && _e !== void 0 ? _e : \"\";\n    message.clientConfiguration = object.clientConfiguration !== void 0 && object.clientConfiguration !== null ? ClientConfiguration.fromPartial(object.clientConfiguration) : void 0;\n    message.serverRegion = (_f = object.serverRegion) !== null && _f !== void 0 ? _f : \"\";\n    message.pingTimeout = (_g = object.pingTimeout) !== null && _g !== void 0 ? _g : 0;\n    message.pingInterval = (_h = object.pingInterval) !== null && _h !== void 0 ? _h : 0;\n    message.serverInfo = object.serverInfo !== void 0 && object.serverInfo !== null ? ServerInfo.fromPartial(object.serverInfo) : void 0;\n    return message;\n  }\n};\nfunction createBaseReconnectResponse() {\n  return {\n    iceServers: [],\n    clientConfiguration: void 0\n  };\n}\nvar ReconnectResponse = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    for (const v of message.iceServers) {\n      ICEServer.encode(v, writer2.uint32(10).fork()).ldelim();\n    }\n    if (message.clientConfiguration !== void 0) {\n      ClientConfiguration.encode(message.clientConfiguration, writer2.uint32(18).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseReconnectResponse();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.iceServers.push(ICEServer.decode(reader2, reader2.uint32()));\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.clientConfiguration = ClientConfiguration.decode(reader2, reader2.uint32());\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      iceServers: Array.isArray(object === null || object === void 0 ? void 0 : object.iceServers) ? object.iceServers.map((e) => ICEServer.fromJSON(e)) : [],\n      clientConfiguration: isSet(object.clientConfiguration) ? ClientConfiguration.fromJSON(object.clientConfiguration) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.iceServers) {\n      obj.iceServers = message.iceServers.map((e) => e ? ICEServer.toJSON(e) : void 0);\n    } else {\n      obj.iceServers = [];\n    }\n    message.clientConfiguration !== void 0 && (obj.clientConfiguration = message.clientConfiguration ? ClientConfiguration.toJSON(message.clientConfiguration) : void 0);\n    return obj;\n  },\n  create(base) {\n    return ReconnectResponse.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseReconnectResponse();\n    message.iceServers = ((_a = object.iceServers) === null || _a === void 0 ? void 0 : _a.map((e) => ICEServer.fromPartial(e))) || [];\n    message.clientConfiguration = object.clientConfiguration !== void 0 && object.clientConfiguration !== null ? ClientConfiguration.fromPartial(object.clientConfiguration) : void 0;\n    return message;\n  }\n};\nfunction createBaseTrackPublishedResponse() {\n  return {\n    cid: \"\",\n    track: void 0\n  };\n}\nvar TrackPublishedResponse = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.cid !== \"\") {\n      writer2.uint32(10).string(message.cid);\n    }\n    if (message.track !== void 0) {\n      TrackInfo.encode(message.track, writer2.uint32(18).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseTrackPublishedResponse();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.cid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.track = TrackInfo.decode(reader2, reader2.uint32());\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      cid: isSet(object.cid) ? String(object.cid) : \"\",\n      track: isSet(object.track) ? TrackInfo.fromJSON(object.track) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.cid !== void 0 && (obj.cid = message.cid);\n    message.track !== void 0 && (obj.track = message.track ? TrackInfo.toJSON(message.track) : void 0);\n    return obj;\n  },\n  create(base) {\n    return TrackPublishedResponse.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseTrackPublishedResponse();\n    message.cid = (_a = object.cid) !== null && _a !== void 0 ? _a : \"\";\n    message.track = object.track !== void 0 && object.track !== null ? TrackInfo.fromPartial(object.track) : void 0;\n    return message;\n  }\n};\nfunction createBaseTrackUnpublishedResponse() {\n  return {\n    trackSid: \"\"\n  };\n}\nvar TrackUnpublishedResponse = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.trackSid !== \"\") {\n      writer2.uint32(10).string(message.trackSid);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseTrackUnpublishedResponse();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.trackSid = reader2.string();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      trackSid: isSet(object.trackSid) ? String(object.trackSid) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.trackSid !== void 0 && (obj.trackSid = message.trackSid);\n    return obj;\n  },\n  create(base) {\n    return TrackUnpublishedResponse.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseTrackUnpublishedResponse();\n    message.trackSid = (_a = object.trackSid) !== null && _a !== void 0 ? _a : \"\";\n    return message;\n  }\n};\nfunction createBaseSessionDescription() {\n  return {\n    type: \"\",\n    sdp: \"\"\n  };\n}\nvar SessionDescription = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.type !== \"\") {\n      writer2.uint32(10).string(message.type);\n    }\n    if (message.sdp !== \"\") {\n      writer2.uint32(18).string(message.sdp);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseSessionDescription();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.type = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.sdp = reader2.string();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      type: isSet(object.type) ? String(object.type) : \"\",\n      sdp: isSet(object.sdp) ? String(object.sdp) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.type !== void 0 && (obj.type = message.type);\n    message.sdp !== void 0 && (obj.sdp = message.sdp);\n    return obj;\n  },\n  create(base) {\n    return SessionDescription.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseSessionDescription();\n    message.type = (_a = object.type) !== null && _a !== void 0 ? _a : \"\";\n    message.sdp = (_b = object.sdp) !== null && _b !== void 0 ? _b : \"\";\n    return message;\n  }\n};\nfunction createBaseParticipantUpdate() {\n  return {\n    participants: []\n  };\n}\nvar ParticipantUpdate = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    for (const v of message.participants) {\n      ParticipantInfo.encode(v, writer2.uint32(10).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseParticipantUpdate();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.participants.push(ParticipantInfo.decode(reader2, reader2.uint32()));\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      participants: Array.isArray(object === null || object === void 0 ? void 0 : object.participants) ? object.participants.map((e) => ParticipantInfo.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.participants) {\n      obj.participants = message.participants.map((e) => e ? ParticipantInfo.toJSON(e) : void 0);\n    } else {\n      obj.participants = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return ParticipantUpdate.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseParticipantUpdate();\n    message.participants = ((_a = object.participants) === null || _a === void 0 ? void 0 : _a.map((e) => ParticipantInfo.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseUpdateSubscription() {\n  return {\n    trackSids: [],\n    subscribe: false,\n    participantTracks: []\n  };\n}\nvar UpdateSubscription = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    for (const v of message.trackSids) {\n      writer2.uint32(10).string(v);\n    }\n    if (message.subscribe === true) {\n      writer2.uint32(16).bool(message.subscribe);\n    }\n    for (const v of message.participantTracks) {\n      ParticipantTracks.encode(v, writer2.uint32(26).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseUpdateSubscription();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.trackSids.push(reader2.string());\n          continue;\n        case 2:\n          if (tag != 16) {\n            break;\n          }\n          message.subscribe = reader2.bool();\n          continue;\n        case 3:\n          if (tag != 26) {\n            break;\n          }\n          message.participantTracks.push(ParticipantTracks.decode(reader2, reader2.uint32()));\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      trackSids: Array.isArray(object === null || object === void 0 ? void 0 : object.trackSids) ? object.trackSids.map((e) => String(e)) : [],\n      subscribe: isSet(object.subscribe) ? Boolean(object.subscribe) : false,\n      participantTracks: Array.isArray(object === null || object === void 0 ? void 0 : object.participantTracks) ? object.participantTracks.map((e) => ParticipantTracks.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.trackSids) {\n      obj.trackSids = message.trackSids.map((e) => e);\n    } else {\n      obj.trackSids = [];\n    }\n    message.subscribe !== void 0 && (obj.subscribe = message.subscribe);\n    if (message.participantTracks) {\n      obj.participantTracks = message.participantTracks.map((e) => e ? ParticipantTracks.toJSON(e) : void 0);\n    } else {\n      obj.participantTracks = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return UpdateSubscription.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseUpdateSubscription();\n    message.trackSids = ((_a = object.trackSids) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n    message.subscribe = (_b = object.subscribe) !== null && _b !== void 0 ? _b : false;\n    message.participantTracks = ((_c = object.participantTracks) === null || _c === void 0 ? void 0 : _c.map((e) => ParticipantTracks.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseUpdateTrackSettings() {\n  return {\n    trackSids: [],\n    disabled: false,\n    quality: 0,\n    width: 0,\n    height: 0,\n    fps: 0,\n    priority: 0\n  };\n}\nvar UpdateTrackSettings = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    for (const v of message.trackSids) {\n      writer2.uint32(10).string(v);\n    }\n    if (message.disabled === true) {\n      writer2.uint32(24).bool(message.disabled);\n    }\n    if (message.quality !== 0) {\n      writer2.uint32(32).int32(message.quality);\n    }\n    if (message.width !== 0) {\n      writer2.uint32(40).uint32(message.width);\n    }\n    if (message.height !== 0) {\n      writer2.uint32(48).uint32(message.height);\n    }\n    if (message.fps !== 0) {\n      writer2.uint32(56).uint32(message.fps);\n    }\n    if (message.priority !== 0) {\n      writer2.uint32(64).uint32(message.priority);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseUpdateTrackSettings();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.trackSids.push(reader2.string());\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.disabled = reader2.bool();\n          continue;\n        case 4:\n          if (tag != 32) {\n            break;\n          }\n          message.quality = reader2.int32();\n          continue;\n        case 5:\n          if (tag != 40) {\n            break;\n          }\n          message.width = reader2.uint32();\n          continue;\n        case 6:\n          if (tag != 48) {\n            break;\n          }\n          message.height = reader2.uint32();\n          continue;\n        case 7:\n          if (tag != 56) {\n            break;\n          }\n          message.fps = reader2.uint32();\n          continue;\n        case 8:\n          if (tag != 64) {\n            break;\n          }\n          message.priority = reader2.uint32();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      trackSids: Array.isArray(object === null || object === void 0 ? void 0 : object.trackSids) ? object.trackSids.map((e) => String(e)) : [],\n      disabled: isSet(object.disabled) ? Boolean(object.disabled) : false,\n      quality: isSet(object.quality) ? videoQualityFromJSON(object.quality) : 0,\n      width: isSet(object.width) ? Number(object.width) : 0,\n      height: isSet(object.height) ? Number(object.height) : 0,\n      fps: isSet(object.fps) ? Number(object.fps) : 0,\n      priority: isSet(object.priority) ? Number(object.priority) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.trackSids) {\n      obj.trackSids = message.trackSids.map((e) => e);\n    } else {\n      obj.trackSids = [];\n    }\n    message.disabled !== void 0 && (obj.disabled = message.disabled);\n    message.quality !== void 0 && (obj.quality = videoQualityToJSON(message.quality));\n    message.width !== void 0 && (obj.width = Math.round(message.width));\n    message.height !== void 0 && (obj.height = Math.round(message.height));\n    message.fps !== void 0 && (obj.fps = Math.round(message.fps));\n    message.priority !== void 0 && (obj.priority = Math.round(message.priority));\n    return obj;\n  },\n  create(base) {\n    return UpdateTrackSettings.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const message = createBaseUpdateTrackSettings();\n    message.trackSids = ((_a = object.trackSids) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n    message.disabled = (_b = object.disabled) !== null && _b !== void 0 ? _b : false;\n    message.quality = (_c = object.quality) !== null && _c !== void 0 ? _c : 0;\n    message.width = (_d = object.width) !== null && _d !== void 0 ? _d : 0;\n    message.height = (_e = object.height) !== null && _e !== void 0 ? _e : 0;\n    message.fps = (_f = object.fps) !== null && _f !== void 0 ? _f : 0;\n    message.priority = (_g = object.priority) !== null && _g !== void 0 ? _g : 0;\n    return message;\n  }\n};\nfunction createBaseLeaveRequest() {\n  return {\n    canReconnect: false,\n    reason: 0\n  };\n}\nvar LeaveRequest = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.canReconnect === true) {\n      writer2.uint32(8).bool(message.canReconnect);\n    }\n    if (message.reason !== 0) {\n      writer2.uint32(16).int32(message.reason);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseLeaveRequest();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 8) {\n            break;\n          }\n          message.canReconnect = reader2.bool();\n          continue;\n        case 2:\n          if (tag != 16) {\n            break;\n          }\n          message.reason = reader2.int32();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      canReconnect: isSet(object.canReconnect) ? Boolean(object.canReconnect) : false,\n      reason: isSet(object.reason) ? disconnectReasonFromJSON(object.reason) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.canReconnect !== void 0 && (obj.canReconnect = message.canReconnect);\n    message.reason !== void 0 && (obj.reason = disconnectReasonToJSON(message.reason));\n    return obj;\n  },\n  create(base) {\n    return LeaveRequest.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseLeaveRequest();\n    message.canReconnect = (_a = object.canReconnect) !== null && _a !== void 0 ? _a : false;\n    message.reason = (_b = object.reason) !== null && _b !== void 0 ? _b : 0;\n    return message;\n  }\n};\nfunction createBaseUpdateVideoLayers() {\n  return {\n    trackSid: \"\",\n    layers: []\n  };\n}\nvar UpdateVideoLayers = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.trackSid !== \"\") {\n      writer2.uint32(10).string(message.trackSid);\n    }\n    for (const v of message.layers) {\n      VideoLayer.encode(v, writer2.uint32(18).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseUpdateVideoLayers();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.trackSid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.layers.push(VideoLayer.decode(reader2, reader2.uint32()));\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      trackSid: isSet(object.trackSid) ? String(object.trackSid) : \"\",\n      layers: Array.isArray(object === null || object === void 0 ? void 0 : object.layers) ? object.layers.map((e) => VideoLayer.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.trackSid !== void 0 && (obj.trackSid = message.trackSid);\n    if (message.layers) {\n      obj.layers = message.layers.map((e) => e ? VideoLayer.toJSON(e) : void 0);\n    } else {\n      obj.layers = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return UpdateVideoLayers.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseUpdateVideoLayers();\n    message.trackSid = (_a = object.trackSid) !== null && _a !== void 0 ? _a : \"\";\n    message.layers = ((_b = object.layers) === null || _b === void 0 ? void 0 : _b.map((e) => VideoLayer.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseUpdateParticipantMetadata() {\n  return {\n    metadata: \"\",\n    name: \"\"\n  };\n}\nvar UpdateParticipantMetadata = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.metadata !== \"\") {\n      writer2.uint32(10).string(message.metadata);\n    }\n    if (message.name !== \"\") {\n      writer2.uint32(18).string(message.name);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseUpdateParticipantMetadata();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.metadata = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.name = reader2.string();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      metadata: isSet(object.metadata) ? String(object.metadata) : \"\",\n      name: isSet(object.name) ? String(object.name) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.metadata !== void 0 && (obj.metadata = message.metadata);\n    message.name !== void 0 && (obj.name = message.name);\n    return obj;\n  },\n  create(base) {\n    return UpdateParticipantMetadata.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseUpdateParticipantMetadata();\n    message.metadata = (_a = object.metadata) !== null && _a !== void 0 ? _a : \"\";\n    message.name = (_b = object.name) !== null && _b !== void 0 ? _b : \"\";\n    return message;\n  }\n};\nfunction createBaseICEServer() {\n  return {\n    urls: [],\n    username: \"\",\n    credential: \"\"\n  };\n}\nvar ICEServer = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    for (const v of message.urls) {\n      writer2.uint32(10).string(v);\n    }\n    if (message.username !== \"\") {\n      writer2.uint32(18).string(message.username);\n    }\n    if (message.credential !== \"\") {\n      writer2.uint32(26).string(message.credential);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseICEServer();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.urls.push(reader2.string());\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.username = reader2.string();\n          continue;\n        case 3:\n          if (tag != 26) {\n            break;\n          }\n          message.credential = reader2.string();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      urls: Array.isArray(object === null || object === void 0 ? void 0 : object.urls) ? object.urls.map((e) => String(e)) : [],\n      username: isSet(object.username) ? String(object.username) : \"\",\n      credential: isSet(object.credential) ? String(object.credential) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.urls) {\n      obj.urls = message.urls.map((e) => e);\n    } else {\n      obj.urls = [];\n    }\n    message.username !== void 0 && (obj.username = message.username);\n    message.credential !== void 0 && (obj.credential = message.credential);\n    return obj;\n  },\n  create(base) {\n    return ICEServer.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseICEServer();\n    message.urls = ((_a = object.urls) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n    message.username = (_b = object.username) !== null && _b !== void 0 ? _b : \"\";\n    message.credential = (_c = object.credential) !== null && _c !== void 0 ? _c : \"\";\n    return message;\n  }\n};\nfunction createBaseSpeakersChanged() {\n  return {\n    speakers: []\n  };\n}\nvar SpeakersChanged = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    for (const v of message.speakers) {\n      SpeakerInfo.encode(v, writer2.uint32(10).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseSpeakersChanged();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.speakers.push(SpeakerInfo.decode(reader2, reader2.uint32()));\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      speakers: Array.isArray(object === null || object === void 0 ? void 0 : object.speakers) ? object.speakers.map((e) => SpeakerInfo.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.speakers) {\n      obj.speakers = message.speakers.map((e) => e ? SpeakerInfo.toJSON(e) : void 0);\n    } else {\n      obj.speakers = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return SpeakersChanged.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseSpeakersChanged();\n    message.speakers = ((_a = object.speakers) === null || _a === void 0 ? void 0 : _a.map((e) => SpeakerInfo.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseRoomUpdate() {\n  return {\n    room: void 0\n  };\n}\nvar RoomUpdate = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.room !== void 0) {\n      Room$1.encode(message.room, writer2.uint32(10).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseRoomUpdate();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.room = Room$1.decode(reader2, reader2.uint32());\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      room: isSet(object.room) ? Room$1.fromJSON(object.room) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.room !== void 0 && (obj.room = message.room ? Room$1.toJSON(message.room) : void 0);\n    return obj;\n  },\n  create(base) {\n    return RoomUpdate.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    const message = createBaseRoomUpdate();\n    message.room = object.room !== void 0 && object.room !== null ? Room$1.fromPartial(object.room) : void 0;\n    return message;\n  }\n};\nfunction createBaseConnectionQualityInfo() {\n  return {\n    participantSid: \"\",\n    quality: 0,\n    score: 0\n  };\n}\nvar ConnectionQualityInfo = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.participantSid !== \"\") {\n      writer2.uint32(10).string(message.participantSid);\n    }\n    if (message.quality !== 0) {\n      writer2.uint32(16).int32(message.quality);\n    }\n    if (message.score !== 0) {\n      writer2.uint32(29).float(message.score);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseConnectionQualityInfo();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.participantSid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 16) {\n            break;\n          }\n          message.quality = reader2.int32();\n          continue;\n        case 3:\n          if (tag != 29) {\n            break;\n          }\n          message.score = reader2.float();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      participantSid: isSet(object.participantSid) ? String(object.participantSid) : \"\",\n      quality: isSet(object.quality) ? connectionQualityFromJSON(object.quality) : 0,\n      score: isSet(object.score) ? Number(object.score) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.participantSid !== void 0 && (obj.participantSid = message.participantSid);\n    message.quality !== void 0 && (obj.quality = connectionQualityToJSON(message.quality));\n    message.score !== void 0 && (obj.score = message.score);\n    return obj;\n  },\n  create(base) {\n    return ConnectionQualityInfo.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseConnectionQualityInfo();\n    message.participantSid = (_a = object.participantSid) !== null && _a !== void 0 ? _a : \"\";\n    message.quality = (_b = object.quality) !== null && _b !== void 0 ? _b : 0;\n    message.score = (_c = object.score) !== null && _c !== void 0 ? _c : 0;\n    return message;\n  }\n};\nfunction createBaseConnectionQualityUpdate() {\n  return {\n    updates: []\n  };\n}\nvar ConnectionQualityUpdate = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    for (const v of message.updates) {\n      ConnectionQualityInfo.encode(v, writer2.uint32(10).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseConnectionQualityUpdate();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.updates.push(ConnectionQualityInfo.decode(reader2, reader2.uint32()));\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      updates: Array.isArray(object === null || object === void 0 ? void 0 : object.updates) ? object.updates.map((e) => ConnectionQualityInfo.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.updates) {\n      obj.updates = message.updates.map((e) => e ? ConnectionQualityInfo.toJSON(e) : void 0);\n    } else {\n      obj.updates = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return ConnectionQualityUpdate.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseConnectionQualityUpdate();\n    message.updates = ((_a = object.updates) === null || _a === void 0 ? void 0 : _a.map((e) => ConnectionQualityInfo.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseStreamStateInfo() {\n  return {\n    participantSid: \"\",\n    trackSid: \"\",\n    state: 0\n  };\n}\nvar StreamStateInfo = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.participantSid !== \"\") {\n      writer2.uint32(10).string(message.participantSid);\n    }\n    if (message.trackSid !== \"\") {\n      writer2.uint32(18).string(message.trackSid);\n    }\n    if (message.state !== 0) {\n      writer2.uint32(24).int32(message.state);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseStreamStateInfo();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.participantSid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.trackSid = reader2.string();\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.state = reader2.int32();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      participantSid: isSet(object.participantSid) ? String(object.participantSid) : \"\",\n      trackSid: isSet(object.trackSid) ? String(object.trackSid) : \"\",\n      state: isSet(object.state) ? streamStateFromJSON(object.state) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.participantSid !== void 0 && (obj.participantSid = message.participantSid);\n    message.trackSid !== void 0 && (obj.trackSid = message.trackSid);\n    message.state !== void 0 && (obj.state = streamStateToJSON(message.state));\n    return obj;\n  },\n  create(base) {\n    return StreamStateInfo.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseStreamStateInfo();\n    message.participantSid = (_a = object.participantSid) !== null && _a !== void 0 ? _a : \"\";\n    message.trackSid = (_b = object.trackSid) !== null && _b !== void 0 ? _b : \"\";\n    message.state = (_c = object.state) !== null && _c !== void 0 ? _c : 0;\n    return message;\n  }\n};\nfunction createBaseStreamStateUpdate() {\n  return {\n    streamStates: []\n  };\n}\nvar StreamStateUpdate = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    for (const v of message.streamStates) {\n      StreamStateInfo.encode(v, writer2.uint32(10).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseStreamStateUpdate();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.streamStates.push(StreamStateInfo.decode(reader2, reader2.uint32()));\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      streamStates: Array.isArray(object === null || object === void 0 ? void 0 : object.streamStates) ? object.streamStates.map((e) => StreamStateInfo.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.streamStates) {\n      obj.streamStates = message.streamStates.map((e) => e ? StreamStateInfo.toJSON(e) : void 0);\n    } else {\n      obj.streamStates = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return StreamStateUpdate.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseStreamStateUpdate();\n    message.streamStates = ((_a = object.streamStates) === null || _a === void 0 ? void 0 : _a.map((e) => StreamStateInfo.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseSubscribedQuality() {\n  return {\n    quality: 0,\n    enabled: false\n  };\n}\nvar SubscribedQuality = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.quality !== 0) {\n      writer2.uint32(8).int32(message.quality);\n    }\n    if (message.enabled === true) {\n      writer2.uint32(16).bool(message.enabled);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseSubscribedQuality();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 8) {\n            break;\n          }\n          message.quality = reader2.int32();\n          continue;\n        case 2:\n          if (tag != 16) {\n            break;\n          }\n          message.enabled = reader2.bool();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      quality: isSet(object.quality) ? videoQualityFromJSON(object.quality) : 0,\n      enabled: isSet(object.enabled) ? Boolean(object.enabled) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.quality !== void 0 && (obj.quality = videoQualityToJSON(message.quality));\n    message.enabled !== void 0 && (obj.enabled = message.enabled);\n    return obj;\n  },\n  create(base) {\n    return SubscribedQuality.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseSubscribedQuality();\n    message.quality = (_a = object.quality) !== null && _a !== void 0 ? _a : 0;\n    message.enabled = (_b = object.enabled) !== null && _b !== void 0 ? _b : false;\n    return message;\n  }\n};\nfunction createBaseSubscribedCodec() {\n  return {\n    codec: \"\",\n    qualities: []\n  };\n}\nvar SubscribedCodec = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.codec !== \"\") {\n      writer2.uint32(10).string(message.codec);\n    }\n    for (const v of message.qualities) {\n      SubscribedQuality.encode(v, writer2.uint32(18).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseSubscribedCodec();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.codec = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.qualities.push(SubscribedQuality.decode(reader2, reader2.uint32()));\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      codec: isSet(object.codec) ? String(object.codec) : \"\",\n      qualities: Array.isArray(object === null || object === void 0 ? void 0 : object.qualities) ? object.qualities.map((e) => SubscribedQuality.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.codec !== void 0 && (obj.codec = message.codec);\n    if (message.qualities) {\n      obj.qualities = message.qualities.map((e) => e ? SubscribedQuality.toJSON(e) : void 0);\n    } else {\n      obj.qualities = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return SubscribedCodec.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseSubscribedCodec();\n    message.codec = (_a = object.codec) !== null && _a !== void 0 ? _a : \"\";\n    message.qualities = ((_b = object.qualities) === null || _b === void 0 ? void 0 : _b.map((e) => SubscribedQuality.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseSubscribedQualityUpdate() {\n  return {\n    trackSid: \"\",\n    subscribedQualities: [],\n    subscribedCodecs: []\n  };\n}\nvar SubscribedQualityUpdate = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.trackSid !== \"\") {\n      writer2.uint32(10).string(message.trackSid);\n    }\n    for (const v of message.subscribedQualities) {\n      SubscribedQuality.encode(v, writer2.uint32(18).fork()).ldelim();\n    }\n    for (const v of message.subscribedCodecs) {\n      SubscribedCodec.encode(v, writer2.uint32(26).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseSubscribedQualityUpdate();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.trackSid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.subscribedQualities.push(SubscribedQuality.decode(reader2, reader2.uint32()));\n          continue;\n        case 3:\n          if (tag != 26) {\n            break;\n          }\n          message.subscribedCodecs.push(SubscribedCodec.decode(reader2, reader2.uint32()));\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      trackSid: isSet(object.trackSid) ? String(object.trackSid) : \"\",\n      subscribedQualities: Array.isArray(object === null || object === void 0 ? void 0 : object.subscribedQualities) ? object.subscribedQualities.map((e) => SubscribedQuality.fromJSON(e)) : [],\n      subscribedCodecs: Array.isArray(object === null || object === void 0 ? void 0 : object.subscribedCodecs) ? object.subscribedCodecs.map((e) => SubscribedCodec.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.trackSid !== void 0 && (obj.trackSid = message.trackSid);\n    if (message.subscribedQualities) {\n      obj.subscribedQualities = message.subscribedQualities.map((e) => e ? SubscribedQuality.toJSON(e) : void 0);\n    } else {\n      obj.subscribedQualities = [];\n    }\n    if (message.subscribedCodecs) {\n      obj.subscribedCodecs = message.subscribedCodecs.map((e) => e ? SubscribedCodec.toJSON(e) : void 0);\n    } else {\n      obj.subscribedCodecs = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return SubscribedQualityUpdate.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseSubscribedQualityUpdate();\n    message.trackSid = (_a = object.trackSid) !== null && _a !== void 0 ? _a : \"\";\n    message.subscribedQualities = ((_b = object.subscribedQualities) === null || _b === void 0 ? void 0 : _b.map((e) => SubscribedQuality.fromPartial(e))) || [];\n    message.subscribedCodecs = ((_c = object.subscribedCodecs) === null || _c === void 0 ? void 0 : _c.map((e) => SubscribedCodec.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseTrackPermission() {\n  return {\n    participantSid: \"\",\n    allTracks: false,\n    trackSids: [],\n    participantIdentity: \"\"\n  };\n}\nvar TrackPermission = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.participantSid !== \"\") {\n      writer2.uint32(10).string(message.participantSid);\n    }\n    if (message.allTracks === true) {\n      writer2.uint32(16).bool(message.allTracks);\n    }\n    for (const v of message.trackSids) {\n      writer2.uint32(26).string(v);\n    }\n    if (message.participantIdentity !== \"\") {\n      writer2.uint32(34).string(message.participantIdentity);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseTrackPermission();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.participantSid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 16) {\n            break;\n          }\n          message.allTracks = reader2.bool();\n          continue;\n        case 3:\n          if (tag != 26) {\n            break;\n          }\n          message.trackSids.push(reader2.string());\n          continue;\n        case 4:\n          if (tag != 34) {\n            break;\n          }\n          message.participantIdentity = reader2.string();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      participantSid: isSet(object.participantSid) ? String(object.participantSid) : \"\",\n      allTracks: isSet(object.allTracks) ? Boolean(object.allTracks) : false,\n      trackSids: Array.isArray(object === null || object === void 0 ? void 0 : object.trackSids) ? object.trackSids.map((e) => String(e)) : [],\n      participantIdentity: isSet(object.participantIdentity) ? String(object.participantIdentity) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.participantSid !== void 0 && (obj.participantSid = message.participantSid);\n    message.allTracks !== void 0 && (obj.allTracks = message.allTracks);\n    if (message.trackSids) {\n      obj.trackSids = message.trackSids.map((e) => e);\n    } else {\n      obj.trackSids = [];\n    }\n    message.participantIdentity !== void 0 && (obj.participantIdentity = message.participantIdentity);\n    return obj;\n  },\n  create(base) {\n    return TrackPermission.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseTrackPermission();\n    message.participantSid = (_a = object.participantSid) !== null && _a !== void 0 ? _a : \"\";\n    message.allTracks = (_b = object.allTracks) !== null && _b !== void 0 ? _b : false;\n    message.trackSids = ((_c = object.trackSids) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];\n    message.participantIdentity = (_d = object.participantIdentity) !== null && _d !== void 0 ? _d : \"\";\n    return message;\n  }\n};\nfunction createBaseSubscriptionPermission() {\n  return {\n    allParticipants: false,\n    trackPermissions: []\n  };\n}\nvar SubscriptionPermission = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.allParticipants === true) {\n      writer2.uint32(8).bool(message.allParticipants);\n    }\n    for (const v of message.trackPermissions) {\n      TrackPermission.encode(v, writer2.uint32(18).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseSubscriptionPermission();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 8) {\n            break;\n          }\n          message.allParticipants = reader2.bool();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.trackPermissions.push(TrackPermission.decode(reader2, reader2.uint32()));\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      allParticipants: isSet(object.allParticipants) ? Boolean(object.allParticipants) : false,\n      trackPermissions: Array.isArray(object === null || object === void 0 ? void 0 : object.trackPermissions) ? object.trackPermissions.map((e) => TrackPermission.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.allParticipants !== void 0 && (obj.allParticipants = message.allParticipants);\n    if (message.trackPermissions) {\n      obj.trackPermissions = message.trackPermissions.map((e) => e ? TrackPermission.toJSON(e) : void 0);\n    } else {\n      obj.trackPermissions = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return SubscriptionPermission.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseSubscriptionPermission();\n    message.allParticipants = (_a = object.allParticipants) !== null && _a !== void 0 ? _a : false;\n    message.trackPermissions = ((_b = object.trackPermissions) === null || _b === void 0 ? void 0 : _b.map((e) => TrackPermission.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseSubscriptionPermissionUpdate() {\n  return {\n    participantSid: \"\",\n    trackSid: \"\",\n    allowed: false\n  };\n}\nvar SubscriptionPermissionUpdate = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.participantSid !== \"\") {\n      writer2.uint32(10).string(message.participantSid);\n    }\n    if (message.trackSid !== \"\") {\n      writer2.uint32(18).string(message.trackSid);\n    }\n    if (message.allowed === true) {\n      writer2.uint32(24).bool(message.allowed);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseSubscriptionPermissionUpdate();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.participantSid = reader2.string();\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.trackSid = reader2.string();\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.allowed = reader2.bool();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      participantSid: isSet(object.participantSid) ? String(object.participantSid) : \"\",\n      trackSid: isSet(object.trackSid) ? String(object.trackSid) : \"\",\n      allowed: isSet(object.allowed) ? Boolean(object.allowed) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.participantSid !== void 0 && (obj.participantSid = message.participantSid);\n    message.trackSid !== void 0 && (obj.trackSid = message.trackSid);\n    message.allowed !== void 0 && (obj.allowed = message.allowed);\n    return obj;\n  },\n  create(base) {\n    return SubscriptionPermissionUpdate.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseSubscriptionPermissionUpdate();\n    message.participantSid = (_a = object.participantSid) !== null && _a !== void 0 ? _a : \"\";\n    message.trackSid = (_b = object.trackSid) !== null && _b !== void 0 ? _b : \"\";\n    message.allowed = (_c = object.allowed) !== null && _c !== void 0 ? _c : false;\n    return message;\n  }\n};\nfunction createBaseSyncState() {\n  return {\n    answer: void 0,\n    subscription: void 0,\n    publishTracks: [],\n    dataChannels: [],\n    offer: void 0\n  };\n}\nvar SyncState = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.answer !== void 0) {\n      SessionDescription.encode(message.answer, writer2.uint32(10).fork()).ldelim();\n    }\n    if (message.subscription !== void 0) {\n      UpdateSubscription.encode(message.subscription, writer2.uint32(18).fork()).ldelim();\n    }\n    for (const v of message.publishTracks) {\n      TrackPublishedResponse.encode(v, writer2.uint32(26).fork()).ldelim();\n    }\n    for (const v of message.dataChannels) {\n      DataChannelInfo.encode(v, writer2.uint32(34).fork()).ldelim();\n    }\n    if (message.offer !== void 0) {\n      SessionDescription.encode(message.offer, writer2.uint32(42).fork()).ldelim();\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseSyncState();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.answer = SessionDescription.decode(reader2, reader2.uint32());\n          continue;\n        case 2:\n          if (tag != 18) {\n            break;\n          }\n          message.subscription = UpdateSubscription.decode(reader2, reader2.uint32());\n          continue;\n        case 3:\n          if (tag != 26) {\n            break;\n          }\n          message.publishTracks.push(TrackPublishedResponse.decode(reader2, reader2.uint32()));\n          continue;\n        case 4:\n          if (tag != 34) {\n            break;\n          }\n          message.dataChannels.push(DataChannelInfo.decode(reader2, reader2.uint32()));\n          continue;\n        case 5:\n          if (tag != 42) {\n            break;\n          }\n          message.offer = SessionDescription.decode(reader2, reader2.uint32());\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      answer: isSet(object.answer) ? SessionDescription.fromJSON(object.answer) : void 0,\n      subscription: isSet(object.subscription) ? UpdateSubscription.fromJSON(object.subscription) : void 0,\n      publishTracks: Array.isArray(object === null || object === void 0 ? void 0 : object.publishTracks) ? object.publishTracks.map((e) => TrackPublishedResponse.fromJSON(e)) : [],\n      dataChannels: Array.isArray(object === null || object === void 0 ? void 0 : object.dataChannels) ? object.dataChannels.map((e) => DataChannelInfo.fromJSON(e)) : [],\n      offer: isSet(object.offer) ? SessionDescription.fromJSON(object.offer) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.answer !== void 0 && (obj.answer = message.answer ? SessionDescription.toJSON(message.answer) : void 0);\n    message.subscription !== void 0 && (obj.subscription = message.subscription ? UpdateSubscription.toJSON(message.subscription) : void 0);\n    if (message.publishTracks) {\n      obj.publishTracks = message.publishTracks.map((e) => e ? TrackPublishedResponse.toJSON(e) : void 0);\n    } else {\n      obj.publishTracks = [];\n    }\n    if (message.dataChannels) {\n      obj.dataChannels = message.dataChannels.map((e) => e ? DataChannelInfo.toJSON(e) : void 0);\n    } else {\n      obj.dataChannels = [];\n    }\n    message.offer !== void 0 && (obj.offer = message.offer ? SessionDescription.toJSON(message.offer) : void 0);\n    return obj;\n  },\n  create(base) {\n    return SyncState.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseSyncState();\n    message.answer = object.answer !== void 0 && object.answer !== null ? SessionDescription.fromPartial(object.answer) : void 0;\n    message.subscription = object.subscription !== void 0 && object.subscription !== null ? UpdateSubscription.fromPartial(object.subscription) : void 0;\n    message.publishTracks = ((_a = object.publishTracks) === null || _a === void 0 ? void 0 : _a.map((e) => TrackPublishedResponse.fromPartial(e))) || [];\n    message.dataChannels = ((_b = object.dataChannels) === null || _b === void 0 ? void 0 : _b.map((e) => DataChannelInfo.fromPartial(e))) || [];\n    message.offer = object.offer !== void 0 && object.offer !== null ? SessionDescription.fromPartial(object.offer) : void 0;\n    return message;\n  }\n};\nfunction createBaseDataChannelInfo() {\n  return {\n    label: \"\",\n    id: 0,\n    target: 0\n  };\n}\nvar DataChannelInfo = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.label !== \"\") {\n      writer2.uint32(10).string(message.label);\n    }\n    if (message.id !== 0) {\n      writer2.uint32(16).uint32(message.id);\n    }\n    if (message.target !== 0) {\n      writer2.uint32(24).int32(message.target);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseDataChannelInfo();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 10) {\n            break;\n          }\n          message.label = reader2.string();\n          continue;\n        case 2:\n          if (tag != 16) {\n            break;\n          }\n          message.id = reader2.uint32();\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.target = reader2.int32();\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      label: isSet(object.label) ? String(object.label) : \"\",\n      id: isSet(object.id) ? Number(object.id) : 0,\n      target: isSet(object.target) ? signalTargetFromJSON(object.target) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.label !== void 0 && (obj.label = message.label);\n    message.id !== void 0 && (obj.id = Math.round(message.id));\n    message.target !== void 0 && (obj.target = signalTargetToJSON(message.target));\n    return obj;\n  },\n  create(base) {\n    return DataChannelInfo.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseDataChannelInfo();\n    message.label = (_a = object.label) !== null && _a !== void 0 ? _a : \"\";\n    message.id = (_b = object.id) !== null && _b !== void 0 ? _b : 0;\n    message.target = (_c = object.target) !== null && _c !== void 0 ? _c : 0;\n    return message;\n  }\n};\nfunction createBaseSimulateScenario() {\n  return {\n    scenario: void 0\n  };\n}\nvar SimulateScenario = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    var _a;\n    switch ((_a = message.scenario) === null || _a === void 0 ? void 0 : _a.$case) {\n      case \"speakerUpdate\":\n        writer2.uint32(8).int32(message.scenario.speakerUpdate);\n        break;\n      case \"nodeFailure\":\n        writer2.uint32(16).bool(message.scenario.nodeFailure);\n        break;\n      case \"migration\":\n        writer2.uint32(24).bool(message.scenario.migration);\n        break;\n      case \"serverLeave\":\n        writer2.uint32(32).bool(message.scenario.serverLeave);\n        break;\n      case \"switchCandidateProtocol\":\n        writer2.uint32(40).int32(message.scenario.switchCandidateProtocol);\n        break;\n      case \"subscriberBandwidth\":\n        writer2.uint32(48).int64(message.scenario.subscriberBandwidth);\n        break;\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBaseSimulateScenario();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 8) {\n            break;\n          }\n          message.scenario = {\n            $case: \"speakerUpdate\",\n            speakerUpdate: reader2.int32()\n          };\n          continue;\n        case 2:\n          if (tag != 16) {\n            break;\n          }\n          message.scenario = {\n            $case: \"nodeFailure\",\n            nodeFailure: reader2.bool()\n          };\n          continue;\n        case 3:\n          if (tag != 24) {\n            break;\n          }\n          message.scenario = {\n            $case: \"migration\",\n            migration: reader2.bool()\n          };\n          continue;\n        case 4:\n          if (tag != 32) {\n            break;\n          }\n          message.scenario = {\n            $case: \"serverLeave\",\n            serverLeave: reader2.bool()\n          };\n          continue;\n        case 5:\n          if (tag != 40) {\n            break;\n          }\n          message.scenario = {\n            $case: \"switchCandidateProtocol\",\n            switchCandidateProtocol: reader2.int32()\n          };\n          continue;\n        case 6:\n          if (tag != 48) {\n            break;\n          }\n          message.scenario = {\n            $case: \"subscriberBandwidth\",\n            subscriberBandwidth: longToNumber(reader2.int64())\n          };\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      scenario: isSet(object.speakerUpdate) ? {\n        $case: \"speakerUpdate\",\n        speakerUpdate: Number(object.speakerUpdate)\n      } : isSet(object.nodeFailure) ? {\n        $case: \"nodeFailure\",\n        nodeFailure: Boolean(object.nodeFailure)\n      } : isSet(object.migration) ? {\n        $case: \"migration\",\n        migration: Boolean(object.migration)\n      } : isSet(object.serverLeave) ? {\n        $case: \"serverLeave\",\n        serverLeave: Boolean(object.serverLeave)\n      } : isSet(object.switchCandidateProtocol) ? {\n        $case: \"switchCandidateProtocol\",\n        switchCandidateProtocol: candidateProtocolFromJSON(object.switchCandidateProtocol)\n      } : isSet(object.subscriberBandwidth) ? {\n        $case: \"subscriberBandwidth\",\n        subscriberBandwidth: Number(object.subscriberBandwidth)\n      } : void 0\n    };\n  },\n  toJSON(message) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;\n    const obj = {};\n    ((_a = message.scenario) === null || _a === void 0 ? void 0 : _a.$case) === \"speakerUpdate\" && (obj.speakerUpdate = Math.round((_b = message.scenario) === null || _b === void 0 ? void 0 : _b.speakerUpdate));\n    ((_c = message.scenario) === null || _c === void 0 ? void 0 : _c.$case) === \"nodeFailure\" && (obj.nodeFailure = (_d = message.scenario) === null || _d === void 0 ? void 0 : _d.nodeFailure);\n    ((_e = message.scenario) === null || _e === void 0 ? void 0 : _e.$case) === \"migration\" && (obj.migration = (_f = message.scenario) === null || _f === void 0 ? void 0 : _f.migration);\n    ((_g = message.scenario) === null || _g === void 0 ? void 0 : _g.$case) === \"serverLeave\" && (obj.serverLeave = (_h = message.scenario) === null || _h === void 0 ? void 0 : _h.serverLeave);\n    ((_j = message.scenario) === null || _j === void 0 ? void 0 : _j.$case) === \"switchCandidateProtocol\" && (obj.switchCandidateProtocol = ((_k = message.scenario) === null || _k === void 0 ? void 0 : _k.switchCandidateProtocol) !== void 0 ? candidateProtocolToJSON((_l = message.scenario) === null || _l === void 0 ? void 0 : _l.switchCandidateProtocol) : void 0);\n    ((_m = message.scenario) === null || _m === void 0 ? void 0 : _m.$case) === \"subscriberBandwidth\" && (obj.subscriberBandwidth = Math.round((_o = message.scenario) === null || _o === void 0 ? void 0 : _o.subscriberBandwidth));\n    return obj;\n  },\n  create(base) {\n    return SimulateScenario.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;\n    const message = createBaseSimulateScenario();\n    if (((_a = object.scenario) === null || _a === void 0 ? void 0 : _a.$case) === \"speakerUpdate\" && ((_b = object.scenario) === null || _b === void 0 ? void 0 : _b.speakerUpdate) !== void 0 && ((_c = object.scenario) === null || _c === void 0 ? void 0 : _c.speakerUpdate) !== null) {\n      message.scenario = {\n        $case: \"speakerUpdate\",\n        speakerUpdate: object.scenario.speakerUpdate\n      };\n    }\n    if (((_d = object.scenario) === null || _d === void 0 ? void 0 : _d.$case) === \"nodeFailure\" && ((_e = object.scenario) === null || _e === void 0 ? void 0 : _e.nodeFailure) !== void 0 && ((_f = object.scenario) === null || _f === void 0 ? void 0 : _f.nodeFailure) !== null) {\n      message.scenario = {\n        $case: \"nodeFailure\",\n        nodeFailure: object.scenario.nodeFailure\n      };\n    }\n    if (((_g = object.scenario) === null || _g === void 0 ? void 0 : _g.$case) === \"migration\" && ((_h = object.scenario) === null || _h === void 0 ? void 0 : _h.migration) !== void 0 && ((_j = object.scenario) === null || _j === void 0 ? void 0 : _j.migration) !== null) {\n      message.scenario = {\n        $case: \"migration\",\n        migration: object.scenario.migration\n      };\n    }\n    if (((_k = object.scenario) === null || _k === void 0 ? void 0 : _k.$case) === \"serverLeave\" && ((_l = object.scenario) === null || _l === void 0 ? void 0 : _l.serverLeave) !== void 0 && ((_m = object.scenario) === null || _m === void 0 ? void 0 : _m.serverLeave) !== null) {\n      message.scenario = {\n        $case: \"serverLeave\",\n        serverLeave: object.scenario.serverLeave\n      };\n    }\n    if (((_o = object.scenario) === null || _o === void 0 ? void 0 : _o.$case) === \"switchCandidateProtocol\" && ((_p = object.scenario) === null || _p === void 0 ? void 0 : _p.switchCandidateProtocol) !== void 0 && ((_q = object.scenario) === null || _q === void 0 ? void 0 : _q.switchCandidateProtocol) !== null) {\n      message.scenario = {\n        $case: \"switchCandidateProtocol\",\n        switchCandidateProtocol: object.scenario.switchCandidateProtocol\n      };\n    }\n    if (((_r = object.scenario) === null || _r === void 0 ? void 0 : _r.$case) === \"subscriberBandwidth\" && ((_s = object.scenario) === null || _s === void 0 ? void 0 : _s.subscriberBandwidth) !== void 0 && ((_t = object.scenario) === null || _t === void 0 ? void 0 : _t.subscriberBandwidth) !== null) {\n      message.scenario = {\n        $case: \"subscriberBandwidth\",\n        subscriberBandwidth: object.scenario.subscriberBandwidth\n      };\n    }\n    return message;\n  }\n};\nfunction createBasePing() {\n  return {\n    timestamp: 0,\n    rtt: 0\n  };\n}\nvar Ping = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.timestamp !== 0) {\n      writer2.uint32(8).int64(message.timestamp);\n    }\n    if (message.rtt !== 0) {\n      writer2.uint32(16).int64(message.rtt);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBasePing();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 8) {\n            break;\n          }\n          message.timestamp = longToNumber(reader2.int64());\n          continue;\n        case 2:\n          if (tag != 16) {\n            break;\n          }\n          message.rtt = longToNumber(reader2.int64());\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      timestamp: isSet(object.timestamp) ? Number(object.timestamp) : 0,\n      rtt: isSet(object.rtt) ? Number(object.rtt) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.timestamp !== void 0 && (obj.timestamp = Math.round(message.timestamp));\n    message.rtt !== void 0 && (obj.rtt = Math.round(message.rtt));\n    return obj;\n  },\n  create(base) {\n    return Ping.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBasePing();\n    message.timestamp = (_a = object.timestamp) !== null && _a !== void 0 ? _a : 0;\n    message.rtt = (_b = object.rtt) !== null && _b !== void 0 ? _b : 0;\n    return message;\n  }\n};\nfunction createBasePong() {\n  return {\n    lastPingTimestamp: 0,\n    timestamp: 0\n  };\n}\nvar Pong = {\n  encode(message) {\n    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();\n    if (message.lastPingTimestamp !== 0) {\n      writer2.uint32(8).int64(message.lastPingTimestamp);\n    }\n    if (message.timestamp !== 0) {\n      writer2.uint32(16).int64(message.timestamp);\n    }\n    return writer2;\n  },\n  decode(input, length) {\n    const reader2 = input instanceof _m0.Reader ? input : _m0.Reader.create(input);\n    let end2 = length === void 0 ? reader2.len : reader2.pos + length;\n    const message = createBasePong();\n    while (reader2.pos < end2) {\n      const tag = reader2.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag != 8) {\n            break;\n          }\n          message.lastPingTimestamp = longToNumber(reader2.int64());\n          continue;\n        case 2:\n          if (tag != 16) {\n            break;\n          }\n          message.timestamp = longToNumber(reader2.int64());\n          continue;\n      }\n      if ((tag & 7) == 4 || tag == 0) {\n        break;\n      }\n      reader2.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      lastPingTimestamp: isSet(object.lastPingTimestamp) ? Number(object.lastPingTimestamp) : 0,\n      timestamp: isSet(object.timestamp) ? Number(object.timestamp) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.lastPingTimestamp !== void 0 && (obj.lastPingTimestamp = Math.round(message.lastPingTimestamp));\n    message.timestamp !== void 0 && (obj.timestamp = Math.round(message.timestamp));\n    return obj;\n  },\n  create(base) {\n    return Pong.fromPartial(base !== null && base !== void 0 ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBasePong();\n    message.lastPingTimestamp = (_a = object.lastPingTimestamp) !== null && _a !== void 0 ? _a : 0;\n    message.timestamp = (_b = object.timestamp) !== null && _b !== void 0 ? _b : 0;\n    return message;\n  }\n};\nvar tsProtoGlobalThis = (() => {\n  if (typeof globalThis !== \"undefined\") {\n    return globalThis;\n  }\n  if (typeof self !== \"undefined\") {\n    return self;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n  throw \"Unable to locate global object\";\n})();\nfunction longToNumber(long2) {\n  if (long2.gt(Number.MAX_SAFE_INTEGER)) {\n    throw new tsProtoGlobalThis.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\n  }\n  return long2.toNumber();\n}\nif (_m0.util.Long !== Long$1) {\n  _m0.util.Long = Long$1;\n  _m0.configure();\n}\nfunction isSet(value) {\n  return value !== null && value !== void 0;\n}\nvar LivekitError = class extends Error {\n  constructor(code, message) {\n    super(message || \"an error has occured\");\n    this.code = code;\n  }\n};\nvar ConnectionError = class extends LivekitError {\n  constructor(message, reason, status) {\n    super(1, message);\n    this.status = status;\n    this.reason = reason;\n  }\n};\nvar DeviceUnsupportedError = class extends LivekitError {\n  constructor(message) {\n    super(21, message !== null && message !== void 0 ? message : \"device is unsupported\");\n  }\n};\nvar TrackInvalidError = class extends LivekitError {\n  constructor(message) {\n    super(20, message !== null && message !== void 0 ? message : \"track is invalid\");\n  }\n};\nvar UnsupportedServer = class extends LivekitError {\n  constructor(message) {\n    super(10, message !== null && message !== void 0 ? message : \"unsupported server\");\n  }\n};\nvar UnexpectedConnectionState = class extends LivekitError {\n  constructor(message) {\n    super(12, message !== null && message !== void 0 ? message : \"unexpected connection state\");\n  }\n};\nvar NegotiationError = class extends LivekitError {\n  constructor(message) {\n    super(13, message !== null && message !== void 0 ? message : \"unable to negotiate\");\n  }\n};\nvar PublishDataError = class extends LivekitError {\n  constructor(message) {\n    super(13, message !== null && message !== void 0 ? message : \"unable to publish data\");\n  }\n};\nvar MediaDeviceFailure;\n(function(MediaDeviceFailure2) {\n  MediaDeviceFailure2[\"PermissionDenied\"] = \"PermissionDenied\";\n  MediaDeviceFailure2[\"NotFound\"] = \"NotFound\";\n  MediaDeviceFailure2[\"DeviceInUse\"] = \"DeviceInUse\";\n  MediaDeviceFailure2[\"Other\"] = \"Other\";\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\n(function(MediaDeviceFailure2) {\n  function getFailure(error) {\n    if (error && \"name\" in error) {\n      if (error.name === \"NotFoundError\" || error.name === \"DevicesNotFoundError\") {\n        return MediaDeviceFailure2.NotFound;\n      }\n      if (error.name === \"NotAllowedError\" || error.name === \"PermissionDeniedError\") {\n        return MediaDeviceFailure2.PermissionDenied;\n      }\n      if (error.name === \"NotReadableError\" || error.name === \"TrackStartError\") {\n        return MediaDeviceFailure2.DeviceInUse;\n      }\n      return MediaDeviceFailure2.Other;\n    }\n  }\n  MediaDeviceFailure2.getFailure = getFailure;\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\nvar CriticalTimers = class {\n};\nCriticalTimers.setTimeout = function() {\n  return setTimeout(...arguments);\n};\nCriticalTimers.setInterval = function() {\n  return setInterval(...arguments);\n};\nCriticalTimers.clearTimeout = function() {\n  return clearTimeout(...arguments);\n};\nCriticalTimers.clearInterval = function() {\n  return clearInterval(...arguments);\n};\nvar passThroughQueueSignals = [\"syncState\", \"trickle\", \"offer\", \"answer\", \"simulate\", \"leave\"];\nfunction canPassThroughQueue(req) {\n  const canPass = passThroughQueueSignals.indexOf(req.$case) >= 0;\n  livekitLogger.trace(\"request allowed to bypass queue:\", {\n    canPass,\n    req\n  });\n  return canPass;\n}\nvar SignalClient = class {\n  constructor() {\n    let useJSON = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n    this.rtt = 0;\n    this.isConnected = false;\n    this.isReconnecting = false;\n    this.useJSON = useJSON;\n    this.requestQueue = new AsyncQueue();\n    this.queuedRequests = [];\n    this.closingLock = new Mutex();\n  }\n  join(url, token, opts, abortSignal) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.isConnected = false;\n      this.options = opts;\n      const res = yield this.connect(url, token, opts, abortSignal);\n      return res;\n    });\n  }\n  reconnect(url, token, sid, reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.options) {\n        livekitLogger.warn(\"attempted to reconnect without signal options being set, ignoring\");\n        return;\n      }\n      this.isReconnecting = true;\n      this.clearPingInterval();\n      const res = yield this.connect(url, token, Object.assign(Object.assign({}, this.options), {\n        reconnect: true,\n        sid,\n        reconnectReason: reason\n      }));\n      return res;\n    });\n  }\n  connect(url, token, opts, abortSignal) {\n    this.connectOptions = opts;\n    if (url.startsWith(\"http\")) {\n      url = url.replace(\"http\", \"ws\");\n    }\n    url = url.replace(/\\/$/, \"\");\n    url += \"/rtc\";\n    const clientInfo = getClientInfo();\n    const params = createConnectionParams(token, clientInfo, opts);\n    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n      const abortHandler = () => __awaiter(this, void 0, void 0, function* () {\n        yield this.close();\n        reject(new ConnectionError(\"room connection has been cancelled (signal)\"));\n      });\n      if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {\n        abortHandler();\n      }\n      abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.addEventListener(\"abort\", abortHandler);\n      livekitLogger.debug(\"connecting to \".concat(url + params));\n      if (this.ws) {\n        yield this.close();\n      }\n      this.ws = new WebSocket(url + params);\n      this.ws.binaryType = \"arraybuffer\";\n      this.ws.onerror = (ev) => __awaiter(this, void 0, void 0, function* () {\n        if (!this.isConnected) {\n          try {\n            const resp = yield fetch(\"http\".concat(url.substring(2), \"/validate\").concat(params));\n            if (resp.status.toFixed(0).startsWith(\"4\")) {\n              const msg = yield resp.text();\n              reject(new ConnectionError(msg, 0, resp.status));\n            } else {\n              reject(new ConnectionError(\"Internal error\", 2, resp.status));\n            }\n          } catch (e) {\n            reject(new ConnectionError(\n              \"server was not reachable\",\n              1\n              /* ConnectionErrorReason.ServerUnreachable */\n            ));\n          }\n          return;\n        }\n        this.handleWSError(ev);\n      });\n      this.ws.onmessage = (ev) => __awaiter(this, void 0, void 0, function* () {\n        var _a, _b, _c, _d;\n        let resp;\n        if (typeof ev.data === \"string\") {\n          const json = JSON.parse(ev.data);\n          resp = SignalResponse.fromJSON(json);\n        } else if (ev.data instanceof ArrayBuffer) {\n          resp = SignalResponse.decode(new Uint8Array(ev.data));\n        } else {\n          livekitLogger.error(\"could not decode websocket message: \".concat(typeof ev.data));\n          return;\n        }\n        if (!this.isConnected) {\n          let shouldProcessMessage = false;\n          if (((_a = resp.message) === null || _a === void 0 ? void 0 : _a.$case) === \"join\") {\n            this.isConnected = true;\n            abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener(\"abort\", abortHandler);\n            this.pingTimeoutDuration = resp.message.join.pingTimeout;\n            this.pingIntervalDuration = resp.message.join.pingInterval;\n            if (this.pingTimeoutDuration && this.pingTimeoutDuration > 0) {\n              livekitLogger.debug(\"ping config\", {\n                timeout: this.pingTimeoutDuration,\n                interval: this.pingIntervalDuration\n              });\n              this.startPingInterval();\n            }\n            resolve(resp.message.join);\n          } else if (opts.reconnect) {\n            this.isConnected = true;\n            abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener(\"abort\", abortHandler);\n            this.startPingInterval();\n            if (((_b = resp.message) === null || _b === void 0 ? void 0 : _b.$case) === \"reconnect\") {\n              resolve((_c = resp.message) === null || _c === void 0 ? void 0 : _c.reconnect);\n            } else {\n              resolve();\n              shouldProcessMessage = true;\n            }\n          } else if (!opts.reconnect) {\n            reject(new ConnectionError(\"did not receive join response, got \".concat((_d = resp.message) === null || _d === void 0 ? void 0 : _d.$case, \" instead\")));\n          }\n          if (!shouldProcessMessage) {\n            return;\n          }\n        }\n        if (this.signalLatency) {\n          yield sleep(this.signalLatency);\n        }\n        this.handleSignalResponse(resp);\n      });\n      this.ws.onclose = (ev) => {\n        livekitLogger.warn(\"websocket closed\", {\n          ev\n        });\n        this.handleOnClose(ev.reason);\n      };\n    }));\n  }\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.closingLock.lock();\n      try {\n        this.isConnected = false;\n        if (this.ws) {\n          this.ws.onclose = null;\n          this.ws.onmessage = null;\n          this.ws.onopen = null;\n          const closePromise = new Promise((resolve) => {\n            if (this.ws) {\n              this.ws.onclose = resolve;\n            } else {\n              resolve(true);\n            }\n          });\n          if (this.ws.readyState < this.ws.CLOSING) {\n            this.ws.close();\n            yield Promise.race([closePromise, sleep(250)]);\n          }\n          this.ws = void 0;\n          this.clearPingInterval();\n        }\n      } finally {\n        unlock();\n      }\n    });\n  }\n  // initial offer after joining\n  sendOffer(offer) {\n    livekitLogger.debug(\"sending offer\", offer);\n    this.sendRequest({\n      $case: \"offer\",\n      offer: toProtoSessionDescription(offer)\n    });\n  }\n  // answer a server-initiated offer\n  sendAnswer(answer) {\n    livekitLogger.debug(\"sending answer\");\n    return this.sendRequest({\n      $case: \"answer\",\n      answer: toProtoSessionDescription(answer)\n    });\n  }\n  sendIceCandidate(candidate, target) {\n    livekitLogger.trace(\"sending ice candidate\", candidate);\n    return this.sendRequest({\n      $case: \"trickle\",\n      trickle: {\n        candidateInit: JSON.stringify(candidate),\n        target\n      }\n    });\n  }\n  sendMuteTrack(trackSid, muted) {\n    return this.sendRequest({\n      $case: \"mute\",\n      mute: {\n        sid: trackSid,\n        muted\n      }\n    });\n  }\n  sendAddTrack(req) {\n    return this.sendRequest({\n      $case: \"addTrack\",\n      addTrack: AddTrackRequest.fromPartial(req)\n    });\n  }\n  sendUpdateLocalMetadata(metadata, name) {\n    return this.sendRequest({\n      $case: \"updateMetadata\",\n      updateMetadata: {\n        metadata,\n        name\n      }\n    });\n  }\n  sendUpdateTrackSettings(settings) {\n    this.sendRequest({\n      $case: \"trackSetting\",\n      trackSetting: settings\n    });\n  }\n  sendUpdateSubscription(sub) {\n    return this.sendRequest({\n      $case: \"subscription\",\n      subscription: sub\n    });\n  }\n  sendSyncState(sync) {\n    return this.sendRequest({\n      $case: \"syncState\",\n      syncState: sync\n    });\n  }\n  sendUpdateVideoLayers(trackSid, layers) {\n    return this.sendRequest({\n      $case: \"updateLayers\",\n      updateLayers: {\n        trackSid,\n        layers\n      }\n    });\n  }\n  sendUpdateSubscriptionPermissions(allParticipants, trackPermissions) {\n    return this.sendRequest({\n      $case: \"subscriptionPermission\",\n      subscriptionPermission: {\n        allParticipants,\n        trackPermissions\n      }\n    });\n  }\n  sendSimulateScenario(scenario) {\n    return this.sendRequest({\n      $case: \"simulate\",\n      simulate: scenario\n    });\n  }\n  sendPing() {\n    return Promise.all([this.sendRequest({\n      $case: \"ping\",\n      ping: Date.now()\n    }), this.sendRequest({\n      $case: \"pingReq\",\n      pingReq: {\n        timestamp: Date.now(),\n        rtt: this.rtt\n      }\n    })]);\n  }\n  sendLeave() {\n    return this.sendRequest({\n      $case: \"leave\",\n      leave: {\n        canReconnect: false,\n        reason: DisconnectReason.CLIENT_INITIATED\n      }\n    });\n  }\n  sendRequest(message) {\n    let fromQueue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    return __awaiter(this, void 0, void 0, function* () {\n      const canQueue = !fromQueue && !canPassThroughQueue(message);\n      if (canQueue && this.isReconnecting) {\n        this.queuedRequests.push(() => __awaiter(this, void 0, void 0, function* () {\n          yield this.sendRequest(message, true);\n        }));\n        return;\n      }\n      if (!fromQueue) {\n        yield this.requestQueue.flush();\n      }\n      if (this.signalLatency) {\n        yield sleep(this.signalLatency);\n      }\n      if (!this.ws || this.ws.readyState !== this.ws.OPEN) {\n        livekitLogger.error(\"cannot send signal request before connected, type: \".concat(message === null || message === void 0 ? void 0 : message.$case));\n        return;\n      }\n      const req = {\n        message\n      };\n      try {\n        if (this.useJSON) {\n          this.ws.send(JSON.stringify(SignalRequest.toJSON(req)));\n        } else {\n          this.ws.send(SignalRequest.encode(req).finish());\n        }\n      } catch (e) {\n        livekitLogger.error(\"error sending signal message\", {\n          error: e\n        });\n      }\n    });\n  }\n  handleSignalResponse(res) {\n    var _a, _b;\n    const msg = res.message;\n    if (msg == void 0) {\n      livekitLogger.debug(\"received unsupported message\");\n      return;\n    }\n    if (msg.$case === \"answer\") {\n      const sd = fromProtoSessionDescription(msg.answer);\n      if (this.onAnswer) {\n        this.onAnswer(sd);\n      }\n    } else if (msg.$case === \"offer\") {\n      const sd = fromProtoSessionDescription(msg.offer);\n      if (this.onOffer) {\n        this.onOffer(sd);\n      }\n    } else if (msg.$case === \"trickle\") {\n      const candidate = JSON.parse(msg.trickle.candidateInit);\n      if (this.onTrickle) {\n        this.onTrickle(candidate, msg.trickle.target);\n      }\n    } else if (msg.$case === \"update\") {\n      if (this.onParticipantUpdate) {\n        this.onParticipantUpdate((_a = msg.update.participants) !== null && _a !== void 0 ? _a : []);\n      }\n    } else if (msg.$case === \"trackPublished\") {\n      if (this.onLocalTrackPublished) {\n        this.onLocalTrackPublished(msg.trackPublished);\n      }\n    } else if (msg.$case === \"speakersChanged\") {\n      if (this.onSpeakersChanged) {\n        this.onSpeakersChanged((_b = msg.speakersChanged.speakers) !== null && _b !== void 0 ? _b : []);\n      }\n    } else if (msg.$case === \"leave\") {\n      if (this.onLeave) {\n        this.onLeave(msg.leave);\n      }\n    } else if (msg.$case === \"mute\") {\n      if (this.onRemoteMuteChanged) {\n        this.onRemoteMuteChanged(msg.mute.sid, msg.mute.muted);\n      }\n    } else if (msg.$case === \"roomUpdate\") {\n      if (this.onRoomUpdate && msg.roomUpdate.room) {\n        this.onRoomUpdate(msg.roomUpdate.room);\n      }\n    } else if (msg.$case === \"connectionQuality\") {\n      if (this.onConnectionQuality) {\n        this.onConnectionQuality(msg.connectionQuality);\n      }\n    } else if (msg.$case === \"streamStateUpdate\") {\n      if (this.onStreamStateUpdate) {\n        this.onStreamStateUpdate(msg.streamStateUpdate);\n      }\n    } else if (msg.$case === \"subscribedQualityUpdate\") {\n      if (this.onSubscribedQualityUpdate) {\n        this.onSubscribedQualityUpdate(msg.subscribedQualityUpdate);\n      }\n    } else if (msg.$case === \"subscriptionPermissionUpdate\") {\n      if (this.onSubscriptionPermissionUpdate) {\n        this.onSubscriptionPermissionUpdate(msg.subscriptionPermissionUpdate);\n      }\n    } else if (msg.$case === \"refreshToken\") {\n      if (this.onTokenRefresh) {\n        this.onTokenRefresh(msg.refreshToken);\n      }\n    } else if (msg.$case === \"trackUnpublished\") {\n      if (this.onLocalTrackUnpublished) {\n        this.onLocalTrackUnpublished(msg.trackUnpublished);\n      }\n    } else if (msg.$case === \"pong\") {\n      this.resetPingTimeout();\n    } else if (msg.$case === \"pongResp\") {\n      this.rtt = Date.now() - msg.pongResp.lastPingTimestamp;\n      this.resetPingTimeout();\n    } else {\n      livekitLogger.debug(\"unsupported message\", msg);\n    }\n  }\n  setReconnected() {\n    while (this.queuedRequests.length > 0) {\n      const req = this.queuedRequests.shift();\n      if (req) {\n        this.requestQueue.run(req);\n      }\n    }\n    this.isReconnecting = false;\n  }\n  handleOnClose(reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.isConnected)\n        return;\n      yield this.close();\n      livekitLogger.debug(\"websocket connection closed: \".concat(reason));\n      if (this.onClose) {\n        this.onClose(reason);\n      }\n    });\n  }\n  handleWSError(ev) {\n    livekitLogger.error(\"websocket error\", ev);\n  }\n  /**\n   * Resets the ping timeout and starts a new timeout.\n   * Call this after receiving a pong message\n   */\n  resetPingTimeout() {\n    this.clearPingTimeout();\n    if (!this.pingTimeoutDuration) {\n      livekitLogger.warn(\"ping timeout duration not set\");\n      return;\n    }\n    this.pingTimeout = CriticalTimers.setTimeout(() => {\n      livekitLogger.warn(\"ping timeout triggered. last pong received at: \".concat(new Date(Date.now() - this.pingTimeoutDuration * 1e3).toUTCString()));\n      this.handleOnClose(\"ping timeout\");\n    }, this.pingTimeoutDuration * 1e3);\n  }\n  /**\n   * Clears ping timeout (does not start a new timeout)\n   */\n  clearPingTimeout() {\n    if (this.pingTimeout) {\n      CriticalTimers.clearTimeout(this.pingTimeout);\n    }\n  }\n  startPingInterval() {\n    this.clearPingInterval();\n    this.resetPingTimeout();\n    if (!this.pingIntervalDuration) {\n      livekitLogger.warn(\"ping interval duration not set\");\n      return;\n    }\n    livekitLogger.debug(\"start ping interval\");\n    this.pingInterval = CriticalTimers.setInterval(() => {\n      this.sendPing();\n    }, this.pingIntervalDuration * 1e3);\n  }\n  clearPingInterval() {\n    livekitLogger.debug(\"clearing ping interval\");\n    this.clearPingTimeout();\n    if (this.pingInterval) {\n      CriticalTimers.clearInterval(this.pingInterval);\n    }\n  }\n};\nfunction fromProtoSessionDescription(sd) {\n  const rsd = {\n    type: \"offer\",\n    sdp: sd.sdp\n  };\n  switch (sd.type) {\n    case \"answer\":\n    case \"offer\":\n    case \"pranswer\":\n    case \"rollback\":\n      rsd.type = sd.type;\n      break;\n  }\n  return rsd;\n}\nfunction toProtoSessionDescription(rsd) {\n  const sd = {\n    sdp: rsd.sdp,\n    type: rsd.type\n  };\n  return sd;\n}\nfunction createConnectionParams(token, info, opts) {\n  var _a;\n  const params = new URLSearchParams();\n  params.set(\"access_token\", token);\n  if (opts.reconnect) {\n    params.set(\"reconnect\", \"1\");\n    if (opts.sid) {\n      params.set(\"sid\", opts.sid);\n    }\n  }\n  params.set(\"auto_subscribe\", opts.autoSubscribe ? \"1\" : \"0\");\n  params.set(\"sdk\", isReactNative() ? \"reactnative\" : \"js\");\n  params.set(\"version\", info.version);\n  params.set(\"protocol\", info.protocol.toString());\n  if (info.deviceModel) {\n    params.set(\"device_model\", info.deviceModel);\n  }\n  if (info.os) {\n    params.set(\"os\", info.os);\n  }\n  if (info.osVersion) {\n    params.set(\"os_version\", info.osVersion);\n  }\n  if (info.browser) {\n    params.set(\"browser\", info.browser);\n  }\n  if (info.browserVersion) {\n    params.set(\"browser_version\", info.browserVersion);\n  }\n  if (opts.publishOnly !== void 0) {\n    params.set(\"publish\", opts.publishOnly);\n  }\n  if (opts.adaptiveStream) {\n    params.set(\"adaptive_stream\", \"1\");\n  }\n  if (opts.reconnectReason) {\n    params.set(\"reconnect_reason\", opts.reconnectReason.toString());\n  }\n  if ((_a = navigator.connection) === null || _a === void 0 ? void 0 : _a.type) {\n    params.set(\"network\", navigator.connection.type);\n  }\n  return \"?\".concat(params.toString());\n}\nvar defaultId = \"default\";\nvar DeviceManager = class {\n  static getInstance() {\n    if (this.instance === void 0) {\n      this.instance = new DeviceManager();\n    }\n    return this.instance;\n  }\n  getDevices(kind) {\n    let requestPermissions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (((_a = DeviceManager.userMediaPromiseMap) === null || _a === void 0 ? void 0 : _a.size) > 0) {\n        livekitLogger.debug(\"awaiting getUserMedia promise\");\n        try {\n          if (kind) {\n            yield DeviceManager.userMediaPromiseMap.get(kind);\n          } else {\n            yield Promise.all(DeviceManager.userMediaPromiseMap.values());\n          }\n        } catch (e) {\n          livekitLogger.warn(\"error waiting for media permissons\");\n        }\n      }\n      let devices = yield navigator.mediaDevices.enumerateDevices();\n      if (requestPermissions && kind && // for safari we need to skip this check, as otherwise it will re-acquire user media and fail on iOS https://bugs.webkit.org/show_bug.cgi?id=179363\n      (!DeviceManager.userMediaPromiseMap.get(kind) || !isSafari())) {\n        const isDummyDeviceOrEmpty = devices.length === 0 || devices.some((device) => {\n          const noLabel = device.label === \"\";\n          const isRelevant = kind ? device.kind === kind : true;\n          return noLabel && isRelevant;\n        });\n        if (isDummyDeviceOrEmpty) {\n          const permissionsToAcquire = {\n            video: kind !== \"audioinput\" && kind !== \"audiooutput\",\n            audio: kind !== \"videoinput\"\n          };\n          const stream = yield navigator.mediaDevices.getUserMedia(permissionsToAcquire);\n          devices = yield navigator.mediaDevices.enumerateDevices();\n          stream.getTracks().forEach((track) => {\n            track.stop();\n          });\n        }\n      }\n      if (kind) {\n        devices = devices.filter((device) => device.kind === kind);\n      }\n      return devices;\n    });\n  }\n  normalizeDeviceId(kind, deviceId, groupId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (deviceId !== defaultId) {\n        return deviceId;\n      }\n      const devices = yield this.getDevices(kind);\n      const device = devices.find((d) => d.groupId === groupId && d.deviceId !== defaultId);\n      return device === null || device === void 0 ? void 0 : device.deviceId;\n    });\n  }\n};\nDeviceManager.mediaDeviceKinds = [\"audioinput\", \"audiooutput\", \"videoinput\"];\nDeviceManager.userMediaPromiseMap = /* @__PURE__ */ new Map();\nvar parser$1 = {};\nvar grammar$2 = { exports: {} };\nvar grammar$1 = grammar$2.exports = {\n  v: [{\n    name: \"version\",\n    reg: /^(\\d*)$/\n  }],\n  o: [{\n    // o=- 20518 0 IN IP4 203.0.113.1\n    // NB: sessionId will be a String in most cases because it is huge\n    name: \"origin\",\n    reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n    names: [\"username\", \"sessionId\", \"sessionVersion\", \"netType\", \"ipVer\", \"address\"],\n    format: \"%s %s %d %s IP%d %s\"\n  }],\n  // default parsing of these only (though some of these feel outdated)\n  s: [{\n    name: \"name\"\n  }],\n  i: [{\n    name: \"description\"\n  }],\n  u: [{\n    name: \"uri\"\n  }],\n  e: [{\n    name: \"email\"\n  }],\n  p: [{\n    name: \"phone\"\n  }],\n  z: [{\n    name: \"timezones\"\n  }],\n  // TODO: this one can actually be parsed properly...\n  r: [{\n    name: \"repeats\"\n  }],\n  // TODO: this one can also be parsed properly\n  // k: [{}], // outdated thing ignored\n  t: [{\n    // t=0 0\n    name: \"timing\",\n    reg: /^(\\d*) (\\d*)/,\n    names: [\"start\", \"stop\"],\n    format: \"%d %d\"\n  }],\n  c: [{\n    // c=IN IP4 10.47.197.26\n    name: \"connection\",\n    reg: /^IN IP(\\d) (\\S*)/,\n    names: [\"version\", \"ip\"],\n    format: \"IN IP%d %s\"\n  }],\n  b: [{\n    // b=AS:4000\n    push: \"bandwidth\",\n    reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n    names: [\"type\", \"limit\"],\n    format: \"%s:%s\"\n  }],\n  m: [{\n    // m=video 51744 RTP/AVP 126 97 98 34 31\n    // NB: special - pushes to session\n    // TODO: rtp/fmtp should be filtered by the payloads found here?\n    reg: /^(\\w*) (\\d*) ([\\w/]*)(?: (.*))?/,\n    names: [\"type\", \"port\", \"protocol\", \"payloads\"],\n    format: \"%s %d %s %s\"\n  }],\n  a: [\n    {\n      // a=rtpmap:110 opus/48000/2\n      push: \"rtp\",\n      reg: /^rtpmap:(\\d*) ([\\w\\-.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n      names: [\"payload\", \"codec\", \"rate\", \"encoding\"],\n      format: function(o) {\n        return o.encoding ? \"rtpmap:%d %s/%s/%s\" : o.rate ? \"rtpmap:%d %s/%s\" : \"rtpmap:%d %s\";\n      }\n    },\n    {\n      // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n      // a=fmtp:111 minptime=10; useinbandfec=1\n      push: \"fmtp\",\n      reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n      names: [\"payload\", \"config\"],\n      format: \"fmtp:%d %s\"\n    },\n    {\n      // a=control:streamid=0\n      name: \"control\",\n      reg: /^control:(.*)/,\n      format: \"control:%s\"\n    },\n    {\n      // a=rtcp:65179 IN IP4 193.84.77.194\n      name: \"rtcp\",\n      reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n      names: [\"port\", \"netType\", \"ipVer\", \"address\"],\n      format: function(o) {\n        return o.address != null ? \"rtcp:%d %s IP%d %s\" : \"rtcp:%d\";\n      }\n    },\n    {\n      // a=rtcp-fb:98 trr-int 100\n      push: \"rtcpFbTrrInt\",\n      reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n      names: [\"payload\", \"value\"],\n      format: \"rtcp-fb:%s trr-int %d\"\n    },\n    {\n      // a=rtcp-fb:98 nack rpsi\n      push: \"rtcpFb\",\n      reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n      names: [\"payload\", \"type\", \"subtype\"],\n      format: function(o) {\n        return o.subtype != null ? \"rtcp-fb:%s %s %s\" : \"rtcp-fb:%s %s\";\n      }\n    },\n    {\n      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n      // a=extmap:1/recvonly URI-gps-string\n      // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24\n      push: \"ext\",\n      reg: /^extmap:(\\d+)(?:\\/(\\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\\S*)(?: (\\S*))?/,\n      names: [\"value\", \"direction\", \"encrypt-uri\", \"uri\", \"config\"],\n      format: function(o) {\n        return \"extmap:%d\" + (o.direction ? \"/%s\" : \"%v\") + (o[\"encrypt-uri\"] ? \" %s\" : \"%v\") + \" %s\" + (o.config ? \" %s\" : \"\");\n      }\n    },\n    {\n      // a=extmap-allow-mixed\n      name: \"extmapAllowMixed\",\n      reg: /^(extmap-allow-mixed)/\n    },\n    {\n      // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n      push: \"crypto\",\n      reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n      names: [\"id\", \"suite\", \"config\", \"sessionConfig\"],\n      format: function(o) {\n        return o.sessionConfig != null ? \"crypto:%d %s %s %s\" : \"crypto:%d %s %s\";\n      }\n    },\n    {\n      // a=setup:actpass\n      name: \"setup\",\n      reg: /^setup:(\\w*)/,\n      format: \"setup:%s\"\n    },\n    {\n      // a=connection:new\n      name: \"connectionType\",\n      reg: /^connection:(new|existing)/,\n      format: \"connection:%s\"\n    },\n    {\n      // a=mid:1\n      name: \"mid\",\n      reg: /^mid:([^\\s]*)/,\n      format: \"mid:%s\"\n    },\n    {\n      // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n      name: \"msid\",\n      reg: /^msid:(.*)/,\n      format: \"msid:%s\"\n    },\n    {\n      // a=ptime:20\n      name: \"ptime\",\n      reg: /^ptime:(\\d*(?:\\.\\d*)*)/,\n      format: \"ptime:%d\"\n    },\n    {\n      // a=maxptime:60\n      name: \"maxptime\",\n      reg: /^maxptime:(\\d*(?:\\.\\d*)*)/,\n      format: \"maxptime:%d\"\n    },\n    {\n      // a=sendrecv\n      name: \"direction\",\n      reg: /^(sendrecv|recvonly|sendonly|inactive)/\n    },\n    {\n      // a=ice-lite\n      name: \"icelite\",\n      reg: /^(ice-lite)/\n    },\n    {\n      // a=ice-ufrag:F7gI\n      name: \"iceUfrag\",\n      reg: /^ice-ufrag:(\\S*)/,\n      format: \"ice-ufrag:%s\"\n    },\n    {\n      // a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n      name: \"icePwd\",\n      reg: /^ice-pwd:(\\S*)/,\n      format: \"ice-pwd:%s\"\n    },\n    {\n      // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n      name: \"fingerprint\",\n      reg: /^fingerprint:(\\S*) (\\S*)/,\n      names: [\"type\", \"hash\"],\n      format: \"fingerprint:%s %s\"\n    },\n    {\n      // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n      // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\n      // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\n      // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\n      // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\n      push: \"candidates\",\n      reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\n      names: [\"foundation\", \"component\", \"transport\", \"priority\", \"ip\", \"port\", \"type\", \"raddr\", \"rport\", \"tcptype\", \"generation\", \"network-id\", \"network-cost\"],\n      format: function(o) {\n        var str = \"candidate:%s %d %s %d %s %d typ %s\";\n        str += o.raddr != null ? \" raddr %s rport %d\" : \"%v%v\";\n        str += o.tcptype != null ? \" tcptype %s\" : \"%v\";\n        if (o.generation != null) {\n          str += \" generation %d\";\n        }\n        str += o[\"network-id\"] != null ? \" network-id %d\" : \"%v\";\n        str += o[\"network-cost\"] != null ? \" network-cost %d\" : \"%v\";\n        return str;\n      }\n    },\n    {\n      // a=end-of-candidates (keep after the candidates line for readability)\n      name: \"endOfCandidates\",\n      reg: /^(end-of-candidates)/\n    },\n    {\n      // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n      name: \"remoteCandidates\",\n      reg: /^remote-candidates:(.*)/,\n      format: \"remote-candidates:%s\"\n    },\n    {\n      // a=ice-options:google-ice\n      name: \"iceOptions\",\n      reg: /^ice-options:(\\S*)/,\n      format: \"ice-options:%s\"\n    },\n    {\n      // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n      push: \"ssrcs\",\n      reg: /^ssrc:(\\d*) ([\\w_-]*)(?::(.*))?/,\n      names: [\"id\", \"attribute\", \"value\"],\n      format: function(o) {\n        var str = \"ssrc:%d\";\n        if (o.attribute != null) {\n          str += \" %s\";\n          if (o.value != null) {\n            str += \":%s\";\n          }\n        }\n        return str;\n      }\n    },\n    {\n      // a=ssrc-group:FEC 1 2\n      // a=ssrc-group:FEC-FR 3004364195 1080772241\n      push: \"ssrcGroups\",\n      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\n      reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\n      names: [\"semantics\", \"ssrcs\"],\n      format: \"ssrc-group:%s %s\"\n    },\n    {\n      // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n      name: \"msidSemantic\",\n      reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n      names: [\"semantic\", \"token\"],\n      format: \"msid-semantic: %s %s\"\n      // space after ':' is not accidental\n    },\n    {\n      // a=group:BUNDLE audio video\n      push: \"groups\",\n      reg: /^group:(\\w*) (.*)/,\n      names: [\"type\", \"mids\"],\n      format: \"group:%s %s\"\n    },\n    {\n      // a=rtcp-mux\n      name: \"rtcpMux\",\n      reg: /^(rtcp-mux)/\n    },\n    {\n      // a=rtcp-rsize\n      name: \"rtcpRsize\",\n      reg: /^(rtcp-rsize)/\n    },\n    {\n      // a=sctpmap:5000 webrtc-datachannel 1024\n      name: \"sctpmap\",\n      reg: /^sctpmap:([\\w_/]*) (\\S*)(?: (\\S*))?/,\n      names: [\"sctpmapNumber\", \"app\", \"maxMessageSize\"],\n      format: function(o) {\n        return o.maxMessageSize != null ? \"sctpmap:%s %s %s\" : \"sctpmap:%s %s\";\n      }\n    },\n    {\n      // a=x-google-flag:conference\n      name: \"xGoogleFlag\",\n      reg: /^x-google-flag:([^\\s]*)/,\n      format: \"x-google-flag:%s\"\n    },\n    {\n      // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\n      push: \"rids\",\n      reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\n      names: [\"id\", \"direction\", \"params\"],\n      format: function(o) {\n        return o.params ? \"rid:%s %s %s\" : \"rid:%s %s\";\n      }\n    },\n    {\n      // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\n      // a=imageattr:* send [x=800,y=640] recv *\n      // a=imageattr:100 recv [x=320,y=240]\n      push: \"imageattrs\",\n      reg: new RegExp(\n        // a=imageattr:97\n        \"^imageattr:(\\\\d+|\\\\*)[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?\"\n      ),\n      names: [\"pt\", \"dir1\", \"attrs1\", \"dir2\", \"attrs2\"],\n      format: function(o) {\n        return \"imageattr:%s %s %s\" + (o.dir2 ? \" %s %s\" : \"\");\n      }\n    },\n    {\n      // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\n      // a=simulcast:recv 1;4,5 send 6;7\n      name: \"simulcast\",\n      reg: new RegExp(\n        // a=simulcast:\n        \"^simulcast:(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?$\"\n      ),\n      names: [\"dir1\", \"list1\", \"dir2\", \"list2\"],\n      format: function(o) {\n        return \"simulcast:%s %s\" + (o.dir2 ? \" %s %s\" : \"\");\n      }\n    },\n    {\n      // old simulcast draft 03 (implemented by Firefox)\n      //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\n      // a=simulcast: recv pt=97;98 send pt=97\n      // a=simulcast: send rid=5;6;7 paused=6,7\n      name: \"simulcast_03\",\n      reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\n      names: [\"value\"],\n      format: \"simulcast: %s\"\n    },\n    {\n      // a=framerate:25\n      // a=framerate:29.97\n      name: \"framerate\",\n      reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\n      format: \"framerate:%s\"\n    },\n    {\n      // RFC4570\n      // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5\n      name: \"sourceFilter\",\n      reg: /^source-filter: *(excl|incl) (\\S*) (IP4|IP6|\\*) (\\S*) (.*)/,\n      names: [\"filterMode\", \"netType\", \"addressTypes\", \"destAddress\", \"srcList\"],\n      format: \"source-filter: %s %s %s %s %s\"\n    },\n    {\n      // a=bundle-only\n      name: \"bundleOnly\",\n      reg: /^(bundle-only)/\n    },\n    {\n      // a=label:1\n      name: \"label\",\n      reg: /^label:(.+)/,\n      format: \"label:%s\"\n    },\n    {\n      // RFC version 26 for SCTP over DTLS\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5\n      name: \"sctpPort\",\n      reg: /^sctp-port:(\\d+)$/,\n      format: \"sctp-port:%s\"\n    },\n    {\n      // RFC version 26 for SCTP over DTLS\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6\n      name: \"maxMessageSize\",\n      reg: /^max-message-size:(\\d+)$/,\n      format: \"max-message-size:%s\"\n    },\n    {\n      // RFC7273\n      // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37\n      push: \"tsRefClocks\",\n      reg: /^ts-refclk:([^\\s=]*)(?:=(\\S*))?/,\n      names: [\"clksrc\", \"clksrcExt\"],\n      format: function(o) {\n        return \"ts-refclk:%s\" + (o.clksrcExt != null ? \"=%s\" : \"\");\n      }\n    },\n    {\n      // RFC7273\n      // a=mediaclk:direct=963214424\n      name: \"mediaClk\",\n      reg: /^mediaclk:(?:id=(\\S*))? *([^\\s=]*)(?:=(\\S*))?(?: *rate=(\\d+)\\/(\\d+))?/,\n      names: [\"id\", \"mediaClockName\", \"mediaClockValue\", \"rateNumerator\", \"rateDenominator\"],\n      format: function(o) {\n        var str = \"mediaclk:\";\n        str += o.id != null ? \"id=%s %s\" : \"%v%s\";\n        str += o.mediaClockValue != null ? \"=%s\" : \"\";\n        str += o.rateNumerator != null ? \" rate=%s\" : \"\";\n        str += o.rateDenominator != null ? \"/%s\" : \"\";\n        return str;\n      }\n    },\n    {\n      // a=keywds:keywords\n      name: \"keywords\",\n      reg: /^keywds:(.+)$/,\n      format: \"keywds:%s\"\n    },\n    {\n      // a=content:main\n      name: \"content\",\n      reg: /^content:(.+)/,\n      format: \"content:%s\"\n    },\n    // BFCP https://tools.ietf.org/html/rfc4583\n    {\n      // a=floorctrl:c-s\n      name: \"bfcpFloorCtrl\",\n      reg: /^floorctrl:(c-only|s-only|c-s)/,\n      format: \"floorctrl:%s\"\n    },\n    {\n      // a=confid:1\n      name: \"bfcpConfId\",\n      reg: /^confid:(\\d+)/,\n      format: \"confid:%s\"\n    },\n    {\n      // a=userid:1\n      name: \"bfcpUserId\",\n      reg: /^userid:(\\d+)/,\n      format: \"userid:%s\"\n    },\n    {\n      // a=floorid:1\n      name: \"bfcpFloorId\",\n      reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,\n      names: [\"id\", \"mStream\"],\n      format: \"floorid:%s mstrm:%s\"\n    },\n    {\n      // any a= that we don't understand is kept verbatim on media.invalid\n      push: \"invalid\",\n      names: [\"value\"]\n    }\n  ]\n};\nObject.keys(grammar$1).forEach(function(key) {\n  var objs = grammar$1[key];\n  objs.forEach(function(obj) {\n    if (!obj.reg) {\n      obj.reg = /(.*)/;\n    }\n    if (!obj.format) {\n      obj.format = \"%s\";\n    }\n  });\n});\nvar grammarExports = grammar$2.exports;\n(function(exports) {\n  var toIntIfInt = function(v) {\n    return String(Number(v)) === v ? Number(v) : v;\n  };\n  var attachProperties = function(match, location, names, rawName) {\n    if (rawName && !names) {\n      location[rawName] = toIntIfInt(match[1]);\n    } else {\n      for (var i = 0; i < names.length; i += 1) {\n        if (match[i + 1] != null) {\n          location[names[i]] = toIntIfInt(match[i + 1]);\n        }\n      }\n    }\n  };\n  var parseReg = function(obj, location, content) {\n    var needsBlank = obj.name && obj.names;\n    if (obj.push && !location[obj.push]) {\n      location[obj.push] = [];\n    } else if (needsBlank && !location[obj.name]) {\n      location[obj.name] = {};\n    }\n    var keyLocation = obj.push ? {} : (\n      // blank object that will be pushed\n      needsBlank ? location[obj.name] : location\n    );\n    attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n    if (obj.push) {\n      location[obj.push].push(keyLocation);\n    }\n  };\n  var grammar2 = grammarExports;\n  var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n  exports.parse = function(sdp2) {\n    var session = {}, media = [], location = session;\n    sdp2.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function(l) {\n      var type = l[0];\n      var content = l.slice(2);\n      if (type === \"m\") {\n        media.push({\n          rtp: [],\n          fmtp: []\n        });\n        location = media[media.length - 1];\n      }\n      for (var j = 0; j < (grammar2[type] || []).length; j += 1) {\n        var obj = grammar2[type][j];\n        if (obj.reg.test(content)) {\n          return parseReg(obj, location, content);\n        }\n      }\n    });\n    session.media = media;\n    return session;\n  };\n  var paramReducer = function(acc, expr) {\n    var s = expr.split(/=(.+)/, 2);\n    if (s.length === 2) {\n      acc[s[0]] = toIntIfInt(s[1]);\n    } else if (s.length === 1 && expr.length > 1) {\n      acc[s[0]] = void 0;\n    }\n    return acc;\n  };\n  exports.parseParams = function(str) {\n    return str.split(/;\\s?/).reduce(paramReducer, {});\n  };\n  exports.parseFmtpConfig = exports.parseParams;\n  exports.parsePayloads = function(str) {\n    return str.toString().split(\" \").map(Number);\n  };\n  exports.parseRemoteCandidates = function(str) {\n    var candidates = [];\n    var parts = str.split(\" \").map(toIntIfInt);\n    for (var i = 0; i < parts.length; i += 3) {\n      candidates.push({\n        component: parts[i],\n        ip: parts[i + 1],\n        port: parts[i + 2]\n      });\n    }\n    return candidates;\n  };\n  exports.parseImageAttributes = function(str) {\n    return str.split(\" \").map(function(item) {\n      return item.substring(1, item.length - 1).split(\",\").reduce(paramReducer, {});\n    });\n  };\n  exports.parseSimulcastStreamList = function(str) {\n    return str.split(\";\").map(function(stream) {\n      return stream.split(\",\").map(function(format2) {\n        var scid, paused = false;\n        if (format2[0] !== \"~\") {\n          scid = toIntIfInt(format2);\n        } else {\n          scid = toIntIfInt(format2.substring(1, format2.length));\n          paused = true;\n        }\n        return {\n          scid,\n          paused\n        };\n      });\n    });\n  };\n})(parser$1);\nvar grammar = grammarExports;\nvar formatRegExp = /%[sdv%]/g;\nvar format = function(formatStr) {\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  return formatStr.replace(formatRegExp, function(x) {\n    if (i >= len) {\n      return x;\n    }\n    var arg = args[i];\n    i += 1;\n    switch (x) {\n      case \"%%\":\n        return \"%\";\n      case \"%s\":\n        return String(arg);\n      case \"%d\":\n        return Number(arg);\n      case \"%v\":\n        return \"\";\n    }\n  });\n};\nvar makeLine = function(type, obj, location) {\n  var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;\n  var args = [type + \"=\" + str];\n  if (obj.names) {\n    for (var i = 0; i < obj.names.length; i += 1) {\n      var n = obj.names[i];\n      if (obj.name) {\n        args.push(location[obj.name][n]);\n      } else {\n        args.push(location[obj.names[i]]);\n      }\n    }\n  } else {\n    args.push(location[obj.name]);\n  }\n  return format.apply(null, args);\n};\nvar defaultOuterOrder = [\"v\", \"o\", \"s\", \"i\", \"u\", \"e\", \"p\", \"c\", \"b\", \"t\", \"r\", \"z\", \"a\"];\nvar defaultInnerOrder = [\"i\", \"c\", \"b\", \"a\"];\nvar writer$1 = function(session, opts) {\n  opts = opts || {};\n  if (session.version == null) {\n    session.version = 0;\n  }\n  if (session.name == null) {\n    session.name = \" \";\n  }\n  session.media.forEach(function(mLine) {\n    if (mLine.payloads == null) {\n      mLine.payloads = \"\";\n    }\n  });\n  var outerOrder = opts.outerOrder || defaultOuterOrder;\n  var innerOrder = opts.innerOrder || defaultInnerOrder;\n  var sdp2 = [];\n  outerOrder.forEach(function(type) {\n    grammar[type].forEach(function(obj) {\n      if (obj.name in session && session[obj.name] != null) {\n        sdp2.push(makeLine(type, obj, session));\n      } else if (obj.push in session && session[obj.push] != null) {\n        session[obj.push].forEach(function(el) {\n          sdp2.push(makeLine(type, obj, el));\n        });\n      }\n    });\n  });\n  session.media.forEach(function(mLine) {\n    sdp2.push(makeLine(\"m\", grammar.m[0], mLine));\n    innerOrder.forEach(function(type) {\n      grammar[type].forEach(function(obj) {\n        if (obj.name in mLine && mLine[obj.name] != null) {\n          sdp2.push(makeLine(type, obj, mLine));\n        } else if (obj.push in mLine && mLine[obj.push] != null) {\n          mLine[obj.push].forEach(function(el) {\n            sdp2.push(makeLine(type, obj, el));\n          });\n        }\n      });\n    });\n  });\n  return sdp2.join(\"\\r\\n\") + \"\\r\\n\";\n};\nvar parser = parser$1;\nvar writer = writer$1;\nvar write = writer;\nvar parse = parser.parse;\nparser.parseParams;\nparser.parseFmtpConfig;\nparser.parsePayloads;\nparser.parseRemoteCandidates;\nparser.parseImageAttributes;\nparser.parseSimulcastStreamList;\nfunction r(r2, e, n) {\n  var i, t, o;\n  void 0 === e && (e = 50), void 0 === n && (n = {});\n  var a = null != (i = n.isImmediate) && i, u = null != (t = n.callback) && t, c = n.maxWait, v = Date.now(), l = [];\n  function f() {\n    if (void 0 !== c) {\n      var r3 = Date.now() - v;\n      if (r3 + e >= c)\n        return c - r3;\n    }\n    return e;\n  }\n  var d = function() {\n    var e2 = [].slice.call(arguments), n2 = this;\n    return new Promise(function(i2, t2) {\n      var c2 = a && void 0 === o;\n      if (void 0 !== o && clearTimeout(o), o = setTimeout(function() {\n        if (o = void 0, v = Date.now(), !a) {\n          var i3 = r2.apply(n2, e2);\n          u && u(i3), l.forEach(function(r3) {\n            return (0, r3.resolve)(i3);\n          }), l = [];\n        }\n      }, f()), c2) {\n        var d2 = r2.apply(n2, e2);\n        return u && u(d2), i2(d2);\n      }\n      l.push({\n        resolve: i2,\n        reject: t2\n      });\n    });\n  };\n  return d.cancel = function(r3) {\n    void 0 !== o && clearTimeout(o), l.forEach(function(e2) {\n      return (0, e2.reject)(r3);\n    }), l = [];\n  }, d;\n}\nvar PCEvents = {\n  NegotiationStarted: \"negotiationStarted\",\n  NegotiationComplete: \"negotiationComplete\"\n};\nvar PCTransport = class extends eventsExports.EventEmitter {\n  constructor(config) {\n    let mediaConstraints = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    super();\n    this.pendingCandidates = [];\n    this.restartingIce = false;\n    this.renegotiate = false;\n    this.trackBitrates = [];\n    this.remoteStereoMids = [];\n    this.remoteNackMids = [];\n    this.negotiate = r((onError) => {\n      this.emit(PCEvents.NegotiationStarted);\n      try {\n        this.createAndSendOffer();\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          throw e;\n        }\n      }\n    }, 100);\n    this.pc = isChromiumBased() ? (\n      // @ts-expect-error chrome allows additional media constraints to be passed into the RTCPeerConnection constructor\n      new RTCPeerConnection(config, mediaConstraints)\n    ) : new RTCPeerConnection(config);\n  }\n  get isICEConnected() {\n    return this.pc.iceConnectionState === \"connected\" || this.pc.iceConnectionState === \"completed\";\n  }\n  addIceCandidate(candidate) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.pc.remoteDescription && !this.restartingIce) {\n        return this.pc.addIceCandidate(candidate);\n      }\n      this.pendingCandidates.push(candidate);\n    });\n  }\n  setRemoteDescription(sd) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (sd.type === \"offer\") {\n        let {\n          stereoMids,\n          nackMids\n        } = extractStereoAndNackAudioFromOffer(sd);\n        this.remoteStereoMids = stereoMids;\n        this.remoteNackMids = nackMids;\n      }\n      yield this.pc.setRemoteDescription(sd);\n      this.pendingCandidates.forEach((candidate) => {\n        this.pc.addIceCandidate(candidate);\n      });\n      this.pendingCandidates = [];\n      this.restartingIce = false;\n      if (this.renegotiate) {\n        this.renegotiate = false;\n        this.createAndSendOffer();\n      } else if (sd.type === \"answer\") {\n        this.emit(PCEvents.NegotiationComplete);\n      }\n    });\n  }\n  createAndSendOffer(options) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.onOffer === void 0) {\n        return;\n      }\n      if (options === null || options === void 0 ? void 0 : options.iceRestart) {\n        livekitLogger.debug(\"restarting ICE\");\n        this.restartingIce = true;\n      }\n      if (this.pc.signalingState === \"have-local-offer\") {\n        const currentSD = this.pc.remoteDescription;\n        if ((options === null || options === void 0 ? void 0 : options.iceRestart) && currentSD) {\n          yield this.pc.setRemoteDescription(currentSD);\n        } else {\n          this.renegotiate = true;\n          return;\n        }\n      } else if (this.pc.signalingState === \"closed\") {\n        livekitLogger.warn(\"could not createOffer with closed peer connection\");\n        return;\n      }\n      livekitLogger.debug(\"starting to negotiate\");\n      const offer = yield this.pc.createOffer(options);\n      const sdpParsed = parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : \"\");\n      sdpParsed.media.forEach((media) => {\n        if (media.type === \"audio\") {\n          ensureAudioNackAndStereo(media, [], []);\n        } else if (media.type === \"video\") {\n          ensureVideoDDExtensionForSVC(media);\n          this.trackBitrates.some((trackbr) => {\n            if (!media.msid || !media.msid.includes(trackbr.sid)) {\n              return false;\n            }\n            let codecPayload = 0;\n            media.rtp.some((rtp) => {\n              if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {\n                codecPayload = rtp.payload;\n                return true;\n              }\n              return false;\n            });\n            if (codecPayload > 0) {\n              if (!media.fmtp.some((fmtp) => {\n                if (fmtp.payload === codecPayload) {\n                  if (!fmtp.config.includes(\"x-google-start-bitrate\")) {\n                    fmtp.config += \";x-google-start-bitrate=\".concat(trackbr.maxbr * 0.7);\n                  }\n                  if (!fmtp.config.includes(\"x-google-max-bitrate\")) {\n                    fmtp.config += \";x-google-max-bitrate=\".concat(trackbr.maxbr);\n                  }\n                  return true;\n                }\n                return false;\n              })) {\n                media.fmtp.push({\n                  payload: codecPayload,\n                  config: \"x-google-start-bitrate=\".concat(trackbr.maxbr * 0.7, \";x-google-max-bitrate=\").concat(trackbr.maxbr)\n                });\n              }\n            }\n            return true;\n          });\n        }\n      });\n      this.trackBitrates = [];\n      yield this.setMungedLocalDescription(offer, write(sdpParsed));\n      this.onOffer(offer);\n    });\n  }\n  createAndSetAnswer() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const answer = yield this.pc.createAnswer();\n      const sdpParsed = parse((_a = answer.sdp) !== null && _a !== void 0 ? _a : \"\");\n      sdpParsed.media.forEach((media) => {\n        if (media.type === \"audio\") {\n          ensureAudioNackAndStereo(media, this.remoteStereoMids, this.remoteNackMids);\n        }\n      });\n      yield this.setMungedLocalDescription(answer, write(sdpParsed));\n      return answer;\n    });\n  }\n  setTrackCodecBitrate(sid, codec, maxbr) {\n    this.trackBitrates.push({\n      sid,\n      codec,\n      maxbr\n    });\n  }\n  close() {\n    this.pc.onconnectionstatechange = null;\n    this.pc.oniceconnectionstatechange = null;\n    this.pc.close();\n  }\n  setMungedLocalDescription(sd, munged) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const originalSdp = sd.sdp;\n      sd.sdp = munged;\n      try {\n        livekitLogger.debug(\"setting munged local description\");\n        yield this.pc.setLocalDescription(sd);\n        return;\n      } catch (e) {\n        livekitLogger.warn(\"not able to set \".concat(sd.type, \", falling back to unmodified sdp\"), {\n          error: e\n        });\n        sd.sdp = originalSdp;\n      }\n      try {\n        yield this.pc.setLocalDescription(sd);\n      } catch (e) {\n        let msg = \"unknown error\";\n        if (e instanceof Error) {\n          msg = e.message;\n        } else if (typeof e === \"string\") {\n          msg = e;\n        }\n        throw new NegotiationError(msg);\n      }\n    });\n  }\n};\nfunction ensureAudioNackAndStereo(media, stereoMids, nackMids) {\n  let opusPayload = 0;\n  media.rtp.some((rtp) => {\n    if (rtp.codec === \"opus\") {\n      opusPayload = rtp.payload;\n      return true;\n    }\n    return false;\n  });\n  if (opusPayload > 0) {\n    if (!media.rtcpFb) {\n      media.rtcpFb = [];\n    }\n    if (nackMids.includes(media.mid) && !media.rtcpFb.some((fb) => fb.payload === opusPayload && fb.type === \"nack\")) {\n      media.rtcpFb.push({\n        payload: opusPayload,\n        type: \"nack\"\n      });\n    }\n    if (stereoMids.includes(media.mid)) {\n      media.fmtp.some((fmtp) => {\n        if (fmtp.payload === opusPayload) {\n          if (!fmtp.config.includes(\"stereo=1\")) {\n            fmtp.config += \";stereo=1\";\n          }\n          return true;\n        }\n        return false;\n      });\n    }\n  }\n}\nfunction ensureVideoDDExtensionForSVC(media) {\n  var _a, _b, _c, _d;\n  const codec = (_b = (_a = media.rtp[0]) === null || _a === void 0 ? void 0 : _a.codec) === null || _b === void 0 ? void 0 : _b.toLowerCase();\n  if (!isSVCCodec(codec)) {\n    return;\n  }\n  let maxID = 0;\n  const ddFound = (_c = media.ext) === null || _c === void 0 ? void 0 : _c.some((ext) => {\n    if (ext.uri === ddExtensionURI) {\n      return true;\n    }\n    if (ext.value > maxID) {\n      maxID = ext.value;\n    }\n    return false;\n  });\n  if (!ddFound) {\n    (_d = media.ext) === null || _d === void 0 ? void 0 : _d.push({\n      value: maxID + 1,\n      uri: ddExtensionURI\n    });\n  }\n}\nfunction extractStereoAndNackAudioFromOffer(offer) {\n  var _a;\n  const stereoMids = [];\n  const nackMids = [];\n  const sdpParsed = parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : \"\");\n  let opusPayload = 0;\n  sdpParsed.media.forEach((media) => {\n    var _a2;\n    if (media.type === \"audio\") {\n      media.rtp.some((rtp) => {\n        if (rtp.codec === \"opus\") {\n          opusPayload = rtp.payload;\n          return true;\n        }\n        return false;\n      });\n      if ((_a2 = media.rtcpFb) === null || _a2 === void 0 ? void 0 : _a2.some((fb) => fb.payload === opusPayload && fb.type === \"nack\")) {\n        nackMids.push(media.mid);\n      }\n      media.fmtp.some((fmtp) => {\n        if (fmtp.payload === opusPayload) {\n          if (fmtp.config.includes(\"sprop-stereo=1\")) {\n            stereoMids.push(media.mid);\n          }\n          return true;\n        }\n        return false;\n      });\n    }\n  });\n  return {\n    stereoMids,\n    nackMids\n  };\n}\nvar RegionUrlProvider = class {\n  constructor(url, token) {\n    this.lastUpdateAt = 0;\n    this.settingsCacheTime = 3e3;\n    this.attemptedRegions = [];\n    this.serverUrl = new URL(url);\n    this.token = token;\n  }\n  isCloud() {\n    return isCloud(this.serverUrl);\n  }\n  getNextBestRegionUrl(abortSignal) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.isCloud()) {\n        throw Error(\"region availability is only supported for LiveKit Cloud domains\");\n      }\n      if (!this.regionSettings || Date.now() - this.lastUpdateAt > this.settingsCacheTime) {\n        this.regionSettings = yield this.fetchRegionSettings(abortSignal);\n      }\n      const regionsLeft = this.regionSettings.regions.filter((region) => !this.attemptedRegions.find((attempted) => attempted.url === region.url));\n      if (regionsLeft.length > 0) {\n        const nextRegion = regionsLeft[0];\n        this.attemptedRegions.push(nextRegion);\n        livekitLogger.debug(\"next region: \".concat(nextRegion.region));\n        return nextRegion.url;\n      } else {\n        return null;\n      }\n    });\n  }\n  resetAttempts() {\n    this.attemptedRegions = [];\n  }\n  fetchRegionSettings(signal) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const regionSettingsResponse = yield fetch(\"\".concat(getCloudConfigUrl(this.serverUrl), \"/regions\"), {\n        headers: {\n          authorization: \"Bearer \".concat(this.token)\n        },\n        signal\n      });\n      if (regionSettingsResponse.ok) {\n        const regionSettings = yield regionSettingsResponse.json();\n        this.lastUpdateAt = Date.now();\n        return regionSettings;\n      } else {\n        throw new ConnectionError(\"Could not fetch region settings: \".concat(regionSettingsResponse.statusText), regionSettingsResponse.status === 401 ? 0 : void 0, regionSettingsResponse.status);\n      }\n    });\n  }\n};\nfunction getCloudConfigUrl(serverUrl) {\n  return \"\".concat(serverUrl.protocol.replace(\"ws\", \"http\"), \"//\").concat(serverUrl.host, \"/settings\");\n}\nvar VideoPreset = class {\n  constructor(width, height, maxBitrate, maxFramerate, priority) {\n    this.width = width;\n    this.height = height;\n    this.encoding = {\n      maxBitrate,\n      maxFramerate,\n      priority\n    };\n  }\n  get resolution() {\n    return {\n      width: this.width,\n      height: this.height,\n      frameRate: this.encoding.maxFramerate,\n      aspectRatio: this.width / this.height\n    };\n  }\n};\nvar backupCodecs = [\"vp8\", \"h264\"];\nfunction isBackupCodec(codec) {\n  return !!backupCodecs.find((backup) => backup === codec);\n}\nfunction isCodecEqual(c1, c2) {\n  return (c1 === null || c1 === void 0 ? void 0 : c1.toLowerCase().replace(/audio\\/|video\\//y, \"\")) === (c2 === null || c2 === void 0 ? void 0 : c2.toLowerCase().replace(/audio\\/|video\\//y, \"\"));\n}\nvar AudioPresets;\n(function(AudioPresets2) {\n  AudioPresets2.telephone = {\n    maxBitrate: 12e3\n  };\n  AudioPresets2.speech = {\n    maxBitrate: 2e4\n  };\n  AudioPresets2.music = {\n    maxBitrate: 32e3\n  };\n  AudioPresets2.musicStereo = {\n    maxBitrate: 48e3\n  };\n  AudioPresets2.musicHighQuality = {\n    maxBitrate: 64e3\n  };\n  AudioPresets2.musicHighQualityStereo = {\n    maxBitrate: 96e3\n  };\n})(AudioPresets || (AudioPresets = {}));\nvar VideoPresets = {\n  h90: new VideoPreset(160, 90, 6e4, 15),\n  h180: new VideoPreset(320, 180, 12e4, 15),\n  h216: new VideoPreset(384, 216, 18e4, 15),\n  h360: new VideoPreset(640, 360, 3e5, 20),\n  h540: new VideoPreset(960, 540, 6e5, 25),\n  h720: new VideoPreset(1280, 720, 17e5, 30),\n  h1080: new VideoPreset(1920, 1080, 3e6, 30),\n  h1440: new VideoPreset(2560, 1440, 5e6, 30),\n  h2160: new VideoPreset(3840, 2160, 8e6, 30)\n};\nvar VideoPresets43 = {\n  h120: new VideoPreset(160, 120, 8e4, 15),\n  h180: new VideoPreset(240, 180, 1e5, 15),\n  h240: new VideoPreset(320, 240, 15e4, 15),\n  h360: new VideoPreset(480, 360, 225e3, 20),\n  h480: new VideoPreset(640, 480, 3e5, 20),\n  h540: new VideoPreset(720, 540, 45e4, 25),\n  h720: new VideoPreset(960, 720, 15e5, 30),\n  h1080: new VideoPreset(1440, 1080, 25e5, 30),\n  h1440: new VideoPreset(1920, 1440, 35e5, 30)\n};\nvar ScreenSharePresets = {\n  h360fps3: new VideoPreset(640, 360, 2e5, 3, \"medium\"),\n  h720fps5: new VideoPreset(1280, 720, 4e5, 5, \"medium\"),\n  h720fps15: new VideoPreset(1280, 720, 1e6, 15, \"medium\"),\n  h1080fps15: new VideoPreset(1920, 1080, 15e5, 15, \"medium\"),\n  h1080fps30: new VideoPreset(1920, 1080, 3e6, 30, \"medium\")\n};\nvar publishDefaults = {\n  /**\n   * @deprecated\n   */\n  audioBitrate: AudioPresets.music.maxBitrate,\n  audioPreset: AudioPresets.music,\n  dtx: true,\n  red: true,\n  forceStereo: false,\n  simulcast: true,\n  screenShareEncoding: ScreenSharePresets.h1080fps15.encoding,\n  stopMicTrackOnMute: false,\n  videoCodec: \"vp8\",\n  backupCodec: {\n    codec: \"vp8\",\n    encoding: VideoPresets.h540.encoding\n  }\n};\nvar audioDefaults = {\n  autoGainControl: true,\n  echoCancellation: true,\n  noiseSuppression: true\n};\nvar videoDefaults = {\n  resolution: VideoPresets.h720.resolution\n};\nvar roomOptionDefaults = {\n  adaptiveStream: false,\n  dynacast: false,\n  stopLocalTrackOnUnpublish: true,\n  reconnectPolicy: new DefaultReconnectPolicy(),\n  disconnectOnPageLeave: true,\n  expWebAudioMix: false\n};\nvar roomConnectOptionDefaults = {\n  autoSubscribe: true,\n  maxRetries: 1,\n  peerConnectionTimeout: 15e3\n};\nvar RoomEvent;\n(function(RoomEvent2) {\n  RoomEvent2[\"Connected\"] = \"connected\";\n  RoomEvent2[\"Reconnecting\"] = \"reconnecting\";\n  RoomEvent2[\"Reconnected\"] = \"reconnected\";\n  RoomEvent2[\"Disconnected\"] = \"disconnected\";\n  RoomEvent2[\"ConnectionStateChanged\"] = \"connectionStateChanged\";\n  RoomEvent2[\"StateChanged\"] = \"connectionStateChanged\";\n  RoomEvent2[\"MediaDevicesChanged\"] = \"mediaDevicesChanged\";\n  RoomEvent2[\"ParticipantConnected\"] = \"participantConnected\";\n  RoomEvent2[\"ParticipantDisconnected\"] = \"participantDisconnected\";\n  RoomEvent2[\"TrackPublished\"] = \"trackPublished\";\n  RoomEvent2[\"TrackSubscribed\"] = \"trackSubscribed\";\n  RoomEvent2[\"TrackSubscriptionFailed\"] = \"trackSubscriptionFailed\";\n  RoomEvent2[\"TrackUnpublished\"] = \"trackUnpublished\";\n  RoomEvent2[\"TrackUnsubscribed\"] = \"trackUnsubscribed\";\n  RoomEvent2[\"TrackMuted\"] = \"trackMuted\";\n  RoomEvent2[\"TrackUnmuted\"] = \"trackUnmuted\";\n  RoomEvent2[\"LocalTrackPublished\"] = \"localTrackPublished\";\n  RoomEvent2[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n  RoomEvent2[\"LocalAudioSilenceDetected\"] = \"localAudioSilenceDetected\";\n  RoomEvent2[\"ActiveSpeakersChanged\"] = \"activeSpeakersChanged\";\n  RoomEvent2[\"ParticipantMetadataChanged\"] = \"participantMetadataChanged\";\n  RoomEvent2[\"ParticipantNameChanged\"] = \"participantNameChanged\";\n  RoomEvent2[\"RoomMetadataChanged\"] = \"roomMetadataChanged\";\n  RoomEvent2[\"DataReceived\"] = \"dataReceived\";\n  RoomEvent2[\"ConnectionQualityChanged\"] = \"connectionQualityChanged\";\n  RoomEvent2[\"TrackStreamStateChanged\"] = \"trackStreamStateChanged\";\n  RoomEvent2[\"TrackSubscriptionPermissionChanged\"] = \"trackSubscriptionPermissionChanged\";\n  RoomEvent2[\"TrackSubscriptionStatusChanged\"] = \"trackSubscriptionStatusChanged\";\n  RoomEvent2[\"AudioPlaybackStatusChanged\"] = \"audioPlaybackChanged\";\n  RoomEvent2[\"MediaDevicesError\"] = \"mediaDevicesError\";\n  RoomEvent2[\"ParticipantPermissionsChanged\"] = \"participantPermissionsChanged\";\n  RoomEvent2[\"SignalConnected\"] = \"signalConnected\";\n  RoomEvent2[\"RecordingStatusChanged\"] = \"recordingStatusChanged\";\n  RoomEvent2[\"DCBufferStatusChanged\"] = \"dcBufferStatusChanged\";\n})(RoomEvent || (RoomEvent = {}));\nvar ParticipantEvent;\n(function(ParticipantEvent2) {\n  ParticipantEvent2[\"TrackPublished\"] = \"trackPublished\";\n  ParticipantEvent2[\"TrackSubscribed\"] = \"trackSubscribed\";\n  ParticipantEvent2[\"TrackSubscriptionFailed\"] = \"trackSubscriptionFailed\";\n  ParticipantEvent2[\"TrackUnpublished\"] = \"trackUnpublished\";\n  ParticipantEvent2[\"TrackUnsubscribed\"] = \"trackUnsubscribed\";\n  ParticipantEvent2[\"TrackMuted\"] = \"trackMuted\";\n  ParticipantEvent2[\"TrackUnmuted\"] = \"trackUnmuted\";\n  ParticipantEvent2[\"LocalTrackPublished\"] = \"localTrackPublished\";\n  ParticipantEvent2[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n  ParticipantEvent2[\"ParticipantMetadataChanged\"] = \"participantMetadataChanged\";\n  ParticipantEvent2[\"ParticipantNameChanged\"] = \"participantNameChanged\";\n  ParticipantEvent2[\"DataReceived\"] = \"dataReceived\";\n  ParticipantEvent2[\"IsSpeakingChanged\"] = \"isSpeakingChanged\";\n  ParticipantEvent2[\"ConnectionQualityChanged\"] = \"connectionQualityChanged\";\n  ParticipantEvent2[\"TrackStreamStateChanged\"] = \"trackStreamStateChanged\";\n  ParticipantEvent2[\"TrackSubscriptionPermissionChanged\"] = \"trackSubscriptionPermissionChanged\";\n  ParticipantEvent2[\"TrackSubscriptionStatusChanged\"] = \"trackSubscriptionStatusChanged\";\n  ParticipantEvent2[\"MediaDevicesError\"] = \"mediaDevicesError\";\n  ParticipantEvent2[\"ParticipantPermissionsChanged\"] = \"participantPermissionsChanged\";\n})(ParticipantEvent || (ParticipantEvent = {}));\nvar EngineEvent;\n(function(EngineEvent2) {\n  EngineEvent2[\"TransportsCreated\"] = \"transportsCreated\";\n  EngineEvent2[\"Connected\"] = \"connected\";\n  EngineEvent2[\"Disconnected\"] = \"disconnected\";\n  EngineEvent2[\"Resuming\"] = \"resuming\";\n  EngineEvent2[\"Resumed\"] = \"resumed\";\n  EngineEvent2[\"Restarting\"] = \"restarting\";\n  EngineEvent2[\"Restarted\"] = \"restarted\";\n  EngineEvent2[\"SignalResumed\"] = \"signalResumed\";\n  EngineEvent2[\"SignalRestarted\"] = \"signalRestarted\";\n  EngineEvent2[\"Closing\"] = \"closing\";\n  EngineEvent2[\"MediaTrackAdded\"] = \"mediaTrackAdded\";\n  EngineEvent2[\"ActiveSpeakersUpdate\"] = \"activeSpeakersUpdate\";\n  EngineEvent2[\"DataPacketReceived\"] = \"dataPacketReceived\";\n  EngineEvent2[\"DCBufferStatusChanged\"] = \"dcBufferStatusChanged\";\n})(EngineEvent || (EngineEvent = {}));\nvar TrackEvent;\n(function(TrackEvent2) {\n  TrackEvent2[\"Message\"] = \"message\";\n  TrackEvent2[\"Muted\"] = \"muted\";\n  TrackEvent2[\"Unmuted\"] = \"unmuted\";\n  TrackEvent2[\"Restarted\"] = \"restarted\";\n  TrackEvent2[\"Ended\"] = \"ended\";\n  TrackEvent2[\"Subscribed\"] = \"subscribed\";\n  TrackEvent2[\"Unsubscribed\"] = \"unsubscribed\";\n  TrackEvent2[\"UpdateSettings\"] = \"updateSettings\";\n  TrackEvent2[\"UpdateSubscription\"] = \"updateSubscription\";\n  TrackEvent2[\"AudioPlaybackStarted\"] = \"audioPlaybackStarted\";\n  TrackEvent2[\"AudioPlaybackFailed\"] = \"audioPlaybackFailed\";\n  TrackEvent2[\"AudioSilenceDetected\"] = \"audioSilenceDetected\";\n  TrackEvent2[\"VisibilityChanged\"] = \"visibilityChanged\";\n  TrackEvent2[\"VideoDimensionsChanged\"] = \"videoDimensionsChanged\";\n  TrackEvent2[\"ElementAttached\"] = \"elementAttached\";\n  TrackEvent2[\"ElementDetached\"] = \"elementDetached\";\n  TrackEvent2[\"UpstreamPaused\"] = \"upstreamPaused\";\n  TrackEvent2[\"UpstreamResumed\"] = \"upstreamResumed\";\n  TrackEvent2[\"SubscriptionPermissionChanged\"] = \"subscriptionPermissionChanged\";\n  TrackEvent2[\"SubscriptionStatusChanged\"] = \"subscriptionStatusChanged\";\n})(TrackEvent || (TrackEvent = {}));\nvar BACKGROUND_REACTION_DELAY = 5e3;\nvar recycledElements = [];\nvar Track = class extends eventsExports.EventEmitter {\n  constructor(mediaTrack, kind) {\n    super();\n    this.attachedElements = [];\n    this.isMuted = false;\n    this.streamState = Track.StreamState.Active;\n    this.isInBackground = false;\n    this._currentBitrate = 0;\n    this.appVisibilityChangedListener = () => {\n      if (this.backgroundTimeout) {\n        clearTimeout(this.backgroundTimeout);\n      }\n      if (document.visibilityState === \"hidden\") {\n        this.backgroundTimeout = setTimeout(() => this.handleAppVisibilityChanged(), BACKGROUND_REACTION_DELAY);\n      } else {\n        this.handleAppVisibilityChanged();\n      }\n    };\n    this.setMaxListeners(100);\n    this.kind = kind;\n    this._mediaStreamTrack = mediaTrack;\n    this._mediaStreamID = mediaTrack.id;\n    this.source = Track.Source.Unknown;\n  }\n  /** current receive bits per second */\n  get currentBitrate() {\n    return this._currentBitrate;\n  }\n  get mediaStreamTrack() {\n    return this._mediaStreamTrack;\n  }\n  /**\n   * @internal\n   * used for keep mediaStream's first id, since it's id might change\n   * if we disable/enable a track\n   */\n  get mediaStreamID() {\n    return this._mediaStreamID;\n  }\n  attach(element) {\n    let elementType = \"audio\";\n    if (this.kind === Track.Kind.Video) {\n      elementType = \"video\";\n    }\n    if (this.attachedElements.length === 0 && Track.Kind.Video) {\n      this.addAppVisibilityListener();\n    }\n    if (!element) {\n      if (elementType === \"audio\") {\n        recycledElements.forEach((e) => {\n          if (e.parentElement === null && !element) {\n            element = e;\n          }\n        });\n        if (element) {\n          recycledElements.splice(recycledElements.indexOf(element), 1);\n        }\n      }\n      if (!element) {\n        element = document.createElement(elementType);\n      }\n    }\n    if (!this.attachedElements.includes(element)) {\n      this.attachedElements.push(element);\n    }\n    attachToElement(this._mediaStreamTrack, element);\n    const allMediaStreamTracks = element.srcObject.getTracks();\n    if (allMediaStreamTracks.some((tr) => tr.kind === \"audio\")) {\n      element.play().then(() => {\n        this.emit(TrackEvent.AudioPlaybackStarted);\n      }).catch((e) => {\n        if (e.name === \"NotAllowedError\") {\n          this.emit(TrackEvent.AudioPlaybackFailed, e);\n        } else {\n          livekitLogger.warn(\"could not playback audio\", e);\n        }\n        if (element && allMediaStreamTracks.some((tr) => tr.kind === \"video\") && e.name === \"NotAllowedError\") {\n          element.muted = true;\n          element.play().catch(() => {\n          });\n        }\n      });\n    }\n    this.emit(TrackEvent.ElementAttached, element);\n    return element;\n  }\n  detach(element) {\n    try {\n      if (element) {\n        detachTrack(this._mediaStreamTrack, element);\n        const idx = this.attachedElements.indexOf(element);\n        if (idx >= 0) {\n          this.attachedElements.splice(idx, 1);\n          this.recycleElement(element);\n          this.emit(TrackEvent.ElementDetached, element);\n        }\n        return element;\n      }\n      const detached = [];\n      this.attachedElements.forEach((elm) => {\n        detachTrack(this._mediaStreamTrack, elm);\n        detached.push(elm);\n        this.recycleElement(elm);\n        this.emit(TrackEvent.ElementDetached, elm);\n      });\n      this.attachedElements = [];\n      return detached;\n    } finally {\n      if (this.attachedElements.length === 0) {\n        this.removeAppVisibilityListener();\n      }\n    }\n  }\n  stop() {\n    this.stopMonitor();\n    this._mediaStreamTrack.stop();\n  }\n  enable() {\n    this._mediaStreamTrack.enabled = true;\n  }\n  disable() {\n    this._mediaStreamTrack.enabled = false;\n  }\n  /* @internal */\n  stopMonitor() {\n    if (this.monitorInterval) {\n      clearInterval(this.monitorInterval);\n    }\n  }\n  recycleElement(element) {\n    if (element instanceof HTMLAudioElement) {\n      let shouldCache = true;\n      element.pause();\n      recycledElements.forEach((e) => {\n        if (!e.parentElement) {\n          shouldCache = false;\n        }\n      });\n      if (shouldCache) {\n        recycledElements.push(element);\n      }\n    }\n  }\n  handleAppVisibilityChanged() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.isInBackground = document.visibilityState === \"hidden\";\n    });\n  }\n  addAppVisibilityListener() {\n    if (isWeb()) {\n      this.isInBackground = document.visibilityState === \"hidden\";\n      document.addEventListener(\"visibilitychange\", this.appVisibilityChangedListener);\n    } else {\n      this.isInBackground = false;\n    }\n  }\n  removeAppVisibilityListener() {\n    if (isWeb()) {\n      document.removeEventListener(\"visibilitychange\", this.appVisibilityChangedListener);\n    }\n  }\n};\nfunction attachToElement(track, element) {\n  let mediaStream;\n  if (element.srcObject instanceof MediaStream) {\n    mediaStream = element.srcObject;\n  } else {\n    mediaStream = new MediaStream();\n  }\n  let existingTracks;\n  if (track.kind === \"audio\") {\n    existingTracks = mediaStream.getAudioTracks();\n  } else {\n    existingTracks = mediaStream.getVideoTracks();\n  }\n  if (!existingTracks.includes(track)) {\n    existingTracks.forEach((et) => {\n      mediaStream.removeTrack(et);\n    });\n    mediaStream.addTrack(track);\n  }\n  element.autoplay = true;\n  element.muted = mediaStream.getAudioTracks().length === 0;\n  if (element instanceof HTMLVideoElement) {\n    element.playsInline = true;\n  }\n  if (element.srcObject !== mediaStream) {\n    element.srcObject = mediaStream;\n    if ((isSafari() || isFireFox()) && element instanceof HTMLVideoElement) {\n      setTimeout(() => {\n        element.srcObject = mediaStream;\n        element.play().catch(() => {\n        });\n      }, 0);\n    }\n  }\n}\nfunction detachTrack(track, element) {\n  if (element.srcObject instanceof MediaStream) {\n    const mediaStream = element.srcObject;\n    mediaStream.removeTrack(track);\n    if (mediaStream.getTracks().length > 0) {\n      element.srcObject = mediaStream;\n    } else {\n      element.srcObject = null;\n    }\n  }\n}\n(function(Track2) {\n  let Kind;\n  (function(Kind2) {\n    Kind2[\"Audio\"] = \"audio\";\n    Kind2[\"Video\"] = \"video\";\n    Kind2[\"Unknown\"] = \"unknown\";\n  })(Kind = Track2.Kind || (Track2.Kind = {}));\n  let Source;\n  (function(Source2) {\n    Source2[\"Camera\"] = \"camera\";\n    Source2[\"Microphone\"] = \"microphone\";\n    Source2[\"ScreenShare\"] = \"screen_share\";\n    Source2[\"ScreenShareAudio\"] = \"screen_share_audio\";\n    Source2[\"Unknown\"] = \"unknown\";\n  })(Source = Track2.Source || (Track2.Source = {}));\n  let StreamState$1;\n  (function(StreamState2) {\n    StreamState2[\"Active\"] = \"active\";\n    StreamState2[\"Paused\"] = \"paused\";\n    StreamState2[\"Unknown\"] = \"unknown\";\n  })(StreamState$1 = Track2.StreamState || (Track2.StreamState = {}));\n  function kindToProto(k) {\n    switch (k) {\n      case Kind.Audio:\n        return TrackType.AUDIO;\n      case Kind.Video:\n        return TrackType.VIDEO;\n      default:\n        return TrackType.UNRECOGNIZED;\n    }\n  }\n  Track2.kindToProto = kindToProto;\n  function kindFromProto(t) {\n    switch (t) {\n      case TrackType.AUDIO:\n        return Kind.Audio;\n      case TrackType.VIDEO:\n        return Kind.Video;\n      default:\n        return Kind.Unknown;\n    }\n  }\n  Track2.kindFromProto = kindFromProto;\n  function sourceToProto(s) {\n    switch (s) {\n      case Source.Camera:\n        return TrackSource.CAMERA;\n      case Source.Microphone:\n        return TrackSource.MICROPHONE;\n      case Source.ScreenShare:\n        return TrackSource.SCREEN_SHARE;\n      case Source.ScreenShareAudio:\n        return TrackSource.SCREEN_SHARE_AUDIO;\n      default:\n        return TrackSource.UNRECOGNIZED;\n    }\n  }\n  Track2.sourceToProto = sourceToProto;\n  function sourceFromProto(s) {\n    switch (s) {\n      case TrackSource.CAMERA:\n        return Source.Camera;\n      case TrackSource.MICROPHONE:\n        return Source.Microphone;\n      case TrackSource.SCREEN_SHARE:\n        return Source.ScreenShare;\n      case TrackSource.SCREEN_SHARE_AUDIO:\n        return Source.ScreenShareAudio;\n      default:\n        return Source.Unknown;\n    }\n  }\n  Track2.sourceFromProto = sourceFromProto;\n  function streamStateFromProto(s) {\n    switch (s) {\n      case StreamState.ACTIVE:\n        return StreamState$1.Active;\n      case StreamState.PAUSED:\n        return StreamState$1.Paused;\n      default:\n        return StreamState$1.Unknown;\n    }\n  }\n  Track2.streamStateFromProto = streamStateFromProto;\n})(Track || (Track = {}));\nvar lossyDataChannel = \"_lossy\";\nvar reliableDataChannel = \"_reliable\";\nvar minReconnectWait = 2 * 1e3;\nvar leaveReconnect = \"leave-reconnect\";\nvar PCState;\n(function(PCState2) {\n  PCState2[PCState2[\"New\"] = 0] = \"New\";\n  PCState2[PCState2[\"Connected\"] = 1] = \"Connected\";\n  PCState2[PCState2[\"Disconnected\"] = 2] = \"Disconnected\";\n  PCState2[PCState2[\"Reconnecting\"] = 3] = \"Reconnecting\";\n  PCState2[PCState2[\"Closed\"] = 4] = \"Closed\";\n})(PCState || (PCState = {}));\nvar RTCEngine = class extends eventsExports.EventEmitter {\n  get isClosed() {\n    return this._isClosed;\n  }\n  constructor(options) {\n    super();\n    this.options = options;\n    this.rtcConfig = {};\n    this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;\n    this.fullReconnectOnNext = false;\n    this.subscriberPrimary = false;\n    this.pcState = PCState.New;\n    this._isClosed = true;\n    this.pendingTrackResolvers = {};\n    this.hasPublished = false;\n    this.reconnectAttempts = 0;\n    this.reconnectStart = 0;\n    this.attemptingReconnect = false;\n    this.joinAttempts = 0;\n    this.maxJoinAttempts = 1;\n    this.shouldFailNext = false;\n    this.handleDataChannel = (_ref) => {\n      let {\n        channel\n      } = _ref;\n      return __awaiter(this, void 0, void 0, function* () {\n        if (!channel) {\n          return;\n        }\n        if (channel.label === reliableDataChannel) {\n          this.reliableDCSub = channel;\n        } else if (channel.label === lossyDataChannel) {\n          this.lossyDCSub = channel;\n        } else {\n          return;\n        }\n        livekitLogger.debug(\"on data channel \".concat(channel.id, \", \").concat(channel.label));\n        channel.onmessage = this.handleDataMessage;\n      });\n    };\n    this.handleDataMessage = (message) => __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      const unlock = yield this.dataProcessLock.lock();\n      try {\n        let buffer;\n        if (message.data instanceof ArrayBuffer) {\n          buffer = message.data;\n        } else if (message.data instanceof Blob) {\n          buffer = yield message.data.arrayBuffer();\n        } else {\n          livekitLogger.error(\"unsupported data type\", message.data);\n          return;\n        }\n        const dp = DataPacket.decode(new Uint8Array(buffer));\n        if (((_a = dp.value) === null || _a === void 0 ? void 0 : _a.$case) === \"speaker\") {\n          this.emit(EngineEvent.ActiveSpeakersUpdate, dp.value.speaker.speakers);\n        } else if (((_b = dp.value) === null || _b === void 0 ? void 0 : _b.$case) === \"user\") {\n          this.emit(EngineEvent.DataPacketReceived, dp.value.user, dp.kind);\n        }\n      } finally {\n        unlock();\n      }\n    });\n    this.handleDataError = (event) => {\n      const channel = event.currentTarget;\n      const channelKind = channel.maxRetransmits === 0 ? \"lossy\" : \"reliable\";\n      if (event instanceof ErrorEvent) {\n        const {\n          error\n        } = event.error;\n        livekitLogger.error(\"DataChannel error on \".concat(channelKind, \": \").concat(event.message), error);\n      } else {\n        livekitLogger.error(\"Unknown DataChannel Error on \".concat(channelKind), event);\n      }\n    };\n    this.handleBufferedAmountLow = (event) => {\n      const channel = event.currentTarget;\n      const channelKind = channel.maxRetransmits === 0 ? DataPacket_Kind.LOSSY : DataPacket_Kind.RELIABLE;\n      this.updateAndEmitDCBufferStatus(channelKind);\n    };\n    this.handleDisconnect = (connection, disconnectReason) => {\n      if (this._isClosed) {\n        return;\n      }\n      livekitLogger.warn(\"\".concat(connection, \" disconnected\"));\n      if (this.reconnectAttempts === 0) {\n        this.reconnectStart = Date.now();\n      }\n      const disconnect = (duration2) => {\n        livekitLogger.warn(\"could not recover connection after \".concat(this.reconnectAttempts, \" attempts, \").concat(duration2, \"ms. giving up\"));\n        this.emit(EngineEvent.Disconnected);\n        this.close();\n      };\n      const duration = Date.now() - this.reconnectStart;\n      let delay = this.getNextRetryDelay({\n        elapsedMs: duration,\n        retryCount: this.reconnectAttempts\n      });\n      if (delay === null) {\n        disconnect(duration);\n        return;\n      }\n      if (connection === leaveReconnect) {\n        delay = 0;\n      }\n      livekitLogger.debug(\"reconnecting in \".concat(delay, \"ms\"));\n      this.clearReconnectTimeout();\n      if (this.url && this.token && isCloud(new URL(this.url))) {\n        this.regionUrlProvider = new RegionUrlProvider(this.url, this.token);\n      }\n      this.reconnectTimeout = CriticalTimers.setTimeout(() => this.attemptReconnect(disconnectReason), delay);\n    };\n    this.waitForRestarted = () => {\n      return new Promise((resolve, reject) => {\n        if (this.pcState === PCState.Connected) {\n          resolve();\n        }\n        const onRestarted = () => {\n          this.off(EngineEvent.Disconnected, onDisconnected);\n          resolve();\n        };\n        const onDisconnected = () => {\n          this.off(EngineEvent.Restarted, onRestarted);\n          reject();\n        };\n        this.once(EngineEvent.Restarted, onRestarted);\n        this.once(EngineEvent.Disconnected, onDisconnected);\n      });\n    };\n    this.updateAndEmitDCBufferStatus = (kind) => {\n      const status = this.isBufferStatusLow(kind);\n      if (typeof status !== \"undefined\" && status !== this.dcBufferStatus.get(kind)) {\n        this.dcBufferStatus.set(kind, status);\n        this.emit(EngineEvent.DCBufferStatusChanged, status, kind);\n      }\n    };\n    this.isBufferStatusLow = (kind) => {\n      const dc = this.dataChannelForKind(kind);\n      if (dc) {\n        return dc.bufferedAmount <= dc.bufferedAmountLowThreshold;\n      }\n    };\n    this.handleBrowserOnLine = () => {\n      if (this.client.isReconnecting) {\n        this.clearReconnectTimeout();\n        this.attemptReconnect(ReconnectReason.RR_SIGNAL_DISCONNECTED);\n      }\n    };\n    this.client = new SignalClient();\n    this.client.signalLatency = this.options.expSignalLatency;\n    this.reconnectPolicy = this.options.reconnectPolicy;\n    this.registerOnLineListener();\n    this.closingLock = new Mutex();\n    this.dataProcessLock = new Mutex();\n    this.dcBufferStatus = /* @__PURE__ */ new Map([[DataPacket_Kind.LOSSY, true], [DataPacket_Kind.RELIABLE, true]]);\n  }\n  join(url, token, opts, abortSignal) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.url = url;\n      this.token = token;\n      this.signalOpts = opts;\n      try {\n        this.joinAttempts += 1;\n        const joinResponse = yield this.client.join(url, token, opts, abortSignal);\n        this._isClosed = false;\n        this.latestJoinResponse = joinResponse;\n        this.subscriberPrimary = joinResponse.subscriberPrimary;\n        if (!this.publisher) {\n          this.configure(joinResponse);\n        }\n        if (!this.subscriberPrimary) {\n          this.negotiate();\n        }\n        this.clientConfiguration = joinResponse.clientConfiguration;\n        return joinResponse;\n      } catch (e) {\n        if (e instanceof ConnectionError) {\n          if (e.reason === 1) {\n            livekitLogger.warn(\"Couldn't connect to server, attempt \".concat(this.joinAttempts, \" of \").concat(this.maxJoinAttempts));\n            if (this.joinAttempts < this.maxJoinAttempts) {\n              return this.join(url, token, opts, abortSignal);\n            }\n          }\n        }\n        throw e;\n      }\n    });\n  }\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.closingLock.lock();\n      if (this.isClosed) {\n        unlock();\n        return;\n      }\n      try {\n        this._isClosed = true;\n        this.emit(EngineEvent.Closing);\n        this.removeAllListeners();\n        this.deregisterOnLineListener();\n        this.clearPendingReconnect();\n        if (this.publisher && this.publisher.pc.signalingState !== \"closed\") {\n          this.publisher.pc.getSenders().forEach((sender) => {\n            var _a, _b;\n            try {\n              if ((_a = this.publisher) === null || _a === void 0 ? void 0 : _a.pc.removeTrack) {\n                (_b = this.publisher) === null || _b === void 0 ? void 0 : _b.pc.removeTrack(sender);\n              }\n            } catch (e) {\n              livekitLogger.warn(\"could not removeTrack\", {\n                error: e\n              });\n            }\n          });\n          this.publisher.close();\n          this.publisher = void 0;\n        }\n        if (this.subscriber) {\n          this.subscriber.close();\n          this.subscriber = void 0;\n        }\n        yield this.client.close();\n      } finally {\n        unlock();\n      }\n    });\n  }\n  addTrack(req) {\n    if (this.pendingTrackResolvers[req.cid]) {\n      throw new TrackInvalidError(\"a track with the same ID has already been published\");\n    }\n    return new Promise((resolve, reject) => {\n      const publicationTimeout = setTimeout(() => {\n        delete this.pendingTrackResolvers[req.cid];\n        reject(new ConnectionError(\"publication of local track timed out, no response from server\"));\n      }, 1e4);\n      this.pendingTrackResolvers[req.cid] = {\n        resolve: (info) => {\n          clearTimeout(publicationTimeout);\n          resolve(info);\n        },\n        reject: () => {\n          clearTimeout(publicationTimeout);\n          reject(new Error(\"Cancelled publication by calling unpublish\"));\n        }\n      };\n      this.client.sendAddTrack(req);\n    });\n  }\n  /**\n   * Removes sender from PeerConnection, returning true if it was removed successfully\n   * and a negotiation is necessary\n   * @param sender\n   * @returns\n   */\n  removeTrack(sender) {\n    var _a;\n    if (sender.track && this.pendingTrackResolvers[sender.track.id]) {\n      const {\n        reject\n      } = this.pendingTrackResolvers[sender.track.id];\n      if (reject) {\n        reject();\n      }\n      delete this.pendingTrackResolvers[sender.track.id];\n    }\n    try {\n      (_a = this.publisher) === null || _a === void 0 ? void 0 : _a.pc.removeTrack(sender);\n      return true;\n    } catch (e) {\n      livekitLogger.warn(\"failed to remove track\", {\n        error: e,\n        method: \"removeTrack\"\n      });\n    }\n    return false;\n  }\n  updateMuteStatus(trackSid, muted) {\n    this.client.sendMuteTrack(trackSid, muted);\n  }\n  get dataSubscriberReadyState() {\n    var _a;\n    return (_a = this.reliableDCSub) === null || _a === void 0 ? void 0 : _a.readyState;\n  }\n  getConnectedServerAddress() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.primaryPC === void 0) {\n        return void 0;\n      }\n      return getConnectedAddress(this.primaryPC);\n    });\n  }\n  configure(joinResponse) {\n    var _a;\n    if (this.publisher || this.subscriber) {\n      return;\n    }\n    this.participantSid = (_a = joinResponse.participant) === null || _a === void 0 ? void 0 : _a.sid;\n    const rtcConfig = this.makeRTCConfiguration(joinResponse);\n    const googConstraints = {\n      optional: [{\n        googDscp: true\n      }]\n    };\n    this.publisher = new PCTransport(rtcConfig, googConstraints);\n    this.subscriber = new PCTransport(rtcConfig);\n    this.emit(EngineEvent.TransportsCreated, this.publisher, this.subscriber);\n    this.publisher.pc.onicecandidate = (ev) => {\n      if (!ev.candidate)\n        return;\n      livekitLogger.trace(\"adding ICE candidate for peer\", ev.candidate);\n      this.client.sendIceCandidate(ev.candidate, SignalTarget.PUBLISHER);\n    };\n    this.subscriber.pc.onicecandidate = (ev) => {\n      if (!ev.candidate)\n        return;\n      this.client.sendIceCandidate(ev.candidate, SignalTarget.SUBSCRIBER);\n    };\n    this.publisher.onOffer = (offer) => {\n      this.client.sendOffer(offer);\n    };\n    let primaryPC = this.publisher.pc;\n    let secondaryPC = this.subscriber.pc;\n    let subscriberPrimary = joinResponse.subscriberPrimary;\n    if (subscriberPrimary) {\n      primaryPC = this.subscriber.pc;\n      secondaryPC = this.publisher.pc;\n      this.subscriber.pc.ondatachannel = this.handleDataChannel;\n    }\n    this.primaryPC = primaryPC;\n    primaryPC.onconnectionstatechange = () => __awaiter(this, void 0, void 0, function* () {\n      livekitLogger.debug(\"primary PC state changed \".concat(primaryPC.connectionState));\n      if (primaryPC.connectionState === \"connected\") {\n        const shouldEmit = this.pcState === PCState.New;\n        this.pcState = PCState.Connected;\n        if (shouldEmit) {\n          this.emit(EngineEvent.Connected, joinResponse);\n        }\n      } else if (primaryPC.connectionState === \"failed\") {\n        if (this.pcState === PCState.Connected) {\n          this.pcState = PCState.Disconnected;\n          this.handleDisconnect(\"primary peerconnection\", subscriberPrimary ? ReconnectReason.RR_SUBSCRIBER_FAILED : ReconnectReason.RR_PUBLISHER_FAILED);\n        }\n      }\n    });\n    secondaryPC.onconnectionstatechange = () => __awaiter(this, void 0, void 0, function* () {\n      livekitLogger.debug(\"secondary PC state changed \".concat(secondaryPC.connectionState));\n      if (secondaryPC.connectionState === \"failed\") {\n        this.handleDisconnect(\"secondary peerconnection\", subscriberPrimary ? ReconnectReason.RR_PUBLISHER_FAILED : ReconnectReason.RR_SUBSCRIBER_FAILED);\n      }\n    });\n    this.subscriber.pc.ontrack = (ev) => {\n      this.emit(EngineEvent.MediaTrackAdded, ev.track, ev.streams[0], ev.receiver);\n    };\n    this.createDataChannels();\n    this.client.onAnswer = (sd) => __awaiter(this, void 0, void 0, function* () {\n      if (!this.publisher) {\n        return;\n      }\n      livekitLogger.debug(\"received server answer\", {\n        RTCSdpType: sd.type,\n        signalingState: this.publisher.pc.signalingState\n      });\n      yield this.publisher.setRemoteDescription(sd);\n    });\n    this.client.onTrickle = (candidate, target) => {\n      if (!this.publisher || !this.subscriber) {\n        return;\n      }\n      livekitLogger.trace(\"got ICE candidate from peer\", {\n        candidate,\n        target\n      });\n      if (target === SignalTarget.PUBLISHER) {\n        this.publisher.addIceCandidate(candidate);\n      } else {\n        this.subscriber.addIceCandidate(candidate);\n      }\n    };\n    this.client.onOffer = (sd) => __awaiter(this, void 0, void 0, function* () {\n      if (!this.subscriber) {\n        return;\n      }\n      livekitLogger.debug(\"received server offer\", {\n        RTCSdpType: sd.type,\n        signalingState: this.subscriber.pc.signalingState\n      });\n      yield this.subscriber.setRemoteDescription(sd);\n      const answer = yield this.subscriber.createAndSetAnswer();\n      this.client.sendAnswer(answer);\n    });\n    this.client.onLocalTrackPublished = (res) => {\n      livekitLogger.debug(\"received trackPublishedResponse\", res);\n      const {\n        resolve\n      } = this.pendingTrackResolvers[res.cid];\n      if (!resolve) {\n        livekitLogger.error(\"missing track resolver for \".concat(res.cid));\n        return;\n      }\n      delete this.pendingTrackResolvers[res.cid];\n      resolve(res.track);\n    };\n    this.client.onTokenRefresh = (token) => {\n      this.token = token;\n    };\n    this.client.onClose = () => {\n      this.handleDisconnect(\"signal\", ReconnectReason.RR_SIGNAL_DISCONNECTED);\n    };\n    this.client.onLeave = (leave) => {\n      if (leave === null || leave === void 0 ? void 0 : leave.canReconnect) {\n        this.fullReconnectOnNext = true;\n        this.primaryPC = void 0;\n        this.handleDisconnect(leaveReconnect);\n      } else {\n        this.emit(EngineEvent.Disconnected, leave === null || leave === void 0 ? void 0 : leave.reason);\n        this.close();\n      }\n      livekitLogger.trace(\"leave request\", {\n        leave\n      });\n    };\n  }\n  makeRTCConfiguration(serverResponse) {\n    const rtcConfig = Object.assign({}, this.rtcConfig);\n    if (serverResponse.iceServers && !rtcConfig.iceServers) {\n      const rtcIceServers = [];\n      serverResponse.iceServers.forEach((iceServer) => {\n        const rtcIceServer = {\n          urls: iceServer.urls\n        };\n        if (iceServer.username)\n          rtcIceServer.username = iceServer.username;\n        if (iceServer.credential) {\n          rtcIceServer.credential = iceServer.credential;\n        }\n        rtcIceServers.push(rtcIceServer);\n      });\n      rtcConfig.iceServers = rtcIceServers;\n    }\n    if (serverResponse.clientConfiguration && serverResponse.clientConfiguration.forceRelay === ClientConfigSetting.ENABLED) {\n      rtcConfig.iceTransportPolicy = \"relay\";\n    }\n    rtcConfig.sdpSemantics = \"unified-plan\";\n    rtcConfig.continualGatheringPolicy = \"gather_continually\";\n    return rtcConfig;\n  }\n  createDataChannels() {\n    if (!this.publisher) {\n      return;\n    }\n    if (this.lossyDC) {\n      this.lossyDC.onmessage = null;\n      this.lossyDC.onerror = null;\n    }\n    if (this.reliableDC) {\n      this.reliableDC.onmessage = null;\n      this.reliableDC.onerror = null;\n    }\n    this.lossyDC = this.publisher.pc.createDataChannel(lossyDataChannel, {\n      // will drop older packets that arrive\n      ordered: true,\n      maxRetransmits: 0\n    });\n    this.reliableDC = this.publisher.pc.createDataChannel(reliableDataChannel, {\n      ordered: true\n    });\n    this.lossyDC.onmessage = this.handleDataMessage;\n    this.reliableDC.onmessage = this.handleDataMessage;\n    this.lossyDC.onerror = this.handleDataError;\n    this.reliableDC.onerror = this.handleDataError;\n    this.lossyDC.bufferedAmountLowThreshold = 65535;\n    this.reliableDC.bufferedAmountLowThreshold = 65535;\n    this.lossyDC.onbufferedamountlow = this.handleBufferedAmountLow;\n    this.reliableDC.onbufferedamountlow = this.handleBufferedAmountLow;\n  }\n  setPreferredCodec(transceiver, kind, videoCodec) {\n    if (!(\"getCapabilities\" in RTCRtpSender)) {\n      return;\n    }\n    const cap = RTCRtpSender.getCapabilities(kind);\n    if (!cap)\n      return;\n    livekitLogger.debug(\"get capabilities\", cap);\n    const matched = [];\n    const partialMatched = [];\n    const unmatched = [];\n    cap.codecs.forEach((c) => {\n      const codec = c.mimeType.toLowerCase();\n      if (codec === \"audio/opus\") {\n        matched.push(c);\n        return;\n      }\n      const matchesVideoCodec = codec === \"video/\".concat(videoCodec);\n      if (!matchesVideoCodec) {\n        unmatched.push(c);\n        return;\n      }\n      if (videoCodec === \"h264\") {\n        if (c.sdpFmtpLine && c.sdpFmtpLine.includes(\"profile-level-id=42e01f\")) {\n          matched.push(c);\n        } else {\n          partialMatched.push(c);\n        }\n        return;\n      }\n      matched.push(c);\n    });\n    if (supportsSetCodecPreferences(transceiver)) {\n      transceiver.setCodecPreferences(matched.concat(partialMatched, unmatched));\n    }\n  }\n  createSender(track, opts, encodings) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (supportsTransceiver()) {\n        return this.createTransceiverRTCRtpSender(track, opts, encodings);\n      }\n      if (supportsAddTrack()) {\n        livekitLogger.debug(\"using add-track fallback\");\n        return this.createRTCRtpSender(track.mediaStreamTrack);\n      }\n      throw new UnexpectedConnectionState(\"Required webRTC APIs not supported on this device\");\n    });\n  }\n  createSimulcastSender(track, simulcastTrack, opts, encodings) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (supportsTransceiver()) {\n        return this.createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings);\n      }\n      if (supportsAddTrack()) {\n        livekitLogger.debug(\"using add-track fallback\");\n        return this.createRTCRtpSender(track.mediaStreamTrack);\n      }\n      throw new UnexpectedConnectionState(\"Cannot stream on this device\");\n    });\n  }\n  createTransceiverRTCRtpSender(track, opts, encodings) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.publisher) {\n        throw new UnexpectedConnectionState(\"publisher is closed\");\n      }\n      const transceiverInit = {\n        direction: \"sendonly\"\n      };\n      if (encodings) {\n        transceiverInit.sendEncodings = encodings;\n      }\n      const transceiver = yield this.publisher.pc.addTransceiver(track.mediaStreamTrack, transceiverInit);\n      if (track.kind === Track.Kind.Video && opts.videoCodec) {\n        this.setPreferredCodec(transceiver, track.kind, opts.videoCodec);\n        track.codec = opts.videoCodec;\n      }\n      return transceiver.sender;\n    });\n  }\n  createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.publisher) {\n        throw new UnexpectedConnectionState(\"publisher is closed\");\n      }\n      const transceiverInit = {\n        direction: \"sendonly\"\n      };\n      if (encodings) {\n        transceiverInit.sendEncodings = encodings;\n      }\n      const transceiver = yield this.publisher.pc.addTransceiver(simulcastTrack.mediaStreamTrack, transceiverInit);\n      if (!opts.videoCodec) {\n        return;\n      }\n      this.setPreferredCodec(transceiver, track.kind, opts.videoCodec);\n      track.setSimulcastTrackSender(opts.videoCodec, transceiver.sender);\n      return transceiver.sender;\n    });\n  }\n  createRTCRtpSender(track) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.publisher) {\n        throw new UnexpectedConnectionState(\"publisher is closed\");\n      }\n      return this.publisher.pc.addTrack(track);\n    });\n  }\n  attemptReconnect(reason) {\n    var _a, _b, _c;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._isClosed) {\n        return;\n      }\n      if (this.attemptingReconnect) {\n        return;\n      }\n      if (((_a = this.clientConfiguration) === null || _a === void 0 ? void 0 : _a.resumeConnection) === ClientConfigSetting.DISABLED || // signaling state could change to closed due to hardware sleep\n      // those connections cannot be resumed\n      ((_c = (_b = this.primaryPC) === null || _b === void 0 ? void 0 : _b.signalingState) !== null && _c !== void 0 ? _c : \"closed\") === \"closed\") {\n        this.fullReconnectOnNext = true;\n      }\n      try {\n        this.attemptingReconnect = true;\n        if (this.fullReconnectOnNext) {\n          yield this.restartConnection();\n        } else {\n          yield this.resumeConnection(reason);\n        }\n        this.clearPendingReconnect();\n        this.fullReconnectOnNext = false;\n      } catch (e) {\n        this.reconnectAttempts += 1;\n        let recoverable = true;\n        if (e instanceof UnexpectedConnectionState) {\n          livekitLogger.debug(\"received unrecoverable error\", {\n            error: e\n          });\n          recoverable = false;\n        } else if (!(e instanceof SignalReconnectError)) {\n          this.fullReconnectOnNext = true;\n        }\n        if (recoverable) {\n          this.handleDisconnect(\"reconnect\", ReconnectReason.RR_UNKOWN);\n        } else {\n          livekitLogger.info(\"could not recover connection after \".concat(this.reconnectAttempts, \" attempts, \").concat(Date.now() - this.reconnectStart, \"ms. giving up\"));\n          this.emit(EngineEvent.Disconnected);\n          yield this.close();\n        }\n      } finally {\n        this.attemptingReconnect = false;\n      }\n    });\n  }\n  getNextRetryDelay(context) {\n    try {\n      return this.reconnectPolicy.nextRetryDelayInMs(context);\n    } catch (e) {\n      livekitLogger.warn(\"encountered error in reconnect policy\", {\n        error: e\n      });\n    }\n    return null;\n  }\n  restartConnection(regionUrl) {\n    var _a, _b, _c, _d, _e;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!this.url || !this.token) {\n          throw new UnexpectedConnectionState(\"could not reconnect, url or token not saved\");\n        }\n        livekitLogger.info(\"reconnecting, attempt: \".concat(this.reconnectAttempts));\n        this.emit(EngineEvent.Restarting);\n        if (this.client.isConnected) {\n          yield this.client.sendLeave();\n        }\n        yield this.client.close();\n        this.primaryPC = void 0;\n        (_a = this.publisher) === null || _a === void 0 ? void 0 : _a.close();\n        this.publisher = void 0;\n        (_b = this.subscriber) === null || _b === void 0 ? void 0 : _b.close();\n        this.subscriber = void 0;\n        let joinResponse;\n        try {\n          if (!this.signalOpts) {\n            livekitLogger.warn(\"attempted connection restart, without signal options present\");\n            throw new SignalReconnectError();\n          }\n          joinResponse = yield this.join(regionUrl !== null && regionUrl !== void 0 ? regionUrl : this.url, this.token, this.signalOpts);\n        } catch (e) {\n          if (e instanceof ConnectionError && e.reason === 0) {\n            throw new UnexpectedConnectionState(\"could not reconnect, token might be expired\");\n          }\n          throw new SignalReconnectError();\n        }\n        if (this.shouldFailNext) {\n          this.shouldFailNext = false;\n          throw new Error(\"simulated failure\");\n        }\n        this.client.setReconnected();\n        this.emit(EngineEvent.SignalRestarted, joinResponse);\n        yield this.waitForPCReconnected();\n        (_c = this.regionUrlProvider) === null || _c === void 0 ? void 0 : _c.resetAttempts();\n        this.emit(EngineEvent.Restarted);\n      } catch (error) {\n        const nextRegionUrl = yield (_d = this.regionUrlProvider) === null || _d === void 0 ? void 0 : _d.getNextBestRegionUrl();\n        if (nextRegionUrl) {\n          yield this.restartConnection(nextRegionUrl);\n          return;\n        } else {\n          (_e = this.regionUrlProvider) === null || _e === void 0 ? void 0 : _e.resetAttempts();\n          throw error;\n        }\n      }\n    });\n  }\n  resumeConnection(reason) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.url || !this.token) {\n        throw new UnexpectedConnectionState(\"could not reconnect, url or token not saved\");\n      }\n      if (!this.publisher || !this.subscriber) {\n        throw new UnexpectedConnectionState(\"publisher and subscriber connections unset\");\n      }\n      livekitLogger.info(\"resuming signal connection, attempt \".concat(this.reconnectAttempts));\n      this.emit(EngineEvent.Resuming);\n      try {\n        const res = yield this.client.reconnect(this.url, this.token, this.participantSid, reason);\n        if (res) {\n          const rtcConfig = this.makeRTCConfiguration(res);\n          this.publisher.pc.setConfiguration(rtcConfig);\n          this.subscriber.pc.setConfiguration(rtcConfig);\n        }\n      } catch (e) {\n        let message = \"\";\n        if (e instanceof Error) {\n          message = e.message;\n        }\n        if (e instanceof ConnectionError && e.reason === 0) {\n          throw new UnexpectedConnectionState(\"could not reconnect, token might be expired\");\n        }\n        throw new SignalReconnectError(message);\n      }\n      this.emit(EngineEvent.SignalResumed);\n      if (this.shouldFailNext) {\n        this.shouldFailNext = false;\n        throw new Error(\"simulated failure\");\n      }\n      this.subscriber.restartingIce = true;\n      if (this.hasPublished) {\n        yield this.publisher.createAndSendOffer({\n          iceRestart: true\n        });\n      }\n      yield this.waitForPCReconnected();\n      this.client.setReconnected();\n      if (((_a = this.reliableDC) === null || _a === void 0 ? void 0 : _a.readyState) === \"open\" && this.reliableDC.id === null) {\n        this.createDataChannels();\n      }\n      this.emit(EngineEvent.Resumed);\n    });\n  }\n  waitForPCInitialConnection(timeout, abortController) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.pcState === PCState.Connected) {\n        return;\n      }\n      if (this.pcState !== PCState.New) {\n        throw new UnexpectedConnectionState(\"Expected peer connection to be new on initial connection\");\n      }\n      return new Promise((resolve, reject) => {\n        const abortHandler = () => {\n          livekitLogger.warn(\"closing engine\");\n          CriticalTimers.clearTimeout(connectTimeout);\n          reject(new ConnectionError(\n            \"room connection has been cancelled\",\n            3\n            /* ConnectionErrorReason.Cancelled */\n          ));\n        };\n        if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {\n          abortHandler();\n        }\n        abortController === null || abortController === void 0 ? void 0 : abortController.signal.addEventListener(\"abort\", abortHandler);\n        const onConnected = () => {\n          CriticalTimers.clearTimeout(connectTimeout);\n          abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener(\"abort\", abortHandler);\n          resolve();\n        };\n        const connectTimeout = CriticalTimers.setTimeout(() => {\n          this.off(EngineEvent.Connected, onConnected);\n          reject(new ConnectionError(\"could not establish pc connection\"));\n        }, timeout !== null && timeout !== void 0 ? timeout : this.peerConnectionTimeout);\n        this.once(EngineEvent.Connected, onConnected);\n      });\n    });\n  }\n  waitForPCReconnected() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const startTime = Date.now();\n      let now = startTime;\n      this.pcState = PCState.Reconnecting;\n      livekitLogger.debug(\"waiting for peer connection to reconnect\");\n      while (now - startTime < this.peerConnectionTimeout) {\n        if (this.primaryPC === void 0) {\n          break;\n        } else if (\n          // on Safari, we don't get a connectionstatechanged event during ICE restart\n          // this means we'd have to check its status manually and update address\n          // manually\n          now - startTime > minReconnectWait && ((_a = this.primaryPC) === null || _a === void 0 ? void 0 : _a.connectionState) === \"connected\"\n        ) {\n          this.pcState = PCState.Connected;\n        }\n        if (this.pcState === PCState.Connected) {\n          return;\n        }\n        yield sleep(100);\n        now = Date.now();\n      }\n      throw new ConnectionError(\"could not establish PC connection\");\n    });\n  }\n  /* @internal */\n  sendDataPacket(packet, kind) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const msg = DataPacket.encode(packet).finish();\n      yield this.ensurePublisherConnected(kind);\n      const dc = this.dataChannelForKind(kind);\n      if (dc) {\n        dc.send(msg);\n      }\n      this.updateAndEmitDCBufferStatus(kind);\n    });\n  }\n  /**\n   * @internal\n   */\n  ensureDataTransportConnected(kind) {\n    let subscriber = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.subscriberPrimary;\n    var _a, _b, _c;\n    return __awaiter(this, void 0, void 0, function* () {\n      const transport = subscriber ? this.subscriber : this.publisher;\n      const transportName = subscriber ? \"Subscriber\" : \"Publisher\";\n      if (!transport) {\n        throw new ConnectionError(\"\".concat(transportName, \" connection not set\"));\n      }\n      if (!subscriber && !((_a = this.publisher) === null || _a === void 0 ? void 0 : _a.isICEConnected) && ((_b = this.publisher) === null || _b === void 0 ? void 0 : _b.pc.iceConnectionState) !== \"checking\") {\n        this.negotiate();\n      }\n      const targetChannel = this.dataChannelForKind(kind, subscriber);\n      if ((targetChannel === null || targetChannel === void 0 ? void 0 : targetChannel.readyState) === \"open\") {\n        return;\n      }\n      const endTime = (/* @__PURE__ */ new Date()).getTime() + this.peerConnectionTimeout;\n      while ((/* @__PURE__ */ new Date()).getTime() < endTime) {\n        if (transport.isICEConnected && ((_c = this.dataChannelForKind(kind, subscriber)) === null || _c === void 0 ? void 0 : _c.readyState) === \"open\") {\n          return;\n        }\n        yield sleep(50);\n      }\n      throw new ConnectionError(\"could not establish \".concat(transportName, \" connection, state: \").concat(transport.pc.iceConnectionState));\n    });\n  }\n  ensurePublisherConnected(kind) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.ensureDataTransportConnected(kind, false);\n    });\n  }\n  /* @internal */\n  verifyTransport() {\n    if (!this.primaryPC) {\n      return false;\n    }\n    if (this.primaryPC.connectionState === \"closed\" || this.primaryPC.connectionState === \"failed\") {\n      return false;\n    }\n    if (this.hasPublished && this.subscriberPrimary) {\n      if (!this.publisher) {\n        return false;\n      }\n      if (this.publisher.pc.connectionState === \"closed\" || this.publisher.pc.connectionState === \"failed\") {\n        return false;\n      }\n    }\n    if (!this.client.ws || this.client.ws.readyState === WebSocket.CLOSED) {\n      return false;\n    }\n    return true;\n  }\n  /** @internal */\n  negotiate() {\n    return new Promise((resolve, reject) => {\n      if (!this.publisher) {\n        reject(new NegotiationError(\"publisher is not defined\"));\n        return;\n      }\n      this.hasPublished = true;\n      const handleClosed = () => {\n        livekitLogger.debug(\"engine disconnected while negotiation was ongoing\");\n        cleanup();\n        resolve();\n        return;\n      };\n      this.on(EngineEvent.Closing, handleClosed);\n      const negotiationTimeout = setTimeout(() => {\n        reject(\"negotiation timed out\");\n        this.handleDisconnect(\"negotiation\", ReconnectReason.RR_SIGNAL_DISCONNECTED);\n      }, this.peerConnectionTimeout);\n      const cleanup = () => {\n        clearTimeout(negotiationTimeout);\n        this.off(EngineEvent.Closing, handleClosed);\n      };\n      this.publisher.once(PCEvents.NegotiationStarted, () => {\n        var _a;\n        (_a = this.publisher) === null || _a === void 0 ? void 0 : _a.once(PCEvents.NegotiationComplete, () => {\n          cleanup();\n          resolve();\n        });\n      });\n      this.publisher.negotiate((e) => {\n        cleanup();\n        reject(e);\n        if (e instanceof NegotiationError) {\n          this.fullReconnectOnNext = true;\n        }\n        this.handleDisconnect(\"negotiation\", ReconnectReason.RR_UNKOWN);\n      });\n    });\n  }\n  dataChannelForKind(kind, sub) {\n    if (!sub) {\n      if (kind === DataPacket_Kind.LOSSY) {\n        return this.lossyDC;\n      }\n      if (kind === DataPacket_Kind.RELIABLE) {\n        return this.reliableDC;\n      }\n    } else {\n      if (kind === DataPacket_Kind.LOSSY) {\n        return this.lossyDCSub;\n      }\n      if (kind === DataPacket_Kind.RELIABLE) {\n        return this.reliableDCSub;\n      }\n    }\n  }\n  /* @internal */\n  failNext() {\n    this.shouldFailNext = true;\n  }\n  clearReconnectTimeout() {\n    if (this.reconnectTimeout) {\n      CriticalTimers.clearTimeout(this.reconnectTimeout);\n    }\n  }\n  clearPendingReconnect() {\n    this.clearReconnectTimeout();\n    this.reconnectAttempts = 0;\n  }\n  registerOnLineListener() {\n    if (isWeb()) {\n      window.addEventListener(\"online\", this.handleBrowserOnLine);\n    }\n  }\n  deregisterOnLineListener() {\n    if (isWeb()) {\n      window.removeEventListener(\"online\", this.handleBrowserOnLine);\n    }\n  }\n};\nfunction getConnectedAddress(pc) {\n  var _a;\n  return __awaiter(this, void 0, void 0, function* () {\n    let selectedCandidatePairId = \"\";\n    const candidatePairs = /* @__PURE__ */ new Map();\n    const candidates = /* @__PURE__ */ new Map();\n    const stats = yield pc.getStats();\n    stats.forEach((v) => {\n      switch (v.type) {\n        case \"transport\":\n          selectedCandidatePairId = v.selectedCandidatePairId;\n          break;\n        case \"candidate-pair\":\n          if (selectedCandidatePairId === \"\" && v.selected) {\n            selectedCandidatePairId = v.id;\n          }\n          candidatePairs.set(v.id, v);\n          break;\n        case \"remote-candidate\":\n          candidates.set(v.id, \"\".concat(v.address, \":\").concat(v.port));\n          break;\n      }\n    });\n    if (selectedCandidatePairId === \"\") {\n      return void 0;\n    }\n    const selectedID = (_a = candidatePairs.get(selectedCandidatePairId)) === null || _a === void 0 ? void 0 : _a.remoteCandidateId;\n    if (selectedID === void 0) {\n      return void 0;\n    }\n    return candidates.get(selectedID);\n  });\n}\nvar SignalReconnectError = class extends Error {\n};\nvar monitorFrequency = 2e3;\nfunction computeBitrate(currentStats, prevStats) {\n  if (!prevStats) {\n    return 0;\n  }\n  let bytesNow;\n  let bytesPrev;\n  if (\"bytesReceived\" in currentStats) {\n    bytesNow = currentStats.bytesReceived;\n    bytesPrev = prevStats.bytesReceived;\n  } else if (\"bytesSent\" in currentStats) {\n    bytesNow = currentStats.bytesSent;\n    bytesPrev = prevStats.bytesSent;\n  }\n  if (bytesNow === void 0 || bytesPrev === void 0 || currentStats.timestamp === void 0 || prevStats.timestamp === void 0) {\n    return 0;\n  }\n  return (bytesNow - bytesPrev) * 8 * 1e3 / (currentStats.timestamp - prevStats.timestamp);\n}\nvar defaultDimensionsTimeout = 2 * 1e3;\nvar LocalTrack = class extends Track {\n  /**\n   *\n   * @param mediaTrack\n   * @param kind\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */\n  constructor(mediaTrack, kind, constraints) {\n    let userProvidedTrack = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n    super(mediaTrack, kind);\n    this._isUpstreamPaused = false;\n    this.handleEnded = () => {\n      if (this.isInBackground) {\n        this.reacquireTrack = true;\n      }\n      this.emit(TrackEvent.Ended, this);\n    };\n    this._mediaStreamTrack.addEventListener(\"ended\", this.handleEnded);\n    this.constraints = constraints !== null && constraints !== void 0 ? constraints : mediaTrack.getConstraints();\n    this.reacquireTrack = false;\n    this.providedByUser = userProvidedTrack;\n    this.muteLock = new Mutex();\n    this.pauseUpstreamLock = new Mutex();\n  }\n  get id() {\n    return this._mediaStreamTrack.id;\n  }\n  get dimensions() {\n    if (this.kind !== Track.Kind.Video) {\n      return void 0;\n    }\n    const {\n      width,\n      height\n    } = this._mediaStreamTrack.getSettings();\n    if (width && height) {\n      return {\n        width,\n        height\n      };\n    }\n    return void 0;\n  }\n  get isUpstreamPaused() {\n    return this._isUpstreamPaused;\n  }\n  get isUserProvided() {\n    return this.providedByUser;\n  }\n  waitForDimensions() {\n    let timeout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultDimensionsTimeout;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.kind === Track.Kind.Audio) {\n        throw new Error(\"cannot get dimensions for audio tracks\");\n      }\n      const started = Date.now();\n      while (Date.now() - started < timeout) {\n        const dims = this.dimensions;\n        if (dims) {\n          return dims;\n        }\n        yield sleep(50);\n      }\n      throw new TrackInvalidError(\"unable to get track dimensions after timeout\");\n    });\n  }\n  /**\n   * @returns DeviceID of the device that is currently being used for this track\n   */\n  getDeviceId() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.source === Track.Source.ScreenShare) {\n        return;\n      }\n      const {\n        deviceId,\n        groupId\n      } = this._mediaStreamTrack.getSettings();\n      const kind = this.kind === Track.Kind.Audio ? \"audioinput\" : \"videoinput\";\n      return DeviceManager.getInstance().normalizeDeviceId(kind, deviceId, groupId);\n    });\n  }\n  mute() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.setTrackMuted(true);\n      return this;\n    });\n  }\n  unmute() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.setTrackMuted(false);\n      return this;\n    });\n  }\n  replaceTrack(track) {\n    let userProvidedTrack = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.sender) {\n        throw new TrackInvalidError(\"unable to replace an unpublished track\");\n      }\n      this.attachedElements.forEach((el) => {\n        detachTrack(this._mediaStreamTrack, el);\n      });\n      this._mediaStreamTrack.removeEventListener(\"ended\", this.handleEnded);\n      if (!this.providedByUser) {\n        this._mediaStreamTrack.stop();\n      }\n      track.addEventListener(\"ended\", this.handleEnded);\n      livekitLogger.debug(\"replace MediaStreamTrack\");\n      if (this.sender) {\n        yield this.sender.replaceTrack(track);\n      }\n      this._mediaStreamTrack = track;\n      this._mediaStreamTrack.enabled = !this.isMuted;\n      yield this.resumeUpstream();\n      this.attachedElements.forEach((el) => {\n        attachToElement(track, el);\n      });\n      this.mediaStream = new MediaStream([track]);\n      this.providedByUser = userProvidedTrack;\n      return this;\n    });\n  }\n  restart(constraints) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!constraints) {\n        constraints = this.constraints;\n      }\n      livekitLogger.debug(\"restarting track with constraints\", constraints);\n      const streamConstraints = {\n        audio: false,\n        video: false\n      };\n      if (this.kind === Track.Kind.Video) {\n        streamConstraints.video = constraints;\n      } else {\n        streamConstraints.audio = constraints;\n      }\n      this.attachedElements.forEach((el) => {\n        detachTrack(this._mediaStreamTrack, el);\n      });\n      this._mediaStreamTrack.removeEventListener(\"ended\", this.handleEnded);\n      this._mediaStreamTrack.stop();\n      const mediaStream = yield navigator.mediaDevices.getUserMedia(streamConstraints);\n      const newTrack = mediaStream.getTracks()[0];\n      newTrack.addEventListener(\"ended\", this.handleEnded);\n      livekitLogger.debug(\"re-acquired MediaStreamTrack\");\n      if (this.sender) {\n        yield this.sender.replaceTrack(newTrack);\n      }\n      this._mediaStreamTrack = newTrack;\n      yield this.resumeUpstream();\n      this.attachedElements.forEach((el) => {\n        attachToElement(newTrack, el);\n      });\n      this.mediaStream = mediaStream;\n      this.constraints = constraints;\n      this.emit(TrackEvent.Restarted, this);\n      return this;\n    });\n  }\n  setTrackMuted(muted) {\n    livekitLogger.debug(\"setting \".concat(this.kind, \" track \").concat(muted ? \"muted\" : \"unmuted\"));\n    if (this.isMuted === muted && this._mediaStreamTrack.enabled !== muted) {\n      return;\n    }\n    this.isMuted = muted;\n    this._mediaStreamTrack.enabled = !muted;\n    this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);\n  }\n  get needsReAcquisition() {\n    return this._mediaStreamTrack.readyState !== \"live\" || this._mediaStreamTrack.muted || !this._mediaStreamTrack.enabled || this.reacquireTrack;\n  }\n  handleAppVisibilityChanged() {\n    const _super = Object.create(null, {\n      handleAppVisibilityChanged: {\n        get: () => super.handleAppVisibilityChanged\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      yield _super.handleAppVisibilityChanged.call(this);\n      if (!isMobile())\n        return;\n      livekitLogger.debug(\"visibility changed, is in Background: \".concat(this.isInBackground));\n      if (!this.isInBackground && this.needsReAcquisition && !this.isUserProvided && !this.isMuted) {\n        livekitLogger.debug(\"track needs to be reaquired, restarting \".concat(this.source));\n        yield this.restart();\n        this.reacquireTrack = false;\n      }\n    });\n  }\n  pauseUpstream() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.pauseUpstreamLock.lock();\n      try {\n        if (this._isUpstreamPaused === true) {\n          return;\n        }\n        if (!this.sender) {\n          livekitLogger.warn(\"unable to pause upstream for an unpublished track\");\n          return;\n        }\n        this._isUpstreamPaused = true;\n        this.emit(TrackEvent.UpstreamPaused, this);\n        const emptyTrack = this.kind === Track.Kind.Audio ? getEmptyAudioStreamTrack() : getEmptyVideoStreamTrack();\n        yield this.sender.replaceTrack(emptyTrack);\n      } finally {\n        unlock();\n      }\n    });\n  }\n  resumeUpstream() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.pauseUpstreamLock.lock();\n      try {\n        if (this._isUpstreamPaused === false) {\n          return;\n        }\n        if (!this.sender) {\n          livekitLogger.warn(\"unable to resume upstream for an unpublished track\");\n          return;\n        }\n        this._isUpstreamPaused = false;\n        this.emit(TrackEvent.UpstreamResumed, this);\n        yield this.sender.replaceTrack(this._mediaStreamTrack);\n      } finally {\n        unlock();\n      }\n    });\n  }\n};\nvar LocalAudioTrack = class extends LocalTrack {\n  /**\n   *\n   * @param mediaTrack\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */\n  constructor(mediaTrack, constraints) {\n    let userProvidedTrack = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n    super(mediaTrack, Track.Kind.Audio, constraints, userProvidedTrack);\n    this.stopOnMute = false;\n    this.monitorSender = () => __awaiter(this, void 0, void 0, function* () {\n      if (!this.sender) {\n        this._currentBitrate = 0;\n        return;\n      }\n      let stats;\n      try {\n        stats = yield this.getSenderStats();\n      } catch (e) {\n        livekitLogger.error(\"could not get audio sender stats\", {\n          error: e\n        });\n        return;\n      }\n      if (stats && this.prevStats) {\n        this._currentBitrate = computeBitrate(stats, this.prevStats);\n      }\n      this.prevStats = stats;\n    });\n    this.checkForSilence();\n  }\n  setDeviceId(deviceId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.constraints.deviceId === deviceId) {\n        return;\n      }\n      this.constraints.deviceId = deviceId;\n      if (!this.isMuted) {\n        yield this.restartTrack();\n      }\n    });\n  }\n  mute() {\n    const _super = Object.create(null, {\n      mute: {\n        get: () => super.mute\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.muteLock.lock();\n      try {\n        if (this.source === Track.Source.Microphone && this.stopOnMute && !this.isUserProvided) {\n          livekitLogger.debug(\"stopping mic track\");\n          this._mediaStreamTrack.stop();\n        }\n        yield _super.mute.call(this);\n        return this;\n      } finally {\n        unlock();\n      }\n    });\n  }\n  unmute() {\n    const _super = Object.create(null, {\n      unmute: {\n        get: () => super.unmute\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.muteLock.lock();\n      try {\n        if (this.source === Track.Source.Microphone && (this.stopOnMute || this._mediaStreamTrack.readyState === \"ended\") && !this.isUserProvided) {\n          livekitLogger.debug(\"reacquiring mic track\");\n          yield this.restartTrack();\n        }\n        yield _super.unmute.call(this);\n        return this;\n      } finally {\n        unlock();\n      }\n    });\n  }\n  restartTrack(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let constraints;\n      if (options) {\n        const streamConstraints = constraintsForOptions({\n          audio: options\n        });\n        if (typeof streamConstraints.audio !== \"boolean\") {\n          constraints = streamConstraints.audio;\n        }\n      }\n      yield this.restart(constraints);\n    });\n  }\n  restart(constraints) {\n    const _super = Object.create(null, {\n      restart: {\n        get: () => super.restart\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const track = yield _super.restart.call(this, constraints);\n      this.checkForSilence();\n      return track;\n    });\n  }\n  /* @internal */\n  startMonitor() {\n    if (!isWeb()) {\n      return;\n    }\n    if (this.monitorInterval) {\n      return;\n    }\n    this.monitorInterval = setInterval(() => {\n      this.monitorSender();\n    }, monitorFrequency);\n  }\n  getSenderStats() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n        return void 0;\n      }\n      const stats = yield this.sender.getStats();\n      let audioStats;\n      stats.forEach((v) => {\n        if (v.type === \"outbound-rtp\") {\n          audioStats = {\n            type: \"audio\",\n            streamId: v.id,\n            packetsSent: v.packetsSent,\n            packetsLost: v.packetsLost,\n            bytesSent: v.bytesSent,\n            timestamp: v.timestamp,\n            roundTripTime: v.roundTripTime,\n            jitter: v.jitter\n          };\n        }\n      });\n      return audioStats;\n    });\n  }\n  checkForSilence() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const trackIsSilent = yield detectSilence(this);\n      if (trackIsSilent) {\n        if (!this.isMuted) {\n          livekitLogger.warn(\"silence detected on local audio track\");\n        }\n        this.emit(TrackEvent.AudioSilenceDetected);\n      }\n      return trackIsSilent;\n    });\n  }\n};\nvar refreshSubscribedCodecAfterNewCodec = 5e3;\nvar LocalVideoTrack = class extends LocalTrack {\n  /**\n   *\n   * @param mediaTrack\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */\n  constructor(mediaTrack, constraints) {\n    let userProvidedTrack = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n    super(mediaTrack, Track.Kind.Video, constraints, userProvidedTrack);\n    this.simulcastCodecs = /* @__PURE__ */ new Map();\n    this.monitorSender = () => __awaiter(this, void 0, void 0, function* () {\n      if (!this.sender) {\n        this._currentBitrate = 0;\n        return;\n      }\n      let stats;\n      try {\n        stats = yield this.getSenderStats();\n      } catch (e) {\n        livekitLogger.error(\"could not get audio sender stats\", {\n          error: e\n        });\n        return;\n      }\n      const statsMap = new Map(stats.map((s) => [s.rid, s]));\n      if (this.prevStats) {\n        let totalBitrate = 0;\n        statsMap.forEach((s, key) => {\n          var _a;\n          const prev = (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.get(key);\n          totalBitrate += computeBitrate(s, prev);\n        });\n        this._currentBitrate = totalBitrate;\n      }\n      this.prevStats = statsMap;\n    });\n    this.senderLock = new Mutex();\n  }\n  get isSimulcast() {\n    if (this.sender && this.sender.getParameters().encodings.length > 1) {\n      return true;\n    }\n    return false;\n  }\n  /* @internal */\n  startMonitor(signalClient) {\n    var _a;\n    this.signalClient = signalClient;\n    if (!isWeb()) {\n      return;\n    }\n    const params = (_a = this.sender) === null || _a === void 0 ? void 0 : _a.getParameters();\n    if (params) {\n      this.encodings = params.encodings;\n    }\n    if (this.monitorInterval) {\n      return;\n    }\n    this.monitorInterval = setInterval(() => {\n      this.monitorSender();\n    }, monitorFrequency);\n  }\n  stop() {\n    this._mediaStreamTrack.getConstraints();\n    this.simulcastCodecs.forEach((trackInfo) => {\n      trackInfo.mediaStreamTrack.stop();\n    });\n    super.stop();\n  }\n  mute() {\n    const _super = Object.create(null, {\n      mute: {\n        get: () => super.mute\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.muteLock.lock();\n      try {\n        if (this.source === Track.Source.Camera && !this.isUserProvided) {\n          livekitLogger.debug(\"stopping camera track\");\n          this._mediaStreamTrack.stop();\n        }\n        yield _super.mute.call(this);\n        return this;\n      } finally {\n        unlock();\n      }\n    });\n  }\n  unmute() {\n    const _super = Object.create(null, {\n      unmute: {\n        get: () => super.unmute\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.muteLock.lock();\n      try {\n        if (this.source === Track.Source.Camera && !this.isUserProvided) {\n          livekitLogger.debug(\"reacquiring camera track\");\n          yield this.restartTrack();\n        }\n        yield _super.unmute.call(this);\n        return this;\n      } finally {\n        unlock();\n      }\n    });\n  }\n  getSenderStats() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n        return [];\n      }\n      const items = [];\n      const stats = yield this.sender.getStats();\n      stats.forEach((v) => {\n        var _a2;\n        if (v.type === \"outbound-rtp\") {\n          const vs = {\n            type: \"video\",\n            streamId: v.id,\n            frameHeight: v.frameHeight,\n            frameWidth: v.frameWidth,\n            firCount: v.firCount,\n            pliCount: v.pliCount,\n            nackCount: v.nackCount,\n            packetsSent: v.packetsSent,\n            bytesSent: v.bytesSent,\n            framesSent: v.framesSent,\n            timestamp: v.timestamp,\n            rid: (_a2 = v.rid) !== null && _a2 !== void 0 ? _a2 : v.id,\n            retransmittedPacketsSent: v.retransmittedPacketsSent,\n            qualityLimitationReason: v.qualityLimitationReason,\n            qualityLimitationResolutionChanges: v.qualityLimitationResolutionChanges\n          };\n          const r2 = stats.get(v.remoteId);\n          if (r2) {\n            vs.jitter = r2.jitter;\n            vs.packetsLost = r2.packetsLost;\n            vs.roundTripTime = r2.roundTripTime;\n          }\n          items.push(vs);\n        }\n      });\n      return items;\n    });\n  }\n  setPublishingQuality(maxQuality) {\n    const qualities = [];\n    for (let q = VideoQuality.LOW; q <= VideoQuality.HIGH; q += 1) {\n      qualities.push({\n        quality: q,\n        enabled: q <= maxQuality\n      });\n    }\n    livekitLogger.debug(\"setting publishing quality. max quality \".concat(maxQuality));\n    this.setPublishingLayers(qualities);\n  }\n  setDeviceId(deviceId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.constraints.deviceId === deviceId) {\n        return;\n      }\n      this.constraints.deviceId = deviceId;\n      if (!this.isMuted) {\n        yield this.restartTrack();\n      }\n    });\n  }\n  restartTrack(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let constraints;\n      if (options) {\n        const streamConstraints = constraintsForOptions({\n          video: options\n        });\n        if (typeof streamConstraints.video !== \"boolean\") {\n          constraints = streamConstraints.video;\n        }\n      }\n      yield this.restart(constraints);\n    });\n  }\n  addSimulcastTrack(codec, encodings) {\n    if (this.simulcastCodecs.has(codec)) {\n      throw new Error(\"\".concat(codec, \" already added\"));\n    }\n    const simulcastCodecInfo = {\n      codec,\n      mediaStreamTrack: this.mediaStreamTrack.clone(),\n      sender: void 0,\n      encodings\n    };\n    this.simulcastCodecs.set(codec, simulcastCodecInfo);\n    return simulcastCodecInfo;\n  }\n  setSimulcastTrackSender(codec, sender) {\n    const simulcastCodecInfo = this.simulcastCodecs.get(codec);\n    if (!simulcastCodecInfo) {\n      return;\n    }\n    simulcastCodecInfo.sender = sender;\n    setTimeout(() => {\n      if (this.subscribedCodecs) {\n        this.setPublishingCodecs(this.subscribedCodecs);\n      }\n    }, refreshSubscribedCodecAfterNewCodec);\n  }\n  /**\n   * @internal\n   * Sets codecs that should be publishing\n   */\n  setPublishingCodecs(codecs) {\n    var _a, codecs_1, codecs_1_1;\n    var _b, e_1, _c, _d;\n    return __awaiter(this, void 0, void 0, function* () {\n      livekitLogger.debug(\"setting publishing codecs\", {\n        codecs,\n        currentCodec: this.codec\n      });\n      if (!this.codec && codecs.length > 0) {\n        yield this.setPublishingLayers(codecs[0].qualities);\n        return [];\n      }\n      this.subscribedCodecs = codecs;\n      const newCodecs = [];\n      try {\n        for (_a = true, codecs_1 = __asyncValues(codecs); codecs_1_1 = yield codecs_1.next(), _b = codecs_1_1.done, !_b; ) {\n          _d = codecs_1_1.value;\n          _a = false;\n          try {\n            const codec = _d;\n            if (!this.codec || this.codec === codec.codec) {\n              yield this.setPublishingLayers(codec.qualities);\n            } else {\n              const simulcastCodecInfo = this.simulcastCodecs.get(codec.codec);\n              livekitLogger.debug(\"try setPublishingCodec for \".concat(codec.codec), simulcastCodecInfo);\n              if (!simulcastCodecInfo || !simulcastCodecInfo.sender) {\n                for (const q of codec.qualities) {\n                  if (q.enabled) {\n                    newCodecs.push(codec.codec);\n                    break;\n                  }\n                }\n              } else if (simulcastCodecInfo.encodings) {\n                livekitLogger.debug(\"try setPublishingLayersForSender \".concat(codec.codec));\n                yield setPublishingLayersForSender(simulcastCodecInfo.sender, simulcastCodecInfo.encodings, codec.qualities, this.senderLock);\n              }\n            }\n          } finally {\n            _a = true;\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (!_a && !_b && (_c = codecs_1.return))\n            yield _c.call(codecs_1);\n        } finally {\n          if (e_1)\n            throw e_1.error;\n        }\n      }\n      return newCodecs;\n    });\n  }\n  /**\n   * @internal\n   * Sets layers that should be publishing\n   */\n  setPublishingLayers(qualities) {\n    return __awaiter(this, void 0, void 0, function* () {\n      livekitLogger.debug(\"setting publishing layers\", qualities);\n      if (!this.sender || !this.encodings) {\n        return;\n      }\n      yield setPublishingLayersForSender(this.sender, this.encodings, qualities, this.senderLock);\n    });\n  }\n  handleAppVisibilityChanged() {\n    const _super = Object.create(null, {\n      handleAppVisibilityChanged: {\n        get: () => super.handleAppVisibilityChanged\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      yield _super.handleAppVisibilityChanged.call(this);\n      if (!isMobile())\n        return;\n      if (this.isInBackground && this.source === Track.Source.Camera) {\n        this._mediaStreamTrack.enabled = false;\n      }\n    });\n  }\n};\nfunction setPublishingLayersForSender(sender, senderEncodings, qualities, senderLock) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const unlock = yield senderLock.lock();\n    livekitLogger.debug(\"setPublishingLayersForSender\", {\n      sender,\n      qualities,\n      senderEncodings\n    });\n    try {\n      const params = sender.getParameters();\n      const {\n        encodings\n      } = params;\n      if (!encodings) {\n        return;\n      }\n      if (encodings.length !== senderEncodings.length) {\n        livekitLogger.warn(\"cannot set publishing layers, encodings mismatch\");\n        return;\n      }\n      let hasChanged = false;\n      encodings.forEach((encoding, idx) => {\n        var _a;\n        let rid = (_a = encoding.rid) !== null && _a !== void 0 ? _a : \"\";\n        if (rid === \"\") {\n          rid = \"q\";\n        }\n        const quality = videoQualityForRid(rid);\n        const subscribedQuality = qualities.find((q) => q.quality === quality);\n        if (!subscribedQuality) {\n          return;\n        }\n        if (encoding.active !== subscribedQuality.enabled) {\n          hasChanged = true;\n          encoding.active = subscribedQuality.enabled;\n          livekitLogger.debug(\"setting layer \".concat(subscribedQuality.quality, \" to \").concat(encoding.active ? \"enabled\" : \"disabled\"));\n          if (isFireFox()) {\n            if (subscribedQuality.enabled) {\n              encoding.scaleResolutionDownBy = senderEncodings[idx].scaleResolutionDownBy;\n              encoding.maxBitrate = senderEncodings[idx].maxBitrate;\n              encoding.maxFrameRate = senderEncodings[idx].maxFrameRate;\n            } else {\n              encoding.scaleResolutionDownBy = 4;\n              encoding.maxBitrate = 10;\n              encoding.maxFrameRate = 2;\n            }\n          }\n        }\n      });\n      if (hasChanged) {\n        params.encodings = encodings;\n        yield sender.setParameters(params);\n      }\n    } finally {\n      unlock();\n    }\n  });\n}\nfunction videoQualityForRid(rid) {\n  switch (rid) {\n    case \"f\":\n      return VideoQuality.HIGH;\n    case \"h\":\n      return VideoQuality.MEDIUM;\n    case \"q\":\n      return VideoQuality.LOW;\n    default:\n      return VideoQuality.UNRECOGNIZED;\n  }\n}\nfunction videoLayersFromEncodings(width, height, encodings) {\n  if (!encodings) {\n    return [{\n      quality: VideoQuality.HIGH,\n      width,\n      height,\n      bitrate: 0,\n      ssrc: 0\n    }];\n  }\n  return encodings.map((encoding) => {\n    var _a, _b, _c;\n    const scale = (_a = encoding.scaleResolutionDownBy) !== null && _a !== void 0 ? _a : 1;\n    let quality = videoQualityForRid((_b = encoding.rid) !== null && _b !== void 0 ? _b : \"\");\n    if (quality === VideoQuality.UNRECOGNIZED && encodings.length === 1) {\n      quality = VideoQuality.HIGH;\n    }\n    return {\n      quality,\n      width: width / scale,\n      height: height / scale,\n      bitrate: (_c = encoding.maxBitrate) !== null && _c !== void 0 ? _c : 0,\n      ssrc: 0\n    };\n  });\n}\nvar RemoteTrack = class extends Track {\n  constructor(mediaTrack, sid, kind, receiver) {\n    super(mediaTrack, kind);\n    this.sid = sid;\n    this.receiver = receiver;\n  }\n  /** @internal */\n  setMuted(muted) {\n    if (this.isMuted !== muted) {\n      this.isMuted = muted;\n      this._mediaStreamTrack.enabled = !muted;\n      this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);\n    }\n  }\n  /** @internal */\n  setMediaStream(stream) {\n    this.mediaStream = stream;\n    stream.onremovetrack = () => {\n      this.receiver = void 0;\n      this._currentBitrate = 0;\n      this.emit(TrackEvent.Ended, this);\n    };\n  }\n  start() {\n    this.startMonitor();\n    super.enable();\n  }\n  stop() {\n    this.stopMonitor();\n    super.disable();\n  }\n  /* @internal */\n  startMonitor() {\n    if (!this.monitorInterval) {\n      this.monitorInterval = setInterval(() => this.monitorReceiver(), monitorFrequency);\n    }\n  }\n};\nvar RemoteAudioTrack = class extends RemoteTrack {\n  constructor(mediaTrack, sid, receiver, audioContext, audioOutput) {\n    super(mediaTrack, sid, Track.Kind.Audio, receiver);\n    this.monitorReceiver = () => __awaiter(this, void 0, void 0, function* () {\n      if (!this.receiver) {\n        this._currentBitrate = 0;\n        return;\n      }\n      const stats = yield this.getReceiverStats();\n      if (stats && this.prevStats && this.receiver) {\n        this._currentBitrate = computeBitrate(stats, this.prevStats);\n      }\n      this.prevStats = stats;\n    });\n    this.audioContext = audioContext;\n    this.webAudioPluginNodes = [];\n    if (audioOutput) {\n      this.sinkId = audioOutput.deviceId;\n    }\n  }\n  /**\n   * sets the volume for all attached audio elements\n   */\n  setVolume(volume) {\n    var _a;\n    for (const el of this.attachedElements) {\n      if (this.audioContext) {\n        (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.gain.setTargetAtTime(volume, 0, 0.1);\n      } else {\n        el.volume = volume;\n      }\n    }\n    this.elementVolume = volume;\n  }\n  /**\n   * gets the volume of attached audio elements (loudest)\n   */\n  getVolume() {\n    if (this.elementVolume) {\n      return this.elementVolume;\n    }\n    let highestVolume = 0;\n    this.attachedElements.forEach((element) => {\n      if (element.volume > highestVolume) {\n        highestVolume = element.volume;\n      }\n    });\n    return highestVolume;\n  }\n  /**\n   * calls setSinkId on all attached elements, if supported\n   * @param deviceId audio output device\n   */\n  setSinkId(deviceId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.sinkId = deviceId;\n      yield Promise.all(this.attachedElements.map((elm) => {\n        if (!supportsSetSinkId(elm)) {\n          return;\n        }\n        return elm.setSinkId(deviceId);\n      }));\n    });\n  }\n  attach(element) {\n    const needsNewWebAudioConnection = this.attachedElements.length === 0;\n    if (!element) {\n      element = super.attach();\n    } else {\n      super.attach(element);\n    }\n    if (this.elementVolume) {\n      element.volume = this.elementVolume;\n    }\n    if (this.sinkId && supportsSetSinkId(element)) {\n      element.setSinkId(this.sinkId);\n    }\n    if (this.audioContext && needsNewWebAudioConnection) {\n      livekitLogger.debug(\"using audio context mapping\");\n      this.connectWebAudio(this.audioContext, element);\n      element.volume = 0;\n      element.muted = true;\n    }\n    return element;\n  }\n  detach(element) {\n    let detached;\n    if (!element) {\n      detached = super.detach();\n      this.disconnectWebAudio();\n    } else {\n      detached = super.detach(element);\n      if (this.audioContext) {\n        if (this.attachedElements.length > 0) {\n          this.connectWebAudio(this.audioContext, this.attachedElements[0]);\n        } else {\n          this.disconnectWebAudio();\n        }\n      }\n    }\n    return detached;\n  }\n  /**\n   * @internal\n   * @experimental\n   */\n  setAudioContext(audioContext) {\n    this.audioContext = audioContext;\n    if (audioContext && this.attachedElements.length > 0) {\n      this.connectWebAudio(audioContext, this.attachedElements[0]);\n    } else if (!audioContext) {\n      this.disconnectWebAudio();\n    }\n  }\n  /**\n   * @internal\n   * @experimental\n   * @param {AudioNode[]} nodes - An array of WebAudio nodes. These nodes should not be connected to each other when passed, as the sdk will take care of connecting them in the order of the array.\n   */\n  setWebAudioPlugins(nodes) {\n    this.webAudioPluginNodes = nodes;\n    if (this.attachedElements.length > 0 && this.audioContext) {\n      this.connectWebAudio(this.audioContext, this.attachedElements[0]);\n    }\n  }\n  connectWebAudio(context, element) {\n    this.disconnectWebAudio();\n    this.sourceNode = context.createMediaStreamSource(element.srcObject);\n    let lastNode = this.sourceNode;\n    this.webAudioPluginNodes.forEach((node) => {\n      lastNode.connect(node);\n      lastNode = node;\n    });\n    this.gainNode = context.createGain();\n    lastNode.connect(this.gainNode);\n    this.gainNode.connect(context.destination);\n    if (this.elementVolume) {\n      this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1);\n    }\n    if (context.state !== \"running\") {\n      context.resume().then(() => {\n        if (context.state !== \"running\") {\n          this.emit(TrackEvent.AudioPlaybackFailed, new Error(\"Audio Context couldn't be started automatically\"));\n        }\n      }).catch((e) => {\n        this.emit(TrackEvent.AudioPlaybackFailed, e);\n      });\n    }\n  }\n  disconnectWebAudio() {\n    var _a, _b;\n    (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.disconnect();\n    (_b = this.sourceNode) === null || _b === void 0 ? void 0 : _b.disconnect();\n    this.gainNode = void 0;\n    this.sourceNode = void 0;\n  }\n  getReceiverStats() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.receiver || !this.receiver.getStats) {\n        return;\n      }\n      const stats = yield this.receiver.getStats();\n      let receiverStats;\n      stats.forEach((v) => {\n        if (v.type === \"inbound-rtp\") {\n          receiverStats = {\n            type: \"audio\",\n            timestamp: v.timestamp,\n            jitter: v.jitter,\n            bytesReceived: v.bytesReceived,\n            concealedSamples: v.concealedSamples,\n            concealmentEvents: v.concealmentEvents,\n            silentConcealedSamples: v.silentConcealedSamples,\n            silentConcealmentEvents: v.silentConcealmentEvents,\n            totalAudioEnergy: v.totalAudioEnergy,\n            totalSamplesDuration: v.totalSamplesDuration\n          };\n        }\n      });\n      return receiverStats;\n    });\n  }\n};\nvar REACTION_DELAY = 100;\nvar RemoteVideoTrack = class extends RemoteTrack {\n  constructor(mediaTrack, sid, receiver, adaptiveStreamSettings) {\n    super(mediaTrack, sid, Track.Kind.Video, receiver);\n    this.elementInfos = [];\n    this.isObserved = false;\n    this.monitorReceiver = () => __awaiter(this, void 0, void 0, function* () {\n      if (!this.receiver) {\n        this._currentBitrate = 0;\n        return;\n      }\n      const stats = yield this.getReceiverStats();\n      if (stats && this.prevStats && this.receiver) {\n        this._currentBitrate = computeBitrate(stats, this.prevStats);\n      }\n      this.prevStats = stats;\n    });\n    this.debouncedHandleResize = r(() => {\n      this.updateDimensions();\n    }, REACTION_DELAY);\n    this.adaptiveStreamSettings = adaptiveStreamSettings;\n  }\n  get isAdaptiveStream() {\n    return this.adaptiveStreamSettings !== void 0;\n  }\n  get mediaStreamTrack() {\n    if (this.isAdaptiveStream && !this.isObserved) {\n      livekitLogger.warn(\"When using adaptiveStream, you need to use remoteVideoTrack.attach() to add the track to a HTMLVideoElement, otherwise your video tracks might never start\");\n    }\n    return this._mediaStreamTrack;\n  }\n  /** @internal */\n  setMuted(muted) {\n    super.setMuted(muted);\n    this.attachedElements.forEach((element) => {\n      if (muted) {\n        detachTrack(this._mediaStreamTrack, element);\n      } else {\n        attachToElement(this._mediaStreamTrack, element);\n      }\n    });\n  }\n  attach(element) {\n    if (!element) {\n      element = super.attach();\n    } else {\n      super.attach(element);\n    }\n    if (this.adaptiveStreamSettings && this.elementInfos.find((info) => info.element === element) === void 0) {\n      const elementInfo = new HTMLElementInfo(element);\n      this.observeElementInfo(elementInfo);\n    }\n    return element;\n  }\n  /**\n   * Observe an ElementInfo for changes when adaptive streaming.\n   * @param elementInfo\n   * @internal\n   */\n  observeElementInfo(elementInfo) {\n    if (this.adaptiveStreamSettings && this.elementInfos.find((info) => info === elementInfo) === void 0) {\n      elementInfo.handleResize = () => {\n        this.debouncedHandleResize();\n      };\n      elementInfo.handleVisibilityChanged = () => {\n        this.updateVisibility();\n      };\n      this.elementInfos.push(elementInfo);\n      elementInfo.observe();\n      this.debouncedHandleResize();\n      this.updateVisibility();\n      this.isObserved = true;\n    } else {\n      livekitLogger.warn(\"visibility resize observer not triggered\");\n    }\n  }\n  /**\n   * Stop observing an ElementInfo for changes.\n   * @param elementInfo\n   * @internal\n   */\n  stopObservingElementInfo(elementInfo) {\n    if (!this.isAdaptiveStream) {\n      livekitLogger.warn(\"stopObservingElementInfo ignored\");\n      return;\n    }\n    const stopElementInfos = this.elementInfos.filter((info) => info === elementInfo);\n    for (const info of stopElementInfos) {\n      info.stopObserving();\n    }\n    this.elementInfos = this.elementInfos.filter((info) => info !== elementInfo);\n    this.updateVisibility();\n  }\n  detach(element) {\n    let detachedElements = [];\n    if (element) {\n      this.stopObservingElement(element);\n      return super.detach(element);\n    }\n    detachedElements = super.detach();\n    for (const e of detachedElements) {\n      this.stopObservingElement(e);\n    }\n    return detachedElements;\n  }\n  /** @internal */\n  getDecoderImplementation() {\n    var _a;\n    return (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.decoderImplementation;\n  }\n  getReceiverStats() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.receiver || !this.receiver.getStats) {\n        return;\n      }\n      const stats = yield this.receiver.getStats();\n      let receiverStats;\n      stats.forEach((v) => {\n        if (v.type === \"inbound-rtp\") {\n          receiverStats = {\n            type: \"video\",\n            framesDecoded: v.framesDecoded,\n            framesDropped: v.framesDropped,\n            framesReceived: v.framesReceived,\n            packetsReceived: v.packetsReceived,\n            packetsLost: v.packetsLost,\n            frameWidth: v.frameWidth,\n            frameHeight: v.frameHeight,\n            pliCount: v.pliCount,\n            firCount: v.firCount,\n            nackCount: v.nackCount,\n            jitter: v.jitter,\n            timestamp: v.timestamp,\n            bytesReceived: v.bytesReceived,\n            decoderImplementation: v.decoderImplementation\n          };\n        }\n      });\n      return receiverStats;\n    });\n  }\n  stopObservingElement(element) {\n    const stopElementInfos = this.elementInfos.filter((info) => info.element === element);\n    for (const info of stopElementInfos) {\n      info.stopObserving();\n    }\n    this.elementInfos = this.elementInfos.filter((info) => info.element !== element);\n  }\n  handleAppVisibilityChanged() {\n    const _super = Object.create(null, {\n      handleAppVisibilityChanged: {\n        get: () => super.handleAppVisibilityChanged\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      yield _super.handleAppVisibilityChanged.call(this);\n      if (!this.isAdaptiveStream)\n        return;\n      this.updateVisibility();\n    });\n  }\n  updateVisibility() {\n    var _a, _b;\n    const lastVisibilityChange = this.elementInfos.reduce((prev, info) => Math.max(prev, info.visibilityChangedAt || 0), 0);\n    const backgroundPause = ((_b = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pauseVideoInBackground) !== null && _b !== void 0 ? _b : true) ? this.isInBackground : false;\n    const isPiPMode = this.elementInfos.some((info) => info.pictureInPicture);\n    const isVisible = this.elementInfos.some((info) => info.visible) && !backgroundPause || isPiPMode;\n    if (this.lastVisible === isVisible) {\n      return;\n    }\n    if (!isVisible && Date.now() - lastVisibilityChange < REACTION_DELAY) {\n      CriticalTimers.setTimeout(() => {\n        this.updateVisibility();\n      }, REACTION_DELAY);\n      return;\n    }\n    this.lastVisible = isVisible;\n    this.emit(TrackEvent.VisibilityChanged, isVisible, this);\n  }\n  updateDimensions() {\n    var _a, _b, _c, _d;\n    let maxWidth = 0;\n    let maxHeight = 0;\n    for (const info of this.elementInfos) {\n      const pixelDensity = (_b = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pixelDensity) !== null && _b !== void 0 ? _b : 1;\n      const pixelDensityValue = pixelDensity === \"screen\" ? getDevicePixelRatio() : pixelDensity;\n      const currentElementWidth = info.width() * pixelDensityValue;\n      const currentElementHeight = info.height() * pixelDensityValue;\n      if (currentElementWidth + currentElementHeight > maxWidth + maxHeight) {\n        maxWidth = currentElementWidth;\n        maxHeight = currentElementHeight;\n      }\n    }\n    if (((_c = this.lastDimensions) === null || _c === void 0 ? void 0 : _c.width) === maxWidth && ((_d = this.lastDimensions) === null || _d === void 0 ? void 0 : _d.height) === maxHeight) {\n      return;\n    }\n    this.lastDimensions = {\n      width: maxWidth,\n      height: maxHeight\n    };\n    this.emit(TrackEvent.VideoDimensionsChanged, this.lastDimensions, this);\n  }\n};\nvar HTMLElementInfo = class {\n  get visible() {\n    return this.isPiP || this.isIntersecting;\n  }\n  get pictureInPicture() {\n    return this.isPiP;\n  }\n  constructor(element, visible) {\n    this.onVisibilityChanged = (entry) => {\n      var _a;\n      const {\n        target,\n        isIntersecting\n      } = entry;\n      if (target === this.element) {\n        this.isIntersecting = isIntersecting;\n        this.visibilityChangedAt = Date.now();\n        (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n      }\n    };\n    this.onEnterPiP = () => {\n      var _a;\n      this.isPiP = true;\n      (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n    };\n    this.onLeavePiP = () => {\n      var _a;\n      this.isPiP = false;\n      (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n    };\n    this.element = element;\n    this.isIntersecting = visible !== null && visible !== void 0 ? visible : isElementInViewport(element);\n    this.isPiP = isWeb() && document.pictureInPictureElement === element;\n    this.visibilityChangedAt = 0;\n  }\n  width() {\n    return this.element.clientWidth;\n  }\n  height() {\n    return this.element.clientHeight;\n  }\n  observe() {\n    this.isIntersecting = isElementInViewport(this.element);\n    this.isPiP = document.pictureInPictureElement === this.element;\n    this.element.handleResize = () => {\n      var _a;\n      (_a = this.handleResize) === null || _a === void 0 ? void 0 : _a.call(this);\n    };\n    this.element.handleVisibilityChanged = this.onVisibilityChanged;\n    getIntersectionObserver().observe(this.element);\n    getResizeObserver().observe(this.element);\n    this.element.addEventListener(\"enterpictureinpicture\", this.onEnterPiP);\n    this.element.addEventListener(\"leavepictureinpicture\", this.onLeavePiP);\n  }\n  stopObserving() {\n    var _a, _b;\n    (_a = getIntersectionObserver()) === null || _a === void 0 ? void 0 : _a.unobserve(this.element);\n    (_b = getResizeObserver()) === null || _b === void 0 ? void 0 : _b.unobserve(this.element);\n    this.element.removeEventListener(\"enterpictureinpicture\", this.onEnterPiP);\n    this.element.removeEventListener(\"leavepictureinpicture\", this.onLeavePiP);\n  }\n};\nfunction isElementInViewport(el) {\n  let top = el.offsetTop;\n  let left = el.offsetLeft;\n  const width = el.offsetWidth;\n  const height = el.offsetHeight;\n  const {\n    hidden\n  } = el;\n  const {\n    opacity,\n    display\n  } = getComputedStyle(el);\n  while (el.offsetParent) {\n    el = el.offsetParent;\n    top += el.offsetTop;\n    left += el.offsetLeft;\n  }\n  return top < window.pageYOffset + window.innerHeight && left < window.pageXOffset + window.innerWidth && top + height > window.pageYOffset && left + width > window.pageXOffset && !hidden && (opacity !== \"\" ? parseFloat(opacity) > 0 : true) && display !== \"none\";\n}\nvar TrackPublication = class extends eventsExports.EventEmitter {\n  constructor(kind, id, name) {\n    super();\n    this.metadataMuted = false;\n    this.handleMuted = () => {\n      this.emit(TrackEvent.Muted);\n    };\n    this.handleUnmuted = () => {\n      this.emit(TrackEvent.Unmuted);\n    };\n    this.setMaxListeners(100);\n    this.kind = kind;\n    this.trackSid = id;\n    this.trackName = name;\n    this.source = Track.Source.Unknown;\n  }\n  /** @internal */\n  setTrack(track) {\n    if (this.track) {\n      this.track.off(TrackEvent.Muted, this.handleMuted);\n      this.track.off(TrackEvent.Unmuted, this.handleUnmuted);\n    }\n    this.track = track;\n    if (track) {\n      track.on(TrackEvent.Muted, this.handleMuted);\n      track.on(TrackEvent.Unmuted, this.handleUnmuted);\n    }\n  }\n  get isMuted() {\n    return this.metadataMuted;\n  }\n  get isEnabled() {\n    return true;\n  }\n  get isSubscribed() {\n    return this.track !== void 0;\n  }\n  /**\n   * an [AudioTrack] if this publication holds an audio track\n   */\n  get audioTrack() {\n    if (this.track instanceof LocalAudioTrack || this.track instanceof RemoteAudioTrack) {\n      return this.track;\n    }\n  }\n  /**\n   * an [VideoTrack] if this publication holds a video track\n   */\n  get videoTrack() {\n    if (this.track instanceof LocalVideoTrack || this.track instanceof RemoteVideoTrack) {\n      return this.track;\n    }\n  }\n  /** @internal */\n  updateInfo(info) {\n    this.trackSid = info.sid;\n    this.trackName = info.name;\n    this.source = Track.sourceFromProto(info.source);\n    this.mimeType = info.mimeType;\n    if (this.kind === Track.Kind.Video && info.width > 0) {\n      this.dimensions = {\n        width: info.width,\n        height: info.height\n      };\n      this.simulcasted = info.simulcast;\n    }\n    this.trackInfo = info;\n    livekitLogger.trace(\"update publication info\", {\n      info\n    });\n  }\n};\n(function(TrackPublication2) {\n  (function(SubscriptionStatus) {\n    SubscriptionStatus[\"Desired\"] = \"desired\";\n    SubscriptionStatus[\"Subscribed\"] = \"subscribed\";\n    SubscriptionStatus[\"Unsubscribed\"] = \"unsubscribed\";\n  })(TrackPublication2.SubscriptionStatus || (TrackPublication2.SubscriptionStatus = {}));\n  (function(PermissionStatus) {\n    PermissionStatus[\"Allowed\"] = \"allowed\";\n    PermissionStatus[\"NotAllowed\"] = \"not_allowed\";\n  })(TrackPublication2.PermissionStatus || (TrackPublication2.PermissionStatus = {}));\n})(TrackPublication || (TrackPublication = {}));\nvar LocalTrackPublication = class extends TrackPublication {\n  get isUpstreamPaused() {\n    var _a;\n    return (_a = this.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused;\n  }\n  constructor(kind, ti, track) {\n    super(kind, ti.sid, ti.name);\n    this.track = void 0;\n    this.handleTrackEnded = () => {\n      this.emit(TrackEvent.Ended);\n    };\n    this.updateInfo(ti);\n    this.setTrack(track);\n  }\n  setTrack(track) {\n    if (this.track) {\n      this.track.off(TrackEvent.Ended, this.handleTrackEnded);\n    }\n    super.setTrack(track);\n    if (track) {\n      track.on(TrackEvent.Ended, this.handleTrackEnded);\n    }\n  }\n  get isMuted() {\n    if (this.track) {\n      return this.track.isMuted;\n    }\n    return super.isMuted;\n  }\n  get audioTrack() {\n    return super.audioTrack;\n  }\n  get videoTrack() {\n    return super.videoTrack;\n  }\n  /**\n   * Mute the track associated with this publication\n   */\n  mute() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      return (_a = this.track) === null || _a === void 0 ? void 0 : _a.mute();\n    });\n  }\n  /**\n   * Unmute track associated with this publication\n   */\n  unmute() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      return (_a = this.track) === null || _a === void 0 ? void 0 : _a.unmute();\n    });\n  }\n  /**\n   * Pauses the media stream track associated with this publication from being sent to the server\n   * and signals \"muted\" event to other participants\n   * Useful if you want to pause the stream without pausing the local media stream track\n   */\n  pauseUpstream() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.pauseUpstream();\n    });\n  }\n  /**\n   * Resumes sending the media stream track associated with this publication to the server after a call to [[pauseUpstream()]]\n   * and signals \"unmuted\" event to other participants (unless the track is explicitly muted)\n   */\n  resumeUpstream() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.resumeUpstream();\n    });\n  }\n};\nvar ConnectionQuality;\n(function(ConnectionQuality2) {\n  ConnectionQuality2[\"Excellent\"] = \"excellent\";\n  ConnectionQuality2[\"Good\"] = \"good\";\n  ConnectionQuality2[\"Poor\"] = \"poor\";\n  ConnectionQuality2[\"Unknown\"] = \"unknown\";\n})(ConnectionQuality || (ConnectionQuality = {}));\nfunction qualityFromProto(q) {\n  switch (q) {\n    case ConnectionQuality$1.EXCELLENT:\n      return ConnectionQuality.Excellent;\n    case ConnectionQuality$1.GOOD:\n      return ConnectionQuality.Good;\n    case ConnectionQuality$1.POOR:\n      return ConnectionQuality.Poor;\n    default:\n      return ConnectionQuality.Unknown;\n  }\n}\nvar Participant = class extends eventsExports.EventEmitter {\n  /** @internal */\n  constructor(sid, identity, name, metadata) {\n    super();\n    this.audioLevel = 0;\n    this.isSpeaking = false;\n    this._connectionQuality = ConnectionQuality.Unknown;\n    this.setMaxListeners(100);\n    this.sid = sid;\n    this.identity = identity;\n    this.name = name;\n    this.metadata = metadata;\n    this.audioTracks = /* @__PURE__ */ new Map();\n    this.videoTracks = /* @__PURE__ */ new Map();\n    this.tracks = /* @__PURE__ */ new Map();\n  }\n  getTracks() {\n    return Array.from(this.tracks.values());\n  }\n  /**\n   * Finds the first track that matches the source filter, for example, getting\n   * the user's camera track with getTrackBySource(Track.Source.Camera).\n   * @param source\n   * @returns\n   */\n  getTrack(source) {\n    for (const [, pub] of this.tracks) {\n      if (pub.source === source) {\n        return pub;\n      }\n    }\n  }\n  /**\n   * Finds the first track that matches the track's name.\n   * @param name\n   * @returns\n   */\n  getTrackByName(name) {\n    for (const [, pub] of this.tracks) {\n      if (pub.trackName === name) {\n        return pub;\n      }\n    }\n  }\n  get connectionQuality() {\n    return this._connectionQuality;\n  }\n  get isCameraEnabled() {\n    var _a;\n    const track = this.getTrack(Track.Source.Camera);\n    return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);\n  }\n  get isMicrophoneEnabled() {\n    var _a;\n    const track = this.getTrack(Track.Source.Microphone);\n    return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);\n  }\n  get isScreenShareEnabled() {\n    const track = this.getTrack(Track.Source.ScreenShare);\n    return !!track;\n  }\n  get isLocal() {\n    return false;\n  }\n  /** when participant joined the room */\n  get joinedAt() {\n    if (this.participantInfo) {\n      return new Date(this.participantInfo.joinedAt * 1e3);\n    }\n    return /* @__PURE__ */ new Date();\n  }\n  /** @internal */\n  updateInfo(info) {\n    if (this.participantInfo && this.participantInfo.sid === info.sid && this.participantInfo.version > info.version) {\n      return false;\n    }\n    this.identity = info.identity;\n    this.sid = info.sid;\n    this.setName(info.name);\n    this.setMetadata(info.metadata);\n    if (info.permission) {\n      this.setPermissions(info.permission);\n    }\n    this.participantInfo = info;\n    livekitLogger.trace(\"update participant info\", {\n      info\n    });\n    return true;\n  }\n  /** @internal */\n  setMetadata(md) {\n    const changed = this.metadata !== md;\n    const prevMetadata = this.metadata;\n    this.metadata = md;\n    if (changed) {\n      this.emit(ParticipantEvent.ParticipantMetadataChanged, prevMetadata);\n    }\n  }\n  setName(name) {\n    const changed = this.name !== name;\n    this.name = name;\n    if (changed) {\n      this.emit(ParticipantEvent.ParticipantNameChanged, name);\n    }\n  }\n  /** @internal */\n  setPermissions(permissions) {\n    var _a, _b, _c, _d, _e;\n    const prevPermissions = this.permissions;\n    const changed = permissions.canPublish !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublish) || permissions.canSubscribe !== ((_b = this.permissions) === null || _b === void 0 ? void 0 : _b.canSubscribe) || permissions.canPublishData !== ((_c = this.permissions) === null || _c === void 0 ? void 0 : _c.canPublishData) || permissions.hidden !== ((_d = this.permissions) === null || _d === void 0 ? void 0 : _d.hidden) || permissions.recorder !== ((_e = this.permissions) === null || _e === void 0 ? void 0 : _e.recorder) || permissions.canPublishSources.length !== this.permissions.canPublishSources.length || permissions.canPublishSources.some((value, index) => {\n      var _a2;\n      return value !== ((_a2 = this.permissions) === null || _a2 === void 0 ? void 0 : _a2.canPublishSources[index]);\n    });\n    this.permissions = permissions;\n    if (changed) {\n      this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);\n    }\n    return changed;\n  }\n  /** @internal */\n  setIsSpeaking(speaking) {\n    if (speaking === this.isSpeaking) {\n      return;\n    }\n    this.isSpeaking = speaking;\n    if (speaking) {\n      this.lastSpokeAt = /* @__PURE__ */ new Date();\n    }\n    this.emit(ParticipantEvent.IsSpeakingChanged, speaking);\n  }\n  /** @internal */\n  setConnectionQuality(q) {\n    const prevQuality = this._connectionQuality;\n    this._connectionQuality = qualityFromProto(q);\n    if (prevQuality !== this._connectionQuality) {\n      this.emit(ParticipantEvent.ConnectionQualityChanged, this._connectionQuality);\n    }\n  }\n  addTrackPublication(publication) {\n    publication.on(TrackEvent.Muted, () => {\n      this.emit(ParticipantEvent.TrackMuted, publication);\n    });\n    publication.on(TrackEvent.Unmuted, () => {\n      this.emit(ParticipantEvent.TrackUnmuted, publication);\n    });\n    const pub = publication;\n    if (pub.track) {\n      pub.track.sid = publication.trackSid;\n    }\n    this.tracks.set(publication.trackSid, publication);\n    switch (publication.kind) {\n      case Track.Kind.Audio:\n        this.audioTracks.set(publication.trackSid, publication);\n        break;\n      case Track.Kind.Video:\n        this.videoTracks.set(publication.trackSid, publication);\n        break;\n    }\n  }\n};\nfunction trackPermissionToProto(perms) {\n  var _a, _b, _c;\n  if (!perms.participantSid && !perms.participantIdentity) {\n    throw new Error(\"Invalid track permission, must provide at least one of participantIdentity and participantSid\");\n  }\n  return {\n    participantIdentity: (_a = perms.participantIdentity) !== null && _a !== void 0 ? _a : \"\",\n    participantSid: (_b = perms.participantSid) !== null && _b !== void 0 ? _b : \"\",\n    allTracks: (_c = perms.allowAll) !== null && _c !== void 0 ? _c : false,\n    trackSids: perms.allowedTrackSids || []\n  };\n}\nvar RemoteTrackPublication = class extends TrackPublication {\n  constructor(kind, ti, autoSubscribe) {\n    super(kind, ti.sid, ti.name);\n    this.track = void 0;\n    this.allowed = true;\n    this.disabled = false;\n    this.currentVideoQuality = VideoQuality.HIGH;\n    this.handleEnded = (track) => {\n      this.setTrack(void 0);\n      this.emit(TrackEvent.Ended, track);\n    };\n    this.handleVisibilityChange = (visible) => {\n      livekitLogger.debug(\"adaptivestream video visibility \".concat(this.trackSid, \", visible=\").concat(visible), {\n        trackSid: this.trackSid\n      });\n      this.disabled = !visible;\n      this.emitTrackUpdate();\n    };\n    this.handleVideoDimensionsChange = (dimensions) => {\n      livekitLogger.debug(\"adaptivestream video dimensions \".concat(dimensions.width, \"x\").concat(dimensions.height), {\n        trackSid: this.trackSid\n      });\n      this.videoDimensions = dimensions;\n      this.emitTrackUpdate();\n    };\n    this.subscribed = autoSubscribe;\n    this.updateInfo(ti);\n  }\n  /**\n   * Subscribe or unsubscribe to this remote track\n   * @param subscribed true to subscribe to a track, false to unsubscribe\n   */\n  setSubscribed(subscribed) {\n    const prevStatus = this.subscriptionStatus;\n    const prevPermission = this.permissionStatus;\n    this.subscribed = subscribed;\n    if (subscribed) {\n      this.allowed = true;\n    }\n    const sub = {\n      trackSids: [this.trackSid],\n      subscribe: this.subscribed,\n      participantTracks: [{\n        // sending an empty participant id since TrackPublication doesn't keep it\n        // this is filled in by the participant that receives this message\n        participantSid: \"\",\n        trackSids: [this.trackSid]\n      }]\n    };\n    this.emit(TrackEvent.UpdateSubscription, sub);\n    this.emitSubscriptionUpdateIfChanged(prevStatus);\n    this.emitPermissionUpdateIfChanged(prevPermission);\n  }\n  get subscriptionStatus() {\n    if (this.subscribed === false) {\n      return TrackPublication.SubscriptionStatus.Unsubscribed;\n    }\n    if (!super.isSubscribed) {\n      return TrackPublication.SubscriptionStatus.Desired;\n    }\n    return TrackPublication.SubscriptionStatus.Subscribed;\n  }\n  get permissionStatus() {\n    return this.allowed ? TrackPublication.PermissionStatus.Allowed : TrackPublication.PermissionStatus.NotAllowed;\n  }\n  /**\n   * Returns true if track is subscribed, and ready for playback\n   */\n  get isSubscribed() {\n    if (this.subscribed === false) {\n      return false;\n    }\n    return super.isSubscribed;\n  }\n  // returns client's desire to subscribe to a track, also true if autoSubscribe is enabled\n  get isDesired() {\n    return this.subscribed !== false;\n  }\n  get isEnabled() {\n    return !this.disabled;\n  }\n  /**\n   * disable server from sending down data for this track. this is useful when\n   * the participant is off screen, you may disable streaming down their video\n   * to reduce bandwidth requirements\n   * @param enabled\n   */\n  setEnabled(enabled) {\n    if (!this.isManualOperationAllowed() || this.disabled === !enabled) {\n      return;\n    }\n    this.disabled = !enabled;\n    this.emitTrackUpdate();\n  }\n  /**\n   * for tracks that support simulcasting, adjust subscribed quality\n   *\n   * This indicates the highest quality the client can accept. if network\n   * bandwidth does not allow, server will automatically reduce quality to\n   * optimize for uninterrupted video\n   */\n  setVideoQuality(quality) {\n    if (!this.isManualOperationAllowed() || this.currentVideoQuality === quality) {\n      return;\n    }\n    this.currentVideoQuality = quality;\n    this.videoDimensions = void 0;\n    this.emitTrackUpdate();\n  }\n  setVideoDimensions(dimensions) {\n    var _a, _b;\n    if (!this.isManualOperationAllowed()) {\n      return;\n    }\n    if (((_a = this.videoDimensions) === null || _a === void 0 ? void 0 : _a.width) === dimensions.width && ((_b = this.videoDimensions) === null || _b === void 0 ? void 0 : _b.height) === dimensions.height) {\n      return;\n    }\n    if (this.track instanceof RemoteVideoTrack) {\n      this.videoDimensions = dimensions;\n    }\n    this.currentVideoQuality = void 0;\n    this.emitTrackUpdate();\n  }\n  setVideoFPS(fps) {\n    if (!this.isManualOperationAllowed()) {\n      return;\n    }\n    if (!(this.track instanceof RemoteVideoTrack)) {\n      return;\n    }\n    if (this.fps === fps) {\n      return;\n    }\n    this.fps = fps;\n    this.emitTrackUpdate();\n  }\n  get videoQuality() {\n    return this.currentVideoQuality;\n  }\n  /** @internal */\n  setTrack(track) {\n    const prevStatus = this.subscriptionStatus;\n    const prevPermission = this.permissionStatus;\n    const prevTrack = this.track;\n    if (prevTrack === track) {\n      return;\n    }\n    if (prevTrack) {\n      prevTrack.off(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);\n      prevTrack.off(TrackEvent.VisibilityChanged, this.handleVisibilityChange);\n      prevTrack.off(TrackEvent.Ended, this.handleEnded);\n      prevTrack.detach();\n      prevTrack.stopMonitor();\n      this.emit(TrackEvent.Unsubscribed, prevTrack);\n    }\n    super.setTrack(track);\n    if (track) {\n      track.sid = this.trackSid;\n      track.on(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);\n      track.on(TrackEvent.VisibilityChanged, this.handleVisibilityChange);\n      track.on(TrackEvent.Ended, this.handleEnded);\n      this.emit(TrackEvent.Subscribed, track);\n    }\n    this.emitPermissionUpdateIfChanged(prevPermission);\n    this.emitSubscriptionUpdateIfChanged(prevStatus);\n  }\n  /** @internal */\n  setAllowed(allowed) {\n    const prevStatus = this.subscriptionStatus;\n    const prevPermission = this.permissionStatus;\n    this.allowed = allowed;\n    this.emitPermissionUpdateIfChanged(prevPermission);\n    this.emitSubscriptionUpdateIfChanged(prevStatus);\n  }\n  /** @internal */\n  updateInfo(info) {\n    super.updateInfo(info);\n    const prevMetadataMuted = this.metadataMuted;\n    this.metadataMuted = info.muted;\n    if (this.track) {\n      this.track.setMuted(info.muted);\n    } else if (prevMetadataMuted !== info.muted) {\n      this.emit(info.muted ? TrackEvent.Muted : TrackEvent.Unmuted);\n    }\n  }\n  emitSubscriptionUpdateIfChanged(previousStatus) {\n    const currentStatus = this.subscriptionStatus;\n    if (previousStatus === currentStatus) {\n      return;\n    }\n    this.emit(TrackEvent.SubscriptionStatusChanged, currentStatus, previousStatus);\n  }\n  emitPermissionUpdateIfChanged(previousPermissionStatus) {\n    const currentPermissionStatus = this.permissionStatus;\n    if (currentPermissionStatus !== previousPermissionStatus) {\n      this.emit(TrackEvent.SubscriptionPermissionChanged, this.permissionStatus, previousPermissionStatus);\n    }\n  }\n  isManualOperationAllowed() {\n    if (this.kind === Track.Kind.Video && this.isAdaptiveStream) {\n      livekitLogger.warn(\"adaptive stream is enabled, cannot change video track settings\", {\n        trackSid: this.trackSid\n      });\n      return false;\n    }\n    if (!this.isDesired) {\n      livekitLogger.warn(\"cannot update track settings when not subscribed\", {\n        trackSid: this.trackSid\n      });\n      return false;\n    }\n    return true;\n  }\n  get isAdaptiveStream() {\n    return this.track instanceof RemoteVideoTrack && this.track.isAdaptiveStream;\n  }\n  /* @internal */\n  emitTrackUpdate() {\n    const settings = UpdateTrackSettings.fromPartial({\n      trackSids: [this.trackSid],\n      disabled: this.disabled,\n      fps: this.fps\n    });\n    if (this.videoDimensions) {\n      settings.width = this.videoDimensions.width;\n      settings.height = this.videoDimensions.height;\n    } else if (this.currentVideoQuality !== void 0) {\n      settings.quality = this.currentVideoQuality;\n    } else {\n      settings.quality = VideoQuality.HIGH;\n    }\n    this.emit(TrackEvent.UpdateSettings, settings);\n  }\n};\nvar RemoteParticipant = class extends Participant {\n  /** @internal */\n  static fromParticipantInfo(signalClient, pi) {\n    return new RemoteParticipant(signalClient, pi.sid, pi.identity, pi.name, pi.metadata);\n  }\n  /** @internal */\n  constructor(signalClient, sid, identity, name, metadata) {\n    super(sid, identity || \"\", name, metadata);\n    this.signalClient = signalClient;\n    this.tracks = /* @__PURE__ */ new Map();\n    this.audioTracks = /* @__PURE__ */ new Map();\n    this.videoTracks = /* @__PURE__ */ new Map();\n  }\n  addTrackPublication(publication) {\n    super.addTrackPublication(publication);\n    publication.on(TrackEvent.UpdateSettings, (settings) => {\n      livekitLogger.debug(\"send update settings\", settings);\n      this.signalClient.sendUpdateTrackSettings(settings);\n    });\n    publication.on(TrackEvent.UpdateSubscription, (sub) => {\n      sub.participantTracks.forEach((pt) => {\n        pt.participantSid = this.sid;\n      });\n      this.signalClient.sendUpdateSubscription(sub);\n    });\n    publication.on(TrackEvent.SubscriptionPermissionChanged, (status) => {\n      this.emit(ParticipantEvent.TrackSubscriptionPermissionChanged, publication, status);\n    });\n    publication.on(TrackEvent.SubscriptionStatusChanged, (status) => {\n      this.emit(ParticipantEvent.TrackSubscriptionStatusChanged, publication, status);\n    });\n    publication.on(TrackEvent.Subscribed, (track) => {\n      this.emit(ParticipantEvent.TrackSubscribed, track, publication);\n    });\n    publication.on(TrackEvent.Unsubscribed, (previousTrack) => {\n      this.emit(ParticipantEvent.TrackUnsubscribed, previousTrack, publication);\n    });\n  }\n  getTrack(source) {\n    const track = super.getTrack(source);\n    if (track) {\n      return track;\n    }\n  }\n  getTrackByName(name) {\n    const track = super.getTrackByName(name);\n    if (track) {\n      return track;\n    }\n  }\n  /**\n   * sets the volume on the participant's microphone track\n   * if no track exists the volume will be applied when the microphone track is added\n   */\n  setVolume(volume) {\n    this.volume = volume;\n    const audioPublication = this.getTrack(Track.Source.Microphone);\n    if (audioPublication && audioPublication.track) {\n      audioPublication.track.setVolume(volume);\n    }\n  }\n  /**\n   * gets the volume on the participant's microphone track\n   */\n  getVolume() {\n    const audioPublication = this.getTrack(Track.Source.Microphone);\n    if (audioPublication && audioPublication.track) {\n      return audioPublication.track.getVolume();\n    }\n    return this.volume;\n  }\n  /** @internal */\n  addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft) {\n    let publication = this.getTrackPublication(sid);\n    if (!publication) {\n      if (!sid.startsWith(\"TR\")) {\n        this.tracks.forEach((p) => {\n          if (!publication && mediaTrack.kind === p.kind.toString()) {\n            publication = p;\n          }\n        });\n      }\n    }\n    if (!publication) {\n      if (triesLeft === 0) {\n        livekitLogger.error(\"could not find published track\", {\n          participant: this.sid,\n          trackSid: sid\n        });\n        this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);\n        return;\n      }\n      if (triesLeft === void 0)\n        triesLeft = 20;\n      setTimeout(() => {\n        this.addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft - 1);\n      }, 150);\n      return;\n    }\n    if (mediaTrack.readyState === \"ended\") {\n      livekitLogger.error(\"unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()\", {\n        participant: this.sid,\n        trackSid: sid\n      });\n      this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);\n      return;\n    }\n    const isVideo = mediaTrack.kind === \"video\";\n    let track;\n    if (isVideo) {\n      track = new RemoteVideoTrack(mediaTrack, sid, receiver, adaptiveStreamSettings);\n    } else {\n      track = new RemoteAudioTrack(mediaTrack, sid, receiver, this.audioContext, this.audioOutput);\n    }\n    track.source = publication.source;\n    track.isMuted = publication.isMuted;\n    track.setMediaStream(mediaStream);\n    track.start();\n    publication.setTrack(track);\n    if (this.volume !== void 0 && track instanceof RemoteAudioTrack && track.source === Track.Source.Microphone) {\n      track.setVolume(this.volume);\n    }\n    return publication;\n  }\n  /** @internal */\n  get hasMetadata() {\n    return !!this.participantInfo;\n  }\n  getTrackPublication(sid) {\n    return this.tracks.get(sid);\n  }\n  /** @internal */\n  updateInfo(info) {\n    if (!super.updateInfo(info)) {\n      return false;\n    }\n    const validTracks = /* @__PURE__ */ new Map();\n    const newTracks = /* @__PURE__ */ new Map();\n    info.tracks.forEach((ti) => {\n      var _a;\n      let publication = this.getTrackPublication(ti.sid);\n      if (!publication) {\n        const kind = Track.kindFromProto(ti.type);\n        if (!kind) {\n          return;\n        }\n        publication = new RemoteTrackPublication(kind, ti, (_a = this.signalClient.connectOptions) === null || _a === void 0 ? void 0 : _a.autoSubscribe);\n        publication.updateInfo(ti);\n        newTracks.set(ti.sid, publication);\n        const existingTrackOfSource = Array.from(this.tracks.values()).find((publishedTrack) => publishedTrack.source === (publication === null || publication === void 0 ? void 0 : publication.source));\n        if (existingTrackOfSource && publication.source !== Track.Source.Unknown) {\n          livekitLogger.debug(\"received a second track publication for \".concat(this.identity, \" with the same source: \").concat(publication.source), {\n            oldTrack: existingTrackOfSource,\n            newTrack: publication,\n            participant: this,\n            participantInfo: info\n          });\n        }\n        this.addTrackPublication(publication);\n      } else {\n        publication.updateInfo(ti);\n      }\n      validTracks.set(ti.sid, publication);\n    });\n    this.tracks.forEach((publication) => {\n      if (!validTracks.has(publication.trackSid)) {\n        livekitLogger.trace(\"detected removed track on remote participant, unpublishing\", {\n          publication,\n          participantSid: this.sid\n        });\n        this.unpublishTrack(publication.trackSid, true);\n      }\n    });\n    newTracks.forEach((publication) => {\n      this.emit(ParticipantEvent.TrackPublished, publication);\n    });\n    return true;\n  }\n  /** @internal */\n  unpublishTrack(sid, sendUnpublish) {\n    const publication = this.tracks.get(sid);\n    if (!publication) {\n      return;\n    }\n    this.tracks.delete(sid);\n    switch (publication.kind) {\n      case Track.Kind.Audio:\n        this.audioTracks.delete(sid);\n        break;\n      case Track.Kind.Video:\n        this.videoTracks.delete(sid);\n        break;\n    }\n    const {\n      track\n    } = publication;\n    if (track) {\n      track.stop();\n      publication.setTrack(void 0);\n    }\n    if (sendUnpublish) {\n      this.emit(ParticipantEvent.TrackUnpublished, publication);\n    }\n  }\n  /**\n   * @internal\n   */\n  setAudioContext(ctx) {\n    this.audioContext = ctx;\n    this.audioTracks.forEach((track) => track.track instanceof RemoteAudioTrack && track.track.setAudioContext(ctx));\n  }\n  /**\n   * @internal\n   */\n  setAudioOutput(output) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.audioOutput = output;\n      const promises = [];\n      this.audioTracks.forEach((pub) => {\n        var _a;\n        if (pub.track instanceof RemoteAudioTrack) {\n          promises.push(pub.track.setSinkId((_a = output.deviceId) !== null && _a !== void 0 ? _a : \"default\"));\n        }\n      });\n      yield Promise.all(promises);\n    });\n  }\n  /** @internal */\n  emit(event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    livekitLogger.trace(\"participant event\", {\n      participant: this.sid,\n      event,\n      args\n    });\n    return super.emit(event, ...args);\n  }\n};\nfunction mediaTrackToLocalTrack(mediaStreamTrack, constraints) {\n  switch (mediaStreamTrack.kind) {\n    case \"audio\":\n      return new LocalAudioTrack(mediaStreamTrack, constraints, false);\n    case \"video\":\n      return new LocalVideoTrack(mediaStreamTrack, constraints, false);\n    default:\n      throw new TrackInvalidError(\"unsupported track type: \".concat(mediaStreamTrack.kind));\n  }\n}\nvar presets169 = Object.values(VideoPresets);\nvar presets43 = Object.values(VideoPresets43);\nvar presetsScreenShare = Object.values(ScreenSharePresets);\nvar defaultSimulcastPresets169 = [VideoPresets.h180, VideoPresets.h360];\nvar defaultSimulcastPresets43 = [VideoPresets43.h180, VideoPresets43.h360];\nvar computeDefaultScreenShareSimulcastPresets = (fromPreset) => {\n  const layers = [{\n    scaleResolutionDownBy: 2,\n    fps: 3\n  }];\n  return layers.map((t) => {\n    var _a;\n    return new VideoPreset(Math.floor(fromPreset.width / t.scaleResolutionDownBy), Math.floor(fromPreset.height / t.scaleResolutionDownBy), Math.max(15e4, Math.floor(fromPreset.encoding.maxBitrate / (Math.pow(t.scaleResolutionDownBy, 2) * (((_a = fromPreset.encoding.maxFramerate) !== null && _a !== void 0 ? _a : 30) / t.fps)))), t.fps, fromPreset.encoding.priority);\n  });\n};\nvar videoRids = [\"q\", \"h\", \"f\"];\nfunction computeVideoEncodings(isScreenShare, width, height, options) {\n  var _a, _b;\n  let videoEncoding = options === null || options === void 0 ? void 0 : options.videoEncoding;\n  if (isScreenShare) {\n    videoEncoding = options === null || options === void 0 ? void 0 : options.screenShareEncoding;\n  }\n  const useSimulcast = options === null || options === void 0 ? void 0 : options.simulcast;\n  const scalabilityMode = options === null || options === void 0 ? void 0 : options.scalabilityMode;\n  const videoCodec = options === null || options === void 0 ? void 0 : options.videoCodec;\n  if (!videoEncoding && !useSimulcast && !scalabilityMode || !width || !height) {\n    return [{}];\n  }\n  if (!videoEncoding) {\n    videoEncoding = determineAppropriateEncoding(isScreenShare, width, height, videoCodec);\n    livekitLogger.debug(\"using video encoding\", videoEncoding);\n  }\n  const original = new VideoPreset(width, height, videoEncoding.maxBitrate, videoEncoding.maxFramerate);\n  if (scalabilityMode && isSVCCodec(videoCodec)) {\n    livekitLogger.debug(\"using svc with scalabilityMode \".concat(scalabilityMode));\n    const encodings = [];\n    switch (scalabilityMode) {\n      case \"L3T3\":\n        for (let i = 0; i < 3; i += 1) {\n          encodings.push({\n            rid: videoRids[2 - i],\n            scaleResolutionDownBy: Math.pow(2, i),\n            maxBitrate: videoEncoding.maxBitrate / Math.pow(3, i),\n            /* @ts-ignore */\n            maxFramerate: original.encoding.maxFramerate,\n            /* @ts-ignore */\n            scalabilityMode: \"L3T3\"\n          });\n        }\n        livekitLogger.debug(\"encodings\", encodings);\n        return encodings;\n      default:\n        throw new Error(\"unsupported scalabilityMode: \".concat(scalabilityMode));\n    }\n  }\n  if (!useSimulcast) {\n    return [videoEncoding];\n  }\n  let presets = [];\n  if (isScreenShare) {\n    presets = (_a = sortPresets(options === null || options === void 0 ? void 0 : options.screenShareSimulcastLayers)) !== null && _a !== void 0 ? _a : defaultSimulcastLayers(isScreenShare, original);\n  } else {\n    presets = (_b = sortPresets(options === null || options === void 0 ? void 0 : options.videoSimulcastLayers)) !== null && _b !== void 0 ? _b : defaultSimulcastLayers(isScreenShare, original);\n  }\n  let midPreset;\n  if (presets.length > 0) {\n    const lowPreset = presets[0];\n    if (presets.length > 1) {\n      [, midPreset] = presets;\n    }\n    const size = Math.max(width, height);\n    if (size >= 960 && midPreset) {\n      return encodingsFromPresets(width, height, [lowPreset, midPreset, original]);\n    }\n    if (size >= 480) {\n      return encodingsFromPresets(width, height, [lowPreset, original]);\n    }\n  }\n  return encodingsFromPresets(width, height, [original]);\n}\nfunction computeTrackBackupEncodings(track, videoCodec, opts) {\n  var _a, _b, _c, _d;\n  if (!opts.backupCodec || opts.backupCodec.codec === opts.videoCodec) {\n    return;\n  }\n  if (videoCodec !== opts.backupCodec.codec) {\n    livekitLogger.warn(\"requested a different codec than specified as backup\", {\n      serverRequested: videoCodec,\n      backup: opts.backupCodec.codec\n    });\n  }\n  opts.videoCodec = videoCodec;\n  opts.videoEncoding = opts.backupCodec.encoding;\n  const settings = track.mediaStreamTrack.getSettings();\n  const width = (_a = settings.width) !== null && _a !== void 0 ? _a : (_b = track.dimensions) === null || _b === void 0 ? void 0 : _b.width;\n  const height = (_c = settings.height) !== null && _c !== void 0 ? _c : (_d = track.dimensions) === null || _d === void 0 ? void 0 : _d.height;\n  const encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, width, height, opts);\n  return encodings;\n}\nfunction determineAppropriateEncoding(isScreenShare, width, height, codec) {\n  const presets = presetsForResolution(isScreenShare, width, height);\n  let {\n    encoding\n  } = presets[0];\n  const size = Math.max(width, height);\n  for (let i = 0; i < presets.length; i += 1) {\n    const preset = presets[i];\n    encoding = preset.encoding;\n    if (preset.width >= size) {\n      break;\n    }\n  }\n  if (codec) {\n    switch (codec) {\n      case \"av1\":\n        encoding = Object.assign({}, encoding);\n        encoding.maxBitrate = encoding.maxBitrate * 0.7;\n        break;\n      case \"vp9\":\n        encoding = Object.assign({}, encoding);\n        encoding.maxBitrate = encoding.maxBitrate * 0.85;\n        break;\n    }\n  }\n  return encoding;\n}\nfunction presetsForResolution(isScreenShare, width, height) {\n  if (isScreenShare) {\n    return presetsScreenShare;\n  }\n  const aspect = width > height ? width / height : height / width;\n  if (Math.abs(aspect - 16 / 9) < Math.abs(aspect - 4 / 3)) {\n    return presets169;\n  }\n  return presets43;\n}\nfunction defaultSimulcastLayers(isScreenShare, original) {\n  if (isScreenShare) {\n    return computeDefaultScreenShareSimulcastPresets(original);\n  }\n  const {\n    width,\n    height\n  } = original;\n  const aspect = width > height ? width / height : height / width;\n  if (Math.abs(aspect - 16 / 9) < Math.abs(aspect - 4 / 3)) {\n    return defaultSimulcastPresets169;\n  }\n  return defaultSimulcastPresets43;\n}\nfunction encodingsFromPresets(width, height, presets) {\n  const encodings = [];\n  presets.forEach((preset, idx) => {\n    if (idx >= videoRids.length) {\n      return;\n    }\n    const size = Math.min(width, height);\n    const rid = videoRids[idx];\n    const encoding = {\n      rid,\n      scaleResolutionDownBy: Math.max(1, size / Math.min(preset.width, preset.height)),\n      maxBitrate: preset.encoding.maxBitrate\n    };\n    if (preset.encoding.maxFramerate) {\n      encoding.maxFramerate = preset.encoding.maxFramerate;\n    }\n    if (preset.encoding.priority) {\n      encoding.priority = preset.encoding.priority;\n      encoding.networkPriority = preset.encoding.priority;\n    }\n    encodings.push(encoding);\n  });\n  return encodings;\n}\nfunction sortPresets(presets) {\n  if (!presets)\n    return;\n  return presets.sort((a, b) => {\n    const {\n      encoding: aEnc\n    } = a;\n    const {\n      encoding: bEnc\n    } = b;\n    if (aEnc.maxBitrate > bEnc.maxBitrate) {\n      return 1;\n    }\n    if (aEnc.maxBitrate < bEnc.maxBitrate)\n      return -1;\n    if (aEnc.maxBitrate === bEnc.maxBitrate && aEnc.maxFramerate && bEnc.maxFramerate) {\n      return aEnc.maxFramerate > bEnc.maxFramerate ? 1 : -1;\n    }\n    return 0;\n  });\n}\nvar LocalParticipant = class extends Participant {\n  /** @internal */\n  constructor(sid, identity, engine, options) {\n    super(sid, identity);\n    this.pendingPublishing = /* @__PURE__ */ new Set();\n    this.pendingPublishPromises = /* @__PURE__ */ new Map();\n    this.participantTrackPermissions = [];\n    this.allParticipantsAllowedToSubscribe = true;\n    this.handleReconnecting = () => {\n      if (!this.reconnectFuture) {\n        this.reconnectFuture = new Future();\n      }\n    };\n    this.handleReconnected = () => {\n      var _a, _b;\n      (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.resolve) === null || _b === void 0 ? void 0 : _b.call(_a);\n      this.reconnectFuture = void 0;\n      this.updateTrackSubscriptionPermissions();\n    };\n    this.handleDisconnected = () => {\n      var _a, _b;\n      (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.reject) === null || _b === void 0 ? void 0 : _b.call(_a, \"Got disconnected during publishing attempt\");\n      this.reconnectFuture = void 0;\n    };\n    this.updateTrackSubscriptionPermissions = () => {\n      livekitLogger.debug(\"updating track subscription permissions\", {\n        allParticipantsAllowed: this.allParticipantsAllowedToSubscribe,\n        participantTrackPermissions: this.participantTrackPermissions\n      });\n      this.engine.client.sendUpdateSubscriptionPermissions(this.allParticipantsAllowedToSubscribe, this.participantTrackPermissions.map((p) => trackPermissionToProto(p)));\n    };\n    this.onTrackUnmuted = (track) => {\n      this.onTrackMuted(track, track.isUpstreamPaused);\n    };\n    this.onTrackMuted = (track, muted) => {\n      if (muted === void 0) {\n        muted = true;\n      }\n      if (!track.sid) {\n        livekitLogger.error(\"could not update mute status for unpublished track\", track);\n        return;\n      }\n      this.engine.updateMuteStatus(track.sid, muted);\n    };\n    this.onTrackUpstreamPaused = (track) => {\n      livekitLogger.debug(\"upstream paused\");\n      this.onTrackMuted(track, true);\n    };\n    this.onTrackUpstreamResumed = (track) => {\n      livekitLogger.debug(\"upstream resumed\");\n      this.onTrackMuted(track, track.isMuted);\n    };\n    this.handleSubscribedQualityUpdate = (update) => __awaiter(this, void 0, void 0, function* () {\n      var _a, e_1, _b, _c;\n      var _d, _e;\n      if (!((_d = this.roomOptions) === null || _d === void 0 ? void 0 : _d.dynacast)) {\n        return;\n      }\n      const pub = this.videoTracks.get(update.trackSid);\n      if (!pub) {\n        livekitLogger.warn(\"received subscribed quality update for unknown track\", {\n          method: \"handleSubscribedQualityUpdate\",\n          sid: update.trackSid\n        });\n        return;\n      }\n      if (update.subscribedCodecs.length > 0) {\n        if (!pub.videoTrack) {\n          return;\n        }\n        const newCodecs = yield pub.videoTrack.setPublishingCodecs(update.subscribedCodecs);\n        try {\n          for (var _f = true, newCodecs_1 = __asyncValues(newCodecs), newCodecs_1_1; newCodecs_1_1 = yield newCodecs_1.next(), _a = newCodecs_1_1.done, !_a; ) {\n            _c = newCodecs_1_1.value;\n            _f = false;\n            try {\n              const codec = _c;\n              if (isBackupCodec(codec)) {\n                livekitLogger.debug(\"publish \".concat(codec, \" for \").concat(pub.videoTrack.sid));\n                yield this.publishAdditionalCodecForTrack(pub.videoTrack, codec, pub.options);\n              }\n            } finally {\n              _f = true;\n            }\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (!_f && !_a && (_b = newCodecs_1.return))\n              yield _b.call(newCodecs_1);\n          } finally {\n            if (e_1)\n              throw e_1.error;\n          }\n        }\n      } else if (update.subscribedQualities.length > 0) {\n        yield (_e = pub.videoTrack) === null || _e === void 0 ? void 0 : _e.setPublishingLayers(update.subscribedQualities);\n      }\n    });\n    this.handleLocalTrackUnpublished = (unpublished) => {\n      const track = this.tracks.get(unpublished.trackSid);\n      if (!track) {\n        livekitLogger.warn(\"received unpublished event for unknown track\", {\n          method: \"handleLocalTrackUnpublished\",\n          trackSid: unpublished.trackSid\n        });\n        return;\n      }\n      this.unpublishTrack(track.track);\n    };\n    this.handleTrackEnded = (track) => __awaiter(this, void 0, void 0, function* () {\n      if (track.source === Track.Source.ScreenShare || track.source === Track.Source.ScreenShareAudio) {\n        livekitLogger.debug(\"unpublishing local track due to TrackEnded\", {\n          track: track.sid\n        });\n        this.unpublishTrack(track);\n      } else if (track.isUserProvided) {\n        yield track.mute();\n      } else if (track instanceof LocalAudioTrack || track instanceof LocalVideoTrack) {\n        try {\n          if (isWeb()) {\n            try {\n              const currentPermissions = yield navigator === null || navigator === void 0 ? void 0 : navigator.permissions.query({\n                // the permission query for camera and microphone currently not supported in Safari and Firefox\n                // @ts-ignore\n                name: track.source === Track.Source.Camera ? \"camera\" : \"microphone\"\n              });\n              if (currentPermissions && currentPermissions.state === \"denied\") {\n                livekitLogger.warn(\"user has revoked access to \".concat(track.source));\n                currentPermissions.onchange = () => {\n                  if (currentPermissions.state !== \"denied\") {\n                    if (!track.isMuted) {\n                      track.restartTrack();\n                    }\n                    currentPermissions.onchange = null;\n                  }\n                };\n                throw new Error(\"GetUserMedia Permission denied\");\n              }\n            } catch (e) {\n            }\n          }\n          if (!track.isMuted) {\n            livekitLogger.debug(\"track ended, attempting to use a different device\");\n            yield track.restartTrack();\n          }\n        } catch (e) {\n          livekitLogger.warn(\"could not restart track, muting instead\");\n          yield track.mute();\n        }\n      }\n    });\n    this.audioTracks = /* @__PURE__ */ new Map();\n    this.videoTracks = /* @__PURE__ */ new Map();\n    this.tracks = /* @__PURE__ */ new Map();\n    this.engine = engine;\n    this.roomOptions = options;\n    this.setupEngine(engine);\n  }\n  get lastCameraError() {\n    return this.cameraError;\n  }\n  get lastMicrophoneError() {\n    return this.microphoneError;\n  }\n  getTrack(source) {\n    const track = super.getTrack(source);\n    if (track) {\n      return track;\n    }\n  }\n  getTrackByName(name) {\n    const track = super.getTrackByName(name);\n    if (track) {\n      return track;\n    }\n  }\n  /**\n   * @internal\n   */\n  setupEngine(engine) {\n    this.engine = engine;\n    this.engine.client.onRemoteMuteChanged = (trackSid, muted) => {\n      const pub = this.tracks.get(trackSid);\n      if (!pub || !pub.track) {\n        return;\n      }\n      if (muted) {\n        pub.mute();\n      } else {\n        pub.unmute();\n      }\n    };\n    this.engine.client.onSubscribedQualityUpdate = this.handleSubscribedQualityUpdate;\n    this.engine.client.onLocalTrackUnpublished = this.handleLocalTrackUnpublished;\n    this.engine.on(EngineEvent.Connected, this.handleReconnected).on(EngineEvent.Restarted, this.handleReconnected).on(EngineEvent.Resumed, this.handleReconnected).on(EngineEvent.Restarting, this.handleReconnecting).on(EngineEvent.Resuming, this.handleReconnecting).on(EngineEvent.Disconnected, this.handleDisconnected);\n  }\n  /**\n   * Sets and updates the metadata of the local participant.\n   * Note: this requires `canUpdateOwnMetadata` permission encoded in the token.\n   * @param metadata\n   */\n  setMetadata(metadata) {\n    var _a;\n    super.setMetadata(metadata);\n    this.engine.client.sendUpdateLocalMetadata(metadata, (_a = this.name) !== null && _a !== void 0 ? _a : \"\");\n  }\n  /**\n   * Sets and updates the name of the local participant.\n   * Note: this requires `canUpdateOwnMetadata` permission encoded in the token.\n   * @param metadata\n   */\n  setName(name) {\n    var _a;\n    super.setName(name);\n    this.engine.client.sendUpdateLocalMetadata((_a = this.metadata) !== null && _a !== void 0 ? _a : \"\", name);\n  }\n  /**\n   * Enable or disable a participant's camera track.\n   *\n   * If a track has already published, it'll mute or unmute the track.\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */\n  setCameraEnabled(enabled, options, publishOptions) {\n    return this.setTrackEnabled(Track.Source.Camera, enabled, options, publishOptions);\n  }\n  /**\n   * Enable or disable a participant's microphone track.\n   *\n   * If a track has already published, it'll mute or unmute the track.\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */\n  setMicrophoneEnabled(enabled, options, publishOptions) {\n    return this.setTrackEnabled(Track.Source.Microphone, enabled, options, publishOptions);\n  }\n  /**\n   * Start or stop sharing a participant's screen\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */\n  setScreenShareEnabled(enabled, options, publishOptions) {\n    return this.setTrackEnabled(Track.Source.ScreenShare, enabled, options, publishOptions);\n  }\n  setTrackEnabled(source, enabled, options, publishOptions) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      livekitLogger.debug(\"setTrackEnabled\", {\n        source,\n        enabled\n      });\n      let track = this.getTrack(source);\n      if (enabled) {\n        if (track) {\n          yield track.unmute();\n        } else {\n          let localTracks;\n          if (this.pendingPublishing.has(source)) {\n            livekitLogger.info(\"skipping duplicate published source\", {\n              source\n            });\n            return;\n          }\n          this.pendingPublishing.add(source);\n          try {\n            switch (source) {\n              case Track.Source.Camera:\n                localTracks = yield this.createTracks({\n                  video: (_a = options) !== null && _a !== void 0 ? _a : true\n                });\n                break;\n              case Track.Source.Microphone:\n                localTracks = yield this.createTracks({\n                  audio: (_b = options) !== null && _b !== void 0 ? _b : true\n                });\n                break;\n              case Track.Source.ScreenShare:\n                localTracks = yield this.createScreenTracks(Object.assign({}, options));\n                break;\n              default:\n                throw new TrackInvalidError(source);\n            }\n            const publishPromises = [];\n            for (const localTrack of localTracks) {\n              livekitLogger.info(\"publishing track\", {\n                localTrack\n              });\n              publishPromises.push(this.publishTrack(localTrack, publishOptions));\n            }\n            const publishedTracks = yield Promise.all(publishPromises);\n            [track] = publishedTracks;\n          } catch (e) {\n            if (e instanceof Error && !(e instanceof TrackInvalidError)) {\n              this.emit(ParticipantEvent.MediaDevicesError, e);\n            }\n            throw e;\n          } finally {\n            this.pendingPublishing.delete(source);\n          }\n        }\n      } else if (track && track.track) {\n        if (source === Track.Source.ScreenShare) {\n          track = yield this.unpublishTrack(track.track);\n          const screenAudioTrack = this.getTrack(Track.Source.ScreenShareAudio);\n          if (screenAudioTrack && screenAudioTrack.track) {\n            this.unpublishTrack(screenAudioTrack.track);\n          }\n        } else {\n          yield track.mute();\n        }\n      }\n      return track;\n    });\n  }\n  /**\n   * Publish both camera and microphone at the same time. This is useful for\n   * displaying a single Permission Dialog box to the end user.\n   */\n  enableCameraAndMicrophone() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.pendingPublishing.has(Track.Source.Camera) || this.pendingPublishing.has(Track.Source.Microphone)) {\n        return;\n      }\n      this.pendingPublishing.add(Track.Source.Camera);\n      this.pendingPublishing.add(Track.Source.Microphone);\n      try {\n        const tracks = yield this.createTracks({\n          audio: true,\n          video: true\n        });\n        yield Promise.all(tracks.map((track) => this.publishTrack(track)));\n      } finally {\n        this.pendingPublishing.delete(Track.Source.Camera);\n        this.pendingPublishing.delete(Track.Source.Microphone);\n      }\n    });\n  }\n  /**\n   * Create local camera and/or microphone tracks\n   * @param options\n   * @returns\n   */\n  createTracks(options) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const opts = mergeDefaultOptions(options, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.audioCaptureDefaults, (_b = this.roomOptions) === null || _b === void 0 ? void 0 : _b.videoCaptureDefaults);\n      const constraints = constraintsForOptions(opts);\n      let stream;\n      try {\n        stream = yield navigator.mediaDevices.getUserMedia(constraints);\n      } catch (err) {\n        if (err instanceof Error) {\n          if (constraints.audio) {\n            this.microphoneError = err;\n          }\n          if (constraints.video) {\n            this.cameraError = err;\n          }\n        }\n        throw err;\n      }\n      if (constraints.audio) {\n        this.microphoneError = void 0;\n      }\n      if (constraints.video) {\n        this.cameraError = void 0;\n      }\n      return stream.getTracks().map((mediaStreamTrack) => {\n        const isAudio = mediaStreamTrack.kind === \"audio\";\n        isAudio ? options.audio : options.video;\n        let trackConstraints;\n        const conOrBool = isAudio ? constraints.audio : constraints.video;\n        if (typeof conOrBool !== \"boolean\") {\n          trackConstraints = conOrBool;\n        }\n        const track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints);\n        if (track.kind === Track.Kind.Video) {\n          track.source = Track.Source.Camera;\n        } else if (track.kind === Track.Kind.Audio) {\n          track.source = Track.Source.Microphone;\n        }\n        track.mediaStream = stream;\n        return track;\n      });\n    });\n  }\n  /**\n   * Creates a screen capture tracks with getDisplayMedia().\n   * A LocalVideoTrack is always created and returned.\n   * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.\n   */\n  createScreenTracks(options) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (options === void 0) {\n        options = {};\n      }\n      if (options.resolution === void 0) {\n        options.resolution = ScreenSharePresets.h1080fps15.resolution;\n      }\n      let videoConstraints = true;\n      if (options.resolution) {\n        if (isSafari()) {\n          videoConstraints = {\n            width: {\n              max: options.resolution.width\n            },\n            height: {\n              max: options.resolution.height\n            },\n            frameRate: options.resolution.frameRate\n          };\n        } else {\n          videoConstraints = {\n            width: {\n              ideal: options.resolution.width\n            },\n            height: {\n              ideal: options.resolution.height\n            },\n            frameRate: options.resolution.frameRate\n          };\n        }\n      }\n      if (navigator.mediaDevices.getDisplayMedia === void 0) {\n        throw new DeviceUnsupportedError(\"getDisplayMedia not supported\");\n      }\n      const stream = yield navigator.mediaDevices.getDisplayMedia({\n        audio: (_a = options.audio) !== null && _a !== void 0 ? _a : false,\n        video: videoConstraints,\n        // @ts-expect-error support for experimental display media features\n        controller: options.controller,\n        selfBrowserSurface: options.selfBrowserSurface,\n        surfaceSwitching: options.surfaceSwitching,\n        systemAudio: options.systemAudio\n      });\n      const tracks = stream.getVideoTracks();\n      if (tracks.length === 0) {\n        throw new TrackInvalidError(\"no video track found\");\n      }\n      const screenVideo = new LocalVideoTrack(tracks[0], void 0, false);\n      screenVideo.source = Track.Source.ScreenShare;\n      const localTracks = [screenVideo];\n      if (stream.getAudioTracks().length > 0) {\n        const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], void 0, false);\n        screenAudio.source = Track.Source.ScreenShareAudio;\n        localTracks.push(screenAudio);\n      }\n      return localTracks;\n    });\n  }\n  /**\n   * Publish a new track to the room\n   * @param track\n   * @param options\n   */\n  publishTrack(track, options) {\n    var _a, _b, _c;\n    return __awaiter(this, void 0, void 0, function* () {\n      yield (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.promise;\n      if (track instanceof LocalTrack && this.pendingPublishPromises.has(track)) {\n        yield this.pendingPublishPromises.get(track);\n      }\n      if (track instanceof MediaStreamTrack) {\n        switch (track.kind) {\n          case \"audio\":\n            track = new LocalAudioTrack(track, void 0, true);\n            break;\n          case \"video\":\n            track = new LocalVideoTrack(track, void 0, true);\n            break;\n          default:\n            throw new TrackInvalidError(\"unsupported MediaStreamTrack kind \".concat(track.kind));\n        }\n      }\n      let existingPublication;\n      this.tracks.forEach((publication) => {\n        if (!publication.track) {\n          return;\n        }\n        if (publication.track === track) {\n          existingPublication = publication;\n        }\n      });\n      if (existingPublication) {\n        livekitLogger.warn(\"track has already been published, skipping\");\n        return existingPublication;\n      }\n      const isStereo = (options === null || options === void 0 ? void 0 : options.forceStereo) || \"channelCount\" in track.mediaStreamTrack.getSettings() && // @ts-ignore `channelCount` on getSettings() is currently only available for Safari, but is generally the best way to determine a stereo track https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/channelCount\n      track.mediaStreamTrack.getSettings().channelCount === 2 || track.mediaStreamTrack.getConstraints().channelCount === 2;\n      if (isStereo) {\n        if (!options) {\n          options = {};\n        }\n        if (options.dtx === void 0) {\n          livekitLogger.info(\"Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.\");\n        }\n        if (options.red === void 0) {\n          livekitLogger.info(\"Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work.\");\n        }\n        (_b = options.dtx) !== null && _b !== void 0 ? _b : options.dtx = false;\n        (_c = options.red) !== null && _c !== void 0 ? _c : options.red = false;\n      }\n      const opts = Object.assign(Object.assign({}, this.roomOptions.publishDefaults), options);\n      if (opts.source) {\n        track.source = opts.source;\n      }\n      const publishPromise = this.publish(track, opts, options, isStereo);\n      this.pendingPublishPromises.set(track, publishPromise);\n      try {\n        const publication = yield publishPromise;\n        return publication;\n      } catch (e) {\n        throw e;\n      } finally {\n        this.pendingPublishPromises.delete(track);\n      }\n    });\n  }\n  publish(track, opts, options, isStereo) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    return __awaiter(this, void 0, void 0, function* () {\n      const existingTrackOfSource = Array.from(this.tracks.values()).find((publishedTrack) => track instanceof LocalTrack && publishedTrack.source === track.source);\n      if (existingTrackOfSource && track.source !== Track.Source.Unknown) {\n        try {\n          throw Error(\"publishing a second track with the same source: \".concat(track.source));\n        } catch (e) {\n          if (e instanceof Error) {\n            livekitLogger.warn(e.message, {\n              oldTrack: existingTrackOfSource,\n              newTrack: track,\n              trace: e.stack\n            });\n          }\n        }\n      }\n      if (opts.stopMicTrackOnMute && track instanceof LocalAudioTrack) {\n        track.stopOnMute = true;\n      }\n      if (track.source === Track.Source.ScreenShare && isFireFox()) {\n        opts.simulcast = false;\n      }\n      if (opts.videoCodec === \"av1\" && !supportsAV1()) {\n        opts.videoCodec = void 0;\n      }\n      if (opts.videoCodec === \"vp9\" && !supportsVP9()) {\n        opts.videoCodec = void 0;\n      }\n      track.on(TrackEvent.Muted, this.onTrackMuted);\n      track.on(TrackEvent.Unmuted, this.onTrackUnmuted);\n      track.on(TrackEvent.Ended, this.handleTrackEnded);\n      track.on(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);\n      track.on(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);\n      const req = AddTrackRequest.fromPartial({\n        // get local track id for use during publishing\n        cid: track.mediaStreamTrack.id,\n        name: options === null || options === void 0 ? void 0 : options.name,\n        type: Track.kindToProto(track.kind),\n        muted: track.isMuted,\n        source: Track.sourceToProto(track.source),\n        disableDtx: !((_a = opts.dtx) !== null && _a !== void 0 ? _a : true),\n        stereo: isStereo,\n        disableRed: !((_b = opts.red) !== null && _b !== void 0 ? _b : true)\n      });\n      let encodings;\n      let simEncodings;\n      if (track.kind === Track.Kind.Video) {\n        let dims = {\n          width: 0,\n          height: 0\n        };\n        try {\n          dims = yield track.waitForDimensions();\n        } catch (e) {\n          livekitLogger.error(\"could not determine track dimensions\");\n        }\n        req.width = dims.width;\n        req.height = dims.height;\n        if (track instanceof LocalVideoTrack) {\n          if (isSVCCodec(opts.videoCodec)) {\n            opts.scalabilityMode = (_c = opts.scalabilityMode) !== null && _c !== void 0 ? _c : \"L3T3\";\n          }\n          if (opts.videoCodec && opts.backupCodec && opts.videoCodec !== opts.backupCodec.codec) {\n            const simOpts = Object.assign({}, opts);\n            simOpts.simulcast = true;\n            simEncodings = computeTrackBackupEncodings(track, opts.backupCodec.codec, simOpts);\n            req.simulcastCodecs = [{\n              codec: opts.videoCodec,\n              cid: track.mediaStreamTrack.id,\n              enableSimulcastLayers: true\n            }, {\n              codec: opts.backupCodec.codec,\n              cid: \"\",\n              enableSimulcastLayers: true\n            }];\n          }\n        }\n        encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, dims.width, dims.height, opts);\n        req.layers = videoLayersFromEncodings(req.width, req.height, simEncodings !== null && simEncodings !== void 0 ? simEncodings : encodings);\n      } else if (track.kind === Track.Kind.Audio) {\n        encodings = [{\n          maxBitrate: (_e = (_d = opts.audioPreset) === null || _d === void 0 ? void 0 : _d.maxBitrate) !== null && _e !== void 0 ? _e : opts.audioBitrate,\n          priority: (_g = (_f = opts.audioPreset) === null || _f === void 0 ? void 0 : _f.priority) !== null && _g !== void 0 ? _g : \"high\",\n          networkPriority: (_j = (_h = opts.audioPreset) === null || _h === void 0 ? void 0 : _h.priority) !== null && _j !== void 0 ? _j : \"high\"\n        }];\n      }\n      if (!this.engine || this.engine.isClosed) {\n        throw new UnexpectedConnectionState(\"cannot publish track when not connected\");\n      }\n      const ti = yield this.engine.addTrack(req);\n      let primaryCodecSupported = false;\n      let backupCodecSupported = false;\n      ti.codecs.forEach((c) => {\n        if (isCodecEqual(c.mimeType, opts.videoCodec)) {\n          primaryCodecSupported = true;\n        } else if (opts.backupCodec && isCodecEqual(c.mimeType, opts.backupCodec.codec)) {\n          backupCodecSupported = true;\n        }\n      });\n      if (req.simulcastCodecs.length > 0) {\n        if (!primaryCodecSupported && !backupCodecSupported) {\n          throw Error(\"cannot publish track, codec not supported by server\");\n        }\n        if (!primaryCodecSupported && opts.backupCodec) {\n          const backupCodec = opts.backupCodec;\n          opts = Object.assign({}, opts);\n          livekitLogger.debug(\"primary codec \".concat(opts.videoCodec, \" not supported, fallback to \").concat(backupCodec.codec));\n          opts.videoCodec = backupCodec.codec;\n          opts.videoEncoding = backupCodec.encoding;\n          encodings = simEncodings;\n        }\n      }\n      const publication = new LocalTrackPublication(track.kind, ti, track);\n      publication.options = opts;\n      track.sid = ti.sid;\n      if (!this.engine.publisher) {\n        throw new UnexpectedConnectionState(\"publisher is closed\");\n      }\n      livekitLogger.debug(\"publishing \".concat(track.kind, \" with encodings\"), {\n        encodings,\n        trackInfo: ti\n      });\n      track.sender = yield this.engine.createSender(track, opts, encodings);\n      if (track.codec && isSVCCodec(track.codec) && encodings && ((_k = encodings[0]) === null || _k === void 0 ? void 0 : _k.maxBitrate)) {\n        this.engine.publisher.setTrackCodecBitrate(req.cid, track.codec, encodings[0].maxBitrate / 1e3);\n      }\n      this.engine.negotiate();\n      if (track instanceof LocalVideoTrack) {\n        track.startMonitor(this.engine.client);\n      } else if (track instanceof LocalAudioTrack) {\n        track.startMonitor();\n      }\n      this.addTrackPublication(publication);\n      this.emit(ParticipantEvent.LocalTrackPublished, publication);\n      return publication;\n    });\n  }\n  get isLocal() {\n    return true;\n  }\n  /** @internal\n   * publish additional codec to existing track\n   */\n  publishAdditionalCodecForTrack(track, videoCodec, options) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      let existingPublication;\n      this.tracks.forEach((publication) => {\n        if (!publication.track) {\n          return;\n        }\n        if (publication.track === track) {\n          existingPublication = publication;\n        }\n      });\n      if (!existingPublication) {\n        throw new TrackInvalidError(\"track is not published\");\n      }\n      if (!(track instanceof LocalVideoTrack)) {\n        throw new TrackInvalidError(\"track is not a video track\");\n      }\n      const opts = Object.assign(Object.assign({}, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.publishDefaults), options);\n      const encodings = computeTrackBackupEncodings(track, videoCodec, opts);\n      if (!encodings) {\n        livekitLogger.info(\"backup codec has been disabled, ignoring request to add additional codec for track\");\n        return;\n      }\n      const simulcastTrack = track.addSimulcastTrack(videoCodec, encodings);\n      const req = AddTrackRequest.fromPartial({\n        cid: simulcastTrack.mediaStreamTrack.id,\n        type: Track.kindToProto(track.kind),\n        muted: track.isMuted,\n        source: Track.sourceToProto(track.source),\n        sid: track.sid,\n        simulcastCodecs: [{\n          codec: opts.videoCodec,\n          cid: simulcastTrack.mediaStreamTrack.id,\n          enableSimulcastLayers: opts.simulcast\n        }]\n      });\n      req.layers = videoLayersFromEncodings(req.width, req.height, encodings);\n      if (!this.engine || this.engine.isClosed) {\n        throw new UnexpectedConnectionState(\"cannot publish track when not connected\");\n      }\n      const ti = yield this.engine.addTrack(req);\n      yield this.engine.createSimulcastSender(track, simulcastTrack, opts, encodings);\n      this.engine.negotiate();\n      livekitLogger.debug(\"published \".concat(videoCodec, \" for track \").concat(track.sid), {\n        encodings,\n        trackInfo: ti\n      });\n    });\n  }\n  unpublishTrack(track, stopOnUnpublish) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const publication = this.getPublicationForTrack(track);\n      livekitLogger.debug(\"unpublishing track\", {\n        track,\n        method: \"unpublishTrack\"\n      });\n      if (!publication || !publication.track) {\n        livekitLogger.warn(\"track was not unpublished because no publication was found\", {\n          track,\n          method: \"unpublishTrack\"\n        });\n        return void 0;\n      }\n      track = publication.track;\n      track.off(TrackEvent.Muted, this.onTrackMuted);\n      track.off(TrackEvent.Unmuted, this.onTrackUnmuted);\n      track.off(TrackEvent.Ended, this.handleTrackEnded);\n      track.off(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);\n      track.off(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);\n      if (stopOnUnpublish === void 0) {\n        stopOnUnpublish = (_b = (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.stopLocalTrackOnUnpublish) !== null && _b !== void 0 ? _b : true;\n      }\n      if (stopOnUnpublish) {\n        track.stop();\n      }\n      let negotiationNeeded = false;\n      const trackSender = track.sender;\n      track.sender = void 0;\n      if (this.engine.publisher && this.engine.publisher.pc.connectionState !== \"closed\" && trackSender) {\n        try {\n          if (this.engine.removeTrack(trackSender)) {\n            negotiationNeeded = true;\n          }\n          if (track instanceof LocalVideoTrack) {\n            for (const [, trackInfo] of track.simulcastCodecs) {\n              if (trackInfo.sender) {\n                if (this.engine.removeTrack(trackInfo.sender)) {\n                  negotiationNeeded = true;\n                }\n                trackInfo.sender = void 0;\n              }\n            }\n            track.simulcastCodecs.clear();\n          }\n        } catch (e) {\n          livekitLogger.warn(\"failed to unpublish track\", {\n            error: e,\n            method: \"unpublishTrack\"\n          });\n        }\n      }\n      this.tracks.delete(publication.trackSid);\n      switch (publication.kind) {\n        case Track.Kind.Audio:\n          this.audioTracks.delete(publication.trackSid);\n          break;\n        case Track.Kind.Video:\n          this.videoTracks.delete(publication.trackSid);\n          break;\n      }\n      this.emit(ParticipantEvent.LocalTrackUnpublished, publication);\n      publication.setTrack(void 0);\n      if (negotiationNeeded) {\n        yield this.engine.negotiate();\n      }\n      return publication;\n    });\n  }\n  unpublishTracks(tracks) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const results = yield Promise.all(tracks.map((track) => this.unpublishTrack(track)));\n      return results.filter((track) => track instanceof LocalTrackPublication);\n    });\n  }\n  republishAllTracks(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const localPubs = [];\n      this.tracks.forEach((pub) => {\n        if (pub.track) {\n          if (options) {\n            pub.options = Object.assign(Object.assign({}, pub.options), options);\n          }\n          localPubs.push(pub);\n        }\n      });\n      yield Promise.all(localPubs.map((pub) => __awaiter(this, void 0, void 0, function* () {\n        const track = pub.track;\n        yield this.unpublishTrack(track, false);\n        yield this.publishTrack(track, pub.options);\n      })));\n    });\n  }\n  publishData(data, kind) {\n    let publishOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      const destination = Array.isArray(publishOptions) ? publishOptions : publishOptions === null || publishOptions === void 0 ? void 0 : publishOptions.destination;\n      const destinationSids = [];\n      const topic = !Array.isArray(publishOptions) ? publishOptions.topic : void 0;\n      if (destination !== void 0) {\n        destination.forEach((val) => {\n          if (val instanceof RemoteParticipant) {\n            destinationSids.push(val.sid);\n          } else {\n            destinationSids.push(val);\n          }\n        });\n      }\n      const packet = {\n        kind,\n        value: {\n          $case: \"user\",\n          user: {\n            participantSid: this.sid,\n            payload: data,\n            destinationSids,\n            topic\n          }\n        }\n      };\n      yield this.engine.sendDataPacket(packet, kind);\n    });\n  }\n  /**\n   * Control who can subscribe to LocalParticipant's published tracks.\n   *\n   * By default, all participants can subscribe. This allows fine-grained control over\n   * who is able to subscribe at a participant and track level.\n   *\n   * Note: if access is given at a track-level (i.e. both [allParticipantsAllowed] and\n   * [ParticipantTrackPermission.allTracksAllowed] are false), any newer published tracks\n   * will not grant permissions to any participants and will require a subsequent\n   * permissions update to allow subscription.\n   *\n   * @param allParticipantsAllowed Allows all participants to subscribe all tracks.\n   *  Takes precedence over [[participantTrackPermissions]] if set to true.\n   *  By default this is set to true.\n   * @param participantTrackPermissions Full list of individual permissions per\n   *  participant/track. Any omitted participants will not receive any permissions.\n   */\n  setTrackSubscriptionPermissions(allParticipantsAllowed) {\n    let participantTrackPermissions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n    this.participantTrackPermissions = participantTrackPermissions;\n    this.allParticipantsAllowedToSubscribe = allParticipantsAllowed;\n    if (this.engine.client.isConnected) {\n      this.updateTrackSubscriptionPermissions();\n    }\n  }\n  /** @internal */\n  updateInfo(info) {\n    if (info.sid !== this.sid) {\n      return false;\n    }\n    if (!super.updateInfo(info)) {\n      return false;\n    }\n    info.tracks.forEach((ti) => {\n      var _a, _b;\n      const pub = this.tracks.get(ti.sid);\n      if (pub) {\n        const mutedOnServer = pub.isMuted || ((_b = (_a = pub.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused) !== null && _b !== void 0 ? _b : false);\n        if (mutedOnServer !== ti.muted) {\n          livekitLogger.debug(\"updating server mute state after reconcile\", {\n            sid: ti.sid,\n            muted: mutedOnServer\n          });\n          this.engine.client.sendMuteTrack(ti.sid, mutedOnServer);\n        }\n      }\n    });\n    return true;\n  }\n  getPublicationForTrack(track) {\n    let publication;\n    this.tracks.forEach((pub) => {\n      const localTrack = pub.track;\n      if (!localTrack) {\n        return;\n      }\n      if (track instanceof MediaStreamTrack) {\n        if (localTrack instanceof LocalAudioTrack || localTrack instanceof LocalVideoTrack) {\n          if (localTrack.mediaStreamTrack === track) {\n            publication = pub;\n          }\n        }\n      } else if (track === localTrack) {\n        publication = pub;\n      }\n    });\n    return publication;\n  }\n  /** @internal */\n  publishedTracksInfo() {\n    const infos = [];\n    this.tracks.forEach((track) => {\n      if (track.track !== void 0) {\n        infos.push({\n          cid: track.track.mediaStreamID,\n          track: track.trackInfo\n        });\n      }\n    });\n    return infos;\n  }\n  /** @internal */\n  dataChannelsInfo() {\n    const infos = [];\n    const getInfo = (dc, target) => {\n      if ((dc === null || dc === void 0 ? void 0 : dc.id) !== void 0 && dc.id !== null) {\n        infos.push({\n          label: dc.label,\n          id: dc.id,\n          target\n        });\n      }\n    };\n    getInfo(this.engine.dataChannelForKind(DataPacket_Kind.LOSSY), SignalTarget.PUBLISHER);\n    getInfo(this.engine.dataChannelForKind(DataPacket_Kind.RELIABLE), SignalTarget.PUBLISHER);\n    getInfo(this.engine.dataChannelForKind(DataPacket_Kind.LOSSY, true), SignalTarget.SUBSCRIBER);\n    getInfo(this.engine.dataChannelForKind(DataPacket_Kind.RELIABLE, true), SignalTarget.SUBSCRIBER);\n    return infos;\n  }\n};\nvar ConnectionState;\n(function(ConnectionState2) {\n  ConnectionState2[\"Disconnected\"] = \"disconnected\";\n  ConnectionState2[\"Connecting\"] = \"connecting\";\n  ConnectionState2[\"Connected\"] = \"connected\";\n  ConnectionState2[\"Reconnecting\"] = \"reconnecting\";\n})(ConnectionState || (ConnectionState = {}));\nvar connectionReconcileFrequency = 2 * 1e3;\nvar RoomState = ConnectionState;\nvar Room = class extends eventsExports.EventEmitter {\n  /**\n   * Creates a new Room, the primary construct for a LiveKit session.\n   * @param options\n   */\n  constructor(options) {\n    var _this;\n    super();\n    _this = this;\n    this.state = ConnectionState.Disconnected;\n    this.activeSpeakers = [];\n    this.audioEnabled = true;\n    this.connect = (url, token, opts) => __awaiter(this, void 0, void 0, function* () {\n      const unlockDisconnect = yield this.disconnectLock.lock();\n      if (this.state === ConnectionState.Connected) {\n        livekitLogger.info(\"already connected to room \".concat(this.name));\n        unlockDisconnect();\n        return Promise.resolve();\n      }\n      if (this.connectFuture) {\n        unlockDisconnect();\n        return this.connectFuture.promise;\n      }\n      this.setAndEmitConnectionState(ConnectionState.Connecting);\n      const urlProvider = new RegionUrlProvider(url, token);\n      const connectFn = (resolve, reject, regionUrl) => __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        if (this.abortController) {\n          this.abortController.abort();\n        }\n        this.abortController = new AbortController();\n        unlockDisconnect === null || unlockDisconnect === void 0 ? void 0 : unlockDisconnect();\n        try {\n          yield this.attemptConnection(regionUrl !== null && regionUrl !== void 0 ? regionUrl : url, token, opts, this.abortController);\n          this.abortController = void 0;\n          resolve();\n        } catch (e) {\n          if (isCloud(new URL(url)) && e instanceof ConnectionError && e.reason !== 3) {\n            let nextUrl = null;\n            try {\n              nextUrl = yield urlProvider.getNextBestRegionUrl((_a = this.abortController) === null || _a === void 0 ? void 0 : _a.signal);\n            } catch (error) {\n              if (error instanceof ConnectionError && (error.status === 401 || error.reason === 3)) {\n                reject(error);\n                return;\n              }\n            }\n            if (nextUrl) {\n              livekitLogger.debug(\"initial connection failed, retrying with another region\");\n              yield connectFn(resolve, reject, nextUrl);\n            } else {\n              reject(e);\n            }\n          } else {\n            reject(e);\n          }\n        }\n      });\n      this.connectFuture = new Future(connectFn, () => {\n        this.clearConnectionFutures();\n      });\n      return this.connectFuture.promise;\n    });\n    this.connectSignal = (url, token, engine, connectOptions, roomOptions, abortController) => __awaiter(this, void 0, void 0, function* () {\n      const joinResponse = yield engine.join(url, token, {\n        autoSubscribe: connectOptions.autoSubscribe,\n        publishOnly: connectOptions.publishOnly,\n        adaptiveStream: typeof roomOptions.adaptiveStream === \"object\" ? true : roomOptions.adaptiveStream,\n        maxRetries: connectOptions.maxRetries\n      }, abortController.signal);\n      let serverInfo = joinResponse.serverInfo;\n      if (!serverInfo) {\n        serverInfo = {\n          version: joinResponse.serverVersion,\n          region: joinResponse.serverRegion\n        };\n      }\n      livekitLogger.debug(\"connected to Livekit Server \".concat(Object.entries(serverInfo).map((_ref) => {\n        let [key, value] = _ref;\n        return \"\".concat(key, \": \").concat(value);\n      }).join(\", \")));\n      if (!joinResponse.serverVersion) {\n        throw new UnsupportedServer(\"unknown server version\");\n      }\n      if (joinResponse.serverVersion === \"0.15.1\" && this.options.dynacast) {\n        livekitLogger.debug(\"disabling dynacast due to server version\");\n        roomOptions.dynacast = false;\n      }\n      return joinResponse;\n    });\n    this.applyJoinResponse = (joinResponse) => {\n      const pi = joinResponse.participant;\n      this.localParticipant.sid = pi.sid;\n      this.localParticipant.identity = pi.identity;\n      this.handleParticipantUpdates([pi, ...joinResponse.otherParticipants]);\n      if (joinResponse.room) {\n        this.handleRoomUpdate(joinResponse.room);\n      }\n    };\n    this.attemptConnection = (url, token, opts, abortController) => __awaiter(this, void 0, void 0, function* () {\n      var _b;\n      if (this.state === ConnectionState.Reconnecting) {\n        livekitLogger.info(\"Reconnection attempt replaced by new connection attempt\");\n        this.recreateEngine();\n      } else {\n        this.maybeCreateEngine();\n      }\n      this.acquireAudioContext();\n      this.connOptions = Object.assign(Object.assign({}, roomConnectOptionDefaults), opts);\n      if (this.connOptions.rtcConfig) {\n        this.engine.rtcConfig = this.connOptions.rtcConfig;\n      }\n      if (this.connOptions.peerConnectionTimeout) {\n        this.engine.peerConnectionTimeout = this.connOptions.peerConnectionTimeout;\n      }\n      try {\n        const joinResponse = yield this.connectSignal(url, token, this.engine, this.connOptions, this.options, abortController);\n        this.applyJoinResponse(joinResponse);\n        this.setupLocalParticipantEvents();\n        this.emit(RoomEvent.SignalConnected);\n      } catch (err) {\n        this.recreateEngine();\n        this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);\n        const resultingError = new ConnectionError(\"could not establish signal connection\");\n        if (err instanceof Error) {\n          resultingError.message = \"\".concat(resultingError.message, \": \").concat(err.message);\n        }\n        if (err instanceof ConnectionError) {\n          resultingError.reason = err.reason;\n          resultingError.status = err.status;\n        }\n        livekitLogger.debug(\"error trying to establish signal connection\", {\n          error: err\n        });\n        throw resultingError;\n      }\n      if (abortController.signal.aborted) {\n        this.recreateEngine();\n        this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);\n        throw new ConnectionError(\"Connection attempt aborted\");\n      }\n      try {\n        yield this.engine.waitForPCInitialConnection(this.connOptions.peerConnectionTimeout, abortController);\n      } catch (e) {\n        this.recreateEngine();\n        this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);\n        throw e;\n      }\n      if (isWeb() && this.options.disconnectOnPageLeave) {\n        window.addEventListener(\"pagehide\", this.onPageLeave);\n        window.addEventListener(\"beforeunload\", this.onPageLeave);\n        (_b = navigator.mediaDevices) === null || _b === void 0 ? void 0 : _b.addEventListener(\"devicechange\", this.handleDeviceChange);\n      }\n      this.setAndEmitConnectionState(ConnectionState.Connected);\n      this.emit(RoomEvent.Connected);\n      this.registerConnectionReconcile();\n    });\n    this.disconnect = function() {\n      let stopTracks = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n      return __awaiter(_this, void 0, void 0, function* () {\n        var _c, _d, _e, _f;\n        const unlock = yield this.disconnectLock.lock();\n        try {\n          if (this.state === ConnectionState.Disconnected) {\n            livekitLogger.debug(\"already disconnected\");\n            return;\n          }\n          livekitLogger.info(\"disconnect from room\", {\n            identity: this.localParticipant.identity\n          });\n          if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {\n            livekitLogger.warn(\"abort connection attempt\");\n            (_c = this.abortController) === null || _c === void 0 ? void 0 : _c.abort();\n            (_e = (_d = this.connectFuture) === null || _d === void 0 ? void 0 : _d.reject) === null || _e === void 0 ? void 0 : _e.call(_d, new ConnectionError(\"Client initiated disconnect\"));\n            this.connectFuture = void 0;\n          }\n          if ((_f = this.engine) === null || _f === void 0 ? void 0 : _f.client.isConnected) {\n            yield this.engine.client.sendLeave();\n          }\n          if (this.engine) {\n            yield this.engine.close();\n          }\n          this.handleDisconnect(stopTracks, DisconnectReason.CLIENT_INITIATED);\n          this.engine = void 0;\n        } finally {\n          unlock();\n        }\n      });\n    };\n    this.onPageLeave = () => __awaiter(this, void 0, void 0, function* () {\n      yield this.disconnect();\n    });\n    this.handleRestarting = () => {\n      this.clearConnectionReconcile();\n      for (const p of this.participants.values()) {\n        this.handleParticipantDisconnected(p.sid, p);\n      }\n      if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {\n        this.emit(RoomEvent.Reconnecting);\n      }\n    };\n    this.handleSignalRestarted = (joinResponse) => __awaiter(this, void 0, void 0, function* () {\n      livekitLogger.debug(\"signal reconnected to server\", {\n        region: joinResponse.serverRegion\n      });\n      this.cachedParticipantSids = [];\n      this.applyJoinResponse(joinResponse);\n      try {\n        const localPubs = [];\n        this.localParticipant.tracks.forEach((pub) => {\n          if (pub.track) {\n            localPubs.push(pub);\n          }\n        });\n        yield Promise.all(localPubs.map((pub) => __awaiter(this, void 0, void 0, function* () {\n          const track = pub.track;\n          this.localParticipant.unpublishTrack(track, false);\n          if (!track.isMuted) {\n            if ((track instanceof LocalAudioTrack || track instanceof LocalVideoTrack) && !track.isUserProvided) {\n              livekitLogger.debug(\"restarting existing track\", {\n                track: pub.trackSid\n              });\n              yield track.restartTrack();\n            }\n            livekitLogger.debug(\"publishing new track\", {\n              track: pub.trackSid\n            });\n            yield this.localParticipant.publishTrack(track, pub.options);\n          }\n        })));\n      } catch (error) {\n        livekitLogger.error(\"error trying to re-publish tracks after reconnection\", {\n          error\n        });\n      }\n      try {\n        yield this.engine.waitForRestarted();\n        livekitLogger.debug(\"fully reconnected to server\", {\n          region: joinResponse.serverRegion\n        });\n      } catch (_g) {\n        return;\n      }\n      this.setAndEmitConnectionState(ConnectionState.Connected);\n      this.emit(RoomEvent.Reconnected);\n      this.registerConnectionReconcile();\n      this.participants.forEach((participant) => {\n        this.emit(RoomEvent.ParticipantConnected, participant);\n      });\n    });\n    this.handleParticipantUpdates = (participantInfos) => {\n      participantInfos.forEach((info) => {\n        if (info.identity === this.localParticipant.identity) {\n          this.localParticipant.updateInfo(info);\n          return;\n        }\n        const sid = this.identityToSid.get(info.identity);\n        if (sid && sid !== info.sid) {\n          this.handleParticipantDisconnected(sid, this.participants.get(sid));\n        }\n        let remoteParticipant = this.participants.get(info.sid);\n        const isNewParticipant = !remoteParticipant;\n        if (info.state === ParticipantInfo_State.DISCONNECTED) {\n          this.handleParticipantDisconnected(info.sid, remoteParticipant);\n        } else {\n          remoteParticipant = this.getOrCreateParticipant(info.sid, info);\n          if (!isNewParticipant) {\n            remoteParticipant.updateInfo(info);\n          }\n        }\n      });\n    };\n    this.handleActiveSpeakersUpdate = (speakers) => {\n      const activeSpeakers = [];\n      const seenSids = {};\n      speakers.forEach((speaker) => {\n        seenSids[speaker.sid] = true;\n        if (speaker.sid === this.localParticipant.sid) {\n          this.localParticipant.audioLevel = speaker.level;\n          this.localParticipant.setIsSpeaking(true);\n          activeSpeakers.push(this.localParticipant);\n        } else {\n          const p = this.participants.get(speaker.sid);\n          if (p) {\n            p.audioLevel = speaker.level;\n            p.setIsSpeaking(true);\n            activeSpeakers.push(p);\n          }\n        }\n      });\n      if (!seenSids[this.localParticipant.sid]) {\n        this.localParticipant.audioLevel = 0;\n        this.localParticipant.setIsSpeaking(false);\n      }\n      this.participants.forEach((p) => {\n        if (!seenSids[p.sid]) {\n          p.audioLevel = 0;\n          p.setIsSpeaking(false);\n        }\n      });\n      this.activeSpeakers = activeSpeakers;\n      this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);\n    };\n    this.handleSpeakersChanged = (speakerUpdates) => {\n      const lastSpeakers = /* @__PURE__ */ new Map();\n      this.activeSpeakers.forEach((p) => {\n        lastSpeakers.set(p.sid, p);\n      });\n      speakerUpdates.forEach((speaker) => {\n        let p = this.participants.get(speaker.sid);\n        if (speaker.sid === this.localParticipant.sid) {\n          p = this.localParticipant;\n        }\n        if (!p) {\n          return;\n        }\n        p.audioLevel = speaker.level;\n        p.setIsSpeaking(speaker.active);\n        if (speaker.active) {\n          lastSpeakers.set(speaker.sid, p);\n        } else {\n          lastSpeakers.delete(speaker.sid);\n        }\n      });\n      const activeSpeakers = Array.from(lastSpeakers.values());\n      activeSpeakers.sort((a, b) => b.audioLevel - a.audioLevel);\n      this.activeSpeakers = activeSpeakers;\n      this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);\n    };\n    this.handleStreamStateUpdate = (streamStateUpdate) => {\n      streamStateUpdate.streamStates.forEach((streamState) => {\n        const participant = this.participants.get(streamState.participantSid);\n        if (!participant) {\n          return;\n        }\n        const pub = participant.getTrackPublication(streamState.trackSid);\n        if (!pub || !pub.track) {\n          return;\n        }\n        pub.track.streamState = Track.streamStateFromProto(streamState.state);\n        participant.emit(ParticipantEvent.TrackStreamStateChanged, pub, pub.track.streamState);\n        this.emitWhenConnected(RoomEvent.TrackStreamStateChanged, pub, pub.track.streamState, participant);\n      });\n    };\n    this.handleSubscriptionPermissionUpdate = (update) => {\n      const participant = this.participants.get(update.participantSid);\n      if (!participant) {\n        return;\n      }\n      const pub = participant.getTrackPublication(update.trackSid);\n      if (!pub) {\n        return;\n      }\n      pub.setAllowed(update.allowed);\n    };\n    this.handleDataPacket = (userPacket, kind) => {\n      const participant = this.participants.get(userPacket.participantSid);\n      this.emit(RoomEvent.DataReceived, userPacket.payload, participant, kind, userPacket.topic);\n      participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.DataReceived, userPacket.payload, kind);\n    };\n    this.handleAudioPlaybackStarted = () => {\n      if (this.canPlaybackAudio) {\n        return;\n      }\n      this.audioEnabled = true;\n      this.emit(RoomEvent.AudioPlaybackStatusChanged, true);\n    };\n    this.handleAudioPlaybackFailed = (e) => {\n      livekitLogger.warn(\"could not playback audio\", e);\n      if (!this.canPlaybackAudio) {\n        return;\n      }\n      this.audioEnabled = false;\n      this.emit(RoomEvent.AudioPlaybackStatusChanged, false);\n    };\n    this.handleDeviceChange = () => __awaiter(this, void 0, void 0, function* () {\n      this.emit(RoomEvent.MediaDevicesChanged);\n    });\n    this.handleRoomUpdate = (room) => {\n      const oldRoom = this.roomInfo;\n      this.roomInfo = room;\n      if (oldRoom && oldRoom.metadata !== room.metadata) {\n        this.emitWhenConnected(RoomEvent.RoomMetadataChanged, room.metadata);\n      }\n      if ((oldRoom === null || oldRoom === void 0 ? void 0 : oldRoom.activeRecording) !== room.activeRecording) {\n        this.emitWhenConnected(RoomEvent.RecordingStatusChanged, room.activeRecording);\n      }\n    };\n    this.handleConnectionQualityUpdate = (update) => {\n      update.updates.forEach((info) => {\n        if (info.participantSid === this.localParticipant.sid) {\n          this.localParticipant.setConnectionQuality(info.quality);\n          return;\n        }\n        const participant = this.participants.get(info.participantSid);\n        if (participant) {\n          participant.setConnectionQuality(info.quality);\n        }\n      });\n    };\n    this.onLocalParticipantMetadataChanged = (metadata) => {\n      this.emit(RoomEvent.ParticipantMetadataChanged, metadata, this.localParticipant);\n    };\n    this.onLocalParticipantNameChanged = (name) => {\n      this.emit(RoomEvent.ParticipantNameChanged, name, this.localParticipant);\n    };\n    this.onLocalTrackMuted = (pub) => {\n      this.emit(RoomEvent.TrackMuted, pub, this.localParticipant);\n    };\n    this.onLocalTrackUnmuted = (pub) => {\n      this.emit(RoomEvent.TrackUnmuted, pub, this.localParticipant);\n    };\n    this.onLocalTrackPublished = (pub) => __awaiter(this, void 0, void 0, function* () {\n      this.emit(RoomEvent.LocalTrackPublished, pub, this.localParticipant);\n      if (pub.track instanceof LocalAudioTrack) {\n        const trackIsSilent = yield pub.track.checkForSilence();\n        if (trackIsSilent) {\n          this.emit(RoomEvent.LocalAudioSilenceDetected, pub);\n        }\n      }\n    });\n    this.onLocalTrackUnpublished = (pub) => {\n      this.emit(RoomEvent.LocalTrackUnpublished, pub, this.localParticipant);\n    };\n    this.onLocalConnectionQualityChanged = (quality) => {\n      this.emit(RoomEvent.ConnectionQualityChanged, quality, this.localParticipant);\n    };\n    this.onMediaDevicesError = (e) => {\n      this.emit(RoomEvent.MediaDevicesError, e);\n    };\n    this.onLocalParticipantPermissionsChanged = (prevPermissions) => {\n      this.emit(RoomEvent.ParticipantPermissionsChanged, prevPermissions, this.localParticipant);\n    };\n    this.setMaxListeners(100);\n    this.participants = /* @__PURE__ */ new Map();\n    this.cachedParticipantSids = [];\n    this.identityToSid = /* @__PURE__ */ new Map();\n    this.options = Object.assign(Object.assign({}, roomOptionDefaults), options);\n    this.options.audioCaptureDefaults = Object.assign(Object.assign({}, audioDefaults), options === null || options === void 0 ? void 0 : options.audioCaptureDefaults);\n    this.options.videoCaptureDefaults = Object.assign(Object.assign({}, videoDefaults), options === null || options === void 0 ? void 0 : options.videoCaptureDefaults);\n    this.options.publishDefaults = Object.assign(Object.assign({}, publishDefaults), options === null || options === void 0 ? void 0 : options.publishDefaults);\n    this.maybeCreateEngine();\n    this.disconnectLock = new Mutex();\n    this.localParticipant = new LocalParticipant(\"\", \"\", this.engine, this.options);\n  }\n  /**\n   * if the current room has a participant with `recorder: true` in its JWT grant\n   **/\n  get isRecording() {\n    var _a, _b;\n    return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.activeRecording) !== null && _b !== void 0 ? _b : false;\n  }\n  /** server assigned unique room id */\n  get sid() {\n    var _a, _b;\n    return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.sid) !== null && _b !== void 0 ? _b : \"\";\n  }\n  /** user assigned name, derived from JWT token */\n  get name() {\n    var _a, _b;\n    return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : \"\";\n  }\n  /** room metadata */\n  get metadata() {\n    var _a;\n    return (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.metadata;\n  }\n  get numParticipants() {\n    var _a, _b;\n    return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numParticipants) !== null && _b !== void 0 ? _b : 0;\n  }\n  get numPublishers() {\n    var _a, _b;\n    return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numPublishers) !== null && _b !== void 0 ? _b : 0;\n  }\n  maybeCreateEngine() {\n    if (this.engine && !this.engine.isClosed) {\n      return;\n    }\n    this.engine = new RTCEngine(this.options);\n    this.engine.client.onParticipantUpdate = this.handleParticipantUpdates;\n    this.engine.client.onRoomUpdate = this.handleRoomUpdate;\n    this.engine.client.onSpeakersChanged = this.handleSpeakersChanged;\n    this.engine.client.onStreamStateUpdate = this.handleStreamStateUpdate;\n    this.engine.client.onSubscriptionPermissionUpdate = this.handleSubscriptionPermissionUpdate;\n    this.engine.client.onConnectionQuality = this.handleConnectionQualityUpdate;\n    this.engine.on(EngineEvent.MediaTrackAdded, (mediaTrack, stream, receiver) => {\n      this.onTrackAdded(mediaTrack, stream, receiver);\n    }).on(EngineEvent.Disconnected, (reason) => {\n      this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, reason);\n    }).on(EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate).on(EngineEvent.DataPacketReceived, this.handleDataPacket).on(EngineEvent.Resuming, () => {\n      this.clearConnectionReconcile();\n      if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {\n        this.emit(RoomEvent.Reconnecting);\n      }\n      this.cachedParticipantSids = Array.from(this.participants.keys());\n    }).on(EngineEvent.Resumed, () => {\n      this.setAndEmitConnectionState(ConnectionState.Connected);\n      this.emit(RoomEvent.Reconnected);\n      this.registerConnectionReconcile();\n      this.updateSubscriptions();\n      const diffParticipants = Array.from(this.participants.values()).filter((p) => !this.cachedParticipantSids.includes(p.sid));\n      diffParticipants.forEach((p) => this.emit(RoomEvent.ParticipantConnected, p));\n      this.cachedParticipantSids = [];\n    }).on(EngineEvent.SignalResumed, () => {\n      if (this.state === ConnectionState.Reconnecting) {\n        this.sendSyncState();\n      }\n    }).on(EngineEvent.Restarting, this.handleRestarting).on(EngineEvent.SignalRestarted, this.handleSignalRestarted).on(EngineEvent.DCBufferStatusChanged, (status, kind) => {\n      this.emit(RoomEvent.DCBufferStatusChanged, status, kind);\n    });\n    if (this.localParticipant) {\n      this.localParticipant.setupEngine(this.engine);\n    }\n  }\n  /**\n   * getLocalDevices abstracts navigator.mediaDevices.enumerateDevices.\n   * In particular, it handles Chrome's unique behavior of creating `default`\n   * devices. When encountered, it'll be removed from the list of devices.\n   * The actual default device will be placed at top.\n   * @param kind\n   * @returns a list of available local devices\n   */\n  static getLocalDevices(kind) {\n    let requestPermissions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n    return DeviceManager.getInstance().getDevices(kind, requestPermissions);\n  }\n  /**\n   * prepares the connection to the livekit server by sending a HEAD request in order to\n   * 1. speed up DNS resolution\n   * 2. speed up TLS setup\n   * on the actual connection request\n   * throws an error if server is not reachable after the request timeout\n   * @experimental\n   */\n  prepareConnection(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield fetch(\"http\".concat(url.substring(2)), {\n        method: \"HEAD\"\n      });\n    });\n  }\n  /**\n   * retrieves a participant by identity\n   * @param identity\n   * @returns\n   */\n  getParticipantByIdentity(identity) {\n    if (this.localParticipant.identity === identity) {\n      return this.localParticipant;\n    }\n    const sid = this.identityToSid.get(identity);\n    if (sid) {\n      return this.participants.get(sid);\n    }\n  }\n  clearConnectionFutures() {\n    this.connectFuture = void 0;\n  }\n  /**\n   * @internal for testing\n   */\n  simulateScenario(scenario) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let postAction = () => {\n      };\n      let req;\n      switch (scenario) {\n        case \"signal-reconnect\":\n          yield this.engine.client.close();\n          if (this.engine.client.onClose) {\n            this.engine.client.onClose(\"simulate disconnect\");\n          }\n          break;\n        case \"speaker\":\n          req = SimulateScenario.fromPartial({\n            scenario: {\n              $case: \"speakerUpdate\",\n              speakerUpdate: 3\n            }\n          });\n          break;\n        case \"node-failure\":\n          req = SimulateScenario.fromPartial({\n            scenario: {\n              $case: \"nodeFailure\",\n              nodeFailure: true\n            }\n          });\n          break;\n        case \"server-leave\":\n          req = SimulateScenario.fromPartial({\n            scenario: {\n              $case: \"serverLeave\",\n              serverLeave: true\n            }\n          });\n          break;\n        case \"migration\":\n          req = SimulateScenario.fromPartial({\n            scenario: {\n              $case: \"migration\",\n              migration: true\n            }\n          });\n          break;\n        case \"resume-reconnect\":\n          this.engine.failNext();\n          yield this.engine.client.close();\n          if (this.engine.client.onClose) {\n            this.engine.client.onClose(\"simulate resume-reconnect\");\n          }\n          break;\n        case \"full-reconnect\":\n          this.engine.fullReconnectOnNext = true;\n          yield this.engine.client.close();\n          if (this.engine.client.onClose) {\n            this.engine.client.onClose(\"simulate full-reconnect\");\n          }\n          break;\n        case \"force-tcp\":\n        case \"force-tls\":\n          req = SimulateScenario.fromPartial({\n            scenario: {\n              $case: \"switchCandidateProtocol\",\n              switchCandidateProtocol: scenario === \"force-tls\" ? 2 : 1\n            }\n          });\n          postAction = () => __awaiter(this, void 0, void 0, function* () {\n            const onLeave = this.engine.client.onLeave;\n            if (onLeave) {\n              onLeave({\n                reason: DisconnectReason.CLIENT_INITIATED,\n                canReconnect: true\n              });\n            }\n          });\n          break;\n      }\n      if (req) {\n        this.engine.client.sendSimulateScenario(req);\n        postAction();\n      }\n    });\n  }\n  /**\n   * Browsers have different policies regarding audio playback. Most requiring\n   * some form of user interaction (click/tap/etc).\n   * In those cases, audio will be silent until a click/tap triggering one of the following\n   * - `startAudio`\n   * - `getUserMedia`\n   */\n  startAudio() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.acquireAudioContext();\n      const elements = [];\n      this.participants.forEach((p) => {\n        p.audioTracks.forEach((t) => {\n          if (t.track) {\n            t.track.attachedElements.forEach((e) => {\n              elements.push(e);\n            });\n          }\n        });\n      });\n      try {\n        yield Promise.all(elements.map((e) => {\n          e.muted = false;\n          return e.play();\n        }));\n        this.handleAudioPlaybackStarted();\n      } catch (err) {\n        this.handleAudioPlaybackFailed(err);\n        throw err;\n      }\n    });\n  }\n  /**\n   * Returns true if audio playback is enabled\n   */\n  get canPlaybackAudio() {\n    return this.audioEnabled;\n  }\n  /**\n   * Returns the active audio output device used in this room.\n   *\n   * Note: to get the active `audioinput` or `videoinput` use [[LocalTrack.getDeviceId()]]\n   *\n   * @return the previously successfully set audio output device ID or an empty string if the default device is used.\n   */\n  getActiveAudioOutputDevice() {\n    var _a, _b;\n    return (_b = (_a = this.options.audioOutput) === null || _a === void 0 ? void 0 : _a.deviceId) !== null && _b !== void 0 ? _b : \"\";\n  }\n  /**\n   * Switches all active devices used in this room to the given device.\n   *\n   * Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility)\n   *\n   * @param kind use `videoinput` for camera track,\n   *  `audioinput` for microphone track,\n   *  `audiooutput` to set speaker for all incoming audio tracks\n   * @param deviceId\n   */\n  switchActiveDevice(kind, deviceId) {\n    let exact = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    var _a;\n    var _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const deviceConstraint = exact ? {\n        exact: deviceId\n      } : deviceId;\n      if (kind === \"audioinput\") {\n        const prevDeviceId = this.options.audioCaptureDefaults.deviceId;\n        this.options.audioCaptureDefaults.deviceId = deviceConstraint;\n        const tracks = Array.from(this.localParticipant.audioTracks.values()).filter((track) => track.source === Track.Source.Microphone);\n        try {\n          yield Promise.all(tracks.map((t) => {\n            var _a2;\n            return (_a2 = t.audioTrack) === null || _a2 === void 0 ? void 0 : _a2.setDeviceId(deviceConstraint);\n          }));\n        } catch (e) {\n          this.options.audioCaptureDefaults.deviceId = prevDeviceId;\n          throw e;\n        }\n      } else if (kind === \"videoinput\") {\n        const prevDeviceId = this.options.videoCaptureDefaults.deviceId;\n        this.options.videoCaptureDefaults.deviceId = deviceConstraint;\n        const tracks = Array.from(this.localParticipant.videoTracks.values()).filter((track) => track.source === Track.Source.Camera);\n        try {\n          yield Promise.all(tracks.map((t) => {\n            var _a2;\n            return (_a2 = t.videoTrack) === null || _a2 === void 0 ? void 0 : _a2.setDeviceId(deviceConstraint);\n          }));\n        } catch (e) {\n          this.options.videoCaptureDefaults.deviceId = prevDeviceId;\n          throw e;\n        }\n      } else if (kind === \"audiooutput\") {\n        if (!supportsSetSinkId()) {\n          throw new Error(\"cannot switch audio output, setSinkId not supported\");\n        }\n        (_a = (_b = this.options).audioOutput) !== null && _a !== void 0 ? _a : _b.audioOutput = {};\n        const prevDeviceId = this.options.audioOutput.deviceId;\n        this.options.audioOutput.deviceId = deviceId;\n        try {\n          yield Promise.all(Array.from(this.participants.values()).map((p) => p.setAudioOutput({\n            deviceId\n          })));\n        } catch (e) {\n          this.options.audioOutput.deviceId = prevDeviceId;\n          throw e;\n        }\n      }\n    });\n  }\n  setupLocalParticipantEvents() {\n    this.localParticipant.on(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).on(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).on(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).on(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).on(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).on(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).on(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).on(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).on(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);\n  }\n  recreateEngine() {\n    var _a;\n    (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();\n    this.engine = void 0;\n    this.participants.clear();\n    this.maybeCreateEngine();\n  }\n  onTrackAdded(mediaTrack, stream, receiver) {\n    if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {\n      const reconnectedHandler = () => {\n        this.onTrackAdded(mediaTrack, stream, receiver);\n        cleanup();\n      };\n      const cleanup = () => {\n        this.off(RoomEvent.Reconnected, reconnectedHandler);\n        this.off(RoomEvent.Connected, reconnectedHandler);\n        this.off(RoomEvent.Disconnected, cleanup);\n      };\n      this.once(RoomEvent.Reconnected, reconnectedHandler);\n      this.once(RoomEvent.Connected, reconnectedHandler);\n      this.once(RoomEvent.Disconnected, cleanup);\n      return;\n    }\n    if (this.state === ConnectionState.Disconnected) {\n      livekitLogger.warn(\"skipping incoming track after Room disconnected\");\n      return;\n    }\n    const parts = unpackStreamId(stream.id);\n    const participantId = parts[0];\n    let trackId = parts[1];\n    if (!trackId || trackId === \"\")\n      trackId = mediaTrack.id;\n    if (participantId === this.localParticipant.sid) {\n      livekitLogger.warn(\"tried to create RemoteParticipant for local participant\");\n      return;\n    }\n    const participant = this.getOrCreateParticipant(participantId);\n    let adaptiveStreamSettings;\n    if (this.options.adaptiveStream) {\n      if (typeof this.options.adaptiveStream === \"object\") {\n        adaptiveStreamSettings = this.options.adaptiveStream;\n      } else {\n        adaptiveStreamSettings = {};\n      }\n    }\n    participant.addSubscribedMediaTrack(mediaTrack, trackId, stream, receiver, adaptiveStreamSettings);\n  }\n  handleDisconnect() {\n    let shouldStopTracks = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n    let reason = arguments.length > 1 ? arguments[1] : void 0;\n    var _a;\n    this.clearConnectionReconcile();\n    if (this.state === ConnectionState.Disconnected) {\n      return;\n    }\n    try {\n      this.participants.forEach((p) => {\n        p.tracks.forEach((pub) => {\n          p.unpublishTrack(pub.trackSid);\n        });\n      });\n      this.localParticipant.tracks.forEach((pub) => {\n        var _a2, _b;\n        if (pub.track) {\n          this.localParticipant.unpublishTrack(pub.track, shouldStopTracks);\n        }\n        if (shouldStopTracks) {\n          (_a2 = pub.track) === null || _a2 === void 0 ? void 0 : _a2.detach();\n          (_b = pub.track) === null || _b === void 0 ? void 0 : _b.stop();\n        }\n      });\n      this.localParticipant.off(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).off(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).off(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).off(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).off(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).off(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).off(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).off(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).off(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);\n      this.localParticipant.tracks.clear();\n      this.localParticipant.videoTracks.clear();\n      this.localParticipant.audioTracks.clear();\n      this.participants.clear();\n      this.activeSpeakers = [];\n      if (this.audioContext && typeof this.options.expWebAudioMix === \"boolean\") {\n        this.audioContext.close();\n        this.audioContext = void 0;\n      }\n      if (isWeb()) {\n        window.removeEventListener(\"beforeunload\", this.onPageLeave);\n        window.removeEventListener(\"pagehide\", this.onPageLeave);\n        (_a = navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.removeEventListener(\"devicechange\", this.handleDeviceChange);\n      }\n    } finally {\n      this.setAndEmitConnectionState(ConnectionState.Disconnected);\n      this.emit(RoomEvent.Disconnected, reason);\n    }\n  }\n  handleParticipantDisconnected(sid, participant) {\n    this.participants.delete(sid);\n    if (!participant) {\n      return;\n    }\n    this.identityToSid.delete(participant.identity);\n    participant.tracks.forEach((publication) => {\n      participant.unpublishTrack(publication.trackSid, true);\n    });\n    this.emit(RoomEvent.ParticipantDisconnected, participant);\n  }\n  acquireAudioContext() {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (typeof this.options.expWebAudioMix !== \"boolean\" && this.options.expWebAudioMix.audioContext) {\n        this.audioContext = this.options.expWebAudioMix.audioContext;\n        yield this.audioContext.resume();\n      } else {\n        this.audioContext = (_a = getNewAudioContext()) !== null && _a !== void 0 ? _a : void 0;\n      }\n      if (this.options.expWebAudioMix) {\n        this.participants.forEach((participant) => participant.setAudioContext(this.audioContext));\n      }\n      const newContextIsRunning = ((_b = this.audioContext) === null || _b === void 0 ? void 0 : _b.state) === \"running\";\n      if (newContextIsRunning !== this.canPlaybackAudio) {\n        this.audioEnabled = newContextIsRunning;\n        this.emit(RoomEvent.AudioPlaybackStatusChanged, newContextIsRunning);\n      }\n    });\n  }\n  createParticipant(id, info) {\n    let participant;\n    if (info) {\n      participant = RemoteParticipant.fromParticipantInfo(this.engine.client, info);\n    } else {\n      participant = new RemoteParticipant(this.engine.client, id, \"\", void 0, void 0);\n    }\n    if (this.options.expWebAudioMix) {\n      participant.setAudioContext(this.audioContext);\n    }\n    return participant;\n  }\n  getOrCreateParticipant(id, info) {\n    if (this.participants.has(id)) {\n      return this.participants.get(id);\n    }\n    const participant = this.createParticipant(id, info);\n    this.participants.set(id, participant);\n    if (info) {\n      this.identityToSid.set(info.identity, info.sid);\n      this.emitWhenConnected(RoomEvent.ParticipantConnected, participant);\n    }\n    participant.on(ParticipantEvent.TrackPublished, (trackPublication) => {\n      this.emitWhenConnected(RoomEvent.TrackPublished, trackPublication, participant);\n    }).on(ParticipantEvent.TrackSubscribed, (track, publication) => {\n      if (track.kind === Track.Kind.Audio) {\n        track.on(TrackEvent.AudioPlaybackStarted, this.handleAudioPlaybackStarted);\n        track.on(TrackEvent.AudioPlaybackFailed, this.handleAudioPlaybackFailed);\n      }\n      this.emit(RoomEvent.TrackSubscribed, track, publication, participant);\n    }).on(ParticipantEvent.TrackUnpublished, (publication) => {\n      this.emit(RoomEvent.TrackUnpublished, publication, participant);\n    }).on(ParticipantEvent.TrackUnsubscribed, (track, publication) => {\n      this.emit(RoomEvent.TrackUnsubscribed, track, publication, participant);\n    }).on(ParticipantEvent.TrackSubscriptionFailed, (sid) => {\n      this.emit(RoomEvent.TrackSubscriptionFailed, sid, participant);\n    }).on(ParticipantEvent.TrackMuted, (pub) => {\n      this.emitWhenConnected(RoomEvent.TrackMuted, pub, participant);\n    }).on(ParticipantEvent.TrackUnmuted, (pub) => {\n      this.emitWhenConnected(RoomEvent.TrackUnmuted, pub, participant);\n    }).on(ParticipantEvent.ParticipantMetadataChanged, (metadata) => {\n      this.emitWhenConnected(RoomEvent.ParticipantMetadataChanged, metadata, participant);\n    }).on(ParticipantEvent.ParticipantNameChanged, (name) => {\n      this.emitWhenConnected(RoomEvent.ParticipantNameChanged, name, participant);\n    }).on(ParticipantEvent.ConnectionQualityChanged, (quality) => {\n      this.emitWhenConnected(RoomEvent.ConnectionQualityChanged, quality, participant);\n    }).on(ParticipantEvent.ParticipantPermissionsChanged, (prevPermissions) => {\n      this.emitWhenConnected(RoomEvent.ParticipantPermissionsChanged, prevPermissions, participant);\n    }).on(ParticipantEvent.TrackSubscriptionStatusChanged, (pub, status) => {\n      this.emitWhenConnected(RoomEvent.TrackSubscriptionStatusChanged, pub, status, participant);\n    }).on(ParticipantEvent.TrackSubscriptionPermissionChanged, (pub, status) => {\n      this.emitWhenConnected(RoomEvent.TrackSubscriptionPermissionChanged, pub, status, participant);\n    });\n    if (info) {\n      participant.updateInfo(info);\n    }\n    return participant;\n  }\n  sendSyncState() {\n    var _a, _b;\n    if (this.engine.subscriber === void 0 || this.engine.subscriber.pc.localDescription === null) {\n      return;\n    }\n    const previousAnswer = this.engine.subscriber.pc.localDescription;\n    const previousOffer = this.engine.subscriber.pc.remoteDescription;\n    const autoSubscribe = (_b = (_a = this.connOptions) === null || _a === void 0 ? void 0 : _a.autoSubscribe) !== null && _b !== void 0 ? _b : true;\n    const trackSids = new Array();\n    this.participants.forEach((participant) => {\n      participant.tracks.forEach((track) => {\n        if (track.isDesired !== autoSubscribe) {\n          trackSids.push(track.trackSid);\n        }\n      });\n    });\n    this.engine.client.sendSyncState({\n      answer: toProtoSessionDescription({\n        sdp: previousAnswer.sdp,\n        type: previousAnswer.type\n      }),\n      offer: previousOffer ? toProtoSessionDescription({\n        sdp: previousOffer.sdp,\n        type: previousOffer.type\n      }) : void 0,\n      subscription: {\n        trackSids,\n        subscribe: !autoSubscribe,\n        participantTracks: []\n      },\n      publishTracks: this.localParticipant.publishedTracksInfo(),\n      dataChannels: this.localParticipant.dataChannelsInfo()\n    });\n  }\n  /**\n   * After resuming, we'll need to notify the server of the current\n   * subscription settings.\n   */\n  updateSubscriptions() {\n    for (const p of this.participants.values()) {\n      for (const pub of p.videoTracks.values()) {\n        if (pub.isSubscribed && pub instanceof RemoteTrackPublication) {\n          pub.emitTrackUpdate();\n        }\n      }\n    }\n  }\n  registerConnectionReconcile() {\n    this.clearConnectionReconcile();\n    let consecutiveFailures = 0;\n    this.connectionReconcileInterval = CriticalTimers.setInterval(() => {\n      if (\n        // ensure we didn't tear it down\n        !this.engine || // engine detected close, but Room missed it\n        this.engine.isClosed || // transports failed without notifying engine\n        !this.engine.verifyTransport()\n      ) {\n        consecutiveFailures++;\n        livekitLogger.warn(\"detected connection state mismatch\", {\n          numFailures: consecutiveFailures\n        });\n        if (consecutiveFailures >= 3)\n          this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, DisconnectReason.UNKNOWN_REASON);\n      } else {\n        consecutiveFailures = 0;\n      }\n    }, connectionReconcileFrequency);\n  }\n  clearConnectionReconcile() {\n    if (this.connectionReconcileInterval) {\n      CriticalTimers.clearInterval(this.connectionReconcileInterval);\n    }\n  }\n  setAndEmitConnectionState(state) {\n    if (state === this.state) {\n      return false;\n    }\n    this.state = state;\n    this.emit(RoomEvent.ConnectionStateChanged, this.state);\n    return true;\n  }\n  emitWhenConnected(event) {\n    if (this.state === ConnectionState.Connected) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      return this.emit(event, ...args);\n    }\n    return false;\n  }\n  /**\n   * Allows to populate a room with simulated participants.\n   * No actual connection to a server will be established, all state is\n   * @experimental\n   */\n  simulateParticipants(options) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const publishOptions = Object.assign({\n        audio: true,\n        video: true,\n        useRealTracks: false\n      }, options.publish);\n      const participantOptions = Object.assign({\n        count: 9,\n        audio: false,\n        video: true,\n        aspectRatios: [1.66, 1.7, 1.3]\n      }, options.participants);\n      this.handleDisconnect();\n      this.roomInfo = {\n        sid: \"RM_SIMULATED\",\n        name: \"simulated-room\",\n        emptyTimeout: 0,\n        maxParticipants: 0,\n        creationTime: (/* @__PURE__ */ new Date()).getTime(),\n        metadata: \"\",\n        numParticipants: 1,\n        numPublishers: 1,\n        turnPassword: \"\",\n        enabledCodecs: [],\n        activeRecording: false\n      };\n      this.localParticipant.updateInfo(ParticipantInfo.fromPartial({\n        identity: \"simulated-local\",\n        name: \"local-name\"\n      }));\n      this.setupLocalParticipantEvents();\n      this.emit(RoomEvent.SignalConnected);\n      this.emit(RoomEvent.Connected);\n      this.setAndEmitConnectionState(ConnectionState.Connected);\n      if (publishOptions.video) {\n        const camPub = new LocalTrackPublication(Track.Kind.Video, TrackInfo.fromPartial({\n          source: TrackSource.CAMERA,\n          sid: Math.floor(Math.random() * 1e4).toString(),\n          type: TrackType.AUDIO,\n          name: \"video-dummy\"\n        }), new LocalVideoTrack(publishOptions.useRealTracks ? (yield navigator.mediaDevices.getUserMedia({\n          video: true\n        })).getVideoTracks()[0] : createDummyVideoStreamTrack((_a = 160 * participantOptions.aspectRatios[0]) !== null && _a !== void 0 ? _a : 1, 160, true, true)));\n        this.localParticipant.addTrackPublication(camPub);\n        this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, camPub);\n      }\n      if (publishOptions.audio) {\n        const audioPub = new LocalTrackPublication(Track.Kind.Audio, TrackInfo.fromPartial({\n          source: TrackSource.MICROPHONE,\n          sid: Math.floor(Math.random() * 1e4).toString(),\n          type: TrackType.AUDIO\n        }), new LocalAudioTrack(publishOptions.useRealTracks ? (yield navigator.mediaDevices.getUserMedia({\n          audio: true\n        })).getAudioTracks()[0] : getEmptyAudioStreamTrack()));\n        this.localParticipant.addTrackPublication(audioPub);\n        this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, audioPub);\n      }\n      for (let i = 0; i < participantOptions.count - 1; i += 1) {\n        let info = ParticipantInfo.fromPartial({\n          sid: Math.floor(Math.random() * 1e4).toString(),\n          identity: \"simulated-\".concat(i),\n          state: ParticipantInfo_State.ACTIVE,\n          tracks: [],\n          joinedAt: Date.now()\n        });\n        const p = this.getOrCreateParticipant(info.identity, info);\n        if (participantOptions.video) {\n          const dummyVideo = createDummyVideoStreamTrack((_b = 160 * participantOptions.aspectRatios[i % participantOptions.aspectRatios.length]) !== null && _b !== void 0 ? _b : 1, 160, false, true);\n          const videoTrack = TrackInfo.fromPartial({\n            source: TrackSource.CAMERA,\n            sid: Math.floor(Math.random() * 1e4).toString(),\n            type: TrackType.AUDIO\n          });\n          p.addSubscribedMediaTrack(dummyVideo, videoTrack.sid, new MediaStream([dummyVideo]));\n          info.tracks = [...info.tracks, videoTrack];\n        }\n        if (participantOptions.audio) {\n          const dummyTrack = getEmptyAudioStreamTrack();\n          const audioTrack = TrackInfo.fromPartial({\n            source: TrackSource.MICROPHONE,\n            sid: Math.floor(Math.random() * 1e4).toString(),\n            type: TrackType.AUDIO\n          });\n          p.addSubscribedMediaTrack(dummyTrack, audioTrack.sid, new MediaStream([dummyTrack]));\n          info.tracks = [...info.tracks, audioTrack];\n        }\n        p.updateInfo(info);\n      }\n    });\n  }\n  // /** @internal */\n  emit(event) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    if (event !== RoomEvent.ActiveSpeakersChanged) {\n      livekitLogger.debug(\"room event \".concat(event), {\n        event,\n        args\n      });\n    }\n    return super.emit(event, ...args);\n  }\n};\nvar CheckStatus;\n(function(CheckStatus2) {\n  CheckStatus2[CheckStatus2[\"IDLE\"] = 0] = \"IDLE\";\n  CheckStatus2[CheckStatus2[\"RUNNING\"] = 1] = \"RUNNING\";\n  CheckStatus2[CheckStatus2[\"SKIPPED\"] = 2] = \"SKIPPED\";\n  CheckStatus2[CheckStatus2[\"SUCCESS\"] = 3] = \"SUCCESS\";\n  CheckStatus2[CheckStatus2[\"FAILED\"] = 4] = \"FAILED\";\n})(CheckStatus || (CheckStatus = {}));\nvar Checker = class extends eventsExports.EventEmitter {\n  constructor(url, token) {\n    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    super();\n    this.status = CheckStatus.IDLE;\n    this.logs = [];\n    this.errorsAsWarnings = false;\n    this.url = url;\n    this.token = token;\n    this.name = this.constructor.name;\n    this.room = new Room(options.roomOptions);\n    this.connectOptions = options.connectOptions;\n    if (options.errorsAsWarnings) {\n      this.errorsAsWarnings = options.errorsAsWarnings;\n    }\n  }\n  run(onComplete) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.status !== CheckStatus.IDLE) {\n        throw Error(\"check is running already\");\n      }\n      this.setStatus(CheckStatus.RUNNING);\n      this.appendMessage(\"\".concat(this.name, \" started.\"));\n      try {\n        yield this.perform();\n      } catch (err) {\n        if (err instanceof Error) {\n          if (this.errorsAsWarnings) {\n            this.appendWarning(err.message);\n          } else {\n            this.appendError(err.message);\n          }\n        }\n      }\n      yield this.disconnect();\n      yield new Promise((resolve) => setTimeout(resolve, 500));\n      if (this.status !== CheckStatus.SKIPPED) {\n        this.setStatus(this.isSuccess() ? CheckStatus.SUCCESS : CheckStatus.FAILED);\n      }\n      if (onComplete) {\n        onComplete();\n      }\n      return this.getInfo();\n    });\n  }\n  isSuccess() {\n    return !this.logs.some((l) => l.level === \"error\");\n  }\n  connect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.room.state === ConnectionState.Connected) {\n        return this.room;\n      }\n      yield this.room.connect(this.url, this.token);\n      return this.room;\n    });\n  }\n  disconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.room && this.room.state !== ConnectionState.Disconnected) {\n        yield this.room.disconnect();\n        yield new Promise((resolve) => setTimeout(resolve, 500));\n      }\n    });\n  }\n  skip() {\n    this.setStatus(CheckStatus.SKIPPED);\n  }\n  appendMessage(message) {\n    this.logs.push({\n      level: \"info\",\n      message\n    });\n    this.emit(\"update\", this.getInfo());\n  }\n  appendWarning(message) {\n    this.logs.push({\n      level: \"warning\",\n      message\n    });\n    this.emit(\"update\", this.getInfo());\n  }\n  appendError(message) {\n    this.logs.push({\n      level: \"error\",\n      message\n    });\n    this.emit(\"update\", this.getInfo());\n  }\n  setStatus(status) {\n    this.status = status;\n    this.emit(\"update\", this.getInfo());\n  }\n  get engine() {\n    var _a;\n    return (_a = this.room) === null || _a === void 0 ? void 0 : _a.engine;\n  }\n  getInfo() {\n    return {\n      logs: this.logs,\n      name: this.name,\n      status: this.status,\n      description: this.description\n    };\n  }\n};\nfunction createLocalTracks(options) {\n  var _a, _b;\n  return __awaiter(this, void 0, void 0, function* () {\n    options !== null && options !== void 0 ? options : options = {};\n    (_a = options.audio) !== null && _a !== void 0 ? _a : options.audio = true;\n    (_b = options.video) !== null && _b !== void 0 ? _b : options.video = true;\n    const opts = mergeDefaultOptions(options, audioDefaults, videoDefaults);\n    const constraints = constraintsForOptions(opts);\n    const mediaPromise = navigator.mediaDevices.getUserMedia(constraints);\n    if (options.audio) {\n      DeviceManager.userMediaPromiseMap.set(\"audioinput\", mediaPromise);\n      mediaPromise.catch(() => DeviceManager.userMediaPromiseMap.delete(\"audioinput\"));\n    }\n    if (options.video) {\n      DeviceManager.userMediaPromiseMap.set(\"videoinput\", mediaPromise);\n      mediaPromise.catch(() => DeviceManager.userMediaPromiseMap.delete(\"videoinput\"));\n    }\n    const stream = yield mediaPromise;\n    return stream.getTracks().map((mediaStreamTrack) => {\n      const isAudio = mediaStreamTrack.kind === \"audio\";\n      isAudio ? options.audio : options.video;\n      let trackConstraints;\n      const conOrBool = isAudio ? constraints.audio : constraints.video;\n      if (typeof conOrBool !== \"boolean\") {\n        trackConstraints = conOrBool;\n      }\n      const track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints);\n      if (track.kind === Track.Kind.Video) {\n        track.source = Track.Source.Camera;\n      } else if (track.kind === Track.Kind.Audio) {\n        track.source = Track.Source.Microphone;\n      }\n      track.mediaStream = stream;\n      return track;\n    });\n  });\n}\nfunction createLocalVideoTrack(options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const tracks = yield createLocalTracks({\n      audio: false,\n      video: options\n    });\n    return tracks[0];\n  });\n}\nfunction createLocalAudioTrack(options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const tracks = yield createLocalTracks({\n      audio: options,\n      video: false\n    });\n    return tracks[0];\n  });\n}\nfunction createLocalScreenTracks(options) {\n  var _a;\n  return __awaiter(this, void 0, void 0, function* () {\n    if (options === void 0) {\n      options = {};\n    }\n    if (options.resolution === void 0) {\n      options.resolution = VideoPresets.h1080.resolution;\n    }\n    let videoConstraints = true;\n    if (options.resolution) {\n      videoConstraints = {\n        width: options.resolution.width,\n        height: options.resolution.height\n      };\n    }\n    if (navigator.mediaDevices.getDisplayMedia === void 0) {\n      throw new DeviceUnsupportedError(\"getDisplayMedia not supported\");\n    }\n    const stream = yield navigator.mediaDevices.getDisplayMedia({\n      audio: (_a = options.audio) !== null && _a !== void 0 ? _a : false,\n      video: videoConstraints\n    });\n    const tracks = stream.getVideoTracks();\n    if (tracks.length === 0) {\n      throw new TrackInvalidError(\"no video track found\");\n    }\n    const screenVideo = new LocalVideoTrack(tracks[0], void 0, false);\n    screenVideo.source = Track.Source.ScreenShare;\n    const localTracks = [screenVideo];\n    if (stream.getAudioTracks().length > 0) {\n      const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], void 0, false);\n      screenAudio.source = Track.Source.ScreenShareAudio;\n      localTracks.push(screenAudio);\n    }\n    return localTracks;\n  });\n}\nvar PublishAudioCheck = class extends Checker {\n  get description() {\n    return \"Can publish audio\";\n  }\n  perform() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const room = yield this.connect();\n      const track = yield createLocalAudioTrack();\n      room.localParticipant.publishTrack(track);\n      yield new Promise((resolve) => setTimeout(resolve, 3e3));\n      const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();\n      if (!stats) {\n        throw new Error(\"Could not get RTCStats\");\n      }\n      let numPackets = 0;\n      stats.forEach((stat) => {\n        if (stat.type === \"outbound-rtp\" && stat.mediaType === \"audio\") {\n          numPackets = stat.packetsSent;\n        }\n      });\n      if (numPackets === 0) {\n        throw new Error(\"Could not determine packets are sent\");\n      }\n      this.appendMessage(\"published \".concat(numPackets, \" audio packets\"));\n    });\n  }\n};\nvar PublishVideoCheck = class extends Checker {\n  get description() {\n    return \"Can publish video\";\n  }\n  perform() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const room = yield this.connect();\n      const track = yield createLocalVideoTrack();\n      room.localParticipant.publishTrack(track);\n      yield new Promise((resolve) => setTimeout(resolve, 3e3));\n      const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();\n      if (!stats) {\n        throw new Error(\"Could not get RTCStats\");\n      }\n      let numPackets = 0;\n      stats.forEach((stat) => {\n        if (stat.type === \"outbound-rtp\" && stat.mediaType === \"video\") {\n          numPackets = stat.packetsSent;\n        }\n      });\n      if (numPackets === 0) {\n        throw new Error(\"Could not determine packets are sent\");\n      }\n      this.appendMessage(\"published \".concat(numPackets, \" video packets\"));\n    });\n  }\n};\nvar ReconnectCheck = class extends Checker {\n  get description() {\n    return \"Resuming connection after interruption\";\n  }\n  perform() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const room = yield this.connect();\n      let reconnectingTriggered = false;\n      let reconnected = false;\n      let reconnectResolver;\n      const reconnectTimeout = new Promise((resolve) => {\n        setTimeout(resolve, 5e3);\n        reconnectResolver = resolve;\n      });\n      room.on(RoomEvent.Reconnecting, () => {\n        reconnectingTriggered = true;\n      }).on(RoomEvent.Reconnected, () => {\n        reconnected = true;\n        reconnectResolver(true);\n      });\n      (_a = room.engine.client.ws) === null || _a === void 0 ? void 0 : _a.close();\n      const onClose = room.engine.client.onClose;\n      if (onClose) {\n        onClose(\"\");\n      }\n      yield reconnectTimeout;\n      if (!reconnectingTriggered) {\n        throw new Error(\"Did not attempt to reconnect\");\n      } else if (!reconnected || room.state !== ConnectionState.Connected) {\n        this.appendWarning(\"reconnection is only possible in Redis-based configurations\");\n        throw new Error(\"Not able to reconnect\");\n      }\n    });\n  }\n};\nvar TURNCheck = class extends Checker {\n  get description() {\n    return \"Can connect via TURN\";\n  }\n  perform() {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const signalClient = new SignalClient();\n      const joinRes = yield signalClient.join(this.url, this.token, {\n        autoSubscribe: true,\n        maxRetries: 0\n      });\n      let hasTLS = false;\n      let hasTURN = false;\n      let hasSTUN = false;\n      for (let iceServer of joinRes.iceServers) {\n        for (let url of iceServer.urls) {\n          if (url.startsWith(\"turn:\")) {\n            hasTURN = true;\n            hasSTUN = true;\n          } else if (url.startsWith(\"turns:\")) {\n            hasTURN = true;\n            hasSTUN = true;\n            hasTLS = true;\n          }\n          if (url.startsWith(\"stun:\")) {\n            hasSTUN = true;\n          }\n        }\n      }\n      if (!hasSTUN) {\n        this.appendWarning(\"No STUN servers configured on server side.\");\n      } else if (hasTURN && !hasTLS) {\n        this.appendWarning(\"TURN is configured server side, but TURN/TLS is unavailable.\");\n      }\n      yield signalClient.close();\n      if (((_b = (_a = this.connectOptions) === null || _a === void 0 ? void 0 : _a.rtcConfig) === null || _b === void 0 ? void 0 : _b.iceServers) || hasTURN) {\n        yield this.room.connect(this.url, this.token, {\n          rtcConfig: {\n            iceTransportPolicy: \"relay\"\n          }\n        });\n      } else {\n        this.appendWarning(\"No TURN servers configured.\");\n        this.skip();\n        yield new Promise((resolve) => setTimeout(resolve, 0));\n      }\n    });\n  }\n};\nvar WebRTCCheck = class extends Checker {\n  get description() {\n    return \"Establishing WebRTC connection\";\n  }\n  perform() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        console.log(\"initiating room connection\");\n        this.room = yield this.connect();\n        console.log(\"now the room is connected\");\n      } catch (err) {\n        this.appendWarning(\"ports need to be open on firewall in order to connect.\");\n        throw err;\n      }\n    });\n  }\n};\nvar WebSocketCheck = class extends Checker {\n  get description() {\n    return \"Connecting to signal connection via WebSocket\";\n  }\n  perform() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.url.startsWith(\"ws:\") || this.url.startsWith(\"http:\")) {\n        this.appendWarning(\"Server is insecure, clients may block connections to it\");\n      }\n      let signalClient = new SignalClient();\n      const joinRes = yield signalClient.join(this.url, this.token, {\n        autoSubscribe: true,\n        maxRetries: 0\n      });\n      this.appendMessage(\"Connected to server, version \".concat(joinRes.serverVersion, \".\"));\n      yield signalClient.close();\n    });\n  }\n};\nvar ConnectionCheck = class extends eventsExports.EventEmitter {\n  constructor(url, token) {\n    super();\n    this.checkResults = /* @__PURE__ */ new Map();\n    this.url = url;\n    this.token = token;\n  }\n  getNextCheckId() {\n    const nextId = this.checkResults.size;\n    this.checkResults.set(nextId, {\n      logs: [],\n      status: CheckStatus.IDLE,\n      name: \"\",\n      description: \"\"\n    });\n    return nextId;\n  }\n  updateCheck(checkId, info) {\n    this.checkResults.set(checkId, info);\n    this.emit(\"checkUpdate\", checkId, info);\n  }\n  isSuccess() {\n    return Array.from(this.checkResults.values()).every((r2) => r2.status !== CheckStatus.FAILED);\n  }\n  getResults() {\n    return Array.from(this.checkResults.values());\n  }\n  createAndRunCheck(check) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const checkId = this.getNextCheckId();\n      const test = new check(this.url, this.token);\n      const handleUpdate = (info) => {\n        this.updateCheck(checkId, info);\n      };\n      test.on(\"update\", handleUpdate);\n      const result = yield test.run();\n      test.off(\"update\", handleUpdate);\n      return result;\n    });\n  }\n  checkWebsocket() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(WebSocketCheck);\n    });\n  }\n  checkWebRTC() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(WebRTCCheck);\n    });\n  }\n  checkTURN() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(TURNCheck);\n    });\n  }\n  checkReconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(ReconnectCheck);\n    });\n  }\n  checkPublishAudio() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(PublishAudioCheck);\n    });\n  }\n  checkPublishVideo() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(PublishVideoCheck);\n    });\n  }\n};\nexport {\n  AudioPresets,\n  ConnectionCheck,\n  ConnectionError,\n  ConnectionQuality,\n  ConnectionState,\n  CriticalTimers,\n  DataPacket_Kind,\n  DefaultReconnectPolicy,\n  DeviceUnsupportedError,\n  DisconnectReason,\n  EngineEvent,\n  LivekitError,\n  LocalAudioTrack,\n  LocalParticipant,\n  LocalTrack,\n  LocalTrackPublication,\n  LocalVideoTrack,\n  LogLevel,\n  MediaDeviceFailure,\n  NegotiationError,\n  Participant,\n  ParticipantEvent,\n  PublishDataError,\n  RemoteAudioTrack,\n  RemoteParticipant,\n  RemoteTrack,\n  RemoteTrackPublication,\n  RemoteVideoTrack,\n  Room,\n  RoomEvent,\n  RoomState,\n  ScreenSharePresets,\n  Track,\n  TrackEvent,\n  TrackInvalidError,\n  TrackPublication,\n  UnexpectedConnectionState,\n  UnsupportedServer,\n  VideoPreset,\n  VideoPresets,\n  VideoPresets43,\n  VideoQuality,\n  attachToElement,\n  createAudioAnalyser,\n  createLocalAudioTrack,\n  createLocalScreenTracks,\n  createLocalTracks,\n  createLocalVideoTrack,\n  detachTrack,\n  getEmptyAudioStreamTrack,\n  getEmptyVideoStreamTrack,\n  isBackupCodec,\n  isBrowserSupported,\n  isCodecEqual,\n  protocolVersion,\n  setLogExtension,\n  setLogLevel,\n  supportsAV1,\n  supportsAdaptiveStream,\n  supportsDynacast,\n  supportsVP9,\n  version\n};\n//# sourceMappingURL=livekit-client.js.map\n",
      "start": 1684204348529,
      "end": 1684204348535,
      "order": "normal"
    }
  ]
}
